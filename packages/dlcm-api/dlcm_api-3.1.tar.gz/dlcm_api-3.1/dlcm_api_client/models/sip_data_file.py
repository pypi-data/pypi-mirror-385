# coding: utf-8

"""
    DLCM Solution API

    Repository for Research Datasets

    The version of the OpenAPI document: 3.1.1-SNAPSHOT
    Contact: admin@dlcm.ch
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from dlcm_api_client.models.change_info import ChangeInfo
from dlcm_api_client.models.data_file_checksum import DataFileChecksum
from dlcm_api_client.models.file_format import FileFormat
from dlcm_api_client.models.link import Link
from dlcm_api_client.models.metadata_type import MetadataType
from dlcm_api_client.models.search_criteria import SearchCriteria
from dlcm_api_client.models.submission_info_package import SubmissionInfoPackage
from dlcm_api_client.models.virus_check import VirusCheck
from typing import Optional, Set
from typing_extensions import Self

class SipDataFile(BaseModel):
    """
    SipDataFile
    """ # noqa: E501
    creation: Optional[ChangeInfo] = None
    last_update: Optional[ChangeInfo] = Field(default=None, alias="lastUpdate")
    res_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The identifier of the resource. The default format is a Universally Unique IDentifier (UUID).", alias="resId")
    search_criterias: Optional[List[SearchCriteria]] = Field(default=None, alias="searchCriterias")
    compliance_level: Optional[StrictStr] = Field(default=None, description="Compliance level to define the preservation quality based on data file format: - NOT_ASSESSED => The format could not be evaluated - NO_COMPLIANCE => The format could not be determined - WEAK_COMPLIANCE => The format was determined: content type detected - AVERAGE_COMPLIANCE => The format was determined: WEAK_COMPLIANCE + PRONOM identifier detected - FULL_COMPLIANCE => The format was determined: AVERAGE_COMPLIANCE + the format is part of golden formats ", alias="complianceLevel")
    data_category: Optional[StrictStr] = Field(default=None, alias="dataCategory")
    data_type: Optional[StrictStr] = Field(default=None, alias="dataType")
    file_format: Optional[FileFormat] = Field(default=None, alias="fileFormat")
    file_size: Optional[StrictInt] = Field(default=None, alias="fileSize")
    final_data: Optional[StrictStr] = Field(default=None, alias="finalData")
    file_name: Optional[StrictStr] = Field(default=None, alias="fileName")
    metadata_type: Optional[MetadataType] = Field(default=None, alias="metadataType")
    relative_location: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=460)]] = Field(default=None, alias="relativeLocation")
    source_data: Optional[StrictStr] = Field(default=None, alias="sourceData")
    status: Optional[StrictStr] = None
    status_message: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, alias="statusMessage")
    virus_check: Optional[VirusCheck] = Field(default=None, alias="virusCheck")
    checksums: Optional[List[DataFileChecksum]] = None
    info_package: Optional[SubmissionInfoPackage] = Field(default=None, alias="infoPackage")
    file_status: Optional[StrictStr] = Field(default=None, alias="fileStatus")
    full_file_name: Optional[StrictStr] = Field(default=None, alias="fullFileName")
    in_progress: Optional[StrictBool] = Field(default=None, alias="inProgress")
    smart_size: Optional[StrictStr] = Field(default=None, alias="smartSize")
    links: Optional[Dict[str, Link]] = Field(default=None, alias="_links")
    __properties: ClassVar[List[str]] = ["creation", "lastUpdate", "resId", "searchCriterias", "complianceLevel", "dataCategory", "dataType", "fileFormat", "fileSize", "finalData", "fileName", "metadataType", "relativeLocation", "sourceData", "status", "statusMessage", "virusCheck", "checksums", "infoPackage", "fileStatus", "fullFileName", "inProgress", "smartSize", "_links"]

    @field_validator('compliance_level')
    def compliance_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NOT_ASSESSED', 'NO_COMPLIANCE', 'WEAK_COMPLIANCE', 'AVERAGE_COMPLIANCE', 'FULL_COMPLIANCE']):
            raise ValueError("must be one of enum values ('NOT_ASSESSED', 'NO_COMPLIANCE', 'WEAK_COMPLIANCE', 'AVERAGE_COMPLIANCE', 'FULL_COMPLIANCE')")
        return value

    @field_validator('data_category')
    def data_category_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Primary', 'Observational', 'Experimental', 'Simulation', 'Derived', 'Reference', 'Digitalized', 'Secondary', 'Publication', 'DataPaper', 'Documentation', 'Software', 'Code', 'Binaries', 'VirtualMachine', 'Administrative', 'Document', 'WebSite', 'Other', 'Package', 'InformationPackage', 'UpdatePackage', 'Metadata', 'CustomMetadata', 'UpdatedMetadata', 'Internal', 'DatasetThumbnail', 'ArchiveThumbnail', 'ArchiveReadme', 'DatafileThumbnail', 'ArchiveDataUseAgreement']):
            raise ValueError("must be one of enum values ('Primary', 'Observational', 'Experimental', 'Simulation', 'Derived', 'Reference', 'Digitalized', 'Secondary', 'Publication', 'DataPaper', 'Documentation', 'Software', 'Code', 'Binaries', 'VirtualMachine', 'Administrative', 'Document', 'WebSite', 'Other', 'Package', 'InformationPackage', 'UpdatePackage', 'Metadata', 'CustomMetadata', 'UpdatedMetadata', 'Internal', 'DatasetThumbnail', 'ArchiveThumbnail', 'ArchiveReadme', 'DatafileThumbnail', 'ArchiveDataUseAgreement')")
        return value

    @field_validator('data_type')
    def data_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Primary', 'Observational', 'Experimental', 'Simulation', 'Derived', 'Reference', 'Digitalized', 'Secondary', 'Publication', 'DataPaper', 'Documentation', 'Software', 'Code', 'Binaries', 'VirtualMachine', 'Administrative', 'Document', 'WebSite', 'Other', 'Package', 'InformationPackage', 'UpdatePackage', 'Metadata', 'CustomMetadata', 'UpdatedMetadata', 'Internal', 'DatasetThumbnail', 'ArchiveThumbnail', 'ArchiveReadme', 'DatafileThumbnail', 'ArchiveDataUseAgreement']):
            raise ValueError("must be one of enum values ('Primary', 'Observational', 'Experimental', 'Simulation', 'Derived', 'Reference', 'Digitalized', 'Secondary', 'Publication', 'DataPaper', 'Documentation', 'Software', 'Code', 'Binaries', 'VirtualMachine', 'Administrative', 'Document', 'WebSite', 'Other', 'Package', 'InformationPackage', 'UpdatePackage', 'Metadata', 'CustomMetadata', 'UpdatedMetadata', 'Internal', 'DatasetThumbnail', 'ArchiveThumbnail', 'ArchiveReadme', 'DatafileThumbnail', 'ArchiveDataUseAgreement')")
        return value

    @field_validator('relative_location')
    def relative_location_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"(^\/$)|(^\/.*(?<!\/)$)", value):
            raise ValueError(r"must validate the regular expression /(^\/$)|(^\/.*(?<!\/)$)/")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CHANGE_RELATIVE_LOCATION', 'CHANGE_DATA_CATEGORY', 'CLEANED', 'CLEANING', 'EXCLUDED_FILE', 'CHECK_COMPLIANCE', 'CHECK_COMPLIANCE_CLEANED', 'CHECKED_COMPLIANCE', 'CHECKED_COMPLIANCE_CLEANED', 'IGNORED_FILE', 'FILE_FORMAT_IDENTIFIED', 'FILE_FORMAT_SKIPPED', 'FILE_FORMAT_UNKNOWN', 'IN_ERROR', 'PROCESSED', 'READY', 'RECEIVED', 'TO_PROCESS', 'VIRUS_CHECKED', 'VIRUS_SKIPPED']):
            raise ValueError("must be one of enum values ('CHANGE_RELATIVE_LOCATION', 'CHANGE_DATA_CATEGORY', 'CLEANED', 'CLEANING', 'EXCLUDED_FILE', 'CHECK_COMPLIANCE', 'CHECK_COMPLIANCE_CLEANED', 'CHECKED_COMPLIANCE', 'CHECKED_COMPLIANCE_CLEANED', 'IGNORED_FILE', 'FILE_FORMAT_IDENTIFIED', 'FILE_FORMAT_SKIPPED', 'FILE_FORMAT_UNKNOWN', 'IN_ERROR', 'PROCESSED', 'READY', 'RECEIVED', 'TO_PROCESS', 'VIRUS_CHECKED', 'VIRUS_SKIPPED')")
        return value

    @field_validator('file_status')
    def file_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CHANGE_RELATIVE_LOCATION', 'CHANGE_DATA_CATEGORY', 'CLEANED', 'CLEANING', 'EXCLUDED_FILE', 'CHECK_COMPLIANCE', 'CHECK_COMPLIANCE_CLEANED', 'CHECKED_COMPLIANCE', 'CHECKED_COMPLIANCE_CLEANED', 'IGNORED_FILE', 'FILE_FORMAT_IDENTIFIED', 'FILE_FORMAT_SKIPPED', 'FILE_FORMAT_UNKNOWN', 'IN_ERROR', 'PROCESSED', 'READY', 'RECEIVED', 'TO_PROCESS', 'VIRUS_CHECKED', 'VIRUS_SKIPPED']):
            raise ValueError("must be one of enum values ('CHANGE_RELATIVE_LOCATION', 'CHANGE_DATA_CATEGORY', 'CLEANED', 'CLEANING', 'EXCLUDED_FILE', 'CHECK_COMPLIANCE', 'CHECK_COMPLIANCE_CLEANED', 'CHECKED_COMPLIANCE', 'CHECKED_COMPLIANCE_CLEANED', 'IGNORED_FILE', 'FILE_FORMAT_IDENTIFIED', 'FILE_FORMAT_SKIPPED', 'FILE_FORMAT_UNKNOWN', 'IN_ERROR', 'PROCESSED', 'READY', 'RECEIVED', 'TO_PROCESS', 'VIRUS_CHECKED', 'VIRUS_SKIPPED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SipDataFile from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "file_name",
            "full_file_name",
            "smart_size",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of creation
        if self.creation:
            _dict['creation'] = self.creation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_update
        if self.last_update:
            _dict['lastUpdate'] = self.last_update.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in search_criterias (list)
        _items = []
        if self.search_criterias:
            for _item_search_criterias in self.search_criterias:
                if _item_search_criterias:
                    _items.append(_item_search_criterias.to_dict())
            _dict['searchCriterias'] = _items
        # override the default output from pydantic by calling `to_dict()` of file_format
        if self.file_format:
            _dict['fileFormat'] = self.file_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of metadata_type
        if self.metadata_type:
            _dict['metadataType'] = self.metadata_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of virus_check
        if self.virus_check:
            _dict['virusCheck'] = self.virus_check.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in checksums (list)
        _items = []
        if self.checksums:
            for _item_checksums in self.checksums:
                if _item_checksums:
                    _items.append(_item_checksums.to_dict())
            _dict['checksums'] = _items
        # override the default output from pydantic by calling `to_dict()` of info_package
        if self.info_package:
            _dict['infoPackage'] = self.info_package.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in links (dict)
        _field_dict = {}
        if self.links:
            for _key_links in self.links:
                if self.links[_key_links]:
                    _field_dict[_key_links] = self.links[_key_links].to_dict()
            _dict['_links'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SipDataFile from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "creation": ChangeInfo.from_dict(obj["creation"]) if obj.get("creation") is not None else None,
            "lastUpdate": ChangeInfo.from_dict(obj["lastUpdate"]) if obj.get("lastUpdate") is not None else None,
            "resId": obj.get("resId"),
            "searchCriterias": [SearchCriteria.from_dict(_item) for _item in obj["searchCriterias"]] if obj.get("searchCriterias") is not None else None,
            "complianceLevel": obj.get("complianceLevel"),
            "dataCategory": obj.get("dataCategory"),
            "dataType": obj.get("dataType"),
            "fileFormat": FileFormat.from_dict(obj["fileFormat"]) if obj.get("fileFormat") is not None else None,
            "fileSize": obj.get("fileSize"),
            "finalData": obj.get("finalData"),
            "fileName": obj.get("fileName"),
            "metadataType": MetadataType.from_dict(obj["metadataType"]) if obj.get("metadataType") is not None else None,
            "relativeLocation": obj.get("relativeLocation"),
            "sourceData": obj.get("sourceData"),
            "status": obj.get("status"),
            "statusMessage": obj.get("statusMessage"),
            "virusCheck": VirusCheck.from_dict(obj["virusCheck"]) if obj.get("virusCheck") is not None else None,
            "checksums": [DataFileChecksum.from_dict(_item) for _item in obj["checksums"]] if obj.get("checksums") is not None else None,
            "infoPackage": SubmissionInfoPackage.from_dict(obj["infoPackage"]) if obj.get("infoPackage") is not None else None,
            "fileStatus": obj.get("fileStatus"),
            "fullFileName": obj.get("fullFileName"),
            "inProgress": obj.get("inProgress"),
            "smartSize": obj.get("smartSize"),
            "_links": dict(
                (_k, Link.from_dict(_v))
                for _k, _v in obj["_links"].items()
            )
            if obj.get("_links") is not None
            else None
        })
        return _obj


