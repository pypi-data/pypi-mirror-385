# coding: utf-8

"""
    DLCM Solution API

    Repository for Research Datasets

    The version of the OpenAPI document: 3.1.1-SNAPSHOT
    Contact: admin@dlcm.ch
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from dlcm_api_client.models.archive_type import ArchiveType
from dlcm_api_client.models.change_info import ChangeInfo
from dlcm_api_client.models.embargo_info import EmbargoInfo
from dlcm_api_client.models.language import Language
from dlcm_api_client.models.link import Link
from dlcm_api_client.models.organizational_unit import OrganizationalUnit
from dlcm_api_client.models.preservation_policy import PreservationPolicy
from dlcm_api_client.models.search_criteria import SearchCriteria
from dlcm_api_client.models.submission_policy import SubmissionPolicy
from typing import Optional, Set
from typing_extensions import Self

class Deposit(BaseModel):
    """
    A deposit is a simple package to prepare a SIP. Deposit status: - APPROVED => Approved deposit. The SIP preparation is in progress. - CANCEL_EDITING_METADATA => A cancellation of metadata edition is in progress. - CHECKED => Checked deposit. The deposit is ready for SIP preparation. - CHECKING_COMPLIANCE => A compliance check is in progress for completed deposits. - CHECKING_COMPLIANCE_CLEANED => A compliance check is in progress for cleaned deposits. - CLEANED => Cleaned deposit: the data file are purged based on submission policy. - CLEANING => A clean process is in progress. - COMPLETED => Completed deposit. The preparation of SIP is completed. - COMPLIANCE_ERROR => An error occurred during a compliance check. - DELETING => A deletion process is in progress. - EDITING_METADATA_REJECTED => The metadata edition was rejected. - EDITING_METADATA => The deposit is in edition mode for metadata. - IN_ERROR => An error occurred during the SIP preparation. - IN_PROGRESS => The deposit is in progress, ready for adding data files. - IN_VALIDATION => The deposit is waiting for an approval. - REJECTED => The deposit was rejected. - RELOADING => The deposit is a reload process. - SUBMITTED => Submitted deposit. The SIP preparation is in progress. - UPGRADING_METADATA => The deposit is in upgrade mode of metadata version. 
    """ # noqa: E501
    creation: Optional[ChangeInfo] = None
    last_update: Optional[ChangeInfo] = Field(default=None, alias="lastUpdate")
    res_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The identifier of the resource. The default format is a Universally Unique IDentifier (UUID).", alias="resId")
    search_criterias: Optional[List[SearchCriteria]] = Field(default=None, alias="searchCriterias")
    access: Optional[StrictStr] = Field(default=None, description="Access level of the archive: - PUBLIC => Open Access & Everyone - RESTRICTED => Team members (i.e., Org. Unit) & Trusted parties - CLOSED => Case by case & Individuals ")
    data_sensitivity: Optional[StrictStr] = Field(default=None, description="DataTage represents the data sensitivity of the archive: - UNDEFINED => Not defined (Data sensitivity not set to support previous archives) - BLUE => Public (Non-confidential information, stored and shared freely) - GREEN => Controlled public (Not harmful personal information, shared with some access control) - YELLOW => Accountable (Potentially harmful personal information, shared with loosely verified and/or approved recipients) - ORANGE => More accountable (Sensitive personal information, shared with verified and/or approved recipients under agreement) - RED => Fully accountable (Very sensitive personal information, shared with strong verification of approved recipients under signed agreement) - CRIMSON => Maximum restricted (Maximum sensitive, explicit permission for each transaction, strong verification of approved recipients under signed agreement) ", alias="dataSensitivity")
    data_use_policy: Optional[StrictStr] = Field(default=None, description="Data use policy defines the terms to conditions to access to an archive: - NONE => no policy - LICENSE => To respect the license - CLICK_THROUGH_DUA => To click to accept the Data Use Agreement (DUA) - SIGNED_DUA => To sign to accept the Data Use Agreement (DUA) - EXTERNAL_DUA => The Data Use Agreement (DUA) is managed externally ", alias="dataUsePolicy")
    data_file_number: Optional[StrictInt] = Field(default=None, description="The number of deposit data files.", alias="dataFileNumber")
    compliance_level: Optional[StrictStr] = Field(default=None, description="Compliance level to define the preservation quality based on data file format: - NOT_ASSESSED => The format could not be evaluated - NO_COMPLIANCE => The format could not be determined - WEAK_COMPLIANCE => The format was determined: content type detected - AVERAGE_COMPLIANCE => The format was determined: WEAK_COMPLIANCE + PRONOM identifier detected - FULL_COMPLIANCE => The format was determined: AVERAGE_COMPLIANCE + the format is part of golden formats ", alias="complianceLevel")
    collection_begin: Optional[datetime] = Field(default=None, description="The start date of the deposit for collecting data.", alias="collectionBegin")
    collection_end: Optional[datetime] = Field(default=None, description="The end date of the deposit for collecting data.", alias="collectionEnd")
    description: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=4096)]] = Field(default=None, description="The description of the deposit.")
    doi: Optional[StrictStr] = Field(default=None, description="The Digital Object Identifier (DOI) of the deposit.")
    ark: Optional[StrictStr] = Field(default=None, description="The ARK Identifier of the deposit.")
    embargo: Optional[EmbargoInfo] = None
    keywords: Optional[List[StrictStr]] = Field(default=None, description="The keyword List of the deposit.")
    language: Optional[Language] = None
    language_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The language identifier of the deposit.", alias="languageId")
    license_id: Optional[StrictStr] = Field(default=None, description="The license identifier of the deposit.", alias="licenseId")
    archive_type_id: Optional[StrictStr] = Field(default=None, description="The archive type identifier of the deposit.", alias="archiveTypeId")
    archive_type: Optional[ArchiveType] = Field(default=None, alias="archiveType")
    metadata_version: Optional[StrictStr] = Field(default=None, description="DLCM metadata are based on METS container, DataCite as descriptive metadata and PREMIS as administrative metadata. Metadata version: - 1.0 = DataCite 4.0 + PREMIS 3.0 + DLCM Info 1.0 - 1.1 = DataCite 4.0 + PREMIS 3.0 + DLCM Info 1.0 - 2.0 = DataCite 4.3 + PREMIS 3.0 + DLCM Info 2.0 + Data File Categories - 2.1 = DataCite 4.3 + PREMIS 3.0 + DLCM Info 2.1 + Dataset Thumbnail support - 3.0 = DataCite 4.4 + PREMIS 3.0 + DLCM Info 2.1 - 3.1 = DataCite 4.4 + PREMIS 3.0 + DLCM Info 2.2 + Archive Thumbnail & DUA & README support - 4.0 = Datacite 4.5 + PREMIS 3.0 + DLCM Info 3.0 + Update of Archive Thumbnail & DUA & README - 5.0 = Datacite 4.6 + PREMIS 3.0 + DLCM Info 3.0 + Modern ARK ", alias="metadataVersion")
    organizational_unit: Optional[OrganizationalUnit] = Field(default=None, alias="organizationalUnit")
    organizational_unit_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=2147483647)]] = Field(default=None, description="The organizational unit identifier of the deposit.", alias="organizationalUnitId")
    preparation_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The preparation identifier of the deposit.", alias="preparationId")
    preservation_policy: Optional[PreservationPolicy] = Field(default=None, alias="preservationPolicy")
    preservation_policy_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The preservation policy identifier of the deposit.", alias="preservationPolicyId")
    publication_date: Optional[date] = Field(default=None, description="The publication date of the deposit.", alias="publicationDate")
    sip_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The generated SIP identifier of the deposit.", alias="sipId")
    status: Optional[StrictStr] = Field(default=None, description="The status of the deposit.")
    status_message: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The detailed message related to the deposit status.", alias="statusMessage")
    submission_policy: Optional[SubmissionPolicy] = Field(default=None, alias="submissionPolicy")
    submission_policy_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The submission policy identifier of the deposit.", alias="submissionPolicyId")
    title: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="The title of the deposit.")
    contains_updated_metadata: Optional[StrictBool] = Field(default=None, description="If the package contains updated metadata.", alias="containsUpdatedMetadata")
    content_structure_public: Optional[StrictBool] = Field(default=None, description="If the archive structure content is public.", alias="contentStructurePublic")
    is_identical_to: Optional[StrictStr] = Field(default=None, description="DOI indicates that Archive A is identical to B, used to register two separate instances of the same resource.", alias="isIdenticalTo")
    is_obsoleted_by: Optional[StrictStr] = Field(default=None, description="DOI indicates A is replaced by B.", alias="isObsoletedBy")
    is_referenced_by: Optional[List[StrictStr]] = Field(default=None, description="List of DOI which indicates A is used as a source of information by B.", alias="isReferencedBy")
    anonymized_deposit_page_id: Optional[StrictStr] = Field(default=None, description="The id of the page listing all anonymized deposits of a given deposit", alias="anonymizedDepositPageId")
    additional_fields_values: Optional[StrictStr] = Field(default=None, description="Some eventual additional fields values generated through an additional fields form.", alias="additionalFieldsValues")
    additional_fields_form_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=50)]] = Field(default=None, description="The additional fields form ID used to generate the additional fields values.", alias="additionalFieldsFormId")
    error_status_with_message: Optional[StrictStr] = Field(default=None, alias="errorStatusWithMessage")
    collection_size: Optional[StrictInt] = Field(default=None, description="The number of archives in the deposit.", alias="collectionSize")
    has_embargo: Optional[StrictBool] = Field(default=None, alias="hasEmbargo")
    links: Optional[Dict[str, Link]] = Field(default=None, alias="_links")
    __properties: ClassVar[List[str]] = ["creation", "lastUpdate", "resId", "searchCriterias", "access", "dataSensitivity", "dataUsePolicy", "dataFileNumber", "complianceLevel", "collectionBegin", "collectionEnd", "description", "doi", "ark", "embargo", "keywords", "language", "languageId", "licenseId", "archiveTypeId", "archiveType", "metadataVersion", "organizationalUnit", "organizationalUnitId", "preparationId", "preservationPolicy", "preservationPolicyId", "publicationDate", "sipId", "status", "statusMessage", "submissionPolicy", "submissionPolicyId", "title", "containsUpdatedMetadata", "contentStructurePublic", "isIdenticalTo", "isObsoletedBy", "isReferencedBy", "anonymizedDepositPageId", "additionalFieldsValues", "additionalFieldsFormId", "errorStatusWithMessage", "collectionSize", "hasEmbargo", "_links"]

    @field_validator('access')
    def access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PUBLIC', 'RESTRICTED', 'CLOSED']):
            raise ValueError("must be one of enum values ('PUBLIC', 'RESTRICTED', 'CLOSED')")
        return value

    @field_validator('data_sensitivity')
    def data_sensitivity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNDEFINED', 'BLUE', 'GREEN', 'YELLOW', 'ORANGE', 'RED', 'CRIMSON']):
            raise ValueError("must be one of enum values ('UNDEFINED', 'BLUE', 'GREEN', 'YELLOW', 'ORANGE', 'RED', 'CRIMSON')")
        return value

    @field_validator('data_use_policy')
    def data_use_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NONE', 'LICENSE', 'CLICK_THROUGH_DUA', 'SIGNED_DUA', 'EXTERNAL_DUA']):
            raise ValueError("must be one of enum values ('NONE', 'LICENSE', 'CLICK_THROUGH_DUA', 'SIGNED_DUA', 'EXTERNAL_DUA')")
        return value

    @field_validator('compliance_level')
    def compliance_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NOT_ASSESSED', 'NO_COMPLIANCE', 'WEAK_COMPLIANCE', 'AVERAGE_COMPLIANCE', 'FULL_COMPLIANCE']):
            raise ValueError("must be one of enum values ('NOT_ASSESSED', 'NO_COMPLIANCE', 'WEAK_COMPLIANCE', 'AVERAGE_COMPLIANCE', 'FULL_COMPLIANCE')")
        return value

    @field_validator('metadata_version')
    def metadata_version_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['1.0', '1.1', '2.0', '2.1', '3.0', '3.1', '4.0', '5.0']):
            raise ValueError("must be one of enum values ('1.0', '1.1', '2.0', '2.1', '3.0', '3.1', '4.0', '5.0')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['APPROVED', 'CHECKED', 'CLEANED', 'CLEANING', 'COMPLETED', 'DELETING', 'IN_ERROR', 'IN_PROGRESS', 'IN_VALIDATION', 'REJECTED', 'SUBMITTED', 'EDITING_METADATA', 'UPGRADING_METADATA', 'CHECKING_COMPLIANCE', 'CHECKING_COMPLIANCE_CLEANED', 'COMPLIANCE_ERROR', 'CANCEL_EDITING_METADATA', 'EDITING_METADATA_REJECTED', 'SUBMISSION_AGREEMENT_APPROVED', 'RELOADING']):
            raise ValueError("must be one of enum values ('APPROVED', 'CHECKED', 'CLEANED', 'CLEANING', 'COMPLETED', 'DELETING', 'IN_ERROR', 'IN_PROGRESS', 'IN_VALIDATION', 'REJECTED', 'SUBMITTED', 'EDITING_METADATA', 'UPGRADING_METADATA', 'CHECKING_COMPLIANCE', 'CHECKING_COMPLIANCE_CLEANED', 'COMPLIANCE_ERROR', 'CANCEL_EDITING_METADATA', 'EDITING_METADATA_REJECTED', 'SUBMISSION_AGREEMENT_APPROVED', 'RELOADING')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Deposit from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "data_file_number",
            "collection_size",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of creation
        if self.creation:
            _dict['creation'] = self.creation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_update
        if self.last_update:
            _dict['lastUpdate'] = self.last_update.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in search_criterias (list)
        _items = []
        if self.search_criterias:
            for _item_search_criterias in self.search_criterias:
                if _item_search_criterias:
                    _items.append(_item_search_criterias.to_dict())
            _dict['searchCriterias'] = _items
        # override the default output from pydantic by calling `to_dict()` of embargo
        if self.embargo:
            _dict['embargo'] = self.embargo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of language
        if self.language:
            _dict['language'] = self.language.to_dict()
        # override the default output from pydantic by calling `to_dict()` of archive_type
        if self.archive_type:
            _dict['archiveType'] = self.archive_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of organizational_unit
        if self.organizational_unit:
            _dict['organizationalUnit'] = self.organizational_unit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of preservation_policy
        if self.preservation_policy:
            _dict['preservationPolicy'] = self.preservation_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of submission_policy
        if self.submission_policy:
            _dict['submissionPolicy'] = self.submission_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in links (dict)
        _field_dict = {}
        if self.links:
            for _key_links in self.links:
                if self.links[_key_links]:
                    _field_dict[_key_links] = self.links[_key_links].to_dict()
            _dict['_links'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Deposit from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "creation": ChangeInfo.from_dict(obj["creation"]) if obj.get("creation") is not None else None,
            "lastUpdate": ChangeInfo.from_dict(obj["lastUpdate"]) if obj.get("lastUpdate") is not None else None,
            "resId": obj.get("resId"),
            "searchCriterias": [SearchCriteria.from_dict(_item) for _item in obj["searchCriterias"]] if obj.get("searchCriterias") is not None else None,
            "access": obj.get("access"),
            "dataSensitivity": obj.get("dataSensitivity"),
            "dataUsePolicy": obj.get("dataUsePolicy"),
            "dataFileNumber": obj.get("dataFileNumber"),
            "complianceLevel": obj.get("complianceLevel"),
            "collectionBegin": obj.get("collectionBegin"),
            "collectionEnd": obj.get("collectionEnd"),
            "description": obj.get("description"),
            "doi": obj.get("doi"),
            "ark": obj.get("ark"),
            "embargo": EmbargoInfo.from_dict(obj["embargo"]) if obj.get("embargo") is not None else None,
            "keywords": obj.get("keywords"),
            "language": Language.from_dict(obj["language"]) if obj.get("language") is not None else None,
            "languageId": obj.get("languageId"),
            "licenseId": obj.get("licenseId"),
            "archiveTypeId": obj.get("archiveTypeId"),
            "archiveType": ArchiveType.from_dict(obj["archiveType"]) if obj.get("archiveType") is not None else None,
            "metadataVersion": obj.get("metadataVersion"),
            "organizationalUnit": OrganizationalUnit.from_dict(obj["organizationalUnit"]) if obj.get("organizationalUnit") is not None else None,
            "organizationalUnitId": obj.get("organizationalUnitId"),
            "preparationId": obj.get("preparationId"),
            "preservationPolicy": PreservationPolicy.from_dict(obj["preservationPolicy"]) if obj.get("preservationPolicy") is not None else None,
            "preservationPolicyId": obj.get("preservationPolicyId"),
            "publicationDate": obj.get("publicationDate"),
            "sipId": obj.get("sipId"),
            "status": obj.get("status"),
            "statusMessage": obj.get("statusMessage"),
            "submissionPolicy": SubmissionPolicy.from_dict(obj["submissionPolicy"]) if obj.get("submissionPolicy") is not None else None,
            "submissionPolicyId": obj.get("submissionPolicyId"),
            "title": obj.get("title"),
            "containsUpdatedMetadata": obj.get("containsUpdatedMetadata"),
            "contentStructurePublic": obj.get("contentStructurePublic"),
            "isIdenticalTo": obj.get("isIdenticalTo"),
            "isObsoletedBy": obj.get("isObsoletedBy"),
            "isReferencedBy": obj.get("isReferencedBy"),
            "anonymizedDepositPageId": obj.get("anonymizedDepositPageId"),
            "additionalFieldsValues": obj.get("additionalFieldsValues"),
            "additionalFieldsFormId": obj.get("additionalFieldsFormId"),
            "errorStatusWithMessage": obj.get("errorStatusWithMessage"),
            "collectionSize": obj.get("collectionSize"),
            "hasEmbargo": obj.get("hasEmbargo"),
            "_links": dict(
                (_k, Link.from_dict(_v))
                for _k, _v in obj["_links"].items()
            )
            if obj.get("_links") is not None
            else None
        })
        return _obj


