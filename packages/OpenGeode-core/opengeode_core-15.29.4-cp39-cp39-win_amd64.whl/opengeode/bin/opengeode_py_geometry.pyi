"""
OpenGeode Python binding for geometry
"""
from __future__ import annotations
import pybind11_stubgen.typing_ext
import typing
__all__: list[str] = ['Angle', 'BoundingBox2D', 'BoundingBox3D', 'Circle', 'ColocatedInfo2D', 'ColocatedInfo3D', 'CoordinateSystem1D', 'CoordinateSystem2D', 'CoordinateSystem3D', 'Cylinder', 'Frame1D', 'Frame2D', 'Frame3D', 'INTERSECTION_TYPE', 'InfiniteLine2D', 'InfiniteLine3D', 'IntersectionResultInfiniteLine3D', 'IntersectionResultInlinedVectorPoint2D', 'IntersectionResultInlinedVectorPoint3D', 'IntersectionResultPoint2D', 'IntersectionResultPoint3D', 'NNSearch2D', 'NNSearch3D', 'OpenGeodeGeometryLibrary', 'Plane', 'Point1D', 'Point2D', 'Point3D', 'Position', 'Ray2D', 'Ray3D', 'Segment2D', 'Segment3D', 'Side', 'Sphere2D', 'Sphere3D', 'Tetrahedron', 'Triangle2D', 'Triangle3D', 'Vector1D', 'Vector2D', 'Vector3D', 'colinear_segment_segment_intersection_detection2D', 'dot_perpendicular', 'edge0', 'edge01', 'edge02', 'edge03', 'edge1', 'edge12', 'edge13', 'edge2', 'edge23', 'facet0', 'facet1', 'facet2', 'facet3', 'incorrect', 'inside', 'intersect', 'lexicographic_mapping2D', 'lexicographic_mapping3D', 'line_cylinder_intersection3D', 'line_line_intersection2D', 'line_plane_intersection3D', 'line_sphere_intersection2D', 'line_sphere_intersection3D', 'line_triangle_distance3D', 'line_triangle_intersection3D', 'line_triangle_intersection_detection3D', 'morton_mapping2D', 'morton_mapping3D', 'negative', 'none', 'ostream_redirect', 'outside', 'parallel', 'perpendicular', 'plane_circle_intersection3D', 'point_ball_distance2D', 'point_ball_distance3D', 'point_circle_distance3D', 'point_circle_signed_distance3D', 'point_disk_distance3D', 'point_line_distance2D', 'point_line_distance3D', 'point_line_projection2D', 'point_line_projection3D', 'point_line_signed_distance2D', 'point_plane_distance3D', 'point_plane_projection', 'point_plane_signed_distance3D', 'point_point_distance2D', 'point_point_distance3D', 'point_segment_distance2D', 'point_segment_distance3D', 'point_segment_position2D', 'point_segment_position3D', 'point_segment_projection2D', 'point_segment_projection3D', 'point_side_to_line2D', 'point_side_to_plane3D', 'point_side_to_segment2D', 'point_side_to_triangle3D', 'point_sphere_distance2D', 'point_sphere_distance3D', 'point_sphere_signed_distance2D', 'point_sphere_signed_distance3D', 'point_tetrahedron_distance3D', 'point_tetrahedron_position3D', 'point_triangle_distance2D', 'point_triangle_distance3D', 'point_triangle_position2D', 'point_triangle_position3D', 'point_triangle_projection2D', 'point_triangle_projection3D', 'point_triangle_signed_distance3D', 'positive', 'rotate', 'segment_barycentric_coordinates2D', 'segment_barycentric_coordinates3D', 'segment_cylinder_intersection3D', 'segment_line_distance2D', 'segment_line_distance3D', 'segment_line_intersection2D', 'segment_line_intersection_detection2D', 'segment_plane_intersection3D', 'segment_plane_intersection_detection3D', 'segment_segment_distance2D', 'segment_segment_distance3D', 'segment_segment_intersection2D', 'segment_segment_intersection_detection2D', 'segment_sphere_intersection2D', 'segment_sphere_intersection3D', 'segment_triangle_distance3D', 'segment_triangle_intersection3D', 'segment_triangle_intersection_detection3D', 'tetrahedron_barycentric_coordinates', 'tetrahedron_signed_volume', 'tetrahedron_volume', 'tetrahedron_volume_sign', 'triangle_area2D', 'triangle_area3D', 'triangle_area_sign2D', 'triangle_area_sign3D', 'triangle_barycentric_coordinates2D', 'triangle_barycentric_coordinates3D', 'triangle_circle_intersection3D', 'triangle_signed_area2D', 'triangle_signed_area3D', 'vertex0', 'vertex1', 'vertex2', 'vertex3', 'zero']
class Angle:
    __hash__: typing.ClassVar[None] = None
    def __add__(self, arg0: Angle) -> Angle:
        ...
    def __eq__(self, arg0: Angle) -> bool:
        ...
    def __gt__(self, arg0: Angle) -> bool:
        ...
    def __lt__(self, arg0: Angle) -> bool:
        ...
    def __mul__(self, arg0: float) -> Angle:
        ...
    def __sub__(self, arg0: Angle) -> Angle:
        ...
    def __truediv__(self, arg0: float) -> Angle:
        ...
    def cos(self) -> float:
        ...
    def create_from_degrees(self: float) -> Angle:
        ...
    def create_from_radians(self: float) -> Angle:
        ...
    def degrees(self) -> float:
        ...
    def inexact_equal(self, arg0: Angle) -> bool:
        ...
    def normalized_between_0_and_2pi(self) -> Angle:
        ...
    def normalized_between_0_and_pi(self) -> Angle:
        ...
    def normalized_between_minuspi_and_pi(self) -> Angle:
        ...
    def radians(self) -> float:
        ...
    def sin(self) -> float:
        ...
    def tan(self) -> float:
        ...
class BoundingBox2D:
    def __init__(self) -> None:
        ...
    def add_box(self, arg0: BoundingBox2D) -> None:
        ...
    def add_point(self, arg0: Point2D) -> None:
        ...
    def center(self) -> Point2D:
        ...
    def contains_bbox(self, arg0: BoundingBox2D) -> bool:
        ...
    def contains_point(self, arg0: Point2D) -> bool:
        ...
    def diagonal(self) -> Vector2D:
        ...
    def intersects_bbox(self, arg0: BoundingBox2D) -> bool:
        ...
    def largest_length(self) -> tuple[int, float]:
        ...
    def max(self) -> Point2D:
        ...
    def min(self) -> Point2D:
        ...
    def smallest_length(self) -> tuple[int, float]:
        ...
class BoundingBox3D:
    def __init__(self) -> None:
        ...
    def add_box(self, arg0: BoundingBox3D) -> None:
        ...
    def add_point(self, arg0: Point3D) -> None:
        ...
    def center(self) -> Point3D:
        ...
    def contains_bbox(self, arg0: BoundingBox3D) -> bool:
        ...
    def contains_point(self, arg0: Point3D) -> bool:
        ...
    def diagonal(self) -> Vector3D:
        ...
    def intersects_bbox(self, arg0: BoundingBox3D) -> bool:
        ...
    def largest_length(self) -> tuple[int, float]:
        ...
    def max(self) -> Point3D:
        ...
    def min(self) -> Point3D:
        ...
    def smallest_length(self) -> tuple[int, float]:
        ...
class Circle:
    def __init__(self, arg0: Plane, arg1: float) -> None:
        ...
    def bounding_box(self) -> BoundingBox3D:
        ...
    def plane(self) -> Plane:
        ...
    def radius(self) -> float:
        ...
class ColocatedInfo2D:
    def nb_colocated_points(self) -> int:
        ...
    def nb_unique_points(self) -> int:
        ...
    @property
    def colocated_mapping(self) -> list[int]:
        ...
    @property
    def unique_points(self) -> list[Point2D]:
        ...
class ColocatedInfo3D:
    def nb_colocated_points(self) -> int:
        ...
    def nb_unique_points(self) -> int:
        ...
    @property
    def colocated_mapping(self) -> list[int]:
        ...
    @property
    def unique_points(self) -> list[Point3D]:
        ...
class CoordinateSystem1D:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector1D], pybind11_stubgen.typing_ext.FixedSize(1)], arg1: Point1D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point1D, arg1: typing.Annotated[list[Point1D], pybind11_stubgen.typing_ext.FixedSize(1)]) -> None:
        ...
    def coordinates(self, arg0: Point1D) -> Point1D:
        ...
    def global_coordinates(self, arg0: Point1D) -> Point1D:
        ...
    def origin(self) -> Point1D:
        ...
    def set_origin(self, arg0: Point1D) -> None:
        ...
    def string(self) -> str:
        ...
class CoordinateSystem2D:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector2D], pybind11_stubgen.typing_ext.FixedSize(2)], arg1: Point2D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point2D, arg1: typing.Annotated[list[Point2D], pybind11_stubgen.typing_ext.FixedSize(2)]) -> None:
        ...
    def coordinates(self, arg0: Point2D) -> Point2D:
        ...
    def global_coordinates(self, arg0: Point2D) -> Point2D:
        ...
    def origin(self) -> Point2D:
        ...
    def set_origin(self, arg0: Point2D) -> None:
        ...
    def string(self) -> str:
        ...
class CoordinateSystem3D:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector3D], pybind11_stubgen.typing_ext.FixedSize(3)], arg1: Point3D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point3D, arg1: typing.Annotated[list[Point3D], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def coordinates(self, arg0: Point3D) -> Point3D:
        ...
    def global_coordinates(self, arg0: Point3D) -> Point3D:
        ...
    def origin(self) -> Point3D:
        ...
    def set_origin(self, arg0: Point3D) -> None:
        ...
    def string(self) -> str:
        ...
class Cylinder:
    def __init__(self, arg0: Segment3D, arg1: float) -> None:
        ...
    def axis(self) -> Segment3D:
        ...
    def radius(self) -> float:
        ...
class Frame1D:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector1D], pybind11_stubgen.typing_ext.FixedSize(1)]) -> None:
        ...
    def direction(self, arg0: int) -> Vector1D:
        ...
    def inverse(self) -> Frame1D:
        ...
    def rescale(self, arg0: float) -> Frame1D:
        ...
    def set_direction(self, arg0: int, arg1: Vector1D) -> None:
        ...
    def string(self) -> str:
        ...
class Frame2D:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector2D], pybind11_stubgen.typing_ext.FixedSize(2)]) -> None:
        ...
    def direction(self, arg0: int) -> Vector2D:
        ...
    def inverse(self) -> Frame2D:
        ...
    def rescale(self, arg0: float) -> Frame2D:
        ...
    def set_direction(self, arg0: int, arg1: Vector2D) -> None:
        ...
    def string(self) -> str:
        ...
class Frame3D:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector3D], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def direction(self, arg0: int) -> Vector3D:
        ...
    def inverse(self) -> Frame3D:
        ...
    def rescale(self, arg0: float) -> Frame3D:
        ...
    def set_direction(self, arg0: int, arg1: Vector3D) -> None:
        ...
    def string(self) -> str:
        ...
class INTERSECTION_TYPE:
    """
    Members:
    
      none
    
      intersect
    
      parallel
    
      incorrect
    """
    __members__: typing.ClassVar[dict[str, INTERSECTION_TYPE]]  # value = {'none': <INTERSECTION_TYPE.none: 0>, 'intersect': <INTERSECTION_TYPE.intersect: 1>, 'parallel': <INTERSECTION_TYPE.parallel: 2>, 'incorrect': <INTERSECTION_TYPE.incorrect: 3>}
    incorrect: typing.ClassVar[INTERSECTION_TYPE]  # value = <INTERSECTION_TYPE.incorrect: 3>
    intersect: typing.ClassVar[INTERSECTION_TYPE]  # value = <INTERSECTION_TYPE.intersect: 1>
    none: typing.ClassVar[INTERSECTION_TYPE]  # value = <INTERSECTION_TYPE.none: 0>
    parallel: typing.ClassVar[INTERSECTION_TYPE]  # value = <INTERSECTION_TYPE.parallel: 2>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class InfiniteLine2D:
    @typing.overload
    def __init__(self, arg0: Vector2D, arg1: Point2D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Segment2D) -> None:
        ...
    def direction(self) -> Vector2D:
        ...
    def origin(self) -> Point2D:
        ...
class InfiniteLine3D:
    @typing.overload
    def __init__(self, arg0: Vector3D, arg1: Point3D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Segment3D) -> None:
        ...
    def direction(self) -> Vector3D:
        ...
    def origin(self) -> Point3D:
        ...
class IntersectionResultInfiniteLine3D:
    def has_intersection(self) -> bool:
        ...
    @property
    def result(self) -> InfiniteLine3D | None:
        ...
    @property
    def type(self) -> INTERSECTION_TYPE:
        ...
class IntersectionResultInlinedVectorPoint2D:
    def has_intersection(self) -> bool:
        ...
    @property
    def result(self) -> list[Point2D] | None:
        ...
    @property
    def type(self) -> INTERSECTION_TYPE:
        ...
class IntersectionResultInlinedVectorPoint3D:
    def has_intersection(self) -> bool:
        ...
    @property
    def result(self) -> list[Point3D] | None:
        ...
    @property
    def type(self) -> INTERSECTION_TYPE:
        ...
class IntersectionResultPoint2D:
    def has_intersection(self) -> bool:
        ...
    @property
    def result(self) -> Point2D | None:
        ...
    @property
    def type(self) -> INTERSECTION_TYPE:
        ...
class IntersectionResultPoint3D:
    def has_intersection(self) -> bool:
        ...
    @property
    def result(self) -> Point3D | None:
        ...
    @property
    def type(self) -> INTERSECTION_TYPE:
        ...
class NNSearch2D:
    def __init__(self, arg0: list[Point2D]) -> None:
        ...
    def closest_neighbor(self, arg0: Point2D) -> int:
        ...
    def frame_colocated_index_mapping(self, arg0: Frame2D) -> ColocatedInfo2D:
        ...
    def frame_neighbors(self, arg0: Point2D, arg1: Frame2D) -> list[int]:
        ...
    def nb_points(self) -> int:
        ...
    def neighbors(self, arg0: Point2D, arg1: int) -> list[int]:
        ...
    def point(self, arg0: int) -> Point2D:
        ...
    def radius_colocated_index_mapping(self, arg0: float) -> ColocatedInfo2D:
        ...
    def radius_neighbors(self, arg0: Point2D, arg1: float) -> list[int]:
        ...
class NNSearch3D:
    def __init__(self, arg0: list[Point3D]) -> None:
        ...
    def closest_neighbor(self, arg0: Point3D) -> int:
        ...
    def frame_colocated_index_mapping(self, arg0: Frame3D) -> ColocatedInfo3D:
        ...
    def frame_neighbors(self, arg0: Point3D, arg1: Frame3D) -> list[int]:
        ...
    def nb_points(self) -> int:
        ...
    def neighbors(self, arg0: Point3D, arg1: int) -> list[int]:
        ...
    def point(self, arg0: int) -> Point3D:
        ...
    def radius_colocated_index_mapping(self, arg0: float) -> ColocatedInfo3D:
        ...
    def radius_neighbors(self, arg0: Point3D, arg1: float) -> list[int]:
        ...
class OpenGeodeGeometryLibrary:
    @staticmethod
    def initialize() -> None:
        ...
class Plane:
    def __init__(self, arg0: Vector3D, arg1: Point3D) -> None:
        ...
    def normal(self) -> Vector3D:
        ...
    def origin(self) -> Point3D:
        ...
    def plane_constant(self) -> float:
        ...
class Point1D:
    __hash__: typing.ClassVar[None] = None
    def __add__(self, arg0: Point1D) -> Point1D:
        ...
    def __eq__(self, arg0: Point1D) -> bool:
        ...
    def __iadd__(self, arg0: Point1D) -> None:
        ...
    def __imul__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(1)]) -> None:
        ...
    def __isub__(self, arg0: Point1D) -> None:
        ...
    def __itruediv__(self, arg0: float) -> None:
        ...
    def __mul__(self, arg0: float) -> Point1D:
        ...
    def __ne__(self, arg0: Point1D) -> bool:
        ...
    def __sub__(self, arg0: Point1D) -> Point1D:
        ...
    def __truediv__(self, arg0: float) -> Point1D:
        ...
    def inexact_equal(self, arg0: Point1D) -> bool:
        ...
    def set_value(self, arg0: int, arg1: float) -> None:
        ...
    def string(self) -> str:
        ...
    def value(self, arg0: int) -> float:
        ...
class Point2D:
    __hash__: typing.ClassVar[None] = None
    def __add__(self, arg0: Point2D) -> Point2D:
        ...
    def __eq__(self, arg0: Point2D) -> bool:
        ...
    def __iadd__(self, arg0: Point2D) -> None:
        ...
    def __imul__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]) -> None:
        ...
    def __isub__(self, arg0: Point2D) -> None:
        ...
    def __itruediv__(self, arg0: float) -> None:
        ...
    def __mul__(self, arg0: float) -> Point2D:
        ...
    def __ne__(self, arg0: Point2D) -> bool:
        ...
    def __sub__(self, arg0: Point2D) -> Point2D:
        ...
    def __truediv__(self, arg0: float) -> Point2D:
        ...
    def inexact_equal(self, arg0: Point2D) -> bool:
        ...
    def set_value(self, arg0: int, arg1: float) -> None:
        ...
    def string(self) -> str:
        ...
    def value(self, arg0: int) -> float:
        ...
class Point3D:
    __hash__: typing.ClassVar[None] = None
    def __add__(self, arg0: Point3D) -> Point3D:
        ...
    def __eq__(self, arg0: Point3D) -> bool:
        ...
    def __iadd__(self, arg0: Point3D) -> None:
        ...
    def __imul__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def __isub__(self, arg0: Point3D) -> None:
        ...
    def __itruediv__(self, arg0: float) -> None:
        ...
    def __mul__(self, arg0: float) -> Point3D:
        ...
    def __ne__(self, arg0: Point3D) -> bool:
        ...
    def __sub__(self, arg0: Point3D) -> Point3D:
        ...
    def __truediv__(self, arg0: float) -> Point3D:
        ...
    def inexact_equal(self, arg0: Point3D) -> bool:
        ...
    def set_value(self, arg0: int, arg1: float) -> None:
        ...
    def string(self) -> str:
        ...
    def value(self, arg0: int) -> float:
        ...
class Position:
    """
    Members:
    
      outside
    
      inside
    
      vertex0
    
      vertex1
    
      vertex2
    
      vertex3
    
      edge0
    
      edge1
    
      edge2
    
      edge01
    
      edge02
    
      edge03
    
      edge12
    
      edge13
    
      edge23
    
      facet0
    
      facet1
    
      facet2
    
      facet3
    
      parallel
    """
    __members__: typing.ClassVar[dict[str, Position]]  # value = {'outside': <Position.outside: 0>, 'inside': <Position.inside: 1>, 'vertex0': <Position.vertex0: 2>, 'vertex1': <Position.vertex1: 3>, 'vertex2': <Position.vertex2: 4>, 'vertex3': <Position.vertex3: 5>, 'edge0': <Position.edge0: 6>, 'edge1': <Position.edge1: 7>, 'edge2': <Position.edge2: 8>, 'edge01': <Position.edge01: 9>, 'edge02': <Position.edge02: 10>, 'edge03': <Position.edge03: 11>, 'edge12': <Position.edge12: 12>, 'edge13': <Position.edge13: 13>, 'edge23': <Position.edge23: 14>, 'facet0': <Position.facet0: 15>, 'facet1': <Position.facet1: 16>, 'facet2': <Position.facet2: 17>, 'facet3': <Position.facet3: 18>, 'parallel': <Position.parallel: 19>}
    edge0: typing.ClassVar[Position]  # value = <Position.edge0: 6>
    edge01: typing.ClassVar[Position]  # value = <Position.edge01: 9>
    edge02: typing.ClassVar[Position]  # value = <Position.edge02: 10>
    edge03: typing.ClassVar[Position]  # value = <Position.edge03: 11>
    edge1: typing.ClassVar[Position]  # value = <Position.edge1: 7>
    edge12: typing.ClassVar[Position]  # value = <Position.edge12: 12>
    edge13: typing.ClassVar[Position]  # value = <Position.edge13: 13>
    edge2: typing.ClassVar[Position]  # value = <Position.edge2: 8>
    edge23: typing.ClassVar[Position]  # value = <Position.edge23: 14>
    facet0: typing.ClassVar[Position]  # value = <Position.facet0: 15>
    facet1: typing.ClassVar[Position]  # value = <Position.facet1: 16>
    facet2: typing.ClassVar[Position]  # value = <Position.facet2: 17>
    facet3: typing.ClassVar[Position]  # value = <Position.facet3: 18>
    inside: typing.ClassVar[Position]  # value = <Position.inside: 1>
    outside: typing.ClassVar[Position]  # value = <Position.outside: 0>
    parallel: typing.ClassVar[Position]  # value = <Position.parallel: 19>
    vertex0: typing.ClassVar[Position]  # value = <Position.vertex0: 2>
    vertex1: typing.ClassVar[Position]  # value = <Position.vertex1: 3>
    vertex2: typing.ClassVar[Position]  # value = <Position.vertex2: 4>
    vertex3: typing.ClassVar[Position]  # value = <Position.vertex3: 5>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Ray2D:
    @typing.overload
    def __init__(self, arg0: Vector2D, arg1: Point2D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Segment2D) -> None:
        ...
    def direction(self) -> Vector2D:
        ...
    def origin(self) -> Point2D:
        ...
class Ray3D:
    @typing.overload
    def __init__(self, arg0: Vector3D, arg1: Point3D) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Segment3D) -> None:
        ...
    def direction(self) -> Vector3D:
        ...
    def origin(self) -> Point3D:
        ...
class Segment2D:
    def __init__(self, arg0: Point2D, arg1: Point2D) -> None:
        ...
    def barycenter(self) -> Point2D:
        ...
    def bounding_box(self) -> BoundingBox2D:
        ...
    def direction(self) -> Vector2D:
        ...
    def length(self) -> float:
        ...
    def normalized_direction(self) -> Vector2D:
        ...
    def vertices(self) -> typing.Annotated[list[Point2D], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
class Segment3D:
    def __init__(self, arg0: Point3D, arg1: Point3D) -> None:
        ...
    def barycenter(self) -> Point3D:
        ...
    def bounding_box(self) -> BoundingBox3D:
        ...
    def direction(self) -> Vector3D:
        ...
    def length(self) -> float:
        ...
    def normalized_direction(self) -> Vector3D:
        ...
    def vertices(self) -> typing.Annotated[list[Point3D], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
class Side:
    """
    Members:
    
      positive
    
      negative
    
      zero
    """
    __members__: typing.ClassVar[dict[str, Side]]  # value = {'positive': <Side.positive: 0>, 'negative': <Side.negative: 1>, 'zero': <Side.zero: 2>}
    negative: typing.ClassVar[Side]  # value = <Side.negative: 1>
    positive: typing.ClassVar[Side]  # value = <Side.positive: 0>
    zero: typing.ClassVar[Side]  # value = <Side.zero: 2>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Sphere2D:
    def __init__(self, arg0: Point2D, arg1: float) -> None:
        ...
    def bounding_box(self) -> BoundingBox2D:
        ...
    def origin(self) -> Point2D:
        ...
    def radius(self) -> float:
        ...
class Sphere3D:
    def __init__(self, arg0: Point3D, arg1: float) -> None:
        ...
    def bounding_box(self) -> BoundingBox3D:
        ...
    def origin(self) -> Point3D:
        ...
    def radius(self) -> float:
        ...
class Tetrahedron:
    def __init__(self, arg0: Point3D, arg1: Point3D, arg2: Point3D, arg3: Point3D) -> None:
        ...
    def bounding_box(self) -> BoundingBox3D:
        ...
    def vertices(self) -> typing.Annotated[list[Point3D], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
class Triangle2D:
    def __init__(self, arg0: Point2D, arg1: Point2D, arg2: Point2D) -> None:
        ...
    def barycenter(self) -> Point2D:
        ...
    def bounding_box(self) -> BoundingBox2D:
        ...
    def is_degenerated(self) -> bool:
        ...
    def longest_edge_index(self) -> int:
        ...
    def minimum_height(self) -> float:
        ...
    def smallest_edge_index(self) -> int:
        ...
    def string(self) -> str:
        ...
    def vertices(self) -> typing.Annotated[list[Point2D], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Triangle3D:
    def __init__(self, arg0: Point3D, arg1: Point3D, arg2: Point3D) -> None:
        ...
    def barycenter(self) -> Point3D:
        ...
    def bounding_box(self) -> BoundingBox3D:
        ...
    def is_degenerated(self) -> bool:
        ...
    def longest_edge_index(self) -> int:
        ...
    def minimum_height(self) -> float:
        ...
    def normal(self) -> Vector3D | None:
        ...
    def plane(self) -> Plane | None:
        ...
    def smallest_edge_index(self) -> int:
        ...
    def string(self) -> str:
        ...
    def vertices(self) -> typing.Annotated[list[Point3D], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Vector1D(Point1D):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(1)]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point1D, arg1: Point1D) -> None:
        ...
    def dot(self, arg0: Vector1D) -> float:
        ...
    def length(self) -> float:
        ...
    def length2(self) -> float:
        ...
    def normalize(self) -> Vector1D:
        ...
class Vector2D(Point2D):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point2D, arg1: Point2D) -> None:
        ...
    def dot(self, arg0: Vector2D) -> float:
        ...
    def length(self) -> float:
        ...
    def length2(self) -> float:
        ...
    def normalize(self) -> Vector2D:
        ...
class Vector3D(Point3D):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Point3D, arg1: Point3D) -> None:
        ...
    def cross(self, arg0: Vector3D) -> Vector3D:
        ...
    def dot(self, arg0: Vector3D) -> float:
        ...
    def length(self) -> float:
        ...
    def length2(self) -> float:
        ...
    def normalize(self) -> Vector3D:
        ...
class ostream_redirect:
    def __enter__(self) -> None:
        ...
    def __exit__(self, *args) -> None:
        ...
    def __init__(self, stdout: bool = True, stderr: bool = True) -> None:
        ...
def colinear_segment_segment_intersection_detection2D(arg0: Segment2D, arg1: Segment2D) -> tuple[Position, Position]:
    ...
def dot_perpendicular(arg0: Vector2D, arg1: Vector2D) -> float:
    ...
def lexicographic_mapping2D(arg0: list[Point2D]) -> list[int]:
    ...
def lexicographic_mapping3D(arg0: list[Point3D]) -> list[int]:
    ...
def line_cylinder_intersection3D(arg0: InfiniteLine3D, arg1: Cylinder) -> IntersectionResultInlinedVectorPoint3D:
    ...
def line_line_intersection2D(arg0: InfiniteLine2D, arg1: InfiniteLine2D) -> IntersectionResultPoint2D:
    ...
def line_plane_intersection3D(arg0: InfiniteLine3D, arg1: Plane) -> IntersectionResultPoint3D:
    ...
@typing.overload
def line_sphere_intersection2D(arg0: InfiniteLine2D, arg1: Sphere2D) -> IntersectionResultInlinedVectorPoint2D:
    ...
@typing.overload
def line_sphere_intersection2D(arg0: InfiniteLine2D, arg1: Sphere2D) -> IntersectionResultInlinedVectorPoint2D:
    ...
@typing.overload
def line_sphere_intersection3D(arg0: InfiniteLine3D, arg1: Sphere3D) -> IntersectionResultInlinedVectorPoint3D:
    ...
@typing.overload
def line_sphere_intersection3D(arg0: InfiniteLine3D, arg1: Sphere3D) -> IntersectionResultInlinedVectorPoint3D:
    ...
def line_triangle_distance3D(arg0: InfiniteLine3D, arg1: Triangle3D) -> tuple[float, Point3D, Point3D]:
    ...
def line_triangle_intersection3D(arg0: InfiniteLine3D, arg1: Triangle3D) -> IntersectionResultPoint3D:
    ...
def line_triangle_intersection_detection3D(arg0: InfiniteLine3D, arg1: Triangle3D) -> Position:
    ...
def morton_mapping2D(arg0: list[Point2D]) -> list[int]:
    ...
def morton_mapping3D(arg0: list[Point3D]) -> list[int]:
    ...
def perpendicular(arg0: Vector2D) -> Vector2D:
    ...
def plane_circle_intersection3D(arg0: Plane, arg1: Circle) -> IntersectionResultInlinedVectorPoint3D:
    ...
def point_ball_distance2D(arg0: Point2D, arg1: Sphere2D) -> tuple[float, Point2D]:
    ...
def point_ball_distance3D(arg0: Point3D, arg1: Sphere3D) -> tuple[float, Point3D]:
    ...
def point_circle_distance3D(arg0: Point3D, arg1: Circle) -> tuple[float, Point3D]:
    ...
def point_circle_signed_distance3D(arg0: Point3D, arg1: Circle) -> tuple[float, Point3D]:
    ...
def point_disk_distance3D(arg0: Point3D, arg1: Circle) -> tuple[float, Point3D]:
    ...
def point_line_distance2D(arg0: Point2D, arg1: InfiniteLine2D) -> float:
    ...
def point_line_distance3D(arg0: Point3D, arg1: InfiniteLine3D) -> float:
    ...
def point_line_projection2D(arg0: Point2D, arg1: InfiniteLine2D) -> Point2D:
    ...
def point_line_projection3D(arg0: Point3D, arg1: InfiniteLine3D) -> Point3D:
    ...
def point_line_signed_distance2D(arg0: Point2D, arg1: InfiniteLine2D) -> float:
    ...
def point_plane_distance3D(arg0: Point3D, arg1: Plane) -> tuple[float, Point3D]:
    ...
def point_plane_projection(arg0: Point3D, arg1: Plane) -> Point3D:
    ...
def point_plane_signed_distance3D(arg0: Point3D, arg1: Plane) -> tuple[float, Point3D]:
    ...
def point_point_distance2D(arg0: Point2D, arg1: Point2D) -> float:
    ...
def point_point_distance3D(arg0: Point3D, arg1: Point3D) -> float:
    ...
def point_segment_distance2D(arg0: Point2D, arg1: Segment2D) -> float:
    ...
def point_segment_distance3D(arg0: Point3D, arg1: Segment3D) -> float:
    ...
def point_segment_position2D(arg0: Point2D, arg1: Segment2D) -> Position:
    ...
def point_segment_position3D(arg0: Point3D, arg1: Segment3D) -> Position:
    ...
def point_segment_projection2D(arg0: Point2D, arg1: Segment2D) -> Point2D:
    ...
def point_segment_projection3D(arg0: Point3D, arg1: Segment3D) -> Point3D:
    ...
def point_side_to_line2D(arg0: Point2D, arg1: InfiniteLine2D) -> Side:
    ...
def point_side_to_plane3D(arg0: Point3D, arg1: Plane) -> Side:
    ...
def point_side_to_segment2D(arg0: Point2D, arg1: Segment2D) -> Side:
    ...
def point_side_to_triangle3D(arg0: Point3D, arg1: Triangle3D) -> Side:
    ...
def point_sphere_distance2D(arg0: Point2D, arg1: Sphere2D) -> tuple[float, Point2D]:
    ...
def point_sphere_distance3D(arg0: Point3D, arg1: Sphere3D) -> tuple[float, Point3D]:
    ...
def point_sphere_signed_distance2D(arg0: Point2D, arg1: Sphere2D) -> tuple[float, Point2D]:
    ...
def point_sphere_signed_distance3D(arg0: Point3D, arg1: Sphere3D) -> tuple[float, Point3D]:
    ...
def point_tetrahedron_distance3D(arg0: Point3D, arg1: Tetrahedron) -> tuple[float, Point3D]:
    ...
def point_tetrahedron_position3D(arg0: Point3D, arg1: Tetrahedron) -> Position:
    ...
def point_triangle_distance2D(arg0: Point2D, arg1: Triangle2D) -> tuple[float, Point2D]:
    ...
def point_triangle_distance3D(arg0: Point3D, arg1: Triangle3D) -> tuple[float, Point3D]:
    ...
def point_triangle_position2D(arg0: Point2D, arg1: Triangle2D) -> Position:
    ...
def point_triangle_position3D(arg0: Point3D, arg1: Triangle3D) -> Position:
    ...
def point_triangle_projection2D(arg0: Point2D, arg1: Triangle2D) -> Point2D:
    ...
def point_triangle_projection3D(arg0: Point3D, arg1: Triangle3D) -> Point3D:
    ...
def point_triangle_signed_distance3D(arg0: Point3D, arg1: Triangle3D) -> tuple[float, Point3D]:
    ...
def rotate(arg0: Point3D, arg1: Vector3D, arg2: float) -> Point3D:
    ...
def segment_barycentric_coordinates2D(arg0: Point2D, arg1: Segment2D) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
    ...
def segment_barycentric_coordinates3D(arg0: Point3D, arg1: Segment3D) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
    ...
def segment_cylinder_intersection3D(arg0: Segment3D, arg1: Cylinder) -> IntersectionResultInlinedVectorPoint3D:
    ...
def segment_line_distance2D(arg0: Segment2D, arg1: InfiniteLine2D) -> tuple[float, Point2D, Point2D]:
    ...
def segment_line_distance3D(arg0: Segment3D, arg1: InfiniteLine3D) -> tuple[float, Point3D, Point3D]:
    ...
def segment_line_intersection2D(arg0: Segment2D, arg1: InfiniteLine2D) -> IntersectionResultPoint2D:
    ...
def segment_line_intersection_detection2D(arg0: Segment2D, arg1: InfiniteLine2D) -> Position:
    ...
def segment_plane_intersection3D(arg0: Segment3D, arg1: Plane) -> IntersectionResultPoint3D:
    ...
def segment_plane_intersection_detection3D(arg0: Segment3D, arg1: Plane) -> Position:
    ...
def segment_segment_distance2D(arg0: Segment2D, arg1: Segment2D) -> tuple[float, Point2D, Point2D]:
    ...
def segment_segment_distance3D(arg0: Segment3D, arg1: Segment3D) -> tuple[float, Point3D, Point3D]:
    ...
def segment_segment_intersection2D(arg0: Segment2D, arg1: Segment2D) -> IntersectionResultPoint2D:
    ...
def segment_segment_intersection_detection2D(arg0: Segment2D, arg1: Segment2D) -> tuple[Position, Position]:
    ...
@typing.overload
def segment_sphere_intersection2D(arg0: Segment2D, arg1: Sphere2D) -> IntersectionResultInlinedVectorPoint2D:
    ...
@typing.overload
def segment_sphere_intersection2D(arg0: Segment2D, arg1: Sphere2D) -> IntersectionResultInlinedVectorPoint2D:
    ...
@typing.overload
def segment_sphere_intersection3D(arg0: Segment3D, arg1: Sphere3D) -> IntersectionResultInlinedVectorPoint3D:
    ...
@typing.overload
def segment_sphere_intersection3D(arg0: Segment3D, arg1: Sphere3D) -> IntersectionResultInlinedVectorPoint3D:
    ...
def segment_triangle_distance3D(arg0: Segment3D, arg1: Triangle3D) -> tuple[float, Point3D, Point3D]:
    ...
def segment_triangle_intersection3D(arg0: Segment3D, arg1: Triangle3D) -> IntersectionResultPoint3D:
    ...
def segment_triangle_intersection_detection3D(arg0: Segment3D, arg1: Triangle3D) -> tuple[Position, Position]:
    ...
def tetrahedron_barycentric_coordinates(arg0: Point3D, arg1: Tetrahedron) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]:
    ...
def tetrahedron_signed_volume(arg0: Tetrahedron) -> float:
    ...
def tetrahedron_volume(arg0: Tetrahedron) -> float:
    ...
def tetrahedron_volume_sign(arg0: Tetrahedron) -> Side:
    ...
def triangle_area2D(arg0: Triangle2D) -> float:
    ...
def triangle_area3D(arg0: Triangle3D) -> float:
    ...
def triangle_area_sign2D(arg0: Triangle2D) -> Side:
    ...
def triangle_area_sign3D(arg0: Triangle3D, arg1: int) -> Side:
    ...
def triangle_barycentric_coordinates2D(arg0: Point2D, arg1: Triangle2D) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
    ...
def triangle_barycentric_coordinates3D(arg0: Point3D, arg1: Triangle3D) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
    ...
def triangle_circle_intersection3D(arg0: Triangle3D, arg1: Circle) -> IntersectionResultInlinedVectorPoint3D:
    ...
def triangle_signed_area2D(arg0: Triangle2D) -> float:
    ...
def triangle_signed_area3D(arg0: Triangle3D, arg1: Vector3D) -> float:
    ...
edge0: Position  # value = <Position.edge0: 6>
edge01: Position  # value = <Position.edge01: 9>
edge02: Position  # value = <Position.edge02: 10>
edge03: Position  # value = <Position.edge03: 11>
edge1: Position  # value = <Position.edge1: 7>
edge12: Position  # value = <Position.edge12: 12>
edge13: Position  # value = <Position.edge13: 13>
edge2: Position  # value = <Position.edge2: 8>
edge23: Position  # value = <Position.edge23: 14>
facet0: Position  # value = <Position.facet0: 15>
facet1: Position  # value = <Position.facet1: 16>
facet2: Position  # value = <Position.facet2: 17>
facet3: Position  # value = <Position.facet3: 18>
incorrect: INTERSECTION_TYPE  # value = <INTERSECTION_TYPE.incorrect: 3>
inside: Position  # value = <Position.inside: 1>
intersect: INTERSECTION_TYPE  # value = <INTERSECTION_TYPE.intersect: 1>
negative: Side  # value = <Side.negative: 1>
none: INTERSECTION_TYPE  # value = <INTERSECTION_TYPE.none: 0>
outside: Position  # value = <Position.outside: 0>
parallel: INTERSECTION_TYPE  # value = <INTERSECTION_TYPE.parallel: 2>
positive: Side  # value = <Side.positive: 0>
vertex0: Position  # value = <Position.vertex0: 2>
vertex1: Position  # value = <Position.vertex1: 3>
vertex2: Position  # value = <Position.vertex2: 4>
vertex3: Position  # value = <Position.vertex3: 5>
zero: Side  # value = <Side.zero: 2>
