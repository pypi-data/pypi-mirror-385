# coding: utf-8

"""
    Flywheel

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 0.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from flywheel.api_client import ApiClient
import flywheel.models
from flywheel.util import check_filename_params

# NOTE: This file is auto generated by the swagger code generator program.
# Do not edit the class manually.

class UploadApi(object):
    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cleanup_signed_upload_url(self, body, **kwargs):  # noqa: E501
        """Cleanup unused file blob previously uploaded using signed URL

        This method makes a synchronous HTTP request by default.

        :param SignedUrlCleanupInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.cleanup_signed_upload_url_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.cleanup_signed_upload_url_with_http_info(body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def cleanup_signed_upload_url_with_http_info(self, body, **kwargs):  # noqa: E501
        """Cleanup unused file blob previously uploaded using signed URL

        This method makes a synchronous HTTP request by default.

        :param SignedUrlCleanupInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """

        all_params = ['body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cleanup_signed_upload_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `cleanup_signed_upload_url`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'SignedUrlCleanupInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.SignedUrlCleanupInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/signed-url/cleanup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def complete_s3_multipart_upload(self, body, **kwargs):  # noqa: E501
        """Complete S3 multipart signed url upload

        Complete S3 uploads exceeding 5GB and create the final object in the bucket. Expected an upload id returned previously by the `POST /upload/signed-url` endpoint and the e-tags returned by S3 after uploaded each file part.
        This method makes a synchronous HTTP request by default.

        :param CompleteS3MultipartUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CompleteMultipartUploadOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.complete_s3_multipart_upload_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.complete_s3_multipart_upload_with_http_info(body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def complete_s3_multipart_upload_with_http_info(self, body, **kwargs):  # noqa: E501
        """Complete S3 multipart signed url upload

        Complete S3 uploads exceeding 5GB and create the final object in the bucket. Expected an upload id returned previously by the `POST /upload/signed-url` endpoint and the e-tags returned by S3 after uploaded each file part.
        This method makes a synchronous HTTP request by default.

        :param CompleteS3MultipartUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CompleteMultipartUploadOutput
        """

        all_params = ['body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method complete_s3_multipart_upload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `complete_s3_multipart_upload`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'CompleteS3MultipartUploadInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.CompleteS3MultipartUploadInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/complete-s3-multipart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompleteMultipartUploadOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def create_signed_upload_url(self, body, **kwargs):  # noqa: E501
        """Create new signed upload URL

        Return a signed upload URL for the requested storage provider_id. Multiple URLs are returned for S3 uploads exceeding 5GB.
        This method makes a synchronous HTTP request by default.

        :param SignedUrlUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedUrlUploadOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.create_signed_upload_url_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_signed_upload_url_with_http_info(body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def create_signed_upload_url_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create new signed upload URL

        Return a signed upload URL for the requested storage provider_id. Multiple URLs are returned for S3 uploads exceeding 5GB.
        This method makes a synchronous HTTP request by default.

        :param SignedUrlUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedUrlUploadOutput
        """

        all_params = ['body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_signed_upload_url" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_signed_upload_url`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'SignedUrlUploadInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.SignedUrlUploadInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/signed-url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SignedUrlUploadOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_by_label(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > For technical reasons, no form field names can be repeated. Instead, use   (file1, file2) and so forth.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/labelupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.upload_by_label_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.upload_by_label_with_http_info(**kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def upload_by_label_with_http_info(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > For technical reasons, no form field names can be repeated. Instead, use   (file1, file2) and so forth.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/labelupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """

        all_params = ['preserve_metadata','ticket','id','level','job','files','metadata','content_type',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_by_label" % key
                )
            params[key] = val
        del params['kwargs']
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'preserve_metadata' in params:
            query_params.append(('preserve_metadata', params['preserve_metadata']))  # noqa: E501
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['content-type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'files' in params:
            local_var_files['files'] = params['files']  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/label', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[list[File],UploadTicketOutput]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_by_reaper(self, **kwargs):  # noqa: E501
        """Bottom-up UID matching of Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior:  > Upload data, allowing users to move sessions during scans without causing new data to be   created in referenced project/group.  ### Evaluation Order:  * If a matching acquisition UID is found anywhere on the system, the related files will be placed under that acquisition. * **OR** If a matching session UID is found, a new acquistion is created with the specified UID under that Session UID. * **OR** If a matching group ID and project label are found, a new session and acquisition will be created within that project * **OR** If a matching group ID is found, a new project and session and acquisition will be created within that group. * **OR** A new session and acquisition will be created within a special \"Unknown\" group and project, which is only visible to system administrators.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool uid_placement:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.upload_by_reaper_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.upload_by_reaper_with_http_info(**kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def upload_by_reaper_with_http_info(self, **kwargs):  # noqa: E501
        """Bottom-up UID matching of Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior:  > Upload data, allowing users to move sessions during scans without causing new data to be   created in referenced project/group.  ### Evaluation Order:  * If a matching acquisition UID is found anywhere on the system, the related files will be placed under that acquisition. * **OR** If a matching session UID is found, a new acquistion is created with the specified UID under that Session UID. * **OR** If a matching group ID and project label are found, a new session and acquisition will be created within that project * **OR** If a matching group ID is found, a new project and session and acquisition will be created within that group. * **OR** A new session and acquisition will be created within a special \"Unknown\" group and project, which is only visible to system administrators.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool uid_placement:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """

        all_params = ['preserve_metadata','ticket','uid_placement','id','level','job','files','metadata','content_type',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_by_reaper" % key
                )
            params[key] = val
        del params['kwargs']
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'preserve_metadata' in params:
            query_params.append(('preserve_metadata', params['preserve_metadata']))  # noqa: E501
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'uid_placement' in params:
            query_params.append(('uid_placement', params['uid_placement']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['content-type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'files' in params:
            local_var_files['files'] = params['files']  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/reaper', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[list[File],UploadTicketOutput]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_by_uid(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > Same behavior as /api/upload/label,   except the metadata field must be uid format   See ``api/schemas/input/uidupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.upload_by_uid_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.upload_by_uid_with_http_info(**kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def upload_by_uid_with_http_info(self, **kwargs):  # noqa: E501
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > Same behavior as /api/upload/label,   except the metadata field must be uid format   See ``api/schemas/input/uidupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """

        all_params = ['preserve_metadata','ticket','id','level','job','files','metadata','content_type',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_by_uid" % key
                )
            params[key] = val
        del params['kwargs']
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'preserve_metadata' in params:
            query_params.append(('preserve_metadata', params['preserve_metadata']))  # noqa: E501
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['content-type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'files' in params:
            local_var_files['files'] = params['files']  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/uid', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[list[File],UploadTicketOutput]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_signed_fs_file(self, token, body, **kwargs):  # noqa: E501
        """Upload file to local filesystem storage provider

        The POST `/api/upload/signed-url` endpoint returns a url with a jwt token pointing to this endpoint if the storage provider is a local filesystem then the file can be uploaded simply by sending the file content in the body of the payload. The destination storage provider and the file path are encoded in the jwt token.
        This method makes a synchronous HTTP request by default.

        :param str token: Upload token (required)
        :param str body: Signed filesystem file upload payload (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedFSUploadOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.upload_signed_fs_file_with_http_info(token, body, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_signed_fs_file_with_http_info(token, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def upload_signed_fs_file_with_http_info(self, token, body, **kwargs):  # noqa: E501
        """Upload file to local filesystem storage provider

        The POST `/api/upload/signed-url` endpoint returns a url with a jwt token pointing to this endpoint if the storage provider is a local filesystem then the file can be uploaded simply by sending the file content in the body of the payload. The destination storage provider and the file path are encoded in the jwt token.
        This method makes a synchronous HTTP request by default.

        :param str token: Upload token (required)
        :param str body: Signed filesystem file upload payload (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedFSUploadOutput
        """

        all_params = ['token','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_signed_fs_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `upload_signed_fs_file`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `upload_signed_fs_file`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/upload/fs-file', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SignedFSUploadOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)
