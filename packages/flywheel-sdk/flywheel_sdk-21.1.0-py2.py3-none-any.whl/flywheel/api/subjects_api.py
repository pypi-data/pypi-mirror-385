# coding: utf-8

"""
    Flywheel

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 0.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from flywheel.api_client import ApiClient
import flywheel.models
from flywheel.util import check_filename_params

# NOTE: This file is auto generated by the swagger code generator program.
# Do not edit the class manually.

class SubjectsApi(object):
    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_subject(self, body, **kwargs):  # noqa: E501
        """Create a new subject

        Create a new subject
        This method makes a synchronous HTTP request by default.

        :param SubjectInput body: subject object to create (required)
        :param bool async_: Perform the request asynchronously
        :return: InsertedId
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.add_subject_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_with_http_info(body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def add_subject_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new subject

        Create a new subject
        This method makes a synchronous HTTP request by default.

        :param SubjectInput body: subject object to create (required)
        :param bool async_: Perform the request asynchronously
        :return: InsertedId
        """

        all_params = ['body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'SubjectInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.SubjectInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InsertedId',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_analysis(self, cid, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param union[AdhocAnalysisInput,JobAnalysisInput] body: (required)
        :param bool job: returns job_id instead of analysis.id
        :param bool job: returns job_id instead of analysis.id
        :param bool async_: Perform the request asynchronously
        :return: InsertedId
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.add_subject_analysis_with_http_info(cid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_analysis_with_http_info(cid, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def add_subject_analysis_with_http_info(self, cid, body, **kwargs):  # noqa: E501
        """Create an analysis and upload files.

        When query param \"job\" is \"true\", send JSON to create an analysis and job.  Otherwise, multipart/form-data to upload files and create an analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param union[AdhocAnalysisInput,JobAnalysisInput] body: (required)
        :param bool job: returns job_id instead of analysis.id
        :param bool job: returns job_id instead of analysis.id
        :param bool async_: Perform the request asynchronously
        :return: InsertedId
        """

        all_params = ['cid','body','job','job',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `add_subject_analysis`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501

        query_params = []
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501
        else:
            query_params.append(('job', 'true'))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'union[AdhocAnalysisInput,JobAnalysisInput]'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.union[AdhocAnalysisInput,JobAnalysisInput].positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InsertedId',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_analysis_note(self, container_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to a(n) subject analysis.

        Add a note to a(n) subject analysis.
        This method makes a synchronous HTTP request by default.

        :param str container_id: 24-char hex id (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param NoteInput body: note content (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.add_subject_analysis_note_with_http_info(container_id, analysis_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_analysis_note_with_http_info(container_id, analysis_id, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def add_subject_analysis_note_with_http_info(self, container_id, analysis_id, body, **kwargs):  # noqa: E501
        """Add a note to a(n) subject analysis.

        Add a note to a(n) subject analysis.
        This method makes a synchronous HTTP request by default.

        :param str container_id: 24-char hex id (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param NoteInput body: note content (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """

        all_params = ['container_id','analysis_id','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_analysis_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_id' is set
        if ('container_id' not in params or
                params['container_id'] is None):
            raise ValueError("Missing the required parameter `container_id` when calling `add_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `add_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_analysis_note`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'container_id' in params:
            path_params['container_id'] = params['container_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'NoteInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.NoteInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{container_id}/analyses/{analysis_id}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_note(self, container_id, body, **kwargs):  # noqa: E501
        """Add a note to a(n) subject.

        Add a note to a(n) subject.
        This method makes a synchronous HTTP request by default.

        :param str container_id: (required)
        :param NoteInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.add_subject_note_with_http_info(container_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_note_with_http_info(container_id, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def add_subject_note_with_http_info(self, container_id, body, **kwargs):  # noqa: E501
        """Add a note to a(n) subject.

        Add a note to a(n) subject.
        This method makes a synchronous HTTP request by default.

        :param str container_id: (required)
        :param NoteInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """

        all_params = ['container_id','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_id' is set
        if ('container_id' not in params or
                params['container_id'] is None):
            raise ValueError("Missing the required parameter `container_id` when calling `add_subject_note`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_note`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'container_id' in params:
            path_params['container_id'] = params['container_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'NoteInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.NoteInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{container_id}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_tag(self, cid, body, **kwargs):  # noqa: E501
        """Add a tag to a(n) subject.

        Propagates changes to projects, sessions and acquisitions
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.add_subject_tag_with_http_info(cid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_tag_with_http_info(cid, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def add_subject_tag_with_http_info(self, cid, body, **kwargs):  # noqa: E501
        """Add a tag to a(n) subject.

        Propagates changes to projects, sessions and acquisitions
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['cid','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `add_subject_tag`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_tag`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'Tag'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.Tag.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def add_subject_tags(self, cid, body, **kwargs):  # noqa: E501
        """Add multiple tags to a(n) subject

        Add multiple tags to a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param list[str] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.add_subject_tags_with_http_info(cid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_subject_tags_with_http_info(cid, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def add_subject_tags_with_http_info(self, cid, body, **kwargs):  # noqa: E501
        """Add multiple tags to a(n) subject

        Add multiple tags to a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param list[str] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """

        all_params = ['cid','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_subject_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `add_subject_tags`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_subject_tags`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/tags', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def create_master_subject_code(self, body, **kwargs):  # noqa: E501
        """Request a master subject code for the given patient

        The workflow is the following.   - send `patient_id` (e.g., MRN) and/or `first_name`, `last_name`, `date_of_birth`   - indicate whether to use `patient_id` for identification or `first_name`, `last_name`, `date_of_birth`     by the `use_patient_id` field   - the response will contain a master subject code   - if you send the same identifying information again, you will receive the same code  Note that if you received a MSC code for example by just providing the `patient_id`, you can save more information for that MSC in a second request (`first_name`, `last_name`, `date_of_birth`). Only the missing fields will be set, so you can't update any existing field (e.g. changing the name). Since you can create multiple MSC codes with the same name and date of birth using different patient ids, you will get HTTP 400 error if you request an MSC code by name and date of birth and there are multiple matches. In this case you need to use patient id.
        This method makes a synchronous HTTP request by default.

        :param union[MasterSubjectCodeInput,MasterSubjectCodeDobInput] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: MasterSubjectCodeOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.create_master_subject_code_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_master_subject_code_with_http_info(body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def create_master_subject_code_with_http_info(self, body, **kwargs):  # noqa: E501
        """Request a master subject code for the given patient

        The workflow is the following.   - send `patient_id` (e.g., MRN) and/or `first_name`, `last_name`, `date_of_birth`   - indicate whether to use `patient_id` for identification or `first_name`, `last_name`, `date_of_birth`     by the `use_patient_id` field   - the response will contain a master subject code   - if you send the same identifying information again, you will receive the same code  Note that if you received a MSC code for example by just providing the `patient_id`, you can save more information for that MSC in a second request (`first_name`, `last_name`, `date_of_birth`). Only the missing fields will be set, so you can't update any existing field (e.g. changing the name). Since you can create multiple MSC codes with the same name and date of birth using different patient ids, you will get HTTP 400 error if you request an MSC code by name and date of birth and there are multiple matches. In this case you need to use patient id.
        This method makes a synchronous HTTP request by default.

        :param union[MasterSubjectCodeInput,MasterSubjectCodeDobInput] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: MasterSubjectCodeOutput
        """

        all_params = ['body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_master_subject_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_master_subject_code`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'union[MasterSubjectCodeInput,MasterSubjectCodeDobInput]'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.union[MasterSubjectCodeInput,MasterSubjectCodeDobInput].positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/master-code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MasterSubjectCodeOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject(self, subject_id, **kwargs):  # noqa: E501
        """Delete a subject

        Read-write project permissions are required to delete a subject. Admin project permissions are required if the subject or it's acquisitions contain data uploaded by sources other than users and jobs.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param ContainerDeleteReason delete_reason:
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """Delete a subject

        Read-write project permissions are required to delete a subject. Admin project permissions are required if the subject or it's acquisitions contain data uploaded by sources other than users and jobs.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param ContainerDeleteReason delete_reason:
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['subject_id','delete_reason',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `delete_subject`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501

        query_params = []
        if 'delete_reason' in params:
            query_params.append(('delete_reason', params['delete_reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_analysis(self, cid, analysis_id, **kwargs):  # noqa: E501
        """Delete an analysis

        Delete an analysis for a container.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param ContainerDeleteReason delete_reason: Provide a reason for the deletion
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_analysis_with_http_info(cid, analysis_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_analysis_with_http_info(cid, analysis_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_analysis_with_http_info(self, cid, analysis_id, **kwargs):  # noqa: E501
        """Delete an analysis

        Delete an analysis for a container.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param ContainerDeleteReason delete_reason: Provide a reason for the deletion
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['cid','analysis_id','delete_reason',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `delete_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `delete_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501

        query_params = []
        if 'delete_reason' in params:
            query_params.append(('delete_reason', params['delete_reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses/{analysis_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_analysis_note(self, cid, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from a(n) subject analysis.

        Remove a note from a(n) subject analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: 24-char hex id (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str note_id: 24-char hex note id (required)
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_analysis_note_with_http_info(cid, analysis_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_analysis_note_with_http_info(cid, analysis_id, note_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_analysis_note_with_http_info(self, cid, analysis_id, note_id, **kwargs):  # noqa: E501
        """Remove a note from a(n) subject analysis.

        Remove a note from a(n) subject analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: 24-char hex id (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str note_id: 24-char hex note id (required)
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['cid','analysis_id','note_id',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_analysis_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `delete_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `delete_subject_analysis_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `delete_subject_analysis_note`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses/{analysis_id}/notes/{note_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_file(self, cid, filename, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param ContainerDeleteReason delete_reason: A reason for deletion when audit-trail is enabled
        :param bool force: Force deletion of the file even if some checks fail. Deprecated, will be removed in a future release.
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_file_with_http_info(cid, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_file_with_http_info(cid, filename, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_file_with_http_info(self, cid, filename, **kwargs):  # noqa: E501
        """Delete a file

        A user with read-write or higher permissions on the container may delete files that were uploaded by users or were the output of jobs. (Specifically, files whose `origin.type` is either `job` or `user`.) <br/> A user with admin permissions on the container may delete any file.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param ContainerDeleteReason delete_reason: A reason for deletion when audit-trail is enabled
        :param bool force: Force deletion of the file even if some checks fail. Deprecated, will be removed in a future release.
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['cid','filename','delete_reason','force',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `delete_subject_file`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `delete_subject_file`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'delete_reason' in params:
            query_params.append(('delete_reason', params['delete_reason']))  # noqa: E501
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/files/{filename}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_note(self, cid, note_id, **kwargs):  # noqa: E501
        """Remove a note from a(n) subject

        Remove a note from a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_note_with_http_info(cid, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_note_with_http_info(cid, note_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_note_with_http_info(self, cid, note_id, **kwargs):  # noqa: E501
        """Remove a note from a(n) subject

        Remove a note from a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['cid','note_id',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `delete_subject_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `delete_subject_note`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/notes/{note_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_tag(self, cid, value, **kwargs):  # noqa: E501
        """Delete a tag

        Delete a tag
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_tag_with_http_info(cid, value, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_tag_with_http_info(cid, value, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_tag_with_http_info(self, cid, value, **kwargs):  # noqa: E501
        """Delete a tag

        Delete a tag
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['cid','value',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `delete_subject_tag`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `delete_subject_tag`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'value' in params:
            path_params['value'] = params['value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/tags/{value}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subject_tags(self, cid, body, **kwargs):  # noqa: E501
        """Delete multiple tags from a(n) subject

        Delete multiple tags from a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param list[str] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subject_tags_with_http_info(cid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subject_tags_with_http_info(cid, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subject_tags_with_http_info(self, cid, body, **kwargs):  # noqa: E501
        """Delete multiple tags from a(n) subject

        Delete multiple tags from a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param list[str] body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """

        all_params = ['cid','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subject_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `delete_subject_tags`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_subject_tags`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/tags', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def delete_subjects_by_ids(self, body, **kwargs):  # noqa: E501
        """Delete multiple subjects by ID list

        Delete multiple subjects by ID list
        This method makes a synchronous HTTP request by default.

        :param list[str] body: List of IDs to delete (required)
        :param ContainerDeleteReason delete_reason:
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.delete_subjects_by_ids_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_subjects_by_ids_with_http_info(body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def delete_subjects_by_ids_with_http_info(self, body, **kwargs):  # noqa: E501
        """Delete multiple subjects by ID list

        Delete multiple subjects by ID list
        This method makes a synchronous HTTP request by default.

        :param list[str] body: List of IDs to delete (required)
        :param ContainerDeleteReason delete_reason:
        :param bool async_: Perform the request asynchronously
        :return: DeletedResult
        """

        all_params = ['body','delete_reason',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_subjects_by_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_subjects_by_ids`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delete_reason' in params:
            query_params.append(('delete_reason', params['delete_reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_file_from_subject(self, subject_id, file_name, dest_file, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str file_name: output file name (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param int version: version of the file to download
        :param str hash: file hash for comparison
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            (resp) = self.download_file_from_subject_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()


    def download_file_from_subject_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Download a file.

        Files can be downloaded directly from this endpoint with a valid \"Authorization\" header or via a ticket id.  To generate a ticket:   - Make a request with an empty \"ticket\" parameter and a valid \"Authorization\" header. The server will respond with a generated ticket id.   - Make another request with the received ticket id in the \"ticket\" parameter. A valid \"Authorization\" header is no longer required.  When \"view\" is true, [RFC7233](https://tools.ietf.org/html/rfc7233) range request headers are supported.  When virus_scan feature is enabled the quarantined files only can be downloaded using signed urls otherwise it will return with a HTTP 400 response.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str file_name: output file name (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param int version: version of the file to download
        :param str hash: file hash for comparison
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """

        all_params = ['subject_id','file_name','info','member','view','version','hash','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_file_from_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_file_from_subject`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `download_file_from_subject`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['file_name'] = params['file_name']  # noqa: E501

        query_params = []
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'hash' in params:
            query_params.append(('hash', params['hash']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/files/{file_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[DownloadTicketStub,ZipfileInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_file_zip_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Retrieve the zip info of a child file by name.

        Does not work on files whose names contain a forward slash.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str file_name: output file name (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param int version: version of the file to download
        :param str hash: file hash for comparison
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_file_zip_info_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_file_zip_info_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_file_zip_info_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Retrieve the zip info of a child file by name.

        Does not work on files whose names contain a forward slash.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str file_name: output file name (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param int version: version of the file to download
        :param str hash: file hash for comparison
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """

        all_params = ['subject_id','file_name','ticket','info','member','view','version','hash','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_file_zip_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_file_zip_info`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_subject_file_zip_info`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['file_name'] = params['file_name']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        else:
            query_params.append(('info', 'true'))
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'hash' in params:
            query_params.append(('hash', params['hash']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/files/{file_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileZipInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_download_ticket(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Get a signed URL to download a named child file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str file_name: output file name (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param int version: version of the file to download
        :param str hash: file hash for comparison
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_download_ticket_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_download_ticket_with_http_info(subject_id, file_name, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_download_ticket_with_http_info(self, subject_id, file_name, **kwargs):  # noqa: E501
        """Get a signed URL to download a named child file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str file_name: output file name (required)
        :param str ticket: The generated ticket id for the download, or present but empty to generate a ticket id
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: If true, the proper \"Content-Type\" header based on the file's mimetype is set on response If false, the \"Content-Type\" header is set to \"application/octet-stream\" 
        :param int version: version of the file to download
        :param str hash: file hash for comparison
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """

        all_params = ['subject_id','file_name','ticket','info','member','view','version','hash','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_download_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_download_ticket`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `get_subject_download_ticket`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'file_name' in params:
            path_params['file_name'] = params['file_name']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'hash' in params:
            query_params.append(('hash', params['hash']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/files/{file_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[DownloadTicketStub,ZipfileInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_input_from_subject_analysis(self, subject_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: get file info only
        :param str member: get zipfile member
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            (resp) = self.download_input_from_subject_analysis_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()


    def download_input_from_subject_analysis_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis inputs with filter.

        If \"ticket\" query param is included and not empty, download inputs. If \"ticket\" query param is included and empty, create a ticket for matching inputs in the analysis. If no \"ticket\" query param is included, inputs will be downloaded directly.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: get file info only
        :param str member: get zipfile member
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """

        all_params = ['subject_id','analysis_id','filename','info','member','view','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_input_from_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_input_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `download_input_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `download_input_from_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/analyses/{analysis_id}/inputs/{filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[DownloadTicketStub,ZipfileInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_input_zip_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Retrieve the zip info of a child file by name.

        Does not work on files whose names contain a forward slash.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: 24-char hex ticket id
        :param bool info: get file info only
        :param str member: get zipfile member
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_analysis_input_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_input_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_analysis_input_zip_info_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Retrieve the zip info of a child file by name.

        Does not work on files whose names contain a forward slash.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: 24-char hex ticket id
        :param bool info: get file info only
        :param str member: get zipfile member
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """

        all_params = ['subject_id','analysis_id','filename','ticket','info','member','view','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_input_zip_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_input_zip_info`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_input_zip_info`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_input_zip_info`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        else:
            query_params.append(('info', 'true'))
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/analyses/{analysis_id}/inputs/{filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileZipInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_input_download_ticket(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Get a signed URL to download a named child file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: 24-char hex ticket id
        :param bool info: get file info only
        :param str member: get zipfile member
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_analysis_input_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_input_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_analysis_input_download_ticket_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Get a signed URL to download a named child file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: 24-char hex ticket id
        :param bool info: get file info only
        :param str member: get zipfile member
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """

        all_params = ['subject_id','analysis_id','filename','ticket','info','member','view','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_input_download_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_input_download_ticket`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_input_download_ticket`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_input_download_ticket`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/analyses/{analysis_id}/inputs/{filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[DownloadTicketStub,ZipfileInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def download_output_from_subject_analysis(self, subject_id, analysis_id, filename, dest_file, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param str dest_file: Destination file path
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        kwargs['_preload_content'] = False
        # Stream response to file
        with open(dest_file, 'wb') as out_file:
            (resp) = self.download_output_from_subject_analysis_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if resp:
                try:
                    for chunk in resp.iter_content(chunk_size=65536):
                        out_file.write(chunk)
                finally:
                    resp.close()


    def download_output_from_subject_analysis_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Download analysis outputs with filter.

        If \"ticket\" query param is included and not empty, download outputs. If \"ticket\" query param is included and empty, create a ticket for matching outputs in the analysis. If no \"ticket\" query param is included, outputs will be downloaded directly.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """

        all_params = ['subject_id','analysis_id','filename','info','member','view','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_output_from_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `download_output_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `download_output_from_subject_analysis`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `download_output_from_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/analyses/{analysis_id}/files/{filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[DownloadTicketStub,ZipfileInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_output_zip_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Retrieve the zip info of a child file by name.

        Does not work on files whose names contain a forward slash.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_analysis_output_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_output_zip_info_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_analysis_output_zip_info_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Retrieve the zip info of a child file by name.

        Does not work on files whose names contain a forward slash.
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: FileZipInfo
        """

        all_params = ['subject_id','analysis_id','filename','ticket','info','member','view','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_output_zip_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_output_zip_info`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_output_zip_info`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_output_zip_info`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        else:
            query_params.append(('info', 'true'))
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/analyses/{analysis_id}/files/{filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileZipInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis_output_download_ticket(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Get a signed URL to download a named child file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_analysis_output_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_output_download_ticket_with_http_info(subject_id, analysis_id, filename, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_analysis_output_download_ticket_with_http_info(self, subject_id, analysis_id, filename, **kwargs):  # noqa: E501
        """Get a signed URL to download a named child file.

        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-character hex ID (required)
        :param str analysis_id: 24-char hex analysis id (required)
        :param str filename: filename to download (get tar of all if empty) (required)
        :param str ticket: ticket id of the outputs to download
        :param bool info: If the file is a zipfile, return a json response of zipfile member information
        :param str member: The filename of a zipfile member to download rather than the entire file
        :param bool view: feature flag for view/download
        :param str range: byte ranges to return
        :param list[str] x_accept_feature: redirect header
        :param bool async_: Perform the request asynchronously
        :return: union[DownloadTicketStub,ZipfileInfo]
        """

        all_params = ['subject_id','analysis_id','filename','ticket','info','member','view','range','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis_output_download_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_analysis_output_download_ticket`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis_output_download_ticket`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_analysis_output_download_ticket`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501
        if 'member' in params:
            query_params.append(('member', params['member']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}
        if 'range' in params:
            header_params['range'] = params['range']  # noqa: E501
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/analyses/{analysis_id}/files/{filename}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[DownloadTicketStub,ZipfileInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_all_subjects(self, **kwargs):  # noqa: E501
        """Get a list of subjects

        Get a list of subjects
        This method makes a synchronous HTTP request by default.

        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param JoinType join: join file origins
        :param bool join_avatars: add name and avatar to notes
        :param bool include_all_info: Include all info in returned objects
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param list[union[HeaderFeature,str]] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: union[Page,list[SubjectOutputForList]]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_all_subjects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_subjects_with_http_info(**kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_all_subjects_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of subjects

        Get a list of subjects
        This method makes a synchronous HTTP request by default.

        :param bool exhaustive: Set to return a complete list regardless of permissions
        :param JoinType join: join file origins
        :param bool join_avatars: add name and avatar to notes
        :param bool include_all_info: Include all info in returned objects
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param list[union[HeaderFeature,str]] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: union[Page,list[SubjectOutputForList]]
        """

        all_params = ['exhaustive','join','join_avatars','include_all_info','filter','sort','limit','skip','page','after_id','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_subjects" % key
                )
            params[key] = val
        del params['kwargs']
        check_filename_params(params)

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exhaustive' in params:
            query_params.append(('exhaustive', params['exhaustive']))  # noqa: E501
        if 'join' in params:
            query_params.append(('join', params['join']))  # noqa: E501
        if 'join_avatars' in params:
            query_params.append(('join_avatars', params['join_avatars']))  # noqa: E501
        if 'include_all_info' in params:
            query_params.append(('include_all_info', params['include_all_info']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[Page,list[SubjectOutputForList]]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject(self, subject_id, **kwargs):  # noqa: E501
        """Get a single subject

        Get an subject by its id  Args:     subject_id: The id of the subject     join: Attribute to join on     join_avatars: Join the user avatars for permissions     auth_session: The auth session  Returns:     SubjectOutput
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param JoinType join: join file origins
        :param bool join_avatars: add name and avatar to notes
        :param list[union[HeaderFeature,str]] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: SubjectOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_with_http_info(subject_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """Get a single subject

        Get an subject by its id  Args:     subject_id: The id of the subject     join: Attribute to join on     join_avatars: Join the user avatars for permissions     auth_session: The auth session  Returns:     SubjectOutput
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param JoinType join: join file origins
        :param bool join_avatars: add name and avatar to notes
        :param list[union[HeaderFeature,str]] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: SubjectOutput
        """

        all_params = ['subject_id','join','join_avatars','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501

        query_params = []
        if 'join' in params:
            query_params.append(('join', params['join']))  # noqa: E501
        if 'join_avatars' in params:
            query_params.append(('join_avatars', params['join_avatars']))  # noqa: E501

        header_params = {}
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubjectOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analyses(self, cid, **kwargs):  # noqa: E501
        """Get analyses for a(n) subject.

        Returns analyses that directly belong to this resource.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param bool inflate_job:
        :param bool join_avatars:
        :param JoinType join:
        :param bool include_all_info: Include all info in returned objects
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param list[str] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: union[Page,list[union[AnalysisListOutput,AnalysisListOutputInflatedJob]]]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_analyses_with_http_info(cid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analyses_with_http_info(cid, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_analyses_with_http_info(self, cid, **kwargs):  # noqa: E501
        """Get analyses for a(n) subject.

        Returns analyses that directly belong to this resource.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param bool inflate_job:
        :param bool join_avatars:
        :param JoinType join:
        :param bool include_all_info: Include all info in returned objects
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param list[str] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: union[Page,list[union[AnalysisListOutput,AnalysisListOutputInflatedJob]]]
        """

        all_params = ['cid','inflate_job','join_avatars','join','include_all_info','filter','sort','limit','skip','page','after_id','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analyses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `get_subject_analyses`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501

        query_params = []
        if 'inflate_job' in params:
            query_params.append(('inflate_job', params['inflate_job']))  # noqa: E501
        if 'join_avatars' in params:
            query_params.append(('join_avatars', params['join_avatars']))  # noqa: E501
        if 'join' in params:
            query_params.append(('join', params['join']))  # noqa: E501
        if 'include_all_info' in params:
            query_params.append(('include_all_info', params['include_all_info']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[Page,list[union[AnalysisListOutput,AnalysisListOutputInflatedJob]]]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_analysis(self, cid, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.

        Get an analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool join_avatars:
        :param JoinType join:
        :param bool async_: Perform the request asynchronously
        :return: union[AnalysisOutputInflatedJob,AnalysisOutput]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_analysis_with_http_info(cid, analysis_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_analysis_with_http_info(cid, analysis_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_analysis_with_http_info(self, cid, analysis_id, **kwargs):  # noqa: E501
        """Get an analysis.

        Get an analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param bool inflate_job: Return job as an object instead of an id
        :param bool join_avatars:
        :param JoinType join:
        :param bool async_: Perform the request asynchronously
        :return: union[AnalysisOutputInflatedJob,AnalysisOutput]
        """

        all_params = ['cid','analysis_id','inflate_job','join_avatars','join',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `get_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501

        query_params = []
        if 'inflate_job' in params:
            query_params.append(('inflate_job', params['inflate_job']))  # noqa: E501
        if 'join_avatars' in params:
            query_params.append(('join_avatars', params['join_avatars']))  # noqa: E501
        if 'join' in params:
            query_params.append(('join', params['join']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses/{analysis_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[AnalysisOutputInflatedJob,AnalysisOutput]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_file_info(self, cid, filename, **kwargs):  # noqa: E501
        """Get info for a particular file.

        Get info for a particular file.
        This method makes a synchronous HTTP request by default.

        :param str cid: Container Id (required)
        :param str filename: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_file_info_with_http_info(cid, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_file_info_with_http_info(cid, filename, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_file_info_with_http_info(self, cid, filename, **kwargs):  # noqa: E501
        """Get info for a particular file.

        Get info for a particular file.
        This method makes a synchronous HTTP request by default.

        :param str cid: Container Id (required)
        :param str filename: (required)
        :param bool async_: Perform the request asynchronously
        :return: FileOutput
        """

        all_params = ['cid','filename',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_file_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `get_subject_file_info`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_subject_file_info`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/files/{filename}/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_note(self, cid, note_id, **kwargs):  # noqa: E501
        """Get a note of a(n) subject.

        Get a note of a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_note_with_http_info(cid, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_note_with_http_info(cid, note_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_note_with_http_info(self, cid, note_id, **kwargs):  # noqa: E501
        """Get a note of a(n) subject.

        Get a note of a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str note_id: (required)
        :param bool async_: Perform the request asynchronously
        :return: Note
        """

        all_params = ['cid','note_id',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `get_subject_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `get_subject_note`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/notes/{note_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_sessions(self, subject_id, **kwargs):  # noqa: E501
        """List sessions of a subject

        List sessions of a subject
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param JoinType join: join file origins
        :param bool include_all_info: Include all info in returned objects
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param list[union[HeaderFeature,str]] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: union[Page,list[SessionListOutput]]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_sessions_with_http_info(subject_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_sessions_with_http_info(subject_id, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_sessions_with_http_info(self, subject_id, **kwargs):  # noqa: E501
        """List sessions of a subject

        List sessions of a subject
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param JoinType join: join file origins
        :param bool include_all_info: Include all info in returned objects
        :param str filter: The filter to apply. (e.g. label=my-label,created>2018-09-22)
        :param str sort: The sort fields and order. (e.g. label:asc,created:desc)
        :param int limit: The maximum number of entries to return.
        :param int skip: The number of entries to skip.
        :param int page: The page number (i.e. skip limit*page entries)
        :param str after_id: Paginate after the given id. (Cannot be used with sort, page or skip)
        :param list[union[HeaderFeature,str]] x_accept_feature:
        :param bool async_: Perform the request asynchronously
        :return: union[Page,list[SessionListOutput]]
        """

        all_params = ['subject_id','join','include_all_info','filter','sort','limit','skip','page','after_id','x_accept_feature',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `get_subject_sessions`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501

        query_params = []
        if 'join' in params:
            query_params.append(('join', params['join']))  # noqa: E501
        if 'include_all_info' in params:
            query_params.append(('include_all_info', params['include_all_info']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'after_id' in params:
            query_params.append(('after_id', params['after_id']))  # noqa: E501

        header_params = {}
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[Page,list[SessionListOutput]]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def get_subject_tag(self, cid, value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.

        Get the value of a tag, by name
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: str
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.get_subject_tag_with_http_info(cid, value, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subject_tag_with_http_info(cid, value, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def get_subject_tag_with_http_info(self, cid, value, **kwargs):  # noqa: E501
        """Get the value of a tag, by name.

        Get the value of a tag, by name
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str value: The tag to interact with (required)
        :param bool async_: Perform the request asynchronously
        :return: str
        """

        all_params = ['cid','value',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `get_subject_tag`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `get_subject_tag`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'value' in params:
            path_params['value'] = params['value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/tags/{value}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject(self, subject_id, body, **kwargs):  # noqa: E501
        """Update a subject

        Update a subject
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param SubjectModify body: subject object to modify (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Update a subject

        Update a subject
        This method makes a synchronous HTTP request by default.

        :param str subject_id: 24-char hex subject id (required)
        :param SubjectModify body: subject object to modify (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['subject_id','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `modify_subject`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'SubjectModify'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.SubjectModify.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_analysis(self, cid, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.

        Modify an analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param AnalysisModifyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_analysis_with_http_info(cid, analysis_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_analysis_with_http_info(cid, analysis_id, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_analysis_with_http_info(self, cid, analysis_id, body, **kwargs):  # noqa: E501
        """Modify an analysis.

        Modify an analysis.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param AnalysisModifyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['cid','analysis_id','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `modify_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `modify_subject_analysis`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'AnalysisModifyInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.AnalysisModifyInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses/{analysis_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_file(self, cid, filename, body, **kwargs):  # noqa: E501
        """Modify a file&#x27;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list)
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param FileModifyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_file_with_http_info(cid, filename, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_file_with_http_info(cid, filename, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_file_with_http_info(self, cid, filename, body, **kwargs):  # noqa: E501
        """Modify a file&#x27;s attributes

        Note: If modifying a file's modality, the current classification will be cleared (except for items in the \"Custom\" list)
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param FileModifyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['cid','filename','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `modify_subject_file`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `modify_subject_file`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_file`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'FileModifyInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.FileModifyInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/files/{filename}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_file_classification(self, cid, filename, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param FileClassificationDelta body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_file_classification_with_http_info(cid, filename, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_file_classification_with_http_info(cid, filename, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_file_classification_with_http_info(self, cid, filename, body, **kwargs):  # noqa: E501
        """Update classification for a particular file.

        If replacing a file's classification, the modality can optionally be modified as well.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param FileClassificationDelta body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['cid','filename','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_file_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `modify_subject_file_classification`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `modify_subject_file_classification`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_file_classification`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'FileClassificationDelta'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.FileClassificationDelta.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/files/{filename}/classification', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_file_info(self, cid, filename, body, **kwargs):  # noqa: E501
        """Update info for a particular file.

        Modify and return the file 'info' field
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param Info body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_file_info_with_http_info(cid, filename, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_file_info_with_http_info(cid, filename, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_file_info_with_http_info(self, cid, filename, body, **kwargs):  # noqa: E501
        """Update info for a particular file.

        Modify and return the file 'info' field
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str filename: (required)
        :param Info body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['cid','filename','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_file_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `modify_subject_file_info`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `modify_subject_file_info`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_file_info`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'Info'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.Info.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/files/{filename}/info', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_info(self, cid, body, **kwargs):  # noqa: E501
        """Update or replace info for a(n) subject.

        Update or replace info for a(n) subject. Keys that contain '$' or '.' will be sanitized in the process of being updated on the container.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param Info body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_info_with_http_info(cid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_info_with_http_info(cid, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_info_with_http_info(self, cid, body, **kwargs):  # noqa: E501
        """Update or replace info for a(n) subject.

        Update or replace info for a(n) subject. Keys that contain '$' or '.' will be sanitized in the process of being updated on the container.
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param Info body: (required)
        :param bool async_: Perform the request asynchronously
        :return: ModifiedResult
        """

        all_params = ['cid','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `modify_subject_info`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_info`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'Info'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.Info.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/info', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModifiedResult',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def modify_subject_note(self, cid, note_id, body, **kwargs):  # noqa: E501
        """Update a note of a(n) subject.

        Update a note of a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str note_id: (required)
        :param NoteInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: int
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.modify_subject_note_with_http_info(cid, note_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.modify_subject_note_with_http_info(cid, note_id, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def modify_subject_note_with_http_info(self, cid, note_id, body, **kwargs):  # noqa: E501
        """Update a note of a(n) subject.

        Update a note of a(n) subject
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str note_id: (required)
        :param NoteInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: int
        """

        all_params = ['cid','note_id','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_subject_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `modify_subject_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `modify_subject_note`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_subject_note`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'NoteInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.NoteInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/notes/{note_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def rename_subject_tag(self, cid, value, body, **kwargs):  # noqa: E501
        """Rename a tag.

        Rename a tag
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: str
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.rename_subject_tag_with_http_info(cid, value, body, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_subject_tag_with_http_info(cid, value, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def rename_subject_tag_with_http_info(self, cid, value, body, **kwargs):  # noqa: E501
        """Rename a tag.

        Rename a tag
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str value: The tag to interact with (required)
        :param Tag body: (required)
        :param bool async_: Perform the request asynchronously
        :return: str
        """

        all_params = ['cid','value','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_subject_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `rename_subject_tag`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `rename_subject_tag`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_subject_tag`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'value' in params:
            path_params['value'] = params['value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'Tag'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.Tag.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/tags/{value}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def subject_copy(self, subject_id, body, **kwargs):  # noqa: E501
        """Smart copy a subject

        Smart copy a subject
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param SubjectCopyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: Subject
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.subject_copy_with_http_info(subject_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.subject_copy_with_http_info(subject_id, body, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def subject_copy_with_http_info(self, subject_id, body, **kwargs):  # noqa: E501
        """Smart copy a subject

        Smart copy a subject
        This method makes a synchronous HTTP request by default.

        :param str subject_id: (required)
        :param SubjectCopyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: Subject
        """

        all_params = ['subject_id','body',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subject_copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subject_id' is set
        if ('subject_id' not in params or
                params['subject_id'] is None):
            raise ValueError("Missing the required parameter `subject_id` when calling `subject_copy`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `subject_copy`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'subject_id' in params:
            path_params['subject_id'] = params['subject_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            if 'SubjectCopyInput'.startswith('union'):
                body_type = type(params['body'])
                if getattr(body_type, 'positional_to_model', None):
                    body_params = body_type.positional_to_model(params['body'])
                else:
                    body_params = params['body']
            else:
                body_params = flywheel.models.SubjectCopyInput.positional_to_model(params['body'])
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{subject_id}/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Subject',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_file_to_subject(self, container_id, file, **kwargs):  # noqa: E501
        """Upload a file to a(n) subject.

        Upload a file to a(n) subject.
        This method makes a synchronous HTTP request by default.

        :param str container_id: (required)
        :param str file: The file to upload (required)
        :param bool preserve_metadata:
        :param str ticket:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str metadata: Metadata object as a JSON-encoded string
        :param list[str] x_accept_feature: redirect header
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[FileOutput],UploadTicketOutput]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.upload_file_to_subject_with_http_info(container_id, file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_to_subject_with_http_info(container_id, file, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def upload_file_to_subject_with_http_info(self, container_id, file, **kwargs):  # noqa: E501
        """Upload a file to a(n) subject.

        Upload a file to a(n) subject.
        This method makes a synchronous HTTP request by default.

        :param str container_id: (required)
        :param str file: The file to upload (required)
        :param bool preserve_metadata:
        :param str ticket:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str metadata: Metadata object as a JSON-encoded string
        :param list[str] x_accept_feature: redirect header
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[FileOutput],UploadTicketOutput]
        """

        all_params = ['container_id','file','preserve_metadata','ticket','id','level','job','metadata','x_accept_feature','content_type',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file_to_subject" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_id' is set
        if ('container_id' not in params or
                params['container_id'] is None):
            raise ValueError("Missing the required parameter `container_id` when calling `upload_file_to_subject`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_file_to_subject`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'container_id' in params:
            path_params['container_id'] = params['container_id']  # noqa: E501

        query_params = []
        if 'preserve_metadata' in params:
            query_params.append(('preserve_metadata', params['preserve_metadata']))  # noqa: E501
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501

        header_params = {}
        if 'x_accept_feature' in params:
            header_params['x-accept-feature'] = params['x_accept_feature']  # noqa: E501
            collection_formats['x-accept-feature'] = ''  # noqa: E501
        if 'content_type' in params:
            header_params['content-type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'metadata' in params:
            form_params.append(('metadata', params['metadata']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{container_id}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='union[list[FileOutput],UploadTicketOutput]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def upload_output_to_subject_analysis(self, cid, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to an analysis.

        Upload an output file to an analysis
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param str file: The file to upload (required)
        :param str ticket:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: list[FileOutput]
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.upload_output_to_subject_analysis_with_http_info(cid, analysis_id, file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_output_to_subject_analysis_with_http_info(cid, analysis_id, file, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def upload_output_to_subject_analysis_with_http_info(self, cid, analysis_id, file, **kwargs):  # noqa: E501
        """Upload an output file to an analysis.

        Upload an output file to an analysis
        This method makes a synchronous HTTP request by default.

        :param str cid: (required)
        :param str analysis_id: (required)
        :param str file: The file to upload (required)
        :param str ticket:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: list[FileOutput]
        """

        all_params = ['cid','analysis_id','file','ticket','id','level','job','content_type',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_output_to_subject_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cid' is set
        if ('cid' not in params or
                params['cid'] is None):
            raise ValueError("Missing the required parameter `cid` when calling `upload_output_to_subject_analysis`")  # noqa: E501
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params or
                params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `upload_output_to_subject_analysis`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_output_to_subject_analysis`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'cid' in params:
            path_params['cid'] = params['cid']  # noqa: E501
        if 'analysis_id' in params:
            path_params['analysis_id'] = params['analysis_id']  # noqa: E501

        query_params = []
        if 'ticket' in params:
            query_params.append(('ticket', params['ticket']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'job' in params:
            query_params.append(('job', params['job']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['content-type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{cid}/analyses/{analysis_id}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FileOutput]',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)

    def verify_master_subject_code(self, code, **kwargs):  # noqa: E501
        """Verify that the given master subject code exists or not

        Verify that the given master subject code exists or not
        This method makes a synchronous HTTP request by default.

        :param str code: code id (required)
        :param bool async_: Perform the request asynchronously
        :return: MasterSubjectCodeOutput
        """
        ignore_simplified_return_value = kwargs.pop('_ignore_simplified_return_value', False)
        kwargs['_return_http_data_only'] = True

        if kwargs.get('async_'):
            return self.verify_master_subject_code_with_http_info(code, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_master_subject_code_with_http_info(code, **kwargs)  # noqa: E501
            if (
                data
                and hasattr(data, 'return_value')
                and not ignore_simplified_return_value
            ):
                return data.return_value()
            return data


    def verify_master_subject_code_with_http_info(self, code, **kwargs):  # noqa: E501
        """Verify that the given master subject code exists or not

        Verify that the given master subject code exists or not
        This method makes a synchronous HTTP request by default.

        :param str code: code id (required)
        :param bool async_: Perform the request asynchronously
        :return: MasterSubjectCodeOutput
        """

        all_params = ['code',]  # noqa: E501
        all_params.append('async_')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_request_out')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_master_subject_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'code' is set
        if ('code' not in params or
                params['code'] is None):
            raise ValueError("Missing the required parameter `code` when calling `verify_master_subject_code`")  # noqa: E501
        check_filename_params(params)

        collection_formats = {}

        path_params = {}
        if 'code' in params:
            path_params['code'] = params['code']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/master-code/{code}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MasterSubjectCodeOutput',  # noqa: E501
            auth_settings=auth_settings,
            async_=params.get('async_'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            _request_out=params.get('_request_out'),
            collection_formats=collection_formats)
