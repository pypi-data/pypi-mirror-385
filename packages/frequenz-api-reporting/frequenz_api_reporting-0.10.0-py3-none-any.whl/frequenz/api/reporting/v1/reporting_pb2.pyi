"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Reporting API

Copyright:
Copyright 2023 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1.metrics.metric_sample_pb2
import frequenz.api.common.v1.microgrid.components.components_pb2
import frequenz.api.common.v1.microgrid.microgrid_pb2
import frequenz.api.common.v1.microgrid.sensors.sensors_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _FilterOption:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _FilterOptionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FilterOption.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    FILTER_OPTION_UNSPECIFIED: _FilterOption.ValueType  # 0
    FILTER_OPTION_EXCLUDE: _FilterOption.ValueType  # 1
    FILTER_OPTION_INCLUDE: _FilterOption.ValueType  # 2

class FilterOption(_FilterOption, metaclass=_FilterOptionEnumTypeWrapper):
    """Defines whether to include results in the response message."""

FILTER_OPTION_UNSPECIFIED: FilterOption.ValueType  # 0
FILTER_OPTION_EXCLUDE: FilterOption.ValueType  # 1
FILTER_OPTION_INCLUDE: FilterOption.ValueType  # 2
global___FilterOption = FilterOption

@typing.final
class TimeFilter(google.protobuf.message.Message):
    """Time-based filter for querying aggregated microgrid components data.

    !!! note
        Specifies the start and end time for the query. Both fields are optional, but
        their absence or presence has specific implications for the query results.
        Data will be returned as a set of rows, which each row containing a timestamp.
        This timestamp will be >= start and < end.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Optional UTC start time for the query.

        !!! info
            If not provided, the query defaults to the earliest available data for the
            specified microgrid components.
        """

    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Optional UTC end time for the query.

        !!! info
            If not provided, the query will retrieve the requested data and continue
            streaming all new data as it becomes available.
        """

    def __init__(
        self,
        *,
        start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> None: ...

global___TimeFilter = TimeFilter

@typing.final
class ResamplingOptions(google.protobuf.message.Message):
    """Resampling options for aggregated microgrid components data.
    If data is resampled, all samples that fall in a left-closed time interval
    determined by the resolution will be aggregated.
    At the moment only mean aggregation is supported.
    The timestamp for each aggregated sample represents the beginning of its corresponding
    time interval, marking the earliest point from which data was aggregated.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOLUTION_FIELD_NUMBER: builtins.int
    resolution: builtins.int
    """Optional resampling resolution for the data, represented in seconds.
    If omitted, data will be returned in its original resolution.
    """
    def __init__(
        self,
        *,
        resolution: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_resolution", b"_resolution", "resolution", b"resolution"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_resolution", b"_resolution", "resolution", b"resolution"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_resolution", b"_resolution"]) -> typing.Literal["resolution"] | None: ...

global___ResamplingOptions = ResamplingOptions

@typing.final
class AggregationConfig(google.protobuf.message.Message):
    """Message defining the aggregation configuration for a custom formula within a specific microgrid.

    The AggregationConfig allows clients to specify how metrics should be aggregated across
    microgrid components. It serves as the configuration guideline for any aggregation operation.

    !!! example
       To calculate the total voltage across three components in series with IDs 1, 2, and 3, the
        configuration could look like:
        {
          microgrid_id: 42,
          metric: DC_VOLTAGE_V,
          aggregation_formula: "#1 + #2 + #3"
        }
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    METRIC_FIELD_NUMBER: builtins.int
    AGGREGATION_FORMULA_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """ID of the microgrid for which the formula is being specified."""
    metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType
    """The metric that is to be aggregated using the specified formula.

    !!! caution
        Ensure the chosen metric is supported by all relevant microgrid components.
        Failure to meet these conditions might results in an aggregation error.
    """
    aggregation_formula: builtins.str
    """The formula used for aggregating the component metric for this microgrid.

    !!! info
        Two types of aggregation formulas are supported:
        1. Aggregate functions: These are standard aggregation functions like `sum()` and `avg()`.
           Example: `sum(#1,#2)`, `avg(#3,#4)`

        2. Dedicated formulas: These support basic math operators while concatenating microgrid
           component IDs.
           Example: `#1 + #2 - #3`, `(#3 * #2) /# 1`

        Additionally, metric connection identifiers can be used in the formula, for components
        that e.g. provide the same metric from multiple connections/sensors.
        Example: `sum(#1[connection0], #2, #3)`, `#1[connection0] + #2[connection1]`
    """
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType = ...,
        aggregation_formula: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["aggregation_formula", b"aggregation_formula", "metric", b"metric", "microgrid_id", b"microgrid_id"]) -> None: ...

global___AggregationConfig = AggregationConfig

@typing.final
class SimpleAggregatedMetricValue(google.protobuf.message.Message):
    """Defines a single aggregated metric sample, which represents a consolidated metric value
    over a collection of microgrid components within a specific timeframe.

    This message serves to encapsulate aggregate metrics derived from multiple component
    measurements. It is particularly useful in scenarios where an overall metric needs to be
    calculated for a set of components. For instance, you could use it to represent the average
    voltage across multiple sources within a microgrid or to calculate the average state of
    charge of several batteries.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAMPLE_TIME_FIELD_NUMBER: builtins.int
    SAMPLE_FIELD_NUMBER: builtins.int
    @property
    def sample_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The UTC sample timestamp for the aggregated metrics.

        !!! info
            This is the original timestamp of the samples that were aggregated.
        """

    @property
    def sample(self) -> frequenz.api.common.v1.metrics.metric_sample_pb2.SimpleMetricValue:
        """The aggregated value of the metric.
        float value = 2;
        """

    def __init__(
        self,
        *,
        sample_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        sample: frequenz.api.common.v1.metrics.metric_sample_pb2.SimpleMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["sample", b"sample", "sample_time", b"sample_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["sample", b"sample", "sample_time", b"sample_time"]) -> None: ...

global___SimpleAggregatedMetricValue = SimpleAggregatedMetricValue

@typing.final
class MetricConnections(google.protobuf.message.Message):
    """Message defining a metric to receive data for, optionally filtering by connections.

    This message allows clients to request data for a specific metric, and optionally
    filter the data by connection identifiers. This is particularly useful when a metric can
    originate from multiple connections within a component, such as different DC strings for
    batteries or PV arrays connected to a hybrid inverter.

    !!! note
        The `MetricConnections` message enables fine-grained control over which are included in the data stream.
        If multiple `MetricConnections` messages are specified for different metrics, the filters apply
        separately to each metric.
        The `connections` specified here correspond to the `connections` field in the `MetricSample` message
        defined in the common API. By filtering on `connections`, you effectively select which `MetricSample`
        messages to receive based on their `connections` value.

    !!! example
        Suppose you have a hybrid inverter that provides the `VOLTAGE` metric from both its battery and
        PV array. If you're only interested in the voltage measurements from the battery, you can use
        `Metrics` message to specify the `VOLTAGE` metric and set `connections` to `["dc_battery_1"]`
        for the DC string connected to a battery.

        ```
        {
          "metric": "VOLTAGE",
          "connections": ["dc_battery_1"]
        }
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METRIC_FIELD_NUMBER: builtins.int
    CONNECTIONS_FIELD_NUMBER: builtins.int
    metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType
    """The metric for which data is requested.

    If `connections` are specified, only data for this metric from those connections will be returned.
    If no `connections` are specified, data from all connections for this metric will be returned.
    """
    @property
    def connections(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """An optional list of connections to filter the data for the specified metric.

        Each connection corresponds to the `connections` field in `MetricSample` messages
        (see the common API definition).
        If this list is empty or not specified, data from all sources for this metric will be returned.

        !!! important
            The connections identifiers must match exactly those used in the `MetricSample` messages.
            Ensure that the connections specified here are valid for the given metric and component.

        !!! important
            There is an important distinction between these connection strings, and the `ComponentConnection`
            message in the common API. A connection string here may, unlike the `ComponentConnection` message,
            refer to a connection that is not present in the microgrid's component graph.

        !!! example
            For a metric that can come from multiple DC strings in a PV array, you might specify:

            ```
            {
              "connections": ["dc_string_1", "dc_string_2"]
            }
            ```
        """

    def __init__(
        self,
        *,
        metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType = ...,
        connections: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["connections", b"connections", "metric", b"metric"]) -> None: ...

global___MetricConnections = MetricConnections

@typing.final
class ReceiveMicrogridComponentsDataStreamRequest(google.protobuf.message.Message):
    """Request message for receiving stream of metrics, such as electrical
    measurements, and other information for individual microgrid components.

    !!! note
        In addition to the raw metrics, the API can also return additional information
        like errors or operational states of the components during the specified time period.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class IncludeOptions(google.protobuf.message.Message):
        """Include options for filtering microgrid components data.

        !!! note
            Specifies which additional fields should be included in the response.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        BOUNDS_FIELD_NUMBER: builtins.int
        STATES_FIELD_NUMBER: builtins.int
        bounds: global___FilterOption.ValueType
        """Optional bound inclusion. By default, bounds are not included in the response."""
        states: global___FilterOption.ValueType
        """Optional operational state inclusion. By default, states are not included in the response."""
        def __init__(
            self,
            *,
            bounds: global___FilterOption.ValueType | None = ...,
            states: global___FilterOption.ValueType | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_bounds", b"_bounds", "_states", b"_states", "bounds", b"bounds", "states", b"states"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_bounds", b"_bounds", "_states", b"_states", "bounds", b"bounds", "states", b"states"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_bounds", b"_bounds"]) -> typing.Literal["bounds"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_states", b"_states"]) -> typing.Literal["states"] | None: ...

    @typing.final
    class StreamFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid components data.

        !!! note
            The filter criteria defined here are applied universally across all
            specified microgrids and their respective components.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        INCLUDE_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def include_options(self) -> global___ReceiveMicrogridComponentsDataStreamRequest.IncludeOptions:
            """Include options specifying additional fields to be included in the response."""

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria.
            If omitted, data will start streaming from the timestamp that the request was received.
            """

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            include_options: global___ReceiveMicrogridComponentsDataStreamRequest.IncludeOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    MICROGRID_COMPONENTS_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def microgrid_components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridComponentIDs]:
        """Encapsulates the microgrid ID and the component IDs within that microgrid for which
        the historical data should be retrieved.

        !!! note
            Each entry in this repeated field associates a microgrid ID with its respective
            component IDs. At least one such association must be provided for a valid request.
        """

    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetricConnections]:
        """List of metrics to receive data for, each possibly with connection filters.

        !!! note
            At least one metric must be specified. Each metric can have an optional list of connections.
            If connections are provided for a metric, only data from those connections will be returned.
            If no connections are provided for a metric, data from all connections will be returned for that metric.

        !!! example
            To receive `VOLTAGE` data only from the battery connection and `CURRENT` data from all connections:

            ```
            {
              "metrics": [
                {
                  "metric": "VOLTAGE",
                  "connections": ["dc_battery_1"]
                },
                {
                  "metric": "CURRENT"
                  // No connections specified; data from all connections will be returned for CURRENT
                }
              ]
            }
            ```
        """

    @property
    def filter(self) -> global___ReceiveMicrogridComponentsDataStreamRequest.StreamFilter:
        """General filter that applies to the data retrieval for all specified microgrids and components.

        !!! note
            The filter can specify a list of metrics to be return but also specify bounds, operational
            state, or errors to be returned.
        """

    def __init__(
        self,
        *,
        microgrid_components: collections.abc.Iterable[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridComponentIDs] | None = ...,
        metrics: collections.abc.Iterable[global___MetricConnections] | None = ...,
        filter: global___ReceiveMicrogridComponentsDataStreamRequest.StreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "metrics", b"metrics", "microgrid_components", b"microgrid_components"]) -> None: ...

global___ReceiveMicrogridComponentsDataStreamRequest = ReceiveMicrogridComponentsDataStreamRequest

@typing.final
class ReceiveMicrogridComponentsDataStreamResponse(google.protobuf.message.Message):
    """Response containing a single data sample for one microgrid's components.

    !!! note
        The microgrid's components are provided as single data samples that
        encapsulate metrics, bounds, errors, and operational states along with their
        associated timestamps. Each response message covers a single microgrid.
        If multiple microgrids are provided in the request, expect sequential messages
        in the stream.

    !!! example
        Example output structure:
        ```
        {
          microgrid_id: 1,
          components: [
            {
              component_id: 13,
              metric_samples: [
                /* all metrics belong to the same timestamp */
                /* sample is type MetricSampleVariant */
                { sample_time: "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },
                { sample_time: "2023-10-01T00:00:00Z", metric: "DC_CURRENT_A", sample: {...}, bounds: {...} }
              ],
              state: {
                sample_time: "2023-10-01T00:00:13.12Z",
                states: ["COMPONENT_STATE_CHARGING", "CABLE_CONNECTED"],
                warnings: []
                errors: [],
              ]
            },
            {
              component_id: 59,
              metric_samples: [
                /* all metrics belong to the same timestamp */
                /* sample is type MetricSampleVariant */
                { sample_time: "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },
                { sample_time: "2023-10-01T00:00:00Z", metric: "DC_CURRENT_A", sample: {...}, bounds: {...} }
              ],
              state: {
                sample_time: "2023-10-01T00:00:13.12Z",
                states: ["COMPONENT_STATE_ERROR"],
                warnings: []
                errors: ["COMPONENT_ERROR_CODE_BATTERY_RELAY_ERROR"],
              ]
            }
          ]
        }
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    COMPONENTS_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """Microgrid ID for which the components and samples are reported."""
    @property
    def components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentData]:
        """List of components within this microgrid, each with its associated data samples."""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        components: collections.abc.Iterable[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentData] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["components", b"components", "microgrid_id", b"microgrid_id"]) -> None: ...

global___ReceiveMicrogridComponentsDataStreamResponse = ReceiveMicrogridComponentsDataStreamResponse

@typing.final
class ReceiveAggregatedMicrogridComponentsDataStreamRequest(google.protobuf.message.Message):
    """Message defining the request format for streaming aggregated historical metrics.
    This request allows to specify custom aggregation formulas, along with general
    filtering.

    At least one aggregation formula config must be provided. The aggregation
    follows the passive sign convention.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggregationStreamFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid components data."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria.
            If omitted, data will start streaming from the timestamp that the request was received.
            """

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    AGGREGATION_CONFIGS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def aggregation_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregationConfig]:
        """List of pairs of metric and corresponding aggregation formula."""

    @property
    def filter(self) -> global___ReceiveAggregatedMicrogridComponentsDataStreamRequest.AggregationStreamFilter:
        """General streaming filter that applies to all formula aggregations."""

    def __init__(
        self,
        *,
        aggregation_configs: collections.abc.Iterable[global___AggregationConfig] | None = ...,
        filter: global___ReceiveAggregatedMicrogridComponentsDataStreamRequest.AggregationStreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_configs", b"aggregation_configs", "filter", b"filter"]) -> None: ...

global___ReceiveAggregatedMicrogridComponentsDataStreamRequest = ReceiveAggregatedMicrogridComponentsDataStreamRequest

@typing.final
class ReceiveAggregatedMicrogridComponentsDataStreamResponse(google.protobuf.message.Message):
    """Message defining the response format for a stream that fetches aggregated real-time metrics
    for the provided custom aggregation formulas.

    !!! note
        The formula and metric must have been specified in the corresponding request.
        A single aggregated sample for the metric is returned in the sample field. Each message
        covers a single formula. For multiple formulars provided in the request, expect sequential
        messages in the stream.

    !!! example
        Given a stream output, a single sample might be:
        ```
        {
          aggregation_config: {
            microgrid_id: 1,
            metric: "DC_VOLTAGE_V",
            aggregation_formula: "avg(1,2,3)"
          },
          sample {
            sample_time: '2023-10-01T00:00:00Z',
            sample: { value: 42.5 }
          }
        }
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AGGREGATION_CONFIG_FIELD_NUMBER: builtins.int
    SAMPLE_FIELD_NUMBER: builtins.int
    @property
    def aggregation_config(self) -> global___AggregationConfig:
        """The metric and formula that has been used to aggregate the sample."""

    @property
    def sample(self) -> global___SimpleAggregatedMetricValue:
        """Aggregated sample value and corresponding UTC timestamp when it was sampled."""

    def __init__(
        self,
        *,
        aggregation_config: global___AggregationConfig | None = ...,
        sample: global___SimpleAggregatedMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "sample", b"sample"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "sample", b"sample"]) -> None: ...

global___ReceiveAggregatedMicrogridComponentsDataStreamResponse = ReceiveAggregatedMicrogridComponentsDataStreamResponse

@typing.final
class ReceiveMicrogridSensorsDataStreamRequest(google.protobuf.message.Message):
    """Request message for receiving a stream of metrics, such as electrical
    measurements, and other information for individual microgrid sensors.

    !!! note
        In addition to the raw metrics, the API can also return additional information
        like errors or operational states of the sensors during the specified time period.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class IncludeOptions(google.protobuf.message.Message):
        """Include options for filtering microgrid sensors data.

        !!! note
            Specifies which additional fields should be included in the response.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        STATES_FIELD_NUMBER: builtins.int
        states: global___FilterOption.ValueType
        """Optional operational state inclusion. By default, states are not included in the response."""
        def __init__(
            self,
            *,
            states: global___FilterOption.ValueType | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_states", b"_states", "states", b"states"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_states", b"_states", "states", b"states"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["_states", b"_states"]) -> typing.Literal["states"] | None: ...

    @typing.final
    class StreamFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid sensors data.

        !!! note
            The filter criteria defined here are applied universally across all
            specified microgrids and their respective sensors.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        INCLUDE_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def include_options(self) -> global___ReceiveMicrogridSensorsDataStreamRequest.IncludeOptions:
            """Include options specifying additional fields to be included in the response."""

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria.
            If omitted, data will start streaming from the timestamp that the request was received.
            """

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            include_options: global___ReceiveMicrogridSensorsDataStreamRequest.IncludeOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    MICROGRID_SENSORS_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def microgrid_sensors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridSensorIDs]:
        """Encapsulates the microgrid ID and the sensor IDs within that microgrid for which
        the historical data should be retrieved.

        !!! note
            Each entry in this repeated field associates a microgrid ID with its respective
            sensor IDs. At least one such association must be provided for a valid request.
        """

    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetricConnections]:
        """List of metrics to receive data for, each possibly with connection filters.

        !!! note
            At least one metric must be specified. Each metric can have an optional list of connections.
            If connections are provided for a metric, only data from those connections will be returned.
            If no connections are provided for a metric, data from all connections will be returned for that metric.
        """

    @property
    def filter(self) -> global___ReceiveMicrogridSensorsDataStreamRequest.StreamFilter:
        """General filter that applies to the data retrieval for all specified microgrids and sensors.

        !!! note
            The filter can specify a list of metrics to be return but also specify bounds, operational
            state, or errors to be returned.
        """

    def __init__(
        self,
        *,
        microgrid_sensors: collections.abc.Iterable[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridSensorIDs] | None = ...,
        metrics: collections.abc.Iterable[global___MetricConnections] | None = ...,
        filter: global___ReceiveMicrogridSensorsDataStreamRequest.StreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "metrics", b"metrics", "microgrid_sensors", b"microgrid_sensors"]) -> None: ...

global___ReceiveMicrogridSensorsDataStreamRequest = ReceiveMicrogridSensorsDataStreamRequest

@typing.final
class ReceiveMicrogridSensorsDataStreamResponse(google.protobuf.message.Message):
    """Response containing a single data sample for one microgrid's sensors.

    !!! note
        The microgrid's sensors are provided as single data samples that
        encapsulate metrics, bounds, errors, and operational states along with their
        associated timestamps. Each response message covers a single microgrid.
        If multiple microgrids are provided in the request, expect sequential messages
        in the stream.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    SENSORS_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """Microgrid ID for which the sensors and samples are reported."""
    @property
    def sensors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.sensors.sensors_pb2.SensorData]:
        """List of sensors within this microgrid, each with its associated data samples."""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        sensors: collections.abc.Iterable[frequenz.api.common.v1.microgrid.sensors.sensors_pb2.SensorData] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["microgrid_id", b"microgrid_id", "sensors", b"sensors"]) -> None: ...

global___ReceiveMicrogridSensorsDataStreamResponse = ReceiveMicrogridSensorsDataStreamResponse

@typing.final
class ReceiveAggregatedMicrogridSensorsDataStreamRequest(google.protobuf.message.Message):
    """Message defining the request format for streaming aggregated historical metrics.
    This request allows to specify custom aggregation formulas, along with general
    filtering.

    At least one aggregation formula config must be provided. The aggregation
    follows the passive sign convention.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggregationStreamFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid sensors data."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria.
            If omitted, data will start streaming from the timestamp that the request was received.
            """

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    AGGREGATION_CONFIGS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def aggregation_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregationConfig]:
        """List of pairs of metric and corresponding aggregation formula."""

    @property
    def filter(self) -> global___ReceiveAggregatedMicrogridSensorsDataStreamRequest.AggregationStreamFilter:
        """General streaming filter that applies to all formula aggregations."""

    def __init__(
        self,
        *,
        aggregation_configs: collections.abc.Iterable[global___AggregationConfig] | None = ...,
        filter: global___ReceiveAggregatedMicrogridSensorsDataStreamRequest.AggregationStreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_configs", b"aggregation_configs", "filter", b"filter"]) -> None: ...

global___ReceiveAggregatedMicrogridSensorsDataStreamRequest = ReceiveAggregatedMicrogridSensorsDataStreamRequest

@typing.final
class ReceiveAggregatedMicrogridSensorsDataStreamResponse(google.protobuf.message.Message):
    """Message defining the response format for a stream that fetches aggregated real-time metrics
    for the provided custom aggregation formulas.

    !!! note
        The formula and metric must have been specified in the corresponding request.
        A single aggregated sample for the metric is returned in the sample field. Each message
        covers a single formula. For multiple formulars provided in the request, expect sequential
        messages in the stream.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AGGREGATION_CONFIG_FIELD_NUMBER: builtins.int
    SAMPLE_FIELD_NUMBER: builtins.int
    @property
    def aggregation_config(self) -> global___AggregationConfig:
        """The metric and formula that has been used to aggregate the sample."""

    @property
    def sample(self) -> global___SimpleAggregatedMetricValue:
        """Aggregated sample value and corresponding UTC timestamp when it was sampled."""

    def __init__(
        self,
        *,
        aggregation_config: global___AggregationConfig | None = ...,
        sample: global___SimpleAggregatedMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "sample", b"sample"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "sample", b"sample"]) -> None: ...

global___ReceiveAggregatedMicrogridSensorsDataStreamResponse = ReceiveAggregatedMicrogridSensorsDataStreamResponse
