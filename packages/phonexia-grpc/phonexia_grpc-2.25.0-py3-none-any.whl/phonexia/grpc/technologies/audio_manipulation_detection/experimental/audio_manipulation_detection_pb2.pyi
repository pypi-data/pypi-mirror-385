"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2025 Phonexia s.r.o.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Phonexia Audio Manipulation Detection gRPC API.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.message
import phonexia.grpc.common.core_pb2
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class DetectRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUDIO_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    @property
    def audio(self) -> phonexia.grpc.common.core_pb2.Audio:
        """Audio data for audio manipulation detection.
        The audio should have minimum length of 0.645s seconds which is a length of one segment.
        If the audio is shorter, the <code>segments</code> array in the response will be empty.
        """

    @property
    def config(self) -> global___DetectConfig:
        """Audio manipulation detection configuration."""

    def __init__(
        self,
        *,
        audio: phonexia.grpc.common.core_pb2.Audio | None = ...,
        config: global___DetectConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["audio", b"audio", "config", b"config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["audio", b"audio", "config", b"config"]) -> None: ...

global___DetectRequest = DetectRequest

@typing.final
class DetectConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RAW_SEGMENTATION_FIELD_NUMBER: builtins.int
    raw_segmentation: builtins.bool
    """When `raw_segmentation` is true, the audio is analyzed in overlapping segments of 0.645 seconds
    (with 50% overlap between consecutive segments). Each segment is independently classified as
    manipulated or genuine. Adjacent segments that are both classified as manipulated will NOT be
    merged, resulting in potentially redundant but more granular detections. When `raw_segmentation`
    is false (default), adjacent manipulated segments are consolidated into a single continuous
    segment to provide a cleaner output.
    Example: With `raw_segmentation=true`, if segments [0.0, 0.645] and [0.3225, 0.9675] are both 
    detected as manipulated, they will be reported as two separate segments despite their overlap.
    With `raw_segmentation=false`, these would be merged into a single segment [0.0, 0.9675].
    """
    def __init__(
        self,
        *,
        raw_segmentation: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["raw_segmentation", b"raw_segmentation"]) -> None: ...

global___DetectConfig = DetectConfig

@typing.final
class DetectResponse(google.protobuf.message.Message):
    """The top level message returned to the client by the <code>Detect</code> method."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEGMENTS_FIELD_NUMBER: builtins.int
    PROCESSED_AUDIO_LENGTH_FIELD_NUMBER: builtins.int
    @property
    def segments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Segment]:
        """List of detected segments. Will be empty if the audio is shorter than 0.645 seconds."""

    @property
    def processed_audio_length(self) -> google.protobuf.duration_pb2.Duration:
        """Total length of the processed audio."""

    def __init__(
        self,
        *,
        segments: collections.abc.Iterable[global___Segment] | None = ...,
        processed_audio_length: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["processed_audio_length", b"processed_audio_length"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["processed_audio_length", b"processed_audio_length", "segments", b"segments"]) -> None: ...

global___DetectResponse = DetectResponse

@typing.final
class Segment(google.protobuf.message.Message):
    """Detected segment."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SCORE_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    score: builtins.float
    """Score of the audio manipulation represented as a Log-likelihood ratio (LLR).
    A higher score indicates a higher likelihood of the audio being manipulated.
    The threshold is at score == 0. A score greater than 0 indicates that the audio
    may be manipulated, while a score less than 0 indicates that the audio is likely
    not manipulated.
    By default, only the segments containing manipulated audio (score > 0) are returned.
    If multiple adjacent segments contain manipulated audio, they are merged into
    a single segment. To change this behavior, set <code>DetectRequest.config.raw_segmentation</code>
    """
    @property
    def start_time(self) -> google.protobuf.duration_pb2.Duration:
        """Timestamp specifying the beginning of the segment."""

    @property
    def end_time(self) -> google.protobuf.duration_pb2.Duration:
        """Timestamp specifying the end of the segment."""

    def __init__(
        self,
        *,
        score: builtins.float = ...,
        start_time: google.protobuf.duration_pb2.Duration | None = ...,
        end_time: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_time", b"end_time", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_time", b"end_time", "score", b"score", "start_time", b"start_time"]) -> None: ...

global___Segment = Segment
