"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License.

GENERATED FILE - DO NOT EDIT MANUALLY
This file is generated by generate_handlers.py based on activity_config.py

To regenerate, run:
uv run generate-activity-handlers
"""

from abc import ABC, abstractmethod
from logging import Logger
from typing import Callable, Optional, overload

from microsoft.teams.api.activities import (
    Activity,
    AdaptiveCardInvokeActivity,
    CommandResultActivity,
    CommandSendActivity,
    ConfigFetchInvokeActivity,
    ConfigSubmitInvokeActivity,
    ConversationUpdateActivity,
    EndOfConversationActivity,
    EventActivity,
    ExecuteActionInvokeActivity,
    FileConsentInvokeActivity,
    HandoffActionInvokeActivity,
    HandoffActivity,
    InstalledActivity,
    InstallUpdateActivity,
    InvokeActivity,
    MeetingEndEventActivity,
    MeetingParticipantJoinEventActivity,
    MeetingParticipantLeaveEventActivity,
    MeetingStartEventActivity,
    MessageActivity,
    MessageDeleteActivity,
    MessageExtensionAnonQueryLinkInvokeActivity,
    MessageExtensionCardButtonClickedInvokeActivity,
    MessageExtensionFetchTaskInvokeActivity,
    MessageExtensionQueryInvokeActivity,
    MessageExtensionQueryLinkInvokeActivity,
    MessageExtensionQuerySettingUrlInvokeActivity,
    MessageExtensionSelectItemInvokeActivity,
    MessageExtensionSettingInvokeActivity,
    MessageExtensionSubmitActionInvokeActivity,
    MessageReactionActivity,
    MessageSubmitActionInvokeActivity,
    MessageUpdateActivity,
    ReadReceiptEventActivity,
    SignInTokenExchangeInvokeActivity,
    SignInVerifyStateInvokeActivity,
    TabFetchInvokeActivity,
    TabSubmitInvokeActivity,
    TaskFetchInvokeActivity,
    TaskSubmitInvokeActivity,
    TraceActivity,
    TypingActivity,
    UninstalledActivity,
)
from microsoft.teams.api.models.invoke_response import (
    AdaptiveCardInvokeResponse,
    ConfigInvokeResponse,
    MessagingExtensionActionInvokeResponse,
    MessagingExtensionInvokeResponse,
    TabInvokeResponse,
    TaskModuleInvokeResponse,
    TokenExchangeInvokeResponseType,
)

from .activity_route_configs import ACTIVITY_ROUTES
from .router import ActivityRouter
from .type_helpers import (
    BasicHandler,
    BasicHandlerUnion,
    InvokeHandler,
    InvokeHandlerUnion,
    VoidInvokeHandler,
    VoidInvokeHandlerUnion,
)
from .type_validation import validate_handler_type


class GeneratedActivityHandlerMixin(ABC):
    """Mixin class providing typed activity handler registration methods."""

    @property
    @abstractmethod
    def router(self) -> ActivityRouter:
        """The activity router instance. Must be implemented by the concrete class."""
        pass

    @property
    @abstractmethod
    def logger(self) -> Logger:
        """The logger instance used by the app."""
        pass

    @overload
    def on_message(self, handler: BasicHandler[MessageActivity]) -> BasicHandler[MessageActivity]: ...

    @overload
    def on_message(self) -> Callable[[BasicHandler[MessageActivity]], BasicHandler[MessageActivity]]: ...

    def on_message(self, handler: Optional[BasicHandler[MessageActivity]] = None) -> BasicHandlerUnion[MessageActivity]:
        """Register a message activity handler."""

        def decorator(func: BasicHandler[MessageActivity]) -> BasicHandler[MessageActivity]:
            validate_handler_type(self.logger, func, MessageActivity, "on_message", "MessageActivity")
            config = ACTIVITY_ROUTES["message"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_delete(
        self, handler: BasicHandler[MessageDeleteActivity]
    ) -> BasicHandler[MessageDeleteActivity]: ...

    @overload
    def on_message_delete(
        self,
    ) -> Callable[[BasicHandler[MessageDeleteActivity]], BasicHandler[MessageDeleteActivity]]: ...

    def on_message_delete(
        self, handler: Optional[BasicHandler[MessageDeleteActivity]] = None
    ) -> BasicHandlerUnion[MessageDeleteActivity]:
        """Register a message_delete activity handler."""

        def decorator(func: BasicHandler[MessageDeleteActivity]) -> BasicHandler[MessageDeleteActivity]:
            validate_handler_type(
                self.logger, func, MessageDeleteActivity, "on_message_delete", "MessageDeleteActivity"
            )
            config = ACTIVITY_ROUTES["message_delete"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_soft_delete_message(
        self, handler: BasicHandler[MessageDeleteActivity]
    ) -> BasicHandler[MessageDeleteActivity]: ...

    @overload
    def on_soft_delete_message(
        self,
    ) -> Callable[[BasicHandler[MessageDeleteActivity]], BasicHandler[MessageDeleteActivity]]: ...

    def on_soft_delete_message(
        self, handler: Optional[BasicHandler[MessageDeleteActivity]] = None
    ) -> BasicHandlerUnion[MessageDeleteActivity]:
        """Register a soft_delete_message activity handler."""

        def decorator(func: BasicHandler[MessageDeleteActivity]) -> BasicHandler[MessageDeleteActivity]:
            validate_handler_type(
                self.logger, func, MessageDeleteActivity, "on_soft_delete_message", "MessageDeleteActivity"
            )
            config = ACTIVITY_ROUTES["soft_delete_message"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_reaction(
        self, handler: BasicHandler[MessageReactionActivity]
    ) -> BasicHandler[MessageReactionActivity]: ...

    @overload
    def on_message_reaction(
        self,
    ) -> Callable[[BasicHandler[MessageReactionActivity]], BasicHandler[MessageReactionActivity]]: ...

    def on_message_reaction(
        self, handler: Optional[BasicHandler[MessageReactionActivity]] = None
    ) -> BasicHandlerUnion[MessageReactionActivity]:
        """Register a message_reaction activity handler."""

        def decorator(func: BasicHandler[MessageReactionActivity]) -> BasicHandler[MessageReactionActivity]:
            validate_handler_type(
                self.logger, func, MessageReactionActivity, "on_message_reaction", "MessageReactionActivity"
            )
            config = ACTIVITY_ROUTES["message_reaction"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_update(
        self, handler: BasicHandler[MessageUpdateActivity]
    ) -> BasicHandler[MessageUpdateActivity]: ...

    @overload
    def on_message_update(
        self,
    ) -> Callable[[BasicHandler[MessageUpdateActivity]], BasicHandler[MessageUpdateActivity]]: ...

    def on_message_update(
        self, handler: Optional[BasicHandler[MessageUpdateActivity]] = None
    ) -> BasicHandlerUnion[MessageUpdateActivity]:
        """Register a message_update activity handler."""

        def decorator(func: BasicHandler[MessageUpdateActivity]) -> BasicHandler[MessageUpdateActivity]:
            validate_handler_type(
                self.logger, func, MessageUpdateActivity, "on_message_update", "MessageUpdateActivity"
            )
            config = ACTIVITY_ROUTES["message_update"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_undelete_message(
        self, handler: BasicHandler[MessageUpdateActivity]
    ) -> BasicHandler[MessageUpdateActivity]: ...

    @overload
    def on_undelete_message(
        self,
    ) -> Callable[[BasicHandler[MessageUpdateActivity]], BasicHandler[MessageUpdateActivity]]: ...

    def on_undelete_message(
        self, handler: Optional[BasicHandler[MessageUpdateActivity]] = None
    ) -> BasicHandlerUnion[MessageUpdateActivity]:
        """Register a undelete_message activity handler."""

        def decorator(func: BasicHandler[MessageUpdateActivity]) -> BasicHandler[MessageUpdateActivity]:
            validate_handler_type(
                self.logger, func, MessageUpdateActivity, "on_undelete_message", "MessageUpdateActivity"
            )
            config = ACTIVITY_ROUTES["undelete_message"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_edit_message(self, handler: BasicHandler[MessageUpdateActivity]) -> BasicHandler[MessageUpdateActivity]: ...

    @overload
    def on_edit_message(
        self,
    ) -> Callable[[BasicHandler[MessageUpdateActivity]], BasicHandler[MessageUpdateActivity]]: ...

    def on_edit_message(
        self, handler: Optional[BasicHandler[MessageUpdateActivity]] = None
    ) -> BasicHandlerUnion[MessageUpdateActivity]:
        """Register a edit_message activity handler."""

        def decorator(func: BasicHandler[MessageUpdateActivity]) -> BasicHandler[MessageUpdateActivity]:
            validate_handler_type(self.logger, func, MessageUpdateActivity, "on_edit_message", "MessageUpdateActivity")
            config = ACTIVITY_ROUTES["edit_message"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_command(self, handler: BasicHandler[CommandSendActivity]) -> BasicHandler[CommandSendActivity]: ...

    @overload
    def on_command(self) -> Callable[[BasicHandler[CommandSendActivity]], BasicHandler[CommandSendActivity]]: ...

    def on_command(
        self, handler: Optional[BasicHandler[CommandSendActivity]] = None
    ) -> BasicHandlerUnion[CommandSendActivity]:
        """Register a command activity handler."""

        def decorator(func: BasicHandler[CommandSendActivity]) -> BasicHandler[CommandSendActivity]:
            validate_handler_type(self.logger, func, CommandSendActivity, "on_command", "CommandSendActivity")
            config = ACTIVITY_ROUTES["command"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_command_result(
        self, handler: BasicHandler[CommandResultActivity]
    ) -> BasicHandler[CommandResultActivity]: ...

    @overload
    def on_command_result(
        self,
    ) -> Callable[[BasicHandler[CommandResultActivity]], BasicHandler[CommandResultActivity]]: ...

    def on_command_result(
        self, handler: Optional[BasicHandler[CommandResultActivity]] = None
    ) -> BasicHandlerUnion[CommandResultActivity]:
        """Register a command_result activity handler."""

        def decorator(func: BasicHandler[CommandResultActivity]) -> BasicHandler[CommandResultActivity]:
            validate_handler_type(
                self.logger, func, CommandResultActivity, "on_command_result", "CommandResultActivity"
            )
            config = ACTIVITY_ROUTES["command_result"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_conversation_update(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_conversation_update(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_conversation_update(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a conversation_update activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_conversation_update", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["conversation_update"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_channel_created(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_channel_created(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_channel_created(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a channel_created activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_channel_created", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["channel_created"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_channel_deleted(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_channel_deleted(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_channel_deleted(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a channel_deleted activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_channel_deleted", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["channel_deleted"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_channel_renamed(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_channel_renamed(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_channel_renamed(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a channel_renamed activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_channel_renamed", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["channel_renamed"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_channel_restored(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_channel_restored(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_channel_restored(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a channel_restored activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_channel_restored", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["channel_restored"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_team_archived(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_team_archived(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_team_archived(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a team_archived activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_team_archived", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["team_archived"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_team_deleted(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_team_deleted(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_team_deleted(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a team_deleted activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_team_deleted", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["team_deleted"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_team_hard_deleted(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_team_hard_deleted(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_team_hard_deleted(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a team_hard_deleted activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_team_hard_deleted", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["team_hard_deleted"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_team_renamed(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_team_renamed(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_team_renamed(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a team_renamed activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_team_renamed", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["team_renamed"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_team_restored(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_team_restored(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_team_restored(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a team_restored activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_team_restored", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["team_restored"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_team_unarchived(
        self, handler: BasicHandler[ConversationUpdateActivity]
    ) -> BasicHandler[ConversationUpdateActivity]: ...

    @overload
    def on_team_unarchived(
        self,
    ) -> Callable[[BasicHandler[ConversationUpdateActivity]], BasicHandler[ConversationUpdateActivity]]: ...

    def on_team_unarchived(
        self, handler: Optional[BasicHandler[ConversationUpdateActivity]] = None
    ) -> BasicHandlerUnion[ConversationUpdateActivity]:
        """Register a team_unarchived activity handler."""

        def decorator(func: BasicHandler[ConversationUpdateActivity]) -> BasicHandler[ConversationUpdateActivity]:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "on_team_unarchived", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["team_unarchived"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_end_of_conversation(
        self, handler: BasicHandler[EndOfConversationActivity]
    ) -> BasicHandler[EndOfConversationActivity]: ...

    @overload
    def on_end_of_conversation(
        self,
    ) -> Callable[[BasicHandler[EndOfConversationActivity]], BasicHandler[EndOfConversationActivity]]: ...

    def on_end_of_conversation(
        self, handler: Optional[BasicHandler[EndOfConversationActivity]] = None
    ) -> BasicHandlerUnion[EndOfConversationActivity]:
        """Register a end_of_conversation activity handler."""

        def decorator(func: BasicHandler[EndOfConversationActivity]) -> BasicHandler[EndOfConversationActivity]:
            validate_handler_type(
                self.logger, func, EndOfConversationActivity, "on_end_of_conversation", "EndOfConversationActivity"
            )
            config = ACTIVITY_ROUTES["end_of_conversation"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_event(self, handler: BasicHandler[EventActivity]) -> BasicHandler[EventActivity]: ...

    @overload
    def on_event(self) -> Callable[[BasicHandler[EventActivity]], BasicHandler[EventActivity]]: ...

    def on_event(self, handler: Optional[BasicHandler[EventActivity]] = None) -> BasicHandlerUnion[EventActivity]:
        """Register a event activity handler."""

        def decorator(func: BasicHandler[EventActivity]) -> BasicHandler[EventActivity]:
            validate_handler_type(self.logger, func, EventActivity, "on_event", "EventActivity")
            config = ACTIVITY_ROUTES["event"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_read_receipt(
        self, handler: BasicHandler[ReadReceiptEventActivity]
    ) -> BasicHandler[ReadReceiptEventActivity]: ...

    @overload
    def on_read_receipt(
        self,
    ) -> Callable[[BasicHandler[ReadReceiptEventActivity]], BasicHandler[ReadReceiptEventActivity]]: ...

    def on_read_receipt(
        self, handler: Optional[BasicHandler[ReadReceiptEventActivity]] = None
    ) -> BasicHandlerUnion[ReadReceiptEventActivity]:
        """Register a read_receipt activity handler."""

        def decorator(func: BasicHandler[ReadReceiptEventActivity]) -> BasicHandler[ReadReceiptEventActivity]:
            validate_handler_type(
                self.logger, func, ReadReceiptEventActivity, "on_read_receipt", "ReadReceiptEventActivity"
            )
            config = ACTIVITY_ROUTES["read_receipt"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_meeting_start(
        self, handler: BasicHandler[MeetingStartEventActivity]
    ) -> BasicHandler[MeetingStartEventActivity]: ...

    @overload
    def on_meeting_start(
        self,
    ) -> Callable[[BasicHandler[MeetingStartEventActivity]], BasicHandler[MeetingStartEventActivity]]: ...

    def on_meeting_start(
        self, handler: Optional[BasicHandler[MeetingStartEventActivity]] = None
    ) -> BasicHandlerUnion[MeetingStartEventActivity]:
        """Register a meeting_start activity handler."""

        def decorator(func: BasicHandler[MeetingStartEventActivity]) -> BasicHandler[MeetingStartEventActivity]:
            validate_handler_type(
                self.logger, func, MeetingStartEventActivity, "on_meeting_start", "MeetingStartEventActivity"
            )
            config = ACTIVITY_ROUTES["meeting_start"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_meeting_end(
        self, handler: BasicHandler[MeetingEndEventActivity]
    ) -> BasicHandler[MeetingEndEventActivity]: ...

    @overload
    def on_meeting_end(
        self,
    ) -> Callable[[BasicHandler[MeetingEndEventActivity]], BasicHandler[MeetingEndEventActivity]]: ...

    def on_meeting_end(
        self, handler: Optional[BasicHandler[MeetingEndEventActivity]] = None
    ) -> BasicHandlerUnion[MeetingEndEventActivity]:
        """Register a meeting_end activity handler."""

        def decorator(func: BasicHandler[MeetingEndEventActivity]) -> BasicHandler[MeetingEndEventActivity]:
            validate_handler_type(
                self.logger, func, MeetingEndEventActivity, "on_meeting_end", "MeetingEndEventActivity"
            )
            config = ACTIVITY_ROUTES["meeting_end"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_meeting_participant_join(
        self, handler: BasicHandler[MeetingParticipantJoinEventActivity]
    ) -> BasicHandler[MeetingParticipantJoinEventActivity]: ...

    @overload
    def on_meeting_participant_join(
        self,
    ) -> Callable[
        [BasicHandler[MeetingParticipantJoinEventActivity]], BasicHandler[MeetingParticipantJoinEventActivity]
    ]: ...

    def on_meeting_participant_join(
        self, handler: Optional[BasicHandler[MeetingParticipantJoinEventActivity]] = None
    ) -> BasicHandlerUnion[MeetingParticipantJoinEventActivity]:
        """Register a meeting_participant_join activity handler."""

        def decorator(
            func: BasicHandler[MeetingParticipantJoinEventActivity],
        ) -> BasicHandler[MeetingParticipantJoinEventActivity]:
            validate_handler_type(
                self.logger,
                func,
                MeetingParticipantJoinEventActivity,
                "on_meeting_participant_join",
                "MeetingParticipantJoinEventActivity",
            )
            config = ACTIVITY_ROUTES["meeting_participant_join"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_meeting_participant_leave(
        self, handler: BasicHandler[MeetingParticipantLeaveEventActivity]
    ) -> BasicHandler[MeetingParticipantLeaveEventActivity]: ...

    @overload
    def on_meeting_participant_leave(
        self,
    ) -> Callable[
        [BasicHandler[MeetingParticipantLeaveEventActivity]], BasicHandler[MeetingParticipantLeaveEventActivity]
    ]: ...

    def on_meeting_participant_leave(
        self, handler: Optional[BasicHandler[MeetingParticipantLeaveEventActivity]] = None
    ) -> BasicHandlerUnion[MeetingParticipantLeaveEventActivity]:
        """Register a meeting_participant_leave activity handler."""

        def decorator(
            func: BasicHandler[MeetingParticipantLeaveEventActivity],
        ) -> BasicHandler[MeetingParticipantLeaveEventActivity]:
            validate_handler_type(
                self.logger,
                func,
                MeetingParticipantLeaveEventActivity,
                "on_meeting_participant_leave",
                "MeetingParticipantLeaveEventActivity",
            )
            config = ACTIVITY_ROUTES["meeting_participant_leave"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_config_open(
        self, handler: InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse]
    ) -> InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse]: ...

    @overload
    def on_config_open(
        self,
    ) -> Callable[
        [InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse]],
        InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse],
    ]: ...

    def on_config_open(
        self, handler: Optional[InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse]] = None
    ) -> InvokeHandlerUnion[ConfigFetchInvokeActivity, ConfigInvokeResponse]:
        """Register a config.open activity handler."""

        def decorator(
            func: InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse],
        ) -> InvokeHandler[ConfigFetchInvokeActivity, ConfigInvokeResponse]:
            validate_handler_type(
                self.logger, func, ConfigFetchInvokeActivity, "on_config_open", "ConfigFetchInvokeActivity"
            )
            config = ACTIVITY_ROUTES["config.open"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_config_submit(
        self, handler: InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse]
    ) -> InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse]: ...

    @overload
    def on_config_submit(
        self,
    ) -> Callable[
        [InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse]],
        InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse],
    ]: ...

    def on_config_submit(
        self, handler: Optional[InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse]] = None
    ) -> InvokeHandlerUnion[ConfigSubmitInvokeActivity, ConfigInvokeResponse]:
        """Register a config.submit activity handler."""

        def decorator(
            func: InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse],
        ) -> InvokeHandler[ConfigSubmitInvokeActivity, ConfigInvokeResponse]:
            validate_handler_type(
                self.logger, func, ConfigSubmitInvokeActivity, "on_config_submit", "ConfigSubmitInvokeActivity"
            )
            config = ACTIVITY_ROUTES["config.submit"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_file_consent(
        self, handler: VoidInvokeHandler[FileConsentInvokeActivity]
    ) -> VoidInvokeHandler[FileConsentInvokeActivity]: ...

    @overload
    def on_file_consent(
        self,
    ) -> Callable[[VoidInvokeHandler[FileConsentInvokeActivity]], VoidInvokeHandler[FileConsentInvokeActivity]]: ...

    def on_file_consent(
        self, handler: Optional[VoidInvokeHandler[FileConsentInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[FileConsentInvokeActivity]:
        """Register a file.consent activity handler."""

        def decorator(
            func: VoidInvokeHandler[FileConsentInvokeActivity],
        ) -> VoidInvokeHandler[FileConsentInvokeActivity]:
            validate_handler_type(
                self.logger, func, FileConsentInvokeActivity, "on_file_consent", "FileConsentInvokeActivity"
            )
            config = ACTIVITY_ROUTES["file.consent"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_execute(
        self, handler: VoidInvokeHandler[ExecuteActionInvokeActivity]
    ) -> VoidInvokeHandler[ExecuteActionInvokeActivity]: ...

    @overload
    def on_message_execute(
        self,
    ) -> Callable[[VoidInvokeHandler[ExecuteActionInvokeActivity]], VoidInvokeHandler[ExecuteActionInvokeActivity]]: ...

    def on_message_execute(
        self, handler: Optional[VoidInvokeHandler[ExecuteActionInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[ExecuteActionInvokeActivity]:
        """Register a message.execute activity handler."""

        def decorator(
            func: VoidInvokeHandler[ExecuteActionInvokeActivity],
        ) -> VoidInvokeHandler[ExecuteActionInvokeActivity]:
            validate_handler_type(
                self.logger, func, ExecuteActionInvokeActivity, "on_message_execute", "ExecuteActionInvokeActivity"
            )
            config = ACTIVITY_ROUTES["message.execute"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_query_link(
        self, handler: InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]: ...

    @overload
    def on_message_ext_query_link(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]],
        InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse],
    ]: ...

    def on_message_ext_query_link(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]:
        """Register a message.ext.query-link activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionQueryLinkInvokeActivity,
                "on_message_ext_query_link",
                "MessageExtensionQueryLinkInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.query-link"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_anon_query_link(
        self, handler: InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]: ...

    @overload
    def on_message_ext_anon_query_link(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]],
        InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse],
    ]: ...

    def on_message_ext_anon_query_link(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]:
        """Register a message.ext.anon-query-link activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionAnonQueryLinkInvokeActivity, MessagingExtensionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionAnonQueryLinkInvokeActivity,
                "on_message_ext_anon_query_link",
                "MessageExtensionAnonQueryLinkInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.anon-query-link"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_query(
        self, handler: InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse]: ...

    @overload
    def on_message_ext_query(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse]],
        InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse],
    ]: ...

    def on_message_ext_query(
        self,
        handler: Optional[InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse]] = None,
    ) -> InvokeHandlerUnion[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse]:
        """Register a message.ext.query activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionQueryInvokeActivity, MessagingExtensionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionQueryInvokeActivity,
                "on_message_ext_query",
                "MessageExtensionQueryInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.query"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_select_item(
        self, handler: InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse]: ...

    @overload
    def on_message_ext_select_item(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse]],
        InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse],
    ]: ...

    def on_message_ext_select_item(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse]:
        """Register a message.ext.select-item activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionSelectItemInvokeActivity, MessagingExtensionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionSelectItemInvokeActivity,
                "on_message_ext_select_item",
                "MessageExtensionSelectItemInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.select-item"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_submit(
        self, handler: InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse]: ...

    @overload
    def on_message_ext_submit(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse]],
        InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse],
    ]: ...

    def on_message_ext_submit(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse]:
        """Register a message.ext.submit activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionSubmitActionInvokeActivity, MessagingExtensionActionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionSubmitActionInvokeActivity,
                "on_message_ext_submit",
                "MessageExtensionSubmitActionInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.submit"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_open(
        self, handler: InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse]: ...

    @overload
    def on_message_ext_open(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse]],
        InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse],
    ]: ...

    def on_message_ext_open(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse]:
        """Register a message.ext.open activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionFetchTaskInvokeActivity, MessagingExtensionActionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionFetchTaskInvokeActivity,
                "on_message_ext_open",
                "MessageExtensionFetchTaskInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.open"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_query_settings_url(
        self, handler: InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse]: ...

    @overload
    def on_message_ext_query_settings_url(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse]],
        InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse],
    ]: ...

    def on_message_ext_query_settings_url(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse]:
        """Register a message.ext.query-settings-url activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionQuerySettingUrlInvokeActivity, MessagingExtensionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionQuerySettingUrlInvokeActivity,
                "on_message_ext_query_settings_url",
                "MessageExtensionQuerySettingUrlInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.query-settings-url"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_setting(
        self, handler: InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse]
    ) -> InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse]: ...

    @overload
    def on_message_ext_setting(
        self,
    ) -> Callable[
        [InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse]],
        InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse],
    ]: ...

    def on_message_ext_setting(
        self,
        handler: Optional[
            InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse]
        ] = None,
    ) -> InvokeHandlerUnion[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse]:
        """Register a message.ext.setting activity handler."""

        def decorator(
            func: InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse],
        ) -> InvokeHandler[MessageExtensionSettingInvokeActivity, MessagingExtensionInvokeResponse]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionSettingInvokeActivity,
                "on_message_ext_setting",
                "MessageExtensionSettingInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.setting"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_ext_card_button_clicked(
        self, handler: VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity]
    ) -> VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity]: ...

    @overload
    def on_message_ext_card_button_clicked(
        self,
    ) -> Callable[
        [VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity]],
        VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity],
    ]: ...

    def on_message_ext_card_button_clicked(
        self, handler: Optional[VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[MessageExtensionCardButtonClickedInvokeActivity]:
        """Register a message.ext.card-button-clicked activity handler."""

        def decorator(
            func: VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity],
        ) -> VoidInvokeHandler[MessageExtensionCardButtonClickedInvokeActivity]:
            validate_handler_type(
                self.logger,
                func,
                MessageExtensionCardButtonClickedInvokeActivity,
                "on_message_ext_card_button_clicked",
                "MessageExtensionCardButtonClickedInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.ext.card-button-clicked"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_dialog_open(
        self, handler: InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse]
    ) -> InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse]: ...

    @overload
    def on_dialog_open(
        self,
    ) -> Callable[
        [InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse]],
        InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse],
    ]: ...

    def on_dialog_open(
        self, handler: Optional[InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse]] = None
    ) -> InvokeHandlerUnion[TaskFetchInvokeActivity, TaskModuleInvokeResponse]:
        """Register a dialog.open activity handler."""

        def decorator(
            func: InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse],
        ) -> InvokeHandler[TaskFetchInvokeActivity, TaskModuleInvokeResponse]:
            validate_handler_type(
                self.logger, func, TaskFetchInvokeActivity, "on_dialog_open", "TaskFetchInvokeActivity"
            )
            config = ACTIVITY_ROUTES["dialog.open"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_dialog_submit(
        self, handler: InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse]
    ) -> InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse]: ...

    @overload
    def on_dialog_submit(
        self,
    ) -> Callable[
        [InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse]],
        InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse],
    ]: ...

    def on_dialog_submit(
        self, handler: Optional[InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse]] = None
    ) -> InvokeHandlerUnion[TaskSubmitInvokeActivity, TaskModuleInvokeResponse]:
        """Register a dialog.submit activity handler."""

        def decorator(
            func: InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse],
        ) -> InvokeHandler[TaskSubmitInvokeActivity, TaskModuleInvokeResponse]:
            validate_handler_type(
                self.logger, func, TaskSubmitInvokeActivity, "on_dialog_submit", "TaskSubmitInvokeActivity"
            )
            config = ACTIVITY_ROUTES["dialog.submit"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_tab_open(
        self, handler: InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse]
    ) -> InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse]: ...

    @overload
    def on_tab_open(
        self,
    ) -> Callable[
        [InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse]],
        InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse],
    ]: ...

    def on_tab_open(
        self, handler: Optional[InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse]] = None
    ) -> InvokeHandlerUnion[TabFetchInvokeActivity, TabInvokeResponse]:
        """Register a tab.open activity handler."""

        def decorator(
            func: InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse],
        ) -> InvokeHandler[TabFetchInvokeActivity, TabInvokeResponse]:
            validate_handler_type(self.logger, func, TabFetchInvokeActivity, "on_tab_open", "TabFetchInvokeActivity")
            config = ACTIVITY_ROUTES["tab.open"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_tab_submit(
        self, handler: InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse]
    ) -> InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse]: ...

    @overload
    def on_tab_submit(
        self,
    ) -> Callable[
        [InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse]],
        InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse],
    ]: ...

    def on_tab_submit(
        self, handler: Optional[InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse]] = None
    ) -> InvokeHandlerUnion[TabSubmitInvokeActivity, TabInvokeResponse]:
        """Register a tab.submit activity handler."""

        def decorator(
            func: InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse],
        ) -> InvokeHandler[TabSubmitInvokeActivity, TabInvokeResponse]:
            validate_handler_type(
                self.logger, func, TabSubmitInvokeActivity, "on_tab_submit", "TabSubmitInvokeActivity"
            )
            config = ACTIVITY_ROUTES["tab.submit"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_submit(
        self, handler: VoidInvokeHandler[MessageSubmitActionInvokeActivity]
    ) -> VoidInvokeHandler[MessageSubmitActionInvokeActivity]: ...

    @overload
    def on_message_submit(
        self,
    ) -> Callable[
        [VoidInvokeHandler[MessageSubmitActionInvokeActivity]], VoidInvokeHandler[MessageSubmitActionInvokeActivity]
    ]: ...

    def on_message_submit(
        self, handler: Optional[VoidInvokeHandler[MessageSubmitActionInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[MessageSubmitActionInvokeActivity]:
        """Register a message.submit activity handler."""

        def decorator(
            func: VoidInvokeHandler[MessageSubmitActionInvokeActivity],
        ) -> VoidInvokeHandler[MessageSubmitActionInvokeActivity]:
            validate_handler_type(
                self.logger,
                func,
                MessageSubmitActionInvokeActivity,
                "on_message_submit",
                "MessageSubmitActionInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.submit"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_message_submit_feedback(
        self, handler: VoidInvokeHandler[MessageSubmitActionInvokeActivity]
    ) -> VoidInvokeHandler[MessageSubmitActionInvokeActivity]: ...

    @overload
    def on_message_submit_feedback(
        self,
    ) -> Callable[
        [VoidInvokeHandler[MessageSubmitActionInvokeActivity]], VoidInvokeHandler[MessageSubmitActionInvokeActivity]
    ]: ...

    def on_message_submit_feedback(
        self, handler: Optional[VoidInvokeHandler[MessageSubmitActionInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[MessageSubmitActionInvokeActivity]:
        """Register a message.submit.feedback activity handler."""

        def decorator(
            func: VoidInvokeHandler[MessageSubmitActionInvokeActivity],
        ) -> VoidInvokeHandler[MessageSubmitActionInvokeActivity]:
            validate_handler_type(
                self.logger,
                func,
                MessageSubmitActionInvokeActivity,
                "on_message_submit_feedback",
                "MessageSubmitActionInvokeActivity",
            )
            config = ACTIVITY_ROUTES["message.submit.feedback"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_handoff_action(
        self, handler: VoidInvokeHandler[HandoffActionInvokeActivity]
    ) -> VoidInvokeHandler[HandoffActionInvokeActivity]: ...

    @overload
    def on_handoff_action(
        self,
    ) -> Callable[[VoidInvokeHandler[HandoffActionInvokeActivity]], VoidInvokeHandler[HandoffActionInvokeActivity]]: ...

    def on_handoff_action(
        self, handler: Optional[VoidInvokeHandler[HandoffActionInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[HandoffActionInvokeActivity]:
        """Register a handoff.action activity handler."""

        def decorator(
            func: VoidInvokeHandler[HandoffActionInvokeActivity],
        ) -> VoidInvokeHandler[HandoffActionInvokeActivity]:
            validate_handler_type(
                self.logger, func, HandoffActionInvokeActivity, "on_handoff_action", "HandoffActionInvokeActivity"
            )
            config = ACTIVITY_ROUTES["handoff.action"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_signin_token_exchange(
        self, handler: InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType]
    ) -> InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType]: ...

    @overload
    def on_signin_token_exchange(
        self,
    ) -> Callable[
        [InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType]],
        InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType],
    ]: ...

    def on_signin_token_exchange(
        self,
        handler: Optional[InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType]] = None,
    ) -> InvokeHandlerUnion[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType]:
        """Register a signin.token-exchange activity handler."""

        def decorator(
            func: InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType],
        ) -> InvokeHandler[SignInTokenExchangeInvokeActivity, TokenExchangeInvokeResponseType]:
            validate_handler_type(
                self.logger,
                func,
                SignInTokenExchangeInvokeActivity,
                "on_signin_token_exchange",
                "SignInTokenExchangeInvokeActivity",
            )
            config = ACTIVITY_ROUTES["signin.token-exchange"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_signin_verify_state(
        self, handler: VoidInvokeHandler[SignInVerifyStateInvokeActivity]
    ) -> VoidInvokeHandler[SignInVerifyStateInvokeActivity]: ...

    @overload
    def on_signin_verify_state(
        self,
    ) -> Callable[
        [VoidInvokeHandler[SignInVerifyStateInvokeActivity]], VoidInvokeHandler[SignInVerifyStateInvokeActivity]
    ]: ...

    def on_signin_verify_state(
        self, handler: Optional[VoidInvokeHandler[SignInVerifyStateInvokeActivity]] = None
    ) -> VoidInvokeHandlerUnion[SignInVerifyStateInvokeActivity]:
        """Register a signin.verify-state activity handler."""

        def decorator(
            func: VoidInvokeHandler[SignInVerifyStateInvokeActivity],
        ) -> VoidInvokeHandler[SignInVerifyStateInvokeActivity]:
            validate_handler_type(
                self.logger,
                func,
                SignInVerifyStateInvokeActivity,
                "on_signin_verify_state",
                "SignInVerifyStateInvokeActivity",
            )
            config = ACTIVITY_ROUTES["signin.verify-state"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_card_action(
        self, handler: InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse]
    ) -> InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse]: ...

    @overload
    def on_card_action(
        self,
    ) -> Callable[
        [InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse]],
        InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse],
    ]: ...

    def on_card_action(
        self, handler: Optional[InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse]] = None
    ) -> InvokeHandlerUnion[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse]:
        """Register a card.action activity handler."""

        def decorator(
            func: InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse],
        ) -> InvokeHandler[AdaptiveCardInvokeActivity, AdaptiveCardInvokeResponse]:
            validate_handler_type(
                self.logger, func, AdaptiveCardInvokeActivity, "on_card_action", "AdaptiveCardInvokeActivity"
            )
            config = ACTIVITY_ROUTES["card.action"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_invoke(self, handler: BasicHandler[InvokeActivity]) -> BasicHandler[InvokeActivity]: ...

    @overload
    def on_invoke(self) -> Callable[[BasicHandler[InvokeActivity]], BasicHandler[InvokeActivity]]: ...

    def on_invoke(self, handler: Optional[BasicHandler[InvokeActivity]] = None) -> BasicHandlerUnion[InvokeActivity]:
        """Register a invoke activity handler."""

        def decorator(func: BasicHandler[InvokeActivity]) -> BasicHandler[InvokeActivity]:
            validate_handler_type(self.logger, func, InvokeActivity, "on_invoke", "InvokeActivity")
            config = ACTIVITY_ROUTES["invoke"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_installation_update(
        self, handler: BasicHandler[InstallUpdateActivity]
    ) -> BasicHandler[InstallUpdateActivity]: ...

    @overload
    def on_installation_update(
        self,
    ) -> Callable[[BasicHandler[InstallUpdateActivity]], BasicHandler[InstallUpdateActivity]]: ...

    def on_installation_update(
        self, handler: Optional[BasicHandler[InstallUpdateActivity]] = None
    ) -> BasicHandlerUnion[InstallUpdateActivity]:
        """Register a installation_update activity handler."""

        def decorator(func: BasicHandler[InstallUpdateActivity]) -> BasicHandler[InstallUpdateActivity]:
            validate_handler_type(
                self.logger, func, InstallUpdateActivity, "on_installation_update", "InstallUpdateActivity"
            )
            config = ACTIVITY_ROUTES["installation_update"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_install_add(self, handler: BasicHandler[InstalledActivity]) -> BasicHandler[InstalledActivity]: ...

    @overload
    def on_install_add(self) -> Callable[[BasicHandler[InstalledActivity]], BasicHandler[InstalledActivity]]: ...

    def on_install_add(
        self, handler: Optional[BasicHandler[InstalledActivity]] = None
    ) -> BasicHandlerUnion[InstalledActivity]:
        """Register a install.add activity handler."""

        def decorator(func: BasicHandler[InstalledActivity]) -> BasicHandler[InstalledActivity]:
            validate_handler_type(self.logger, func, InstalledActivity, "on_install_add", "InstalledActivity")
            config = ACTIVITY_ROUTES["install.add"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_install_remove(self, handler: BasicHandler[UninstalledActivity]) -> BasicHandler[UninstalledActivity]: ...

    @overload
    def on_install_remove(self) -> Callable[[BasicHandler[UninstalledActivity]], BasicHandler[UninstalledActivity]]: ...

    def on_install_remove(
        self, handler: Optional[BasicHandler[UninstalledActivity]] = None
    ) -> BasicHandlerUnion[UninstalledActivity]:
        """Register a install.remove activity handler."""

        def decorator(func: BasicHandler[UninstalledActivity]) -> BasicHandler[UninstalledActivity]:
            validate_handler_type(self.logger, func, UninstalledActivity, "on_install_remove", "UninstalledActivity")
            config = ACTIVITY_ROUTES["install.remove"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_typing(self, handler: BasicHandler[TypingActivity]) -> BasicHandler[TypingActivity]: ...

    @overload
    def on_typing(self) -> Callable[[BasicHandler[TypingActivity]], BasicHandler[TypingActivity]]: ...

    def on_typing(self, handler: Optional[BasicHandler[TypingActivity]] = None) -> BasicHandlerUnion[TypingActivity]:
        """Register a typing activity handler."""

        def decorator(func: BasicHandler[TypingActivity]) -> BasicHandler[TypingActivity]:
            validate_handler_type(self.logger, func, TypingActivity, "on_typing", "TypingActivity")
            config = ACTIVITY_ROUTES["typing"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_trace(self, handler: BasicHandler[TraceActivity]) -> BasicHandler[TraceActivity]: ...

    @overload
    def on_trace(self) -> Callable[[BasicHandler[TraceActivity]], BasicHandler[TraceActivity]]: ...

    def on_trace(self, handler: Optional[BasicHandler[TraceActivity]] = None) -> BasicHandlerUnion[TraceActivity]:
        """Register a trace activity handler."""

        def decorator(func: BasicHandler[TraceActivity]) -> BasicHandler[TraceActivity]:
            validate_handler_type(self.logger, func, TraceActivity, "on_trace", "TraceActivity")
            config = ACTIVITY_ROUTES["trace"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_handoff(self, handler: BasicHandler[HandoffActivity]) -> BasicHandler[HandoffActivity]: ...

    @overload
    def on_handoff(self) -> Callable[[BasicHandler[HandoffActivity]], BasicHandler[HandoffActivity]]: ...

    def on_handoff(self, handler: Optional[BasicHandler[HandoffActivity]] = None) -> BasicHandlerUnion[HandoffActivity]:
        """Register a handoff activity handler."""

        def decorator(func: BasicHandler[HandoffActivity]) -> BasicHandler[HandoffActivity]:
            validate_handler_type(self.logger, func, HandoffActivity, "on_handoff", "HandoffActivity")
            config = ACTIVITY_ROUTES["handoff"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    @overload
    def on_activity(self, handler: BasicHandler[Activity]) -> BasicHandler[Activity]: ...

    @overload
    def on_activity(self) -> Callable[[BasicHandler[Activity]], BasicHandler[Activity]]: ...

    def on_activity(self, handler: Optional[BasicHandler[Activity]] = None) -> BasicHandlerUnion[Activity]:
        """Register a activity activity handler."""

        def decorator(func: BasicHandler[Activity]) -> BasicHandler[Activity]:
            validate_handler_type(self.logger, func, Activity, "on_activity", "Activity")
            config = ACTIVITY_ROUTES["activity"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator
