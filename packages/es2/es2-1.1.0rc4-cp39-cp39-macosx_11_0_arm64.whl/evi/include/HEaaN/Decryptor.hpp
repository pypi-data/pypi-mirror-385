////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright (C) 2021-2023 Crypto Lab Inc.                                    //
//                                                                            //
// - This file is part of HEaaN homomorphic encryption library.               //
// - HEaaN cannot be copied and/or distributed without the express permission //
//  of Crypto Lab Inc.                                                        //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "HEaaN/Ciphertext.hpp"
#include "HEaaN/Context.hpp"
#include "HEaaN/HEaaNExport.hpp"
#include "HEaaN/SecretKey.hpp"
#include "Message.hpp"

namespace HEaaN {

class Plaintext;

///
///@brief Abstract entity for decrypting ciphertexts
///
class HEAAN_API Decryptor {
public:
    explicit Decryptor(const Context &context);

    ///@brief Decrypt a slot-encoded ciphertext to message using a secret key
    ///@tparam enc_type
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[out] msg
    template <EncryptionType enc_type>
    void decrypt(const CiphertextBase<enc_type> &ctxt,
                 const SecretKeyBase<enc_type> &sk, Message &msg) const;

    void decrypt(const MSRLWECiphertext &ctxt, const MSRLWESecretKey &sk,
                 std::vector<Message> &msg) const;

    ///@brief Decrypt a coeff-encoded ciphertext to coeff-message using a secret
    /// key
    ///@tparam enc_type
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[out] msg
    template <EncryptionType enc_type>
    void decrypt(const CiphertextBase<enc_type> &ctxt,
                 const SecretKeyBase<enc_type> &sk, CoeffMessage &msg) const;

    ///@brief Decrypt a coeff-encoded ciphertext to coeff-message using a secret
    /// key, with custom scale factor
    ///@tparam enc_type
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[in] scale_factor
    ///@param[out] msg
    template <EncryptionType enc_type>
    void decryptWithScale(const CiphertextBase<enc_type> &ctxt,
                          const SecretKeyBase<enc_type> &sk, CoeffMessage &msg,
                          const Real scale_factor,
                          const bool is_input_ntt = false) const;

    ///@brief Decrypt a coeff-encoded ciphertext to coeff-message using a secret
    /// key, with custom scale factor
    ///@tparam enc_type
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[in] scale_factor
    ///@param[out] msg
    template <EncryptionType enc_type>
    void decryptWithScale(const CiphertextBase<enc_type> &ctxt,
                          const SecretKeyBase<enc_type> &sk,
                          std::vector<CoeffMessage> &msg,
                          const Real scale_factor,
                          const bool is_input_ntt = false) const;
    ///@brief Decrypt a coeff-encoded ciphertext to coeff-message using a secret
    /// key, with custom scale factor. quantize_denominator means the
    /// denominaotr that message is quantized for.
    ///@tparam enc_type
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[in] scale_factor
    ///@param[in] quantize_denominator
    ///@param[out] msg
    template <EncryptionType enc_type>
    void torusDecryptWithScale(const CiphertextBase<enc_type> &ctxt,
                               const SecretKeyBase<enc_type> &sk,
                               CoeffMessage &msg, const Real scale_factor,
                               const Real quantize_denominator) const;

    void decrypt(const MSRLWECiphertext &ctxt, const MSRLWESecretKey &sk,
                 std::vector<CoeffMessage> &msg) const;

    ///@brief Decrypt a slot-encoded ciphertext to plaintext using a secret key
    ///@tparam enc_type
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[out] ptxt
    ///@details It sets the parameters of plaintext automatically. You may use
    /// any constructor of plaintext.
    template <EncryptionType enc_type>
    void decrypt(const CiphertextBase<enc_type> &ctxt,
                 const SecretKeyBase<enc_type> &sk, Plaintext &ptxt) const;

    void decrypt(const MSRLWECiphertext &ctxt, const MSRLWESecretKey &sk,
                 std::vector<Plaintext> &ptxt) const;

    ///@brief Partially decrypt a slot-encoded ciphertext, which is encrypted
    /// with a collectively generated encryption key, to another ciphertext
    /// using a secret key, generated by one of the parties.
    ///@param[in] ctxt
    ///@param[in] sk
    ///@param[out] ctxt_out
    ///@details It sets the parameters of ciphertext automatically. You may
    /// use any constructor of ciphertext.
    /// ctxt should be encrypted with an encryption key which is generated by
    /// collective key generation. If ctxt is encrypted for the set of secret
    /// keys {sk_1 , ... , sk_n} and sk is one of the secret keys, ctxt_out is a
    /// ciphertext encrypted for the set of secret keys {sk_1, ... , sk_n} -
    /// {sk}. The parties of collective key generation may sequentially call
    /// `partialDecrypt` to decrypt the ciphertext. The last party may receive a
    /// ciphertext encrypted with a single sk_i, and call `decrypt` to get the
    /// decrypted plaintext.
    ///@throws RuntimeException if the size of input ciphertext is not 2.
    void partialDecrypt(const Ciphertext &ctxt, const SecretKey &sk,
                        Ciphertext &ctxt_out) const;
    void generalDecryptWithScale(const MSRLWECiphertext &ctxt,
                                 const MSRLWESecretKey &sk, CoeffMessage &msg,
                                 const Real scale_factor,
                                 const bool is_input_ntt) const;
    void generalDecrypt(const MSRLWECiphertext &ctxt, const MSRLWESecretKey &sk,
                        Plaintext &ptxt) const;

private:
    ///@brief A context with which decryptor is associated
    const Context context_;
};

} // namespace HEaaN
