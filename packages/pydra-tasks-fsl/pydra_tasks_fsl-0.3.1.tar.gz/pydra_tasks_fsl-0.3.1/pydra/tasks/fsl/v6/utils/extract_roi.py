import attrs
from fileformats.generic import File
import logging
from pydra.tasks.fsl.v6.nipype_ports.utils.filemanip import fname_presuffix
import os
from pathlib import Path
from pathlib import Path
from pydra.compose import shell
import typing as ty


logger = logging.getLogger(__name__)


def _format_arg(name, value, inputs, argstr):
    if value is None:
        return ""

    if name == "crop_list":
        return " ".join(str(x) for sublist in value for x in sublist)

    return argstr.format(**inputs)


def crop_list_formatter(field, inputs):
    return _format_arg("crop_list", field, inputs, argstr="{crop_list}")


def _gen_filename(name, inputs):
    if name == "roi_file":
        return _list_outputs(
            in_file=inputs["in_file"],
            output_type=inputs["output_type"],
            roi_file=inputs["roi_file"],
        )[name]
    return None


def roi_file_default(inputs):
    return _gen_filename("roi_file", inputs=inputs)


@shell.define(
    xor=[
        [
            "crop_list",
            "t_min",
            "t_size",
            "x_min",
            "x_size",
            "y_min",
            "y_size",
            "z_min",
            "z_size",
        ]
    ]
)
class ExtractROI(shell.Task["ExtractROI.Outputs"]):
    """
    Examples
    -------

    >>> from fileformats.generic import File
    >>> from pathlib import Path
    >>> from pydra.tasks.fsl.v6.utils.extract_roi import ExtractROI

    >>> task = ExtractROI()
    >>> task.in_file = File.mock(anatfile)
    >>> task.roi_file = "bar.nii"
    >>> task.t_min = 0
    >>> task.t_size = 1
    >>> task.cmdline
    'None'


    """

    executable = "fslroi"
    in_file: File = shell.arg(help="input file", argstr="{in_file}", position=1)
    x_min: int | None = shell.arg(help="", argstr="{x_min}", position=3)
    x_size: int | None = shell.arg(help="", argstr="{x_size}", position=4)
    y_min: int | None = shell.arg(help="", argstr="{y_min}", position=5)
    y_size: int | None = shell.arg(help="", argstr="{y_size}", position=6)
    z_min: int | None = shell.arg(help="", argstr="{z_min}", position=7)
    z_size: int | None = shell.arg(help="", argstr="{z_size}", position=8)
    t_min: int | None = shell.arg(help="", argstr="{t_min}", position=9)
    t_size: int | None = shell.arg(help="", argstr="{t_size}", position=10)
    crop_list: list[ty.Any] = shell.arg(
        help="list of two tuples specifying crop options",
        formatter=crop_list_formatter,
        position=3,
    )

    class Outputs(shell.Outputs):
        roi_file: Path = shell.outarg(
            help="output file",
            argstr="{roi_file}",
            path_template='"bar.nii"',
            position=2,
        )


def _gen_fname(
    basename, cwd=None, suffix=None, change_ext=True, ext=None, output_type=None
):
    """Generate a filename based on the given parameters.

    The filename will take the form: cwd/basename<suffix><ext>.
    If change_ext is True, it will use the extensions specified in
    <instance>inputs.output_type.

    Parameters
    ----------
    basename : str
        Filename to base the new filename on.
    cwd : str
        Path to prefix to the new filename. (default is output_dir)
    suffix : str
        Suffix to add to the `basename`.  (defaults is '' )
    change_ext : bool
        Flag to change the filename extension to the FSL output type.
        (default True)

    Returns
    -------
    fname : str
        New filename based on given parameters.

    """

    if basename == "":
        msg = "Unable to generate filename for command %s. " % "fslroi"
        msg += "basename is not set!"
        raise ValueError(msg)
    if cwd is None:
        cwd = output_dir
    if ext is None:
        ext = Info.output_type_to_ext(output_type)
    if change_ext:
        if suffix:
            suffix = f"{suffix}{ext}"
        else:
            suffix = ext
    if suffix is None:
        suffix = ""
    fname = fname_presuffix(basename, suffix=suffix, use_ext=False, newpath=cwd)
    return fname


def _list_outputs(in_file=None, output_type=None, roi_file=None):
    """Create a Bunch which contains all possible files generated
    by running the interface.  Some files are always generated, others
    depending on which ``inputs`` options are set.


    Returns
    -------

    outputs : Bunch object
        Bunch object containing all possible files generated by
        interface object.

        If None, file was not generated
        Else, contains path, filename of generated outputfile

    """
    outputs = {}
    outputs["roi_file"] = roi_file
    if outputs["roi_file"] is attrs.NOTHING:
        outputs["roi_file"] = _gen_fname(
            in_file, suffix="_roi", output_type=output_type
        )
    outputs["roi_file"] = os.path.abspath(outputs["roi_file"])
    return outputs


IFLOGGER = logging.getLogger("nipype.interface")
