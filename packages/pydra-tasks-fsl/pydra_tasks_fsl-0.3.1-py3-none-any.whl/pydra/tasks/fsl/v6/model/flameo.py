import attrs
from fileformats.datascience import TextMatrix
from fileformats.generic import Directory, File
from fileformats.medimage import NiftiGz
from fileformats.vendor.fsl.medimage import Con
from glob import glob
import logging
from pydra.tasks.fsl.v6.nipype_ports.utils.misc import human_order_sorted
import os
from pydra.compose import shell
import typing as ty


logger = logging.getLogger(__name__)


def _list_outputs(inputs=None, stdout=None, stderr=None, output_dir=None):
    inputs = attrs.asdict(inputs)

    outputs = {}
    pth = os.path.join(os.getcwd(), inputs["log_dir"])

    pes = human_order_sorted(glob(os.path.join(pth, "pe[0-9]*.*")))
    assert len(pes) >= 1, "No pe volumes generated by FSL Estimate"
    outputs["pes"] = pes

    res4d = human_order_sorted(glob(os.path.join(pth, "res4d.*")))
    assert len(res4d) == 1, "No residual volume generated by FSL Estimate"
    outputs["res4d"] = res4d[0]

    copes = human_order_sorted(glob(os.path.join(pth, "cope[0-9]*.*")))
    assert len(copes) >= 1, "No cope volumes generated by FSL CEstimate"
    outputs["copes"] = copes

    var_copes = human_order_sorted(glob(os.path.join(pth, "varcope[0-9]*.*")))
    assert len(var_copes) >= 1, "No varcope volumes generated by FSL CEstimate"
    outputs["var_copes"] = var_copes

    zstats = human_order_sorted(glob(os.path.join(pth, "zstat[0-9]*.*")))
    assert len(zstats) >= 1, "No zstat volumes generated by FSL CEstimate"
    outputs["zstats"] = zstats

    if inputs["f_con_file"] is not attrs.NOTHING:
        zfstats = human_order_sorted(glob(os.path.join(pth, "zfstat[0-9]*.*")))
        assert len(zfstats) >= 1, "No zfstat volumes generated by FSL CEstimate"
        outputs["zfstats"] = zfstats

        fstats = human_order_sorted(glob(os.path.join(pth, "fstat[0-9]*.*")))
        assert len(fstats) >= 1, "No fstat volumes generated by FSL CEstimate"
        outputs["fstats"] = fstats

    tstats = human_order_sorted(glob(os.path.join(pth, "tstat[0-9]*.*")))
    assert len(tstats) >= 1, "No tstat volumes generated by FSL CEstimate"
    outputs["tstats"] = tstats

    mrefs = human_order_sorted(
        glob(os.path.join(pth, "mean_random_effects_var[0-9]*.*"))
    )
    assert len(mrefs) >= 1, "No mean random effects volumes generated by FLAMEO"
    outputs["mrefvars"] = mrefs

    tdof = human_order_sorted(glob(os.path.join(pth, "tdof_t[0-9]*.*")))
    assert len(tdof) >= 1, "No T dof volumes generated by FLAMEO"
    outputs["tdof"] = tdof

    weights = human_order_sorted(glob(os.path.join(pth, "weights[0-9]*.*")))
    assert len(weights) >= 1, "No weight volumes generated by FLAMEO"
    outputs["weights"] = weights

    outputs["stats_dir"] = pth

    return outputs


def pes_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("pes")


def res4d_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("res4d")


def copes_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("copes")


def var_copes_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("var_copes")


def zstats_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("zstats")


def tstats_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("tstats")


def zfstats_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("zfstats")


def fstats_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("fstats")


def mrefvars_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("mrefvars")


def tdof_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("tdof")


def weights_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("weights")


def stats_dir_callable(output_dir, inputs, stdout, stderr):
    outputs = _list_outputs(
        output_dir=output_dir, inputs=inputs, stdout=stdout, stderr=stderr
    )
    return outputs.get("stats_dir")


@shell.define
class FLAMEO(shell.Task["FLAMEO.Outputs"]):
    """
    Examples
    -------

    >>> from fileformats.datascience import TextMatrix
    >>> from fileformats.generic import Directory, File
    >>> from fileformats.medimage import NiftiGz
    >>> from fileformats.vendor.fsl.medimage import Con
    >>> from pydra.tasks.fsl.v6.model.flameo import FLAMEO

    >>> task = FLAMEO()
    >>> task.cope_file = NiftiGz.mock("cope.nii.gz")
    >>> task.var_cope_file = File.mock()
    >>> task.dof_var_cope_file = File.mock()
    >>> task.mask_file = File.mock()
    >>> task.design_file = File.mock()
    >>> task.t_con_file = Con.mock("design.con")
    >>> task.f_con_file = File.mock()
    >>> task.cov_split_file = TextMatrix.mock("cov_split.mat")
    >>> task.run_mode = "fe"
    >>> task.log_dir = Directory.mock()
    >>> task.cmdline
    'flameo --copefile=cope.nii.gz --covsplitfile=cov_split.mat --designfile=design.mat --ld=stats --maskfile=mask.nii --runmode=fe --tcontrastsfile=design.con --varcopefile=varcope.nii.gz'


    """

    executable = "flameo"
    cope_file: NiftiGz = shell.arg(
        help="cope regressor data file", argstr="--copefile={cope_file}"
    )
    var_cope_file: File = shell.arg(
        help="varcope weightings data file", argstr="--varcopefile={var_cope_file}"
    )
    dof_var_cope_file: File = shell.arg(
        help="dof data file for varcope data",
        argstr="--dofvarcopefile={dof_var_cope_file}",
    )
    mask_file: File = shell.arg(help="mask file", argstr="--maskfile={mask_file}")
    design_file: File = shell.arg(
        help="design matrix file", argstr="--designfile={design_file}"
    )
    t_con_file: Con = shell.arg(
        help="ascii matrix specifying t-contrasts",
        argstr="--tcontrastsfile={t_con_file}",
    )
    f_con_file: File = shell.arg(
        help="ascii matrix specifying f-contrasts",
        argstr="--fcontrastsfile={f_con_file}",
    )
    cov_split_file: TextMatrix = shell.arg(
        help="ascii matrix specifying the groups the covariance is split into",
        argstr="--covsplitfile={cov_split_file}",
    )
    run_mode: ty.Any = shell.arg(
        help="inference to perform", argstr="--runmode={run_mode}"
    )
    n_jumps: int = shell.arg(
        help="number of jumps made by mcmc", argstr="--njumps={n_jumps}"
    )
    burnin: int = shell.arg(
        help="number of jumps at start of mcmc to be discarded",
        argstr="--burnin={burnin}",
    )
    sample_every: int = shell.arg(
        help="number of jumps for each sample", argstr="--sampleevery={sample_every}"
    )
    fix_mean: bool = shell.arg(help="fix mean for tfit", argstr="--fixmean")
    infer_outliers: bool = shell.arg(
        help="infer outliers - not for fe", argstr="--inferoutliers"
    )
    no_pe_outputs: bool = shell.arg(
        help="do not output pe files", argstr="--nopeoutput"
    )
    sigma_dofs: int = shell.arg(
        help="sigma (in mm) to use for Gaussian smoothing the DOFs in FLAME 2. Default is 1mm, -1 indicates no smoothing",
        argstr="--sigma_dofs={sigma_dofs}",
    )
    outlier_iter: int = shell.arg(
        help="Number of max iterations to use when inferring outliers. Default is 12.",
        argstr="--ioni={outlier_iter}",
    )
    log_dir: Directory = shell.arg(help="", argstr="--ld={log_dir}", default="stats")

    class Outputs(shell.Outputs):
        pes: list[File] | None = shell.out(
            help="Parameter estimates for each column of the design matrix for each voxel",
            callable=pes_callable,
        )
        res4d: list[File] | None = shell.out(
            help="Model fit residual mean-squared error for each time point",
            callable=res4d_callable,
        )
        copes: list[File] | None = shell.out(
            help="Contrast estimates for each contrast", callable=copes_callable
        )
        var_copes: list[File] | None = shell.out(
            help="Variance estimates for each contrast", callable=var_copes_callable
        )
        zstats: list[File] | None = shell.out(
            help="z-stat file for each contrast", callable=zstats_callable
        )
        tstats: list[File] | None = shell.out(
            help="t-stat file for each contrast", callable=tstats_callable
        )
        zfstats: list[File] | None = shell.out(
            help="z stat file for each f contrast", callable=zfstats_callable
        )
        fstats: list[File] | None = shell.out(
            help="f-stat file for each contrast", callable=fstats_callable
        )
        mrefvars: list[File] | None = shell.out(
            help="mean random effect variances for each contrast",
            callable=mrefvars_callable,
        )
        tdof: list[File] | None = shell.out(
            help="temporal dof file for each contrast", callable=tdof_callable
        )
        weights: list[File] | None = shell.out(
            help="weights file for each contrast", callable=weights_callable
        )
        stats_dir: Directory | None = shell.out(
            help="directory storing model estimation output",
            callable=stats_dir_callable,
        )
