from _typeshed import Incomplete
from dask.dataframe import DataFrame as ddDataFrame
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.experimental import enable_iterative_imputer as enable_iterative_imputer
from sklearn.impute import IterativeImputer
from sklearn.mixture import GaussianMixture
from sklearn.neighbors import LocalOutlierFactor
from sklearn.preprocessing import OneHotEncoder, QuantileTransformer
from ydata.dataset import Dataset as Dataset
from ydata.metadata.column import Column
from ydata.metadata.metadata import Metadata as Metadata
from ydata.preprocessors.base import BaseOperator
from ydata.preprocessors.methods.anonymization import AnonymizerConfigurationBuilder
from ydata.preprocessors.methods.encoders import OrdinalEncoder

metrics_logger: Incomplete

def synthlogger_config(verbose): ...

logger: Incomplete

class OneHotEncoderTopN(OneHotEncoder):
    max_categories: Incomplete
    categories: Incomplete
    grouped_categories: Incomplete
    def __init__(self, *, max_categories: int | float = 10) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class MultimodalTransformer(GaussianMixture, TransformerMixin):
    def __init__(self, *, n_components: int = 10) -> None: ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...
    def get_feature_names(self, input_features: Incomplete | None = None) -> None: ...

class ClipTransformer(BaseEstimator, TransformerMixin):
    min_: Incomplete
    max_: Incomplete
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class OneHotEncoderStandard(OneHotEncoder):
    def __init__(self) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class OutlierFiltering(LocalOutlierFactor, TransformerMixin):
    max_frac: Incomplete
    def __init__(self, *, max_frac: float = 0.01) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class ConditionTransformer(BaseEstimator, TransformerMixin):
    threshold: Incomplete
    def __init__(self, threshold: float = 0.95) -> None: ...
    less_condition_: Incomplete
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class QuantileTransformer_(QuantileTransformer):
    def fit(self, X, y: Incomplete | None = None): ...

class DatetimeTimestamp(TransformerMixin):
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X):
        """Convert a datetime to a date a timestamp i.e. number of second
        elapsed since Jan 1970.

        Timestamp in second
        """
    def inverse_transform(self, X):
        """Convert a datetime to a date a timestamp i.e. number of second
        elapsed since Jan 1970.

        Timestamp in second
        """

class BayesianGM(BaseEstimator, TransformerMixin):
    """Bayesian Gaussian Mixture according to CTGAN paper (for ctgan)"""
    weight_treshold: Incomplete
    max_clusters: Incomplete
    def __init__(self, weight_treshold: float = 0.005, max_clusters: int = 10) -> None: ...
    def fit(self, X, y: Incomplete | None = None):
        """'For' loop to fit n models to n continuous columns."""
    def transform(self, X, y: Incomplete | None = None):
        """Transform function that output the new vector [scalar,onehot] where
        the scalar is the normalized value and the onehot is a vector
        representing the mode."""
    def inverse_transform(self, X):
        """From processed to raw."""

class SimpleCategoricalImputer(BaseEstimator, TransformerMixin):
    """Simple Categorical Imputer.

    It simply inputs the most frequent value found in the column.
    It uses the SimpleImputer of Scikitlearn. Here it's using the simple imputer for each column for this reason:
        using the strategy 'most_frequent' would work on the dataframe as a whole but it would takes too much time,
        in this way it goes faster.
    source: https://datascience.stackexchange.com/questions/66034/sklearn-simpleimputer-too-slow-for-categorical-data-represented-as-string-values
    """
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class DateTimeImputer(BaseEstimator, TransformerMixin):
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class DateTimeTransformer(BaseEstimator, TransformerMixin):
    COLS_PER_FEATURE: Incomplete
    dt_features: Incomplete
    month_ohe: Incomplete
    dow_ohe: Incomplete
    def __init__(self, *, dt_features: Incomplete | None = None) -> None: ...
    dt_features_: Incomplete
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...
    def get_feature_names(self, input_features: Incomplete | None = None): ...

class DecimalPlaces(BaseEstimator, TransformerMixin):
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X, y: Incomplete | None = None): ...
    def inverse_transform(self, X): ...

class Gaussianization(BaseOperator):
    name: str
    skewed_threshold: float
    transformer: Incomplete
    column_encoder: Incomplete
    input_types: Incomplete
    output_types: Incomplete
    mask_MV: Incomplete
    extreme_skewness_threshold: float
    min_interval: Incomplete
    counts: Incomplete
    extreme_frequent: Incomplete
    metadata: Incomplete
    def __init__(self, metadata: Metadata) -> None: ...
    @staticmethod
    def get_min_interval(dist): ...
    @staticmethod
    def skewness_ratio(metadata): ...
    @staticmethod
    def transformed_columns(dtypes): ...
    def fit(self, X, input_dtypes): ...
    def fit_transform(self, X, input_dtypes): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class CategoricalEncoder(OrdinalEncoder):
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class CategoricalImputer(BaseEstimator, TransformerMixin):
    int_cols_: Incomplete
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class IdentityTransformer(BaseEstimator, TransformerMixin):
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class IntegerTransformer(BaseEstimator, TransformerMixin):
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class NumericImputer(IterativeImputer):
    def __init__(self) -> None: ...
    def fit(self, X, y: Incomplete | None = None): ...
    def transform(self, X): ...
    def inverse_transform(self, X): ...

class CatEncoder(BaseOperator):
    name: str
    col_per_encoder: Incomplete
    categorical_columns: Incomplete
    encoders: Incomplete
    encoders_cols: Incomplete
    value_counts: Incomplete
    n_encoders: int
    vartypes: Incomplete
    bool_cols_with_mv: Incomplete
    anonymize_cols: Incomplete
    def __init__(self, metadata: Metadata, vartypes: Incomplete | None = None, anonymize_config: Incomplete | None = None, col_per_encoder: int = 10) -> None: ...
    def fit(self, X: Dataset, input_dtypes: dict[str, Column]) -> CatEncoder: ...
    cols: Incomplete
    cols_per_encoder: Incomplete
    cat_cols_per_encoder: Incomplete
    def fit_or_fit_transform(self, X: Dataset, input_dtypes: dict[str, Column], fit_transform: bool = False) -> Dataset | CatEncoder: ...
    def transform(self, X: Dataset) -> Dataset: ...
    def fit_transform(self, X: Dataset, input_dtypes: dict[str, Column]) -> Dataset: ...
    def inverse_transform(self, X: ddDataFrame) -> ddDataFrame: ...

class DateTimeToNumerical(BaseOperator):
    name: str
    input_types: Incomplete
    output_types: Incomplete
    transformed_columns: Incomplete
    sortbykey: Incomplete
    origin_dates: Incomplete
    def __init__(self, sortbykey: Incomplete | None = None) -> None: ...
    def fit(self, X: Dataset, input_dtypes: dict[str, Column]): ...
    def fit_transform(self, X: Dataset, input_dtypes: dict[str, Column]): ...
    def transform(self, X: Dataset): ...
    def inverse_transform(self, X: ddDataFrame) -> ddDataFrame: ...

class AnonymizerEngine(BaseOperator):
    name: str
    def __init__(self, locale: str = None) -> None: ...
    def fit(self, X: Dataset, input_dtypes: dict[str, Column] = None, metadata: Metadata = None): ...
    def fit_transform(self, X: Dataset, metadata: Metadata, config: dict | AnonymizerConfigurationBuilder, input_dtypes: dict[str, Column] = None): ...
    def transform(self, X: Dataset, metadata: Metadata = None, config: dict | AnonymizerConfigurationBuilder | None = None): ...
    def inverse_transform(self, X: ddDataFrame) -> ddDataFrame: ...
    @staticmethod
    def process_config(config: dict) -> dict: ...
    @staticmethod
    def get_anonymized_columns(config: dict | AnonymizerConfigurationBuilder): ...

class NumericalClipping(BaseOperator):
    name: str
    input_types: Incomplete
    output_types: Incomplete
    domain: Incomplete
    og_dtypes: Incomplete
    def __init__(self, metadata: Metadata) -> None: ...
    def fit(self, X: Dataset, input_dtypes: dict[str, Column]): ...
    def fit_transform(self, X: Dataset, input_dtypes: dict[str, Column]): ...
    def transform(self, X: Dataset): ...
    def inverse_transform(self, X: ddDataFrame) -> ddDataFrame: ...

class FloatFormatter(BaseOperator):
    name: str
    input_types: Incomplete
    output_types: Incomplete
    decimals: Incomplete
    ctx: Incomplete
    def __init__(self) -> None: ...
    def fit(self, X: Dataset, input_dtypes: dict[str, Column]): ...
    def fit_transform(self, X: Dataset, input_dtypes: dict[str, Column]): ...
    def transform(self, X: Dataset): ...
    def inverse_transform(self, X: ddDataFrame) -> ddDataFrame: ...
