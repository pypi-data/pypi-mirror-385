#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import gen_thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class YarnJobType(object):
    SPARK = 0
    FLINK = 1

    _VALUES_TO_NAMES = {
        0: "SPARK",
        1: "FLINK",
    }

    _NAMES_TO_VALUES = {
        "SPARK": 0,
        "FLINK": 1,
    }


class JobStatusType(object):
    UNKNOWN = 0
    PENDING = 1
    RUNNING = 2
    SUCCEEDED = 3
    FAILED = 4
    CANCELLED = 5

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "PENDING",
        2: "RUNNING",
        3: "SUCCEEDED",
        4: "FAILED",
        5: "CANCELLED",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "PENDING": 1,
        "RUNNING": 2,
        "SUCCEEDED": 3,
        "FAILED": 4,
        "CANCELLED": 5,
    }


class YarnAutoScalingSpec(object):
    """
    Attributes:
     - minInstances
     - maxInstances
     - scaleUpFactor
     - scaleDownFactor
     - cooldownPeriod

    """
    thrift_spec = None


    def __init__(self, minInstances = None, maxInstances = None, scaleUpFactor = None, scaleDownFactor = None, cooldownPeriod = None,):
        self.minInstances = minInstances
        self.maxInstances = maxInstances
        self.scaleUpFactor = scaleUpFactor
        self.scaleDownFactor = scaleDownFactor
        self.cooldownPeriod = cooldownPeriod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minInstances = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.maxInstances = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.scaleUpFactor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.scaleDownFactor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.cooldownPeriod = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('YarnAutoScalingSpec')
        if self.minInstances is not None:
            oprot.writeFieldBegin('minInstances', TType.I32, 1)
            oprot.writeI32(self.minInstances)
            oprot.writeFieldEnd()
        if self.maxInstances is not None:
            oprot.writeFieldBegin('maxInstances', TType.I32, 2)
            oprot.writeI32(self.maxInstances)
            oprot.writeFieldEnd()
        if self.scaleUpFactor is not None:
            oprot.writeFieldBegin('scaleUpFactor', TType.DOUBLE, 3)
            oprot.writeDouble(self.scaleUpFactor)
            oprot.writeFieldEnd()
        if self.scaleDownFactor is not None:
            oprot.writeFieldBegin('scaleDownFactor', TType.DOUBLE, 4)
            oprot.writeDouble(self.scaleDownFactor)
            oprot.writeFieldEnd()
        if self.cooldownPeriod is not None:
            oprot.writeFieldBegin('cooldownPeriod', TType.STRING, 5)
            oprot.writeString(self.cooldownPeriod.encode('utf-8') if sys.version_info[0] == 2 else self.cooldownPeriod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class YarnClusterSpec(object):
    """
    Attributes:
     - clusterName
     - hostType
     - hostCount
     - masterHostType
     - yarnOfferingVersion
     - networkPolicy
     - autoScalingSpec

    """
    thrift_spec = None


    def __init__(self, clusterName = None, hostType = None, hostCount = None, masterHostType = None, yarnOfferingVersion = None, networkPolicy = None, autoScalingSpec = None,):
        self.clusterName = clusterName
        self.hostType = hostType
        self.hostCount = hostCount
        self.masterHostType = masterHostType
        self.yarnOfferingVersion = yarnOfferingVersion
        self.networkPolicy = networkPolicy
        self.autoScalingSpec = autoScalingSpec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hostType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.hostCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.masterHostType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.yarnOfferingVersion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.networkPolicy = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRUCT:
                    self.autoScalingSpec = YarnAutoScalingSpec()
                    self.autoScalingSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('YarnClusterSpec')
        if self.clusterName is not None:
            oprot.writeFieldBegin('clusterName', TType.STRING, 1)
            oprot.writeString(self.clusterName.encode('utf-8') if sys.version_info[0] == 2 else self.clusterName)
            oprot.writeFieldEnd()
        if self.hostType is not None:
            oprot.writeFieldBegin('hostType', TType.STRING, 2)
            oprot.writeString(self.hostType.encode('utf-8') if sys.version_info[0] == 2 else self.hostType)
            oprot.writeFieldEnd()
        if self.hostCount is not None:
            oprot.writeFieldBegin('hostCount', TType.I32, 3)
            oprot.writeI32(self.hostCount)
            oprot.writeFieldEnd()
        if self.masterHostType is not None:
            oprot.writeFieldBegin('masterHostType', TType.STRING, 4)
            oprot.writeString(self.masterHostType.encode('utf-8') if sys.version_info[0] == 2 else self.masterHostType)
            oprot.writeFieldEnd()
        if self.yarnOfferingVersion is not None:
            oprot.writeFieldBegin('yarnOfferingVersion', TType.STRING, 10)
            oprot.writeString(self.yarnOfferingVersion.encode('utf-8') if sys.version_info[0] == 2 else self.yarnOfferingVersion)
            oprot.writeFieldEnd()
        if self.networkPolicy is not None:
            oprot.writeFieldBegin('networkPolicy', TType.STRING, 20)
            oprot.writeString(self.networkPolicy.encode('utf-8') if sys.version_info[0] == 2 else self.networkPolicy)
            oprot.writeFieldEnd()
        if self.autoScalingSpec is not None:
            oprot.writeFieldBegin('autoScalingSpec', TType.STRUCT, 30)
            self.autoScalingSpec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class YarnJob(object):
    """
    Attributes:
     - appName
     - jobType
     - argsList
     - env
     - conf
     - fileWithContents
     - chrononVersion
     - clusterSpec

    """
    thrift_spec = None


    def __init__(self, appName = None, jobType = None, argsList = None, env = None, conf = None, fileWithContents = None, chrononVersion = None, clusterSpec = None,):
        self.appName = appName
        self.jobType = jobType
        self.argsList = argsList
        self.env = env
        self.conf = conf
        self.fileWithContents = fileWithContents
        self.chrononVersion = chrononVersion
        self.clusterSpec = clusterSpec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.appName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.jobType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.argsList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.argsList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.MAP:
                    self.env = {}
                    (_ktype7, _vtype8, _size6) = iprot.readMapBegin()
                    for _i10 in range(_size6):
                        _key11 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.env[_key11] = _val12
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.MAP:
                    self.conf = {}
                    (_ktype14, _vtype15, _size13) = iprot.readMapBegin()
                    for _i17 in range(_size13):
                        _key18 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.conf[_key18] = _val19
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.MAP:
                    self.fileWithContents = {}
                    (_ktype21, _vtype22, _size20) = iprot.readMapBegin()
                    for _i24 in range(_size20):
                        _key25 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.fileWithContents[_key25] = _val26
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.chrononVersion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.clusterSpec = YarnClusterSpec()
                    self.clusterSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('YarnJob')
        if self.appName is not None:
            oprot.writeFieldBegin('appName', TType.STRING, 1)
            oprot.writeString(self.appName.encode('utf-8') if sys.version_info[0] == 2 else self.appName)
            oprot.writeFieldEnd()
        if self.jobType is not None:
            oprot.writeFieldBegin('jobType', TType.I32, 2)
            oprot.writeI32(self.jobType)
            oprot.writeFieldEnd()
        if self.argsList is not None:
            oprot.writeFieldBegin('argsList', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.argsList))
            for iter27 in self.argsList:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.MAP, 11)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
            for kiter28, viter29 in self.env.items():
                oprot.writeString(kiter28.encode('utf-8') if sys.version_info[0] == 2 else kiter28)
                oprot.writeString(viter29.encode('utf-8') if sys.version_info[0] == 2 else viter29)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.MAP, 12)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.conf))
            for kiter30, viter31 in self.conf.items():
                oprot.writeString(kiter30.encode('utf-8') if sys.version_info[0] == 2 else kiter30)
                oprot.writeString(viter31.encode('utf-8') if sys.version_info[0] == 2 else viter31)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.fileWithContents is not None:
            oprot.writeFieldBegin('fileWithContents', TType.MAP, 13)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fileWithContents))
            for kiter32, viter33 in self.fileWithContents.items():
                oprot.writeString(kiter32.encode('utf-8') if sys.version_info[0] == 2 else kiter32)
                oprot.writeString(viter33.encode('utf-8') if sys.version_info[0] == 2 else viter33)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.chrononVersion is not None:
            oprot.writeFieldBegin('chrononVersion', TType.STRING, 20)
            oprot.writeString(self.chrononVersion.encode('utf-8') if sys.version_info[0] == 2 else self.chrononVersion)
            oprot.writeFieldEnd()
        if self.clusterSpec is not None:
            oprot.writeFieldBegin('clusterSpec', TType.STRUCT, 21)
            self.clusterSpec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KvWrite(object):
    """
    Attributes:
     - key
     - value
     - timestamp

    """
    thrift_spec = None


    def __init__(self, key = None, value = None, timestamp = None,):
        self.key = key
        self.value = value
        self.timestamp = timestamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestamp = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KvWrite')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRING, 3)
            oprot.writeString(self.timestamp.encode('utf-8') if sys.version_info[0] == 2 else self.timestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KvWriteJob(object):
    """
    Attributes:
     - scope
     - dataset
     - table
     - writes

    """
    thrift_spec = None


    def __init__(self, scope = None, dataset = None, table = None, writes = None,):
        self.scope = scope
        self.dataset = dataset
        self.table = table
        self.writes = writes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scope = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataset = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.writes = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = KvWrite()
                        _elem39.read(iprot)
                        self.writes.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KvWriteJob')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRING, 1)
            oprot.writeString(self.scope.encode('utf-8') if sys.version_info[0] == 2 else self.scope)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.STRING, 2)
            oprot.writeString(self.dataset.encode('utf-8') if sys.version_info[0] == 2 else self.dataset)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 3)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.writes is not None:
            oprot.writeFieldBegin('writes', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.writes))
            for iter40 in self.writes:
                iter40.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionListingJob(object):
    """
    Attributes:
     - scope
     - dataset
     - table
     - partitionColumn
     - extraPartitionFilters

    """
    thrift_spec = None


    def __init__(self, scope = None, dataset = None, table = None, partitionColumn = None, extraPartitionFilters = None,):
        self.scope = scope
        self.dataset = dataset
        self.table = table
        self.partitionColumn = partitionColumn
        self.extraPartitionFilters = extraPartitionFilters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scope = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataset = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.extraPartitionFilters = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.extraPartitionFilters.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionListingJob')
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.STRING, 1)
            oprot.writeString(self.scope.encode('utf-8') if sys.version_info[0] == 2 else self.scope)
            oprot.writeFieldEnd()
        if self.dataset is not None:
            oprot.writeFieldBegin('dataset', TType.STRING, 2)
            oprot.writeString(self.dataset.encode('utf-8') if sys.version_info[0] == 2 else self.dataset)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 3)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 4)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        if self.extraPartitionFilters is not None:
            oprot.writeFieldBegin('extraPartitionFilters', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.extraPartitionFilters))
            for iter47 in self.extraPartitionFilters:
                oprot.writeString(iter47.encode('utf-8') if sys.version_info[0] == 2 else iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JobBase(object):
    """
    Attributes:
     - yarnJob
     - kvWriteJob
     - partitionListingJob

    """
    thrift_spec = None


    def __init__(self, yarnJob = None, kvWriteJob = None, partitionListingJob = None,):
        self.yarnJob = yarnJob
        self.kvWriteJob = kvWriteJob
        self.partitionListingJob = partitionListingJob

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.yarnJob = YarnJob()
                    self.yarnJob.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.kvWriteJob = KvWriteJob()
                    self.kvWriteJob.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.partitionListingJob = PartitionListingJob()
                    self.partitionListingJob.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JobBase')
        if self.yarnJob is not None:
            oprot.writeFieldBegin('yarnJob', TType.STRUCT, 1)
            self.yarnJob.write(oprot)
            oprot.writeFieldEnd()
        if self.kvWriteJob is not None:
            oprot.writeFieldBegin('kvWriteJob', TType.STRUCT, 2)
            self.kvWriteJob.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionListingJob is not None:
            oprot.writeFieldBegin('partitionListingJob', TType.STRUCT, 3)
            self.partitionListingJob.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Job(object):
    """
    Attributes:
     - jobInfo
     - jobUnion
     - statusReportInterval
     - maxRetries

    """
    thrift_spec = None


    def __init__(self, jobInfo = None, jobUnion = None, statusReportInterval = None, maxRetries = None,):
        self.jobInfo = jobInfo
        self.jobUnion = jobUnion
        self.statusReportInterval = statusReportInterval
        self.maxRetries = maxRetries

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.jobInfo = JobInfo()
                    self.jobInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.jobUnion = JobBase()
                    self.jobUnion.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.statusReportInterval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxRetries = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Job')
        if self.jobInfo is not None:
            oprot.writeFieldBegin('jobInfo', TType.STRUCT, 1)
            self.jobInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.jobUnion is not None:
            oprot.writeFieldBegin('jobUnion', TType.STRUCT, 2)
            self.jobUnion.write(oprot)
            oprot.writeFieldEnd()
        if self.statusReportInterval is not None:
            oprot.writeFieldBegin('statusReportInterval', TType.I32, 3)
            oprot.writeI32(self.statusReportInterval)
            oprot.writeFieldEnd()
        if self.maxRetries is not None:
            oprot.writeFieldBegin('maxRetries', TType.I32, 4)
            oprot.writeI32(self.maxRetries)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JobListGetRequest(object):
    """
    Attributes:
     - topicId

    """
    thrift_spec = None


    def __init__(self, topicId = None,):
        self.topicId = topicId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topicId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JobListGetRequest')
        if self.topicId is not None:
            oprot.writeFieldBegin('topicId', TType.STRING, 1)
            oprot.writeString(self.topicId.encode('utf-8') if sys.version_info[0] == 2 else self.topicId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JobListResponse(object):
    """
    Attributes:
     - jobsToStart
     - jobsToStop

    """
    thrift_spec = None


    def __init__(self, jobsToStart = None, jobsToStop = None,):
        self.jobsToStart = jobsToStart
        self.jobsToStop = jobsToStop

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobsToStart = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = Job()
                        _elem53.read(iprot)
                        self.jobsToStart.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.jobsToStop = []
                    (_etype57, _size54) = iprot.readListBegin()
                    for _i58 in range(_size54):
                        _elem59 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.jobsToStop.append(_elem59)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JobListResponse')
        if self.jobsToStart is not None:
            oprot.writeFieldBegin('jobsToStart', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.jobsToStart))
            for iter60 in self.jobsToStart:
                iter60.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jobsToStop is not None:
            oprot.writeFieldBegin('jobsToStop', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.jobsToStop))
            for iter61 in self.jobsToStop:
                oprot.writeString(iter61.encode('utf-8') if sys.version_info[0] == 2 else iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ResourceUsage(object):
    """
    Attributes:
     - vcoreSeconds
     - megaByteSeconds
     - cumulativeDiskWriteBytes
     - cumulativeDiskReadBytes

    """
    thrift_spec = None


    def __init__(self, vcoreSeconds = None, megaByteSeconds = None, cumulativeDiskWriteBytes = None, cumulativeDiskReadBytes = None,):
        self.vcoreSeconds = vcoreSeconds
        self.megaByteSeconds = megaByteSeconds
        self.cumulativeDiskWriteBytes = cumulativeDiskWriteBytes
        self.cumulativeDiskReadBytes = cumulativeDiskReadBytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.vcoreSeconds = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.megaByteSeconds = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.cumulativeDiskWriteBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.cumulativeDiskReadBytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResourceUsage')
        if self.vcoreSeconds is not None:
            oprot.writeFieldBegin('vcoreSeconds', TType.I64, 1)
            oprot.writeI64(self.vcoreSeconds)
            oprot.writeFieldEnd()
        if self.megaByteSeconds is not None:
            oprot.writeFieldBegin('megaByteSeconds', TType.I64, 2)
            oprot.writeI64(self.megaByteSeconds)
            oprot.writeFieldEnd()
        if self.cumulativeDiskWriteBytes is not None:
            oprot.writeFieldBegin('cumulativeDiskWriteBytes', TType.I64, 3)
            oprot.writeI64(self.cumulativeDiskWriteBytes)
            oprot.writeFieldEnd()
        if self.cumulativeDiskReadBytes is not None:
            oprot.writeFieldBegin('cumulativeDiskReadBytes', TType.I64, 4)
            oprot.writeI64(self.cumulativeDiskReadBytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class YarnIncrementalJobStatus(object):
    """
    Attributes:
     - statusChangeTimes
     - resourceUsage
     - logsSinceLastPush

    """
    thrift_spec = None


    def __init__(self, statusChangeTimes = None, resourceUsage = None, logsSinceLastPush = None,):
        self.statusChangeTimes = statusChangeTimes
        self.resourceUsage = resourceUsage
        self.logsSinceLastPush = logsSinceLastPush

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.statusChangeTimes = {}
                    (_ktype63, _vtype64, _size62) = iprot.readMapBegin()
                    for _i66 in range(_size62):
                        _key67 = iprot.readI32()
                        _val68 = iprot.readI64()
                        self.statusChangeTimes[_key67] = _val68
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.resourceUsage = ResourceUsage()
                    self.resourceUsage.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.logsSinceLastPush = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.logsSinceLastPush.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('YarnIncrementalJobStatus')
        if self.statusChangeTimes is not None:
            oprot.writeFieldBegin('statusChangeTimes', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.I64, len(self.statusChangeTimes))
            for kiter75, viter76 in self.statusChangeTimes.items():
                oprot.writeI32(kiter75)
                oprot.writeI64(viter76)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.resourceUsage is not None:
            oprot.writeFieldBegin('resourceUsage', TType.STRUCT, 2)
            self.resourceUsage.write(oprot)
            oprot.writeFieldEnd()
        if self.logsSinceLastPush is not None:
            oprot.writeFieldBegin('logsSinceLastPush', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.logsSinceLastPush))
            for iter77 in self.logsSinceLastPush:
                oprot.writeString(iter77.encode('utf-8') if sys.version_info[0] == 2 else iter77)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JobInfo(object):
    """
    Attributes:
     - jobId
     - currentStatus
     - yarnIncrementalStatus

    """
    thrift_spec = None


    def __init__(self, jobId = None, currentStatus = None, yarnIncrementalStatus = None,):
        self.jobId = jobId
        self.currentStatus = currentStatus
        self.yarnIncrementalStatus = yarnIncrementalStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.currentStatus = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.yarnIncrementalStatus = YarnIncrementalJobStatus()
                    self.yarnIncrementalStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JobInfo')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.currentStatus is not None:
            oprot.writeFieldBegin('currentStatus', TType.I32, 2)
            oprot.writeI32(self.currentStatus)
            oprot.writeFieldEnd()
        if self.yarnIncrementalStatus is not None:
            oprot.writeFieldBegin('yarnIncrementalStatus', TType.STRUCT, 10)
            self.yarnIncrementalStatus.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionListingPutRequest(object):
    """
    Attributes:
     - partitions
     - errors

    """
    thrift_spec = None


    def __init__(self, partitions = None, errors = None,):
        self.partitions = partitions
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitions = {}
                    (_ktype79, _vtype80, _size78) = iprot.readMapBegin()
                    for _i82 in range(_size78):
                        _key83 = PartitionListingJob()
                        _key83.read(iprot)
                        _val84 = []
                        (_etype88, _size85) = iprot.readListBegin()
                        for _i89 in range(_size85):
                            _elem90 = gen_thrift.common.ttypes.DateRange()
                            _elem90.read(iprot)
                            _val84.append(_elem90)
                        iprot.readListEnd()
                        self.partitions[_key83] = _val84
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.errors = {}
                    (_ktype92, _vtype93, _size91) = iprot.readMapBegin()
                    for _i95 in range(_size91):
                        _key96 = PartitionListingJob()
                        _key96.read(iprot)
                        _val97 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.errors[_key96] = _val97
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionListingPutRequest')
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.partitions))
            for kiter98, viter99 in self.partitions.items():
                kiter98.write(oprot)
                oprot.writeListBegin(TType.STRUCT, len(viter99))
                for iter100 in viter99:
                    iter100.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRUCT, TType.STRING, len(self.errors))
            for kiter101, viter102 in self.errors.items():
                kiter101.write(oprot)
                oprot.writeString(viter102.encode('utf-8') if sys.version_info[0] == 2 else viter102)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JobInfoPutRequest(object):
    """
    Attributes:
     - jobStatuses

    """
    thrift_spec = None


    def __init__(self, jobStatuses = None,):
        self.jobStatuses = jobStatuses

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobStatuses = []
                    (_etype106, _size103) = iprot.readListBegin()
                    for _i107 in range(_size103):
                        _elem108 = JobInfo()
                        _elem108.read(iprot)
                        self.jobStatuses.append(_elem108)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JobInfoPutRequest')
        if self.jobStatuses is not None:
            oprot.writeFieldBegin('jobStatuses', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.jobStatuses))
            for iter109 in self.jobStatuses:
                iter109.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(YarnAutoScalingSpec)
YarnAutoScalingSpec.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'minInstances', None, None, ),  # 1
    (2, TType.I32, 'maxInstances', None, None, ),  # 2
    (3, TType.DOUBLE, 'scaleUpFactor', None, None, ),  # 3
    (4, TType.DOUBLE, 'scaleDownFactor', None, None, ),  # 4
    (5, TType.STRING, 'cooldownPeriod', 'UTF8', None, ),  # 5
)
all_structs.append(YarnClusterSpec)
YarnClusterSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hostType', 'UTF8', None, ),  # 2
    (3, TType.I32, 'hostCount', None, None, ),  # 3
    (4, TType.STRING, 'masterHostType', 'UTF8', None, ),  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.STRING, 'yarnOfferingVersion', 'UTF8', None, ),  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRING, 'networkPolicy', 'UTF8', None, ),  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    (30, TType.STRUCT, 'autoScalingSpec', [YarnAutoScalingSpec, None], None, ),  # 30
)
all_structs.append(YarnJob)
YarnJob.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'appName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'jobType', None, None, ),  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.LIST, 'argsList', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.MAP, 'env', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 11
    (12, TType.MAP, 'conf', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 12
    (13, TType.MAP, 'fileWithContents', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRING, 'chrononVersion', 'UTF8', None, ),  # 20
    (21, TType.STRUCT, 'clusterSpec', [YarnClusterSpec, None], None, ),  # 21
)
all_structs.append(KvWrite)
KvWrite.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timestamp', 'UTF8', None, ),  # 3
)
all_structs.append(KvWriteJob)
KvWriteJob.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scope', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dataset', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'writes', (TType.STRUCT, [KvWrite, None], False), None, ),  # 4
)
all_structs.append(PartitionListingJob)
PartitionListingJob.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scope', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dataset', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'extraPartitionFilters', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(JobBase)
JobBase.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'yarnJob', [YarnJob, None], None, ),  # 1
    (2, TType.STRUCT, 'kvWriteJob', [KvWriteJob, None], None, ),  # 2
    (3, TType.STRUCT, 'partitionListingJob', [PartitionListingJob, None], None, ),  # 3
)
all_structs.append(Job)
Job.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'jobInfo', [JobInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'jobUnion', [JobBase, None], None, ),  # 2
    (3, TType.I32, 'statusReportInterval', None, None, ),  # 3
    (4, TType.I32, 'maxRetries', None, None, ),  # 4
)
all_structs.append(JobListGetRequest)
JobListGetRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topicId', 'UTF8', None, ),  # 1
)
all_structs.append(JobListResponse)
JobListResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobsToStart', (TType.STRUCT, [Job, None], False), None, ),  # 1
    (2, TType.LIST, 'jobsToStop', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(ResourceUsage)
ResourceUsage.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'vcoreSeconds', None, None, ),  # 1
    (2, TType.I64, 'megaByteSeconds', None, None, ),  # 2
    (3, TType.I64, 'cumulativeDiskWriteBytes', None, None, ),  # 3
    (4, TType.I64, 'cumulativeDiskReadBytes', None, None, ),  # 4
)
all_structs.append(YarnIncrementalJobStatus)
YarnIncrementalJobStatus.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'statusChangeTimes', (TType.I32, None, TType.I64, None, False), None, ),  # 1
    (2, TType.STRUCT, 'resourceUsage', [ResourceUsage, None], None, ),  # 2
    (3, TType.LIST, 'logsSinceLastPush', (TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(JobInfo)
JobInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'currentStatus', None, None, ),  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.STRUCT, 'yarnIncrementalStatus', [YarnIncrementalJobStatus, None], None, ),  # 10
)
all_structs.append(PartitionListingPutRequest)
PartitionListingPutRequest.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'partitions', (TType.STRUCT, [PartitionListingJob, None], TType.LIST, (TType.STRUCT, [gen_thrift.common.ttypes.DateRange, None], False), False), None, ),  # 1
    (2, TType.MAP, 'errors', (TType.STRUCT, [PartitionListingJob, None], TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(JobInfoPutRequest)
JobInfoPutRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobStatuses', (TType.STRUCT, [JobInfo, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
