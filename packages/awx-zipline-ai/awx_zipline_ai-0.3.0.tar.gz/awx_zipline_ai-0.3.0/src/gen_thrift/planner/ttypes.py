#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import gen_thrift.common.ttypes
import gen_thrift.api.ttypes

from thrift.transport import TTransport
all_structs = []


class Mode(object):
    BACKFILL = 0
    DEPLOY = 1
    MONITOR = 2

    _VALUES_TO_NAMES = {
        0: "BACKFILL",
        1: "DEPLOY",
        2: "MONITOR",
    }

    _NAMES_TO_VALUES = {
        "BACKFILL": 0,
        "DEPLOY": 1,
        "MONITOR": 2,
    }


class SourceWithFilterNode(object):
    """
    Attributes:
     - source
     - excludeKeys

    """
    thrift_spec = None


    def __init__(self, source = None, excludeKeys = None,):
        self.source = source
        self.excludeKeys = excludeKeys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.source = gen_thrift.api.ttypes.Source()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.excludeKeys = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = []
                        (_etype10, _size7) = iprot.readListBegin()
                        for _i11 in range(_size7):
                            _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val6.append(_elem12)
                        iprot.readListEnd()
                        self.excludeKeys[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SourceWithFilterNode')
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 2)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.excludeKeys is not None:
            oprot.writeFieldBegin('excludeKeys', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.excludeKeys))
            for kiter13, viter14 in self.excludeKeys.items():
                oprot.writeString(kiter13.encode('utf-8') if sys.version_info[0] == 2 else kiter13)
                oprot.writeListBegin(TType.STRING, len(viter14))
                for iter15 in viter14:
                    oprot.writeString(iter15.encode('utf-8') if sys.version_info[0] == 2 else iter15)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinBootstrapNode(object):
    """
    Attributes:
     - join

    """
    thrift_spec = None


    def __init__(self, join = None,):
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.join = gen_thrift.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinBootstrapNode')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinMergeNode(object):
    """
    Attributes:
     - join
     - productionJoin

    """
    thrift_spec = None


    def __init__(self, join = None, productionJoin = None,):
        self.join = join
        self.productionJoin = productionJoin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.join = gen_thrift.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.productionJoin = gen_thrift.api.ttypes.Join()
                    self.productionJoin.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinMergeNode')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        if self.productionJoin is not None:
            oprot.writeFieldBegin('productionJoin', TType.STRUCT, 3)
            self.productionJoin.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinDerivationNode(object):
    """
    Attributes:
     - join

    """
    thrift_spec = None


    def __init__(self, join = None,):
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.join = gen_thrift.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinDerivationNode')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPartNode(object):
    """
    Attributes:
     - leftSourceTable
     - leftDataModel
     - joinPart
     - skewKeys
     - productionJoinPart

    """
    thrift_spec = None


    def __init__(self, leftSourceTable = None, leftDataModel = None, joinPart = None, skewKeys = None, productionJoinPart = None,):
        self.leftSourceTable = leftSourceTable
        self.leftDataModel = leftDataModel
        self.joinPart = joinPart
        self.skewKeys = skewKeys
        self.productionJoinPart = productionJoinPart

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.leftSourceTable = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.leftDataModel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.joinPart = gen_thrift.api.ttypes.JoinPart()
                    self.joinPart.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.skewKeys = {}
                    (_ktype17, _vtype18, _size16) = iprot.readMapBegin()
                    for _i20 in range(_size16):
                        _key21 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val22 = []
                        (_etype26, _size23) = iprot.readListBegin()
                        for _i27 in range(_size23):
                            _elem28 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val22.append(_elem28)
                        iprot.readListEnd()
                        self.skewKeys[_key21] = _val22
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.productionJoinPart = gen_thrift.api.ttypes.JoinPart()
                    self.productionJoinPart.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPartNode')
        if self.leftSourceTable is not None:
            oprot.writeFieldBegin('leftSourceTable', TType.STRING, 2)
            oprot.writeString(self.leftSourceTable.encode('utf-8') if sys.version_info[0] == 2 else self.leftSourceTable)
            oprot.writeFieldEnd()
        if self.leftDataModel is not None:
            oprot.writeFieldBegin('leftDataModel', TType.I32, 3)
            oprot.writeI32(self.leftDataModel)
            oprot.writeFieldEnd()
        if self.joinPart is not None:
            oprot.writeFieldBegin('joinPart', TType.STRUCT, 4)
            self.joinPart.write(oprot)
            oprot.writeFieldEnd()
        if self.skewKeys is not None:
            oprot.writeFieldBegin('skewKeys', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.skewKeys))
            for kiter29, viter30 in self.skewKeys.items():
                oprot.writeString(kiter29.encode('utf-8') if sys.version_info[0] == 2 else kiter29)
                oprot.writeListBegin(TType.STRING, len(viter30))
                for iter31 in viter30:
                    oprot.writeString(iter31.encode('utf-8') if sys.version_info[0] == 2 else iter31)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.productionJoinPart is not None:
            oprot.writeFieldBegin('productionJoinPart', TType.STRUCT, 6)
            self.productionJoinPart.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LabelJoinNode(object):
    """
    Attributes:
     - join

    """
    thrift_spec = None


    def __init__(self, join = None,):
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.join = gen_thrift.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LabelJoinNode')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MonolithJoinNode(object):
    """
    Attributes:
     - join

    """
    thrift_spec = None


    def __init__(self, join = None,):
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.join = gen_thrift.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MonolithJoinNode')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 1)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StagingQueryNode(object):
    """
    Attributes:
     - stagingQuery

    """
    thrift_spec = None


    def __init__(self, stagingQuery = None,):
        self.stagingQuery = stagingQuery

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.stagingQuery = gen_thrift.api.ttypes.StagingQuery()
                    self.stagingQuery.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StagingQueryNode')
        if self.stagingQuery is not None:
            oprot.writeFieldBegin('stagingQuery', TType.STRUCT, 2)
            self.stagingQuery.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByBackfillNode(object):
    """
    Attributes:
     - groupBy

    """
    thrift_spec = None


    def __init__(self, groupBy = None,):
        self.groupBy = groupBy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.groupBy = gen_thrift.api.ttypes.GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByBackfillNode')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 2)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByUploadNode(object):
    """
    Attributes:
     - groupBy

    """
    thrift_spec = None


    def __init__(self, groupBy = None,):
        self.groupBy = groupBy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.groupBy = gen_thrift.api.ttypes.GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByUploadNode')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 2)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByUploadToKVNode(object):
    """
    Attributes:
     - groupBy

    """
    thrift_spec = None


    def __init__(self, groupBy = None,):
        self.groupBy = groupBy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.groupBy = gen_thrift.api.ttypes.GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByUploadToKVNode')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 2)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByStreamingNode(object):
    """
    Attributes:
     - groupBy

    """
    thrift_spec = None


    def __init__(self, groupBy = None,):
        self.groupBy = groupBy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.groupBy = gen_thrift.api.ttypes.GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByStreamingNode')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 2)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinMetadataUpload(object):
    """
    Attributes:
     - join

    """
    thrift_spec = None


    def __init__(self, join = None,):
        self.join = join

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.join = gen_thrift.api.ttypes.Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinMetadataUpload')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 2)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalSourceSensorNode(object):
    """
    Attributes:
     - metaData
     - sourceTableDependency
     - retryCount
     - retryIntervalMin

    """
    thrift_spec = None


    def __init__(self, metaData = None, sourceTableDependency = None, retryCount = None, retryIntervalMin = None,):
        self.metaData = metaData
        self.sourceTableDependency = sourceTableDependency
        self.retryCount = retryCount
        self.retryIntervalMin = retryIntervalMin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = gen_thrift.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sourceTableDependency = gen_thrift.common.ttypes.TableDependency()
                    self.sourceTableDependency.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.retryCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.retryIntervalMin = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalSourceSensorNode')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.sourceTableDependency is not None:
            oprot.writeFieldBegin('sourceTableDependency', TType.STRUCT, 2)
            self.sourceTableDependency.write(oprot)
            oprot.writeFieldEnd()
        if self.retryCount is not None:
            oprot.writeFieldBegin('retryCount', TType.I64, 3)
            oprot.writeI64(self.retryCount)
            oprot.writeFieldEnd()
        if self.retryIntervalMin is not None:
            oprot.writeFieldBegin('retryIntervalMin', TType.I64, 4)
            oprot.writeI64(self.retryIntervalMin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeContent(object):
    """
    Attributes:
     - sourceWithFilter
     - joinBootstrap
     - joinPart
     - joinMerge
     - joinDerivation
     - labelJoin
     - monolithJoin
     - stagingQuery
     - joinMetadataUpload
     - externalSourceSensor
     - groupByBackfill
     - groupByUpload
     - groupByStreaming
     - groupByUploadToKV
     - stagingQueryBackfill

    """
    thrift_spec = None


    def __init__(self, sourceWithFilter = None, joinBootstrap = None, joinPart = None, joinMerge = None, joinDerivation = None, labelJoin = None, monolithJoin = None, stagingQuery = None, joinMetadataUpload = None, externalSourceSensor = None, groupByBackfill = None, groupByUpload = None, groupByStreaming = None, groupByUploadToKV = None, stagingQueryBackfill = None,):
        self.sourceWithFilter = sourceWithFilter
        self.joinBootstrap = joinBootstrap
        self.joinPart = joinPart
        self.joinMerge = joinMerge
        self.joinDerivation = joinDerivation
        self.labelJoin = labelJoin
        self.monolithJoin = monolithJoin
        self.stagingQuery = stagingQuery
        self.joinMetadataUpload = joinMetadataUpload
        self.externalSourceSensor = externalSourceSensor
        self.groupByBackfill = groupByBackfill
        self.groupByUpload = groupByUpload
        self.groupByStreaming = groupByStreaming
        self.groupByUploadToKV = groupByUploadToKV
        self.stagingQueryBackfill = stagingQueryBackfill

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sourceWithFilter = SourceWithFilterNode()
                    self.sourceWithFilter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.joinBootstrap = JoinBootstrapNode()
                    self.joinBootstrap.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.joinPart = JoinPartNode()
                    self.joinPart.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.joinMerge = JoinMergeNode()
                    self.joinMerge.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.joinDerivation = JoinDerivationNode()
                    self.joinDerivation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.labelJoin = LabelJoinNode()
                    self.labelJoin.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.monolithJoin = MonolithJoinNode()
                    self.monolithJoin.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.stagingQuery = StagingQueryNode()
                    self.stagingQuery.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.joinMetadataUpload = JoinMetadataUpload()
                    self.joinMetadataUpload.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.externalSourceSensor = ExternalSourceSensorNode()
                    self.externalSourceSensor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.STRUCT:
                    self.groupByBackfill = GroupByBackfillNode()
                    self.groupByBackfill.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.STRUCT:
                    self.groupByUpload = GroupByUploadNode()
                    self.groupByUpload.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRUCT:
                    self.groupByStreaming = GroupByStreamingNode()
                    self.groupByStreaming.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 103:
                if ftype == TType.STRUCT:
                    self.groupByUploadToKV = GroupByUploadToKVNode()
                    self.groupByUploadToKV.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.STRUCT:
                    self.stagingQueryBackfill = gen_thrift.api.ttypes.StagingQuery()
                    self.stagingQueryBackfill.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeContent')
        if self.sourceWithFilter is not None:
            oprot.writeFieldBegin('sourceWithFilter', TType.STRUCT, 1)
            self.sourceWithFilter.write(oprot)
            oprot.writeFieldEnd()
        if self.joinBootstrap is not None:
            oprot.writeFieldBegin('joinBootstrap', TType.STRUCT, 2)
            self.joinBootstrap.write(oprot)
            oprot.writeFieldEnd()
        if self.joinPart is not None:
            oprot.writeFieldBegin('joinPart', TType.STRUCT, 3)
            self.joinPart.write(oprot)
            oprot.writeFieldEnd()
        if self.joinMerge is not None:
            oprot.writeFieldBegin('joinMerge', TType.STRUCT, 4)
            self.joinMerge.write(oprot)
            oprot.writeFieldEnd()
        if self.joinDerivation is not None:
            oprot.writeFieldBegin('joinDerivation', TType.STRUCT, 5)
            self.joinDerivation.write(oprot)
            oprot.writeFieldEnd()
        if self.labelJoin is not None:
            oprot.writeFieldBegin('labelJoin', TType.STRUCT, 6)
            self.labelJoin.write(oprot)
            oprot.writeFieldEnd()
        if self.monolithJoin is not None:
            oprot.writeFieldBegin('monolithJoin', TType.STRUCT, 7)
            self.monolithJoin.write(oprot)
            oprot.writeFieldEnd()
        if self.stagingQuery is not None:
            oprot.writeFieldBegin('stagingQuery', TType.STRUCT, 8)
            self.stagingQuery.write(oprot)
            oprot.writeFieldEnd()
        if self.joinMetadataUpload is not None:
            oprot.writeFieldBegin('joinMetadataUpload', TType.STRUCT, 10)
            self.joinMetadataUpload.write(oprot)
            oprot.writeFieldEnd()
        if self.externalSourceSensor is not None:
            oprot.writeFieldBegin('externalSourceSensor', TType.STRUCT, 11)
            self.externalSourceSensor.write(oprot)
            oprot.writeFieldEnd()
        if self.groupByBackfill is not None:
            oprot.writeFieldBegin('groupByBackfill', TType.STRUCT, 100)
            self.groupByBackfill.write(oprot)
            oprot.writeFieldEnd()
        if self.groupByUpload is not None:
            oprot.writeFieldBegin('groupByUpload', TType.STRUCT, 101)
            self.groupByUpload.write(oprot)
            oprot.writeFieldEnd()
        if self.groupByStreaming is not None:
            oprot.writeFieldBegin('groupByStreaming', TType.STRUCT, 102)
            self.groupByStreaming.write(oprot)
            oprot.writeFieldEnd()
        if self.groupByUploadToKV is not None:
            oprot.writeFieldBegin('groupByUploadToKV', TType.STRUCT, 103)
            self.groupByUploadToKV.write(oprot)
            oprot.writeFieldEnd()
        if self.stagingQueryBackfill is not None:
            oprot.writeFieldBegin('stagingQueryBackfill', TType.STRUCT, 200)
            self.stagingQueryBackfill.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Node(object):
    """
    Attributes:
     - metaData
     - content
     - semanticHash
     - isLongRunning

    """
    thrift_spec = None


    def __init__(self, metaData = None, content = None, semanticHash = None, isLongRunning = None,):
        self.metaData = metaData
        self.content = content
        self.semanticHash = semanticHash
        self.isLongRunning = isLongRunning

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = gen_thrift.api.ttypes.MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.content = NodeContent()
                    self.content.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.semanticHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isLongRunning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Node')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRUCT, 2)
            self.content.write(oprot)
            oprot.writeFieldEnd()
        if self.semanticHash is not None:
            oprot.writeFieldBegin('semanticHash', TType.STRING, 3)
            oprot.writeString(self.semanticHash.encode('utf-8') if sys.version_info[0] == 2 else self.semanticHash)
            oprot.writeFieldEnd()
        if self.isLongRunning is not None:
            oprot.writeFieldBegin('isLongRunning', TType.BOOL, 4)
            oprot.writeBool(self.isLongRunning)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfPlan(object):
    """
    Attributes:
     - nodes
     - terminalNodeNames

    """
    thrift_spec = None


    def __init__(self, nodes = None, terminalNodeNames = None,):
        self.nodes = nodes
        self.terminalNodeNames = terminalNodeNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodes = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = Node()
                        _elem37.read(iprot)
                        self.nodes.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.terminalNodeNames = {}
                    (_ktype39, _vtype40, _size38) = iprot.readMapBegin()
                    for _i42 in range(_size38):
                        _key43 = iprot.readI32()
                        _val44 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.terminalNodeNames[_key43] = _val44
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfPlan')
        if self.nodes is not None:
            oprot.writeFieldBegin('nodes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodes))
            for iter45 in self.nodes:
                iter45.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.terminalNodeNames is not None:
            oprot.writeFieldBegin('terminalNodeNames', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.terminalNodeNames))
            for kiter46, viter47 in self.terminalNodeNames.items():
                oprot.writeI32(kiter46)
                oprot.writeString(viter47.encode('utf-8') if sys.version_info[0] == 2 else viter47)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NodeMeta(object):
    """
    Attributes:
     - name
     - hash
     - deps
     - continuous
     - stepSize
     - outputTable
     - retries

    """
    thrift_spec = None


    def __init__(self, name = None, hash = None, deps = None, continuous = None, stepSize = None, outputTable = None, retries = None,):
        self.name = name
        self.hash = hash
        self.deps = deps
        self.continuous = continuous
        self.stepSize = stepSize
        self.outputTable = outputTable
        self.retries = retries

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.deps = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = gen_thrift.common.ttypes.TableDependency()
                        _elem53.read(iprot)
                        self.deps.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.continuous = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.stepSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.outputTable = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.retries = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NodeMeta')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeString(self.hash.encode('utf-8') if sys.version_info[0] == 2 else self.hash)
            oprot.writeFieldEnd()
        if self.deps is not None:
            oprot.writeFieldBegin('deps', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.deps))
            for iter54 in self.deps:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.continuous is not None:
            oprot.writeFieldBegin('continuous', TType.BOOL, 4)
            oprot.writeBool(self.continuous)
            oprot.writeFieldEnd()
        if self.stepSize is not None:
            oprot.writeFieldBegin('stepSize', TType.I32, 5)
            oprot.writeI32(self.stepSize)
            oprot.writeFieldEnd()
        if self.outputTable is not None:
            oprot.writeFieldBegin('outputTable', TType.STRING, 6)
            oprot.writeString(self.outputTable.encode('utf-8') if sys.version_info[0] == 2 else self.outputTable)
            oprot.writeFieldEnd()
        if self.retries is not None:
            oprot.writeFieldBegin('retries', TType.I32, 7)
            oprot.writeI32(self.retries)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class WorkflowPlan(object):
    """
    Attributes:
     - nodes
     - terminalNode

    """
    thrift_spec = None


    def __init__(self, nodes = None, terminalNode = None,):
        self.nodes = nodes
        self.terminalNode = terminalNode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodes = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = NodeMeta()
                        _elem60.read(iprot)
                        self.nodes.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.terminalNode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('WorkflowPlan')
        if self.nodes is not None:
            oprot.writeFieldBegin('nodes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodes))
            for iter61 in self.nodes:
                iter61.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.terminalNode is not None:
            oprot.writeFieldBegin('terminalNode', TType.STRING, 2)
            oprot.writeString(self.terminalNode.encode('utf-8') if sys.version_info[0] == 2 else self.terminalNode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SourceWithFilterNode)
SourceWithFilterNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'source', [gen_thrift.api.ttypes.Source, None], None, ),  # 2
    (3, TType.MAP, 'excludeKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
)
all_structs.append(JoinBootstrapNode)
JoinBootstrapNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'join', [gen_thrift.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(JoinMergeNode)
JoinMergeNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'join', [gen_thrift.api.ttypes.Join, None], None, ),  # 2
    (3, TType.STRUCT, 'productionJoin', [gen_thrift.api.ttypes.Join, None], None, ),  # 3
)
all_structs.append(JoinDerivationNode)
JoinDerivationNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'join', [gen_thrift.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(JoinPartNode)
JoinPartNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRING, 'leftSourceTable', 'UTF8', None, ),  # 2
    (3, TType.I32, 'leftDataModel', None, None, ),  # 3
    (4, TType.STRUCT, 'joinPart', [gen_thrift.api.ttypes.JoinPart, None], None, ),  # 4
    (5, TType.MAP, 'skewKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 5
    (6, TType.STRUCT, 'productionJoinPart', [gen_thrift.api.ttypes.JoinPart, None], None, ),  # 6
)
all_structs.append(LabelJoinNode)
LabelJoinNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'join', [gen_thrift.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(MonolithJoinNode)
MonolithJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'join', [gen_thrift.api.ttypes.Join, None], None, ),  # 1
)
all_structs.append(StagingQueryNode)
StagingQueryNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'stagingQuery', [gen_thrift.api.ttypes.StagingQuery, None], None, ),  # 2
)
all_structs.append(GroupByBackfillNode)
GroupByBackfillNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'groupBy', [gen_thrift.api.ttypes.GroupBy, None], None, ),  # 2
)
all_structs.append(GroupByUploadNode)
GroupByUploadNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'groupBy', [gen_thrift.api.ttypes.GroupBy, None], None, ),  # 2
)
all_structs.append(GroupByUploadToKVNode)
GroupByUploadToKVNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'groupBy', [gen_thrift.api.ttypes.GroupBy, None], None, ),  # 2
)
all_structs.append(GroupByStreamingNode)
GroupByStreamingNode.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'groupBy', [gen_thrift.api.ttypes.GroupBy, None], None, ),  # 2
)
all_structs.append(JoinMetadataUpload)
JoinMetadataUpload.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'join', [gen_thrift.api.ttypes.Join, None], None, ),  # 2
)
all_structs.append(ExternalSourceSensorNode)
ExternalSourceSensorNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [gen_thrift.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'sourceTableDependency', [gen_thrift.common.ttypes.TableDependency, None], None, ),  # 2
    (3, TType.I64, 'retryCount', None, None, ),  # 3
    (4, TType.I64, 'retryIntervalMin', None, None, ),  # 4
)
all_structs.append(NodeContent)
NodeContent.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sourceWithFilter', [SourceWithFilterNode, None], None, ),  # 1
    (2, TType.STRUCT, 'joinBootstrap', [JoinBootstrapNode, None], None, ),  # 2
    (3, TType.STRUCT, 'joinPart', [JoinPartNode, None], None, ),  # 3
    (4, TType.STRUCT, 'joinMerge', [JoinMergeNode, None], None, ),  # 4
    (5, TType.STRUCT, 'joinDerivation', [JoinDerivationNode, None], None, ),  # 5
    (6, TType.STRUCT, 'labelJoin', [LabelJoinNode, None], None, ),  # 6
    (7, TType.STRUCT, 'monolithJoin', [MonolithJoinNode, None], None, ),  # 7
    (8, TType.STRUCT, 'stagingQuery', [StagingQueryNode, None], None, ),  # 8
    None,  # 9
    (10, TType.STRUCT, 'joinMetadataUpload', [JoinMetadataUpload, None], None, ),  # 10
    (11, TType.STRUCT, 'externalSourceSensor', [ExternalSourceSensorNode, None], None, ),  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.STRUCT, 'groupByBackfill', [GroupByBackfillNode, None], None, ),  # 100
    (101, TType.STRUCT, 'groupByUpload', [GroupByUploadNode, None], None, ),  # 101
    (102, TType.STRUCT, 'groupByStreaming', [GroupByStreamingNode, None], None, ),  # 102
    (103, TType.STRUCT, 'groupByUploadToKV', [GroupByUploadToKVNode, None], None, ),  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.STRUCT, 'stagingQueryBackfill', [gen_thrift.api.ttypes.StagingQuery, None], None, ),  # 200
)
all_structs.append(Node)
Node.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [gen_thrift.api.ttypes.MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'content', [NodeContent, None], None, ),  # 2
    (3, TType.STRING, 'semanticHash', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isLongRunning', None, None, ),  # 4
)
all_structs.append(ConfPlan)
ConfPlan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT, [Node, None], False), None, ),  # 1
    (2, TType.MAP, 'terminalNodeNames', (TType.I32, None, TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(NodeMeta)
NodeMeta.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hash', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'deps', (TType.STRUCT, [gen_thrift.common.ttypes.TableDependency, None], False), None, ),  # 3
    (4, TType.BOOL, 'continuous', None, None, ),  # 4
    (5, TType.I32, 'stepSize', None, None, ),  # 5
    (6, TType.STRING, 'outputTable', 'UTF8', None, ),  # 6
    (7, TType.I32, 'retries', None, None, ),  # 7
)
all_structs.append(WorkflowPlan)
WorkflowPlan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT, [NodeMeta, None], False), None, ),  # 1
    (2, TType.STRING, 'terminalNode', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
