# -*- coding: utf-8 -*-
"""–ü—Ä–∏–≤–µ—Ç!\n–í —ç—Ç–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –í—ã —É–≤–∏–¥–∏—Ç–µ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ [–±–æ—Ç–∞ –§–ª–æ—Ä–µ—Å—Ç–∞](https://t.me/postbotflorestbot).\n–ú–æ–∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏: [—Ç—ã–∫](https://taplink.cc/florestone4185)"""

import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext
import os, re
import random, requests
import aiohttp
import asyncio
import zipfile
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service as Service1
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from tqdm.asyncio import tqdm
import numpy
import cv2
from yoloface import face_analysis
from telethon.sync import TelegramClient
from mcstatus import JavaServer, BedrockServer
from g4f.client import Client, AsyncClient
from g4f.Provider import OIVSCodeSer2, Blackbox, Chatai, LegacyLMArena, PollinationsAI, RetryProvider, ARTA, PollinationsImage
from g4f.Provider import Together
from phub import Client as PHClient, Quality
from yt_dlp import YoutubeDL
import torch
from whisper import load_model
from moviepy import VideoFileClip, TextClip, CompositeVideoClip
import librosa
from typing import Dict, Any, Optional, List

class VkUser:
    """–û–û–ü-–º–æ–¥–µ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –í–ö–æ–Ω—Ç–∞–∫—Ç–µ —Å –¥–æ—Å—Ç—É–ø–æ–º –∫–æ –≤—Å–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º."""

    def __init__(self, data: Dict[str, Any]):
        self._data = data

    # üîπ –û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    @property
    def id(self) -> int:
        return self._data.get("id")

    @property
    def first_name(self) -> str:
        return self._data.get("first_name", "")

    @property
    def last_name(self) -> str:
        return self._data.get("last_name", "")

    @property
    def full_name(self) -> str:
        return f"{self.first_name} {self.last_name}".strip()

    @property
    def domain(self) -> str:
        return self._data.get("domain", "")

    @property
    def profile_url(self) -> str:
        return f"https://vk.com/{self.domain or 'id' + str(self.id)}"

    # üîπ –î–µ–º–æ–≥—Ä–∞—Ñ–∏—è
    @property
    def sex(self) -> str:
        return {1: "–∂–µ–Ω—Å–∫–∏–π", 2: "–º—É–∂—Å–∫–æ–π"}.get(self._data.get("sex"), "–Ω–µ —É–∫–∞–∑–∞–Ω")

    @property
    def bdate(self) -> Optional[str]:
        return self._data.get("bdate")

    @property
    def city(self) -> Optional[str]:
        return self._data.get("city", {}).get("title")

    @property
    def country(self) -> Optional[str]:
        return self._data.get("country", {}).get("title")

    @property
    def home_town(self) -> Optional[str]:
        return self._data.get("home_town")

    # üîπ –°–æ—Ü–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    @property
    def followers(self) -> int:
        return self._data.get("followers_count", 0)

    @property
    def status(self) -> str:
        return self._data.get("status", "")

    @property
    def about(self) -> str:
        return self._data.get("about", "")

    @property
    def relation(self) -> str:
        relations = {
            0: "–Ω–µ —É–∫–∞–∑–∞–Ω–æ", 1: "–Ω–µ –∂–µ–Ω–∞—Ç/–Ω–µ –∑–∞–º—É–∂–µ–º", 2: "–µ—Å—Ç—å –¥—Ä—É–≥/–ø–æ–¥—Ä—É–≥–∞",
            3: "–ø–æ–º–æ–ª–≤–ª–µ–Ω(–∞)", 4: "–≤ –±—Ä–∞–∫–µ", 5: "–≤—Å—ë —Å–ª–æ–∂–Ω–æ",
            6: "–≤ –∞–∫—Ç–∏–≤–Ω–æ–º –ø–æ–∏—Å–∫–µ", 7: "–≤–ª—é–±–ª—ë–Ω(–∞)", 8: "–≤ –≥—Ä–∞–∂–¥–∞–Ω—Å–∫–æ–º –±—Ä–∞–∫–µ"
        }
        return relations.get(self._data.get("relation"), "–Ω–µ —É–∫–∞–∑–∞–Ω–æ")

    # üîπ –ö–æ–Ω—Ç–∞–∫—Ç—ã
    @property
    def mobile_phone(self) -> Optional[str]:
        return self._data.get("mobile_phone")

    @property
    def home_phone(self) -> Optional[str]:
        return self._data.get("home_phone")

    @property
    def site(self) -> Optional[str]:
        return self._data.get("site")

    @property
    def photo(self) -> str:
        return self._data.get("photo_max_orig", "")

    # üîπ –û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏ —Ä–∞–±–æ—Ç–∞
    @property
    def university(self) -> str:
        return self._data.get("university_name", "")

    @property
    def faculty(self) -> str:
        return self._data.get("faculty_name", "")

    @property
    def graduation(self) -> Optional[int]:
        return self._data.get("graduation")

    @property
    def schools(self) -> List[Dict[str, Any]]:
        return self._data.get("schools", [])

    @property
    def career(self) -> List[Dict[str, Any]]:
        return self._data.get("career", [])

    @property
    def occupation(self) -> Optional[str]:
        occ = self._data.get("occupation")
        return occ.get("name") if occ else None

    # üîπ –ò–Ω—Ç–µ—Ä–µ—Å—ã
    @property
    def interests(self) -> str:
        return self._data.get("interests", "")

    @property
    def activities(self) -> str:
        return self._data.get("activities", "")

    @property
    def music(self) -> str:
        return self._data.get("music", "")

    @property
    def movies(self) -> str:
        return self._data.get("movies", "")

    @property
    def books(self) -> str:
        return self._data.get("books", "")

    @property
    def games(self) -> str:
        return self._data.get("games", "")

    @property
    def quotes(self) -> str:
        return self._data.get("quotes", "")

    # üîπ –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –∏ –¥–æ–ø. –ø–æ–ª—è
    @property
    def personal(self) -> Dict[str, Any]:
        return self._data.get("personal", {})

    @property
    def connections(self) -> Dict[str, Any]:
        return self._data.get("connections", {})

    # üîπ –£–¥–æ–±–Ω—ã–π –≤—ã–≤–æ–¥
    def summary(self) -> str:
        return (
            f"üë§ {self.full_name}\n"
            f"–ü–æ–ª: {self.sex}\n"
            f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {self.bdate or '‚Äî'}\n"
            f"–ì–æ—Ä–æ–¥: {self.city or '‚Äî'}, –°—Ç—Ä–∞–Ω–∞: {self.country or '‚Äî'}\n"
            f"–°—Ç–∞—Ç—É—Å: {self.status}\n"
            f"–û —Å–µ–±–µ: {self.about}\n"
            f"–ü–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {self.followers}\n"
            f"–ü—Ä–æ—Ñ–∏–ª—å: {self.profile_url}"
        )


class ImageFormat:
    """–í–≤–µ–¥–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: `.jpg`, `.webp`, `.gif`, `.bmp`, `.png`."""
    def __init__(self, format_: str):
        """–í–≤–µ–¥–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: `.jpg`, `.webp`, `.gif`, `.bmp`, `.png`."""
        self.format_ = format_
        if format_ in ['.jpg', '.webp', '.gif', '.bmp', '.png']:
            return
        else:
            raise Exception("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.")

class RTMPServerInit:
    def __init__(self, url: str, key: str, user: str = None, password: str = None):
        """–ù—É, –∫–æ—Ä–æ—á–µ, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∞—Å—Å–∞ –¥–ª—è rtmp_livestream().\nurl: —Å—Å—ã–ª–û–ß–ö–ê –Ω–∞ RTMP. –ü—Ä–∏–º–µ—Ä: `rtmp://live.twitch.tv/app`.\nkey: –∫–ª—é—á –ø–æ—Ç–æ–∫–∞.\nuser: –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ù–∏–≥–¥–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è.\npassword: –ø–∞—Ä–æ–ª—å. –ù–∏–≥–¥–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è."""
        self.key = key
        self.user = user
        self.password = password
        if url.startswith('rtmps://'):
            if not all([user, password]):
                self.url = url
            else:
                self.url = url.replace('rtmps://', f'rtmps://{user}:{password}@')
        else:
            if not all([user, password]):
                self.url = url
            else:
                self.url = url.replace('rtmp://', f'rtmp://{user}:{password}@')

class FaceInfo:
    def __init__(self, info: dict):
        self.info = info
    @property
    def gender(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏."""
        return self.info.get('gender')
    @property
    def race(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–∞—Å—É —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏."""
        return self.info.get('race')
    @property
    def age(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤–æ–∑—Ä–∞—Å—Ç —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏."""
        return self.info.get('age')
    @property
    def emotion(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ–º —ç–º–æ—Ü–∏—é —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏."""
        return self.info.get('emotion')

class KworkOffer:
    def __init__(self, data: dict):
        self._data = data

    # –û—Å–Ω–æ–≤–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø—Ä—è–º–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Å—Ç—ã–º –ø–æ–ª—è–º
    @property
    def id(self) -> int:
        """ID –æ—Ñ—Ñ–µ—Ä–∞"""
        return self._data.get('id', 0)

    @property
    def status(self) -> str:
        """–°—Ç–∞—Ç—É—Å –æ—Ñ—Ñ–µ—Ä–∞"""
        return self._data.get('status', '')

    @property
    def name(self) -> str:
        """–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ñ—Ñ–µ—Ä–∞"""
        return self._data.get('name', '')

    @property
    def description(self) -> str:
        """–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ñ—Ñ–µ—Ä–∞"""
        return self._data.get('description', '')

    @property
    def price_limit(self) -> float:
        """–õ–∏–º–∏—Ç —Ü–µ–Ω—ã"""
        return float(self._data.get('priceLimit', '0.00'))

    @property
    def possible_price_limit(self) -> int:
        """–í–æ–∑–º–æ–∂–Ω—ã–π –ª–∏–º–∏—Ç —Ü–µ–Ω—ã"""
        return self._data.get('possiblePriceLimit', 0)

    @property
    def max_days(self) -> int:
        """–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ –¥–Ω—è—Ö"""
        return int(self._data.get('max_days', '0'))

    @property
    def time_left(self) -> str:
        """–û—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è"""
        return self._data.get('timeLeft', '')

    @property
    def is_active(self) -> bool:
        """–ê–∫—Ç–∏–≤–µ–Ω –ª–∏ –æ—Ñ—Ñ–µ—Ä"""
        return self._data.get('isWantActive', False)

    @property
    def is_archived(self) -> bool:
        """–ó–∞–∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω –ª–∏ –æ—Ñ—Ñ–µ—Ä"""
        return self._data.get('isWantArchive', False)

    # –î–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    @property
    def user_id(self) -> int:
        """ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return self._data.get('user', {}).get('USERID', 0)

    @property
    def username(self) -> str:
        """–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return self._data.get('user', {}).get('username', '')

    @property
    def user_profile_url(self) -> str:
        """URL –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return self._data.get('wantUserGetProfileUrl', '')

    # –î–æ—Å—Ç—É–ø –∫ –¥–∞—Ç–∞–º
    def get_date(self, date_type: str) -> str:
        """
        –ü–æ–ª—É—á–∏—Ç—å –¥–∞—Ç—É –∏–∑ wantDates –ø–æ —Ç–∏–ø—É (create, active, expire, reject)
        """
        return self._data.get('wantDates', {}).get(f'date{date_type.capitalize()}', '')

    @property
    def date_create(self) -> str:
        """–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ñ—Ñ–µ—Ä–∞"""
        return self.get_date('create')

    @property
    def date_active(self) -> str:
        """–î–∞—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –æ—Ñ—Ñ–µ—Ä–∞"""
        return self.get_date('active')

    @property
    def date_expire(self) -> str:
        """–î–∞—Ç–∞ –∏—Å—Ç–µ—á–µ–Ω–∏—è –æ—Ñ—Ñ–µ—Ä–∞"""
        return self.get_date('expire')

    # –î–æ—Å—Ç—É–ø –∫ —Å—Ç–∞—Ç—É—Å—É (altStatusHint)
    @property
    def status_color(self) -> str:
        """–¶–≤–µ—Ç —Å—Ç–∞—Ç—É—Å–∞"""
        return self._data.get('altStatusHint', {}).get('color', '')

    @property
    def status_title(self) -> str:
        """–ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞"""
        return self._data.get('altStatusHint', {}).get('title', '')

    # –î–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º –æ –±–µ–π–¥–∂–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    def get_user_badges(self) -> list[dict]:
        """–°–ø–∏—Å–æ–∫ –±–µ–π–¥–∂–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return self._data.get('user', {}).get('badges', [])

    @property
    def user_badge_titles(self) -> list[str]:
        """–°–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –±–µ–π–¥–∂–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return [badge.get('badge', {}).get('title', '') for badge in self.get_user_badges()]

    # –î–æ—Å—Ç—É–ø –∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ
    @property
    def wants_count(self) -> int:
        """–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ñ—Ñ–µ—Ä–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return int(self._data.get('user', {}).get('data', {}).get('wants_count', '0'))

    @property
    def wants_hired_percent(self) -> int:
        """–ü—Ä–æ—Ü–µ–Ω—Ç –Ω–∞–Ω—è—Ç—ã—Ö –ø–æ –æ—Ñ—Ñ–µ—Ä–∞–º"""
        return int(self._data.get('user', {}).get('data', {}).get('wants_hired_percent', '0'))

    # –î–æ—Å—Ç—É–ø –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º
    @property
    def category_id(self) -> str:
        """ID –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
        return self._data.get('category_id', '')

    @property
    def views(self) -> int:
        """–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤"""
        return int(self._data.get('views_dirty', '0'))

    # –î–æ—Å—Ç—É–ø –∫ –¥–æ—Å—Ç—É–ø–Ω—ã–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—è–º
    @property
    def available_durations(self) -> list[int]:
        """–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è"""
        return self._data.get('availableDurations', [])

    # –ú–µ—Ç–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –µ—Å—Ç—å –ª–∏ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ
    @property
    def has_portfolio(self) -> bool:
        """–î–æ—Å—Ç—É–ø–Ω–æ –ª–∏ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ"""
        return self._data.get('hasPortfolioAvailable', False)
    
    @property
    def url(self) -> str:
        """–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–≤–æ—Ä–∫."""
        return f'https://kwork.ru/projects/{self.id}'
    
    @property
    def dictify(self) -> dict:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ª–æ–≤–∞—Ä—å —Å –∫–≤–æ—Ä–∫–æ–º."""
        return self._data

class Resolution:
    def __init__(self, data: dict):
        self.data = data
    @property
    def height(self) -> int:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—ã—Å–æ—Ç—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."""
        return self.data.get('height')
    @property
    def width(self) -> int:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —à–∏—Ä–∏–Ω—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."""
        return self.data.get('width')
    @property
    def orientation(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é.\n0 - –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è, 1 - –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è, 2 - –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è."""
        if self.width > self.height:
            return 0
        elif self.width < self.height:
            return 1
        else:
            return 2

class YandexImage:
    def __init__(self, image: dict):
        self.image = image
    def get_image(self) -> bytes:
        """–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ –±–∞–π—Ç–∞—Ö."""
        return self.image.get('data')
    def get_url(self) -> str:
        """–°—Å—ã–ª–∫–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."""
        return self.image.get('url')
    def get_resolution(self) -> Resolution:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—ã—Å–æ—Ç—É, —à–∏—Ä–∏–Ω—É –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."""
        image = Image.open(io.BytesIO(self.get_image()))
        resolution = image.size
        return Resolution({"width":resolution[0], 'height':resolution[1]})
    def get_size_mb(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –∫–∞—Ä—Ç–∏–Ω–∫–∏ –≤ MB."""
        bytes_size = len(self.get_image()) 
        mbs = bytes_size / (1024 * 1024)
        return mbs
    def get_format(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."""
        image = Image.open(io.BytesIO(self.get_image()))
        return image.format.lower()
    def download(self, dir: str, name: str = None):
        """–ü—Ä–æ—Å—Ç–æ —Å–∫–∞—á–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ.\ndir: –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è. –ï—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –º—ã —Å–æ–∑–¥–∞–¥–∏–º –µ–µ.\nname: –∏–º—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –û–Ω–æ –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ."""
        if not os.path.exists(dir):
            os.mkdir(dir)
        if name:
            file = open(os.path.join(dir, f'{name}.jpg'), 'wb')
            file.write(self.get_image())
            file.close()
        else:
            r = random.random()
            file = open(os.path.join(dir, f'{r}.jpg'), 'wb')
            file.write(self.get_image())
            file.close()

class InitPornHubAccount:
    """–ö–ª–∞—Å—Å –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ PornHub. –£–¥–æ–±–Ω–æ –∏ –±—ã—Å—Ç—Ä–æ.\nemail: –≤–≤–µ–¥–∏—Ç–µ –ø–æ—á—Ç—É, –∫ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–∏–≤—è–∑–∞–Ω –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç.\npassword: –≤–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –æ—Ç –≤–∞—à–µ–π —É—á—ë—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏."""
    def __init__(self, email: str, password: str):
        """–ö–ª–∞—Å—Å –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ PornHub. –£–¥–æ–±–Ω–æ –∏ –±—ã—Å—Ç—Ä–æ.\nemail: –≤–≤–µ–¥–∏—Ç–µ –ø–æ—á—Ç—É, –∫ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–∏–≤—è–∑–∞–Ω –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç.\npassword: –≤–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –æ—Ç –≤–∞—à–µ–π —É—á—ë—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏."""
        self.email = email
        self.password = password
    @property
    def get_user(self):
        return self.email
    
    @property
    def get_password(self):
        return self.password
        

class Cripto():
    """–ö–ª–∞—Å—Å —Å–æ —Å–ø–∏—Å–∫–æ–º –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ `crypto_price`.\nBITKOIN, USDT, DOGECOIN, HAMSTERCOIN"""
    BITKOIN = 'bitcoin'
    USDT = 'tether'
    DOGE = 'dogecoin'
    HMSTR = 'hamster'

class FunctionsObject:
    def __init__(self, proxies: dict = {}, html_headers: dict = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36', 'Accept-Language': 'ru-RU'}, google_api_key: str = "", gigachat_key: str = "", gigachat_id: str = "", username_mail: str = "", mail_passwd: str = "", speech_to_text_key: str = None, vk_token: str = None, rcon_ip: str = None, rcon_port: int = None, rcon_password: str = None, whisper_model: str = None):
        """–ü—Ä–∏–≤–µ—Ç. –ò–º–µ–Ω–Ω–æ –≤ –¥–∞–Ω–Ω–æ–º –∫–ª–∞—Å—Å–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –í–°–ï —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞. –î–∞–≤–∞–π —è –æ–±—ä—è—Å–Ω—é —Å–º—ã—Å–ª –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤?\nproxies: –ø—Ä–æ–∫—Å–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø—Ä–∏ HTTPS –∑–∞–ø—Ä–æ—Å–∞—Ö –∫ —Å–∞–π—Ç–∞–º.\nhtml_headers: –∑–∞–≥–æ–ª–æ–≤–∫–∏ HTTPS –∑–∞–ø—Ä–æ—Å–æ–≤.\ngoogle_api_key: –∞–ø–∏ –∫–ª—é—á –≥—É–≥–ª–∞. –ü–æ–ª—É—á–∏—Ç—å –µ–≥–æ –º–æ–∂–Ω–æ [–∑–¥–µ—Å—å](https://console.google.com/)\ngigachat_key: –∫–ª—é—á –æ—Ç GigaChat (–ü–ê–û "–°–±–µ—Ä–ë–∞–Ω–∫")\ngigachat_id: ID –æ—Ç GigaChat.\nusername_mail: –≤–∞—à–∞ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –ø–æ—á—Ç–∞.\nmail_passwd: –≤–∞—à API-–∫–ª—é—á –æ—Ç SMTP —Å–µ—Ä–≤–µ—Ä–∞.\nspeech_to_text_key: API –∫–ª—é—á –æ—Ç Google Speech To Text. –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ.\nvk_token: —Ç–æ–∫–µ–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å VK API –æ—Ç –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞.\nrcon_ip: IP –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞, –∫ –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è.\nrcon_port: –ø–æ—Ä—Ç —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è RCON, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, 25575.\nrcon_password: –ø–∞—Ä–æ–ª—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ RCON. –•—Ä–∞–Ω–∏—Ç–µ –µ–≥–æ –≤ –Ω–∞–¥–µ–∂–Ω–æ–º –º–µ—Å—Ç–µ.\nwhisper_model: –º–æ–¥–µ–ª—å –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–æ—Ä–∞ —Ä–µ—á–∏ –∏ —Å–æ–∑–¥–∞–Ω–∏—è —Å—É–±—Ç–∏—Ç—Ä–æ–≤. –ö –ø—Ä–∏–º–µ—Ä—É, tiny."""
        print(f'–û–±—ä–µ–∫—Ç –∫–ª–∞—Å—Å–∞ –±—ã–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.')
        self.proxies = proxies
        self.headers = html_headers
        self.google_key = google_api_key
        self.gigachat_key = gigachat_key
        self.client_id_gigachat = gigachat_id
        self.username_mail = username_mail
        self.mail_passwd = mail_passwd
        self.speech_to_text_key = speech_to_text_key
        self.token_of_vk = vk_token
        self.client_for_gpt = Client()
        self.detector = face_analysis()
        if all([rcon_ip, rcon_port, rcon_password]):
            from mcrcon import MCRcon
            self.rcon_server = MCRcon(rcon_ip, rcon_password, rcon_port)
            print(f'RCON —Å–µ—Ä–≤–µ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É.')
        else:
            self.rcon_server = None
        if whisper_model:
            self.whisper = load_model(whisper_model, torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu'))
        else:
            self.whisper = None
    def generate_image(self, prompt: str) -> bytes:
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å –ø–æ–º–æ—â—å—é GigaChat.\nprompt: –∑–∞–ø—Ä–æ—Å, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –Ω–∞–¥–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."""
        import requests, re, urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        if self.gigachat_key and self.client_id_gigachat:
            url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"

            payload={
                'scope': 'GIGACHAT_API_PERS'
            }
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json',
                'RqUID': f'{self.client_id_gigachat}',
                'Authorization': f'Basic {self.gigachat_key}'
            }

            response = requests.request("POST", url, headers=headers, data=payload, verify=False, proxies=self.proxies)

            access_token = response.json()['access_token']

            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'Authorization': f'Bearer {access_token}'
            }

            data = {
                "model": "GigaChat",
                "messages": [
                    {
                        "role": "system",
                        "content": "Glory to Florest."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "function_call": "auto"
            }

            patterns = r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"

            response = requests.post(
                'https://gigachat.devices.sberbank.ru/api/v1/chat/completions',
                headers=headers,
                json=data,
                verify=False,
                proxies=self.proxies
            )
            json = response.json()
            matches = re.search(patterns, json['choices'][0]['message']['content'])
            if not matches:
                return f"–ù–µ–ª—å–∑—è –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å —á—Ç–æ-–ª–∏–±–æ –ø–æ –¥–∞–Ω–Ω–æ–º—É –∑–∞–ø—Ä–æ—Å—É. –ü—Ä–∏—á–∏–Ω–∞: {json['choices'][0]['message']['content']}"
            else:
                req_img = requests.get(f"https://gigachat.devices.sberbank.ru/api/v1/files/{matches}/content", headers={'Accept': 'application/jpg', "Authorization":f"Bearer {access_token}"}, verify=False, stream=True, proxies=self.proxies)
                return req_img.content
        else:
            return "–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä `gigachat_key` –∏ `gigachat_id` –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π."
    def ai(self, prompt: str, is_voice: bool = False):
        """–ò—Å–ø–æ–ª—å–∑—É–µ–º GigaChat.\nprompt: —á—Ç–æ —Ç–µ–±–µ –Ω—É–∂–Ω–æ –æ—Ç –Ω–µ–π—Ä–æ—Å–µ—Ç–∫–∏.\nis_voice: –∑–∞–ø–∏—Å–∞—Ç—å-–ª–∏ –Ω–∞–º –≥–æ–ª–æ—Å–æ–≤—É—Ö—É?"""
        import requests, json, gtts, io
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        if self.gigachat_key and self.client_id_gigachat:
            if not is_voice:
                url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"

                payload={
                    'scope': 'GIGACHAT_API_PERS'
                }
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Accept': 'application/json',
                    'RqUID': f'{self.client_id_gigachat}',
                    'Authorization': f'Basic {self.gigachat_key}'
                }

                response = requests.request("POST", url, headers=headers, data=payload, verify=False, proxies=self.proxies)

                access_token = response.json()['access_token']

                url1 = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions"

                payload1 = json.dumps({
                    "model": "GigaChat",
                    "messages": [
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ],
                    "stream": False,
                    "repetition_penalty": 1
                })
                headers1 = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': f'Bearer {access_token}'
                }

                response1 = requests.request("POST", url1, headers=headers1, data=payload1, verify=False, proxies=self.proxies)
                return response1.json()
            else:
                url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"

                payload={
                    'scope': 'GIGACHAT_API_PERS'
                }
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Accept': 'application/json',
                    'RqUID': f'{self.client_id_gigachat}',
                    'Authorization': f'Basic {self.gigachat_key}'
                }

                response = requests.request("POST", url, headers=headers, data=payload, verify=False, proxies=self.proxies)

                access_token = response.json()['access_token']

                url1 = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions"

                payload1 = json.dumps({
                    "model": "GigaChat",
                    "messages": [
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ],
                    "stream": False,
                    "repetition_penalty": 1
                })
                headers1 = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': f'Bearer {access_token}'
                }

                response1 = requests.request("POST", url1, headers=headers1, data=payload1, verify=False, proxies=self.proxies)
                buffer = io.BytesIO()
                gtts.gTTS(response1.json()['choices'][0]['message']['content'], lang='ru', lang_check=False).write_to_fp(buffer)
                return buffer.getvalue()
        else:
            return "–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä `gigachat_key` –∏ `gigachat_id` –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π."
        
    def deanon(self, ip: str) -> list:
        """–î–µ–∞–Ω–æ–Ω—á–∏–∫ –ø–æ IP.\n–í—ã —Å–∞–º–∏ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ –Ω–∞ —Å–µ–±—è –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.\nip: –¥–∞–π –∞–π–ø–∏, —Ç–≤–∞—Ä—é–∫–∞."""
        import requests
        r = requests.get(f'http://ip-api.com/json/{ip}?lang=ru', proxies=self.proxies, headers=self.headers).json()
        results = []
        for key, value in r.items():
            results.append(f'{key.title()}: {value}')
        return results
    def download_video(self, url: str):
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∫–∞—á–∞–µ—Ç –≤–∏–¥–µ–æ —Å YouTube —Å –ø–æ–º–æ—â—å—é URL.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ."""
        from pytubefix import YouTube
        from tqdm import tqdm as sync_tqdm

        yt_obj = YouTube(url, proxies=self.proxies)

        if yt_obj.age_restricted:
            return '–ù–∞ –≤–∏–¥–µ–æ –Ω–∞–ª–æ–∂–µ–Ω—ã –≤–æ–∑—Ä–∞—Å—Ç–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è.'    
        else:
            import io
            buffer = io.BytesIO()
            stream = yt_obj.streams.get_lowest_resolution()
            pbar = sync_tqdm(total=stream.filesize, desc=f'–°–∫–∞—á–∏–≤–∞–Ω–∏–µ "{yt_obj.title}"..', unit='B', unit_scale=True, dynamic_ncols=True)
            def progress(stream, chunk, bytes_remaining):
                pbar.update(len(chunk)) # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
            yt_obj.register_on_progress_callback(progress)
            stream.stream_to_buffer(buffer)
            pbar.close()
            return buffer.getvalue()
    def search_videos(self, query: str):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–∏–¥–µ–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É –∏ –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –µ–≥–æ –∑–∞–∫–∞—á–∏–≤–∞–Ω–∏—è.\nquery: –∑–∞–ø—Ä–æ—Å, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –Ω–∞–¥–æ –∏—Å–∫–∞—Ç—å –≤–∏–¥–µ–æ."""
        from pytubefix import Search
        from tqdm import tqdm as sync_tqdm

        search = Search(query, proxies=self.proxies)
        videos = search.videos

        if len(videos) == 0:
            return '–í–∏–¥–µ–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.'
        else:
            video = videos[0]
            if video.age_restricted:
                return '–ù–∞ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –Ω–∞—à–ª–∏ –ø–µ—Ä–≤—ã–º –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤–æ–∑—Ä–∞—Å—Ç–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ. –ï–≥–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.'  
            else:
                import io
                buffer = io.BytesIO()
                stream = video.streams.get_lowest_resolution()
                pbar = sync_tqdm(total=stream.filesize, desc=f'–°–∫–∞—á–∏–≤–∞–Ω–∏–µ "{video.title}"..', unit='B', unit_scale=True, dynamic_ncols=True)
                def progress(stream, chunk, bytes_remaining):
                    pbar.update(len(chunk)) # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
                video.register_on_progress_callback(progress)
                stream.stream_to_buffer(buffer)
                pbar.close()
                return buffer.getvalue()
    def create_demotivator(self, top_text: str, bottom_text: str, photo: bytes, font: str):
        """–°–æ–∑–¥–∞–π—Ç–µ –¥–µ–º–æ—Ç–∏–≤–∞—Ç–æ—Ä —Å –ø–æ–º–æ—â—å—é –¥–∞–Ω–Ω–æ–π —Ñ–∏—á–∏!\ntop_text: –≤–µ—Ä—Ö–Ω–∏–π —Ç–µ–∫—Å—Ç.\nbottom_text: –Ω–∏–∂–Ω–∏–π —Ç–µ–∫—Å—Ç.\nphoto: –≤–∞—à–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –≤ bytes.\nfont: –≤–∞—à —à—Ä–∏—Ñ—Ç. –ü—Ä–∏–º–µ—Ä: `times.ttf`."""
        import io
        image = io.BytesIO(photo)
        from PIL import Image, ImageOps, ImageDraw, ImageFont
        img = Image.new('RGB', (1280, 1024), color='black')
        img_border = Image.new('RGB', (1060, 720), color='#000000')
        border = ImageOps.expand(img_border, border=2, fill='#ffffff')
        user_img = Image.open(image).convert("RGBA").resize((1050, 710))
        (width, height) = user_img.size
        img.paste(border, (111, 96))
        img.paste(user_img, (118, 103))
        drawer = ImageDraw.Draw(img)
        font_1 = ImageFont.truetype(font=font, size=80, encoding='UTF-8')
        text_width = font_1.getlength(top_text)

        while text_width >= (width + 250) - 20:
            font_1 = ImageFont.truetype(font=font, size=80, encoding='UTF-8')
            text_width = font_1.getlength(top_text)
            top_size -= 1

        font_2 = ImageFont.truetype(font=font, size=60, encoding='UTF-8')
        text_width = font_2.getlength(bottom_text)

        while text_width >= (width + 250) - 20:
            font_2 = ImageFont.truetype(font=font, size=60, encoding='UTF-8')
            text_width = font_2.getlength(bottom_text)
            bottom_size -= 1

        size_1 = drawer.textlength(top_text, font=font_1)
        size_2 = drawer.textlength(bottom_text, font=font_2)

        drawer.text(((1280 - size_1) / 2, 840), top_text, fill='white', font=font_1)
        drawer.text(((1280 - size_2) / 2, 930), bottom_text, fill='white', font=font_2)

        result_here = io.BytesIO()

        img.save(result_here, 'JPEG')
    
        del drawer

        return result_here.getvalue()
    def photo_make_black(self, photo: bytes):
        """–°–¥–µ–ª–∞—Ç—å —Ñ–æ—Ç–æ —á–µ—Ä–Ω–æ-–±–µ–ª—ã–º.\nphoto: —Ñ–æ—Ç–æ –≤ `bytes`."""
        import io
        from PIL import Image
        your_photo = io.BytesIO(photo)

        image = Image.open(your_photo)
        new_image = image.convert('L')
        buffer = io.BytesIO()
        new_image.save(buffer, 'JPEG')
        return buffer.getvalue()
    def check_weather(self, city):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–≥–æ–¥—É –≤ –∫–∞–∫–æ–º-–ª–∏–±–æ –≥–æ—Ä–æ–¥–µ.\ncity: –≥–æ—Ä–æ–¥, –∏–ª–∏ –µ–≥–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è `{"lat":..., "lon":...}`.\n–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π OpenMeteo API."""
        import requests
        if isinstance(city, str):
            try:
                d = requests.get(f'https://geocoding-api.open-meteo.com/v1/search?name={city}', proxies=self.proxies, headers=self.headers).json()
                lot = d["results"][0]["latitude"]
                lat = d['results'][0]['longitude']
                req = requests.get(f'https://api.open-meteo.com/v1/forecast?latitude={lot}&longitude={lat}&current_weather=true', headers=self.headers, proxies=self.proxies)
                if req.status_code != 200:
                    return None
                else:
                    data = req.json()
                    temperature = data['current_weather']['temperature']
                    title = {0: "–Ø—Å–Ω–æ", 1: "–ß–∞—Å—Ç–∏—á–Ω–æ –æ–±–ª–∞—á–Ω–æ", 3: "–û–±–ª–∞—á–Ω–æ", 61: "–î–æ–∂–¥—å"}
                    weather = title.get(data['current_weather']['weathercode'], '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
                    wind_dir = '–°–µ–≤–µ—Ä' if 0 <= (d := data['current_weather']['winddirection']) < 45 or 315 <= d <= 360 else '–í–æ—Å—Ç–æ–∫' if 45 <= d < 135 else '–Æ–≥' if 135 <= d < 225 else '–ó–∞–ø–∞–¥'
                    time1 = data['current_weather']['time']
                    wind = data['current_weather']['windspeed']
                    return {'temp':temperature, 'weather':weather, 'weather_code':data['current_weather']['weathercode'], 'wind_direction':wind_dir, 'time_of_data':time1, 'wind_speed':wind}
            except:
                return None
        elif isinstance(city, dict):
            try:
                try:
                    lat = city["lat"]
                    lon = city["lon"]
                    req = requests.get(f'https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current_weather=true', headers=self.headers, proxies=self.proxies)
                except KeyError:
                    return f'–ù—É–∂–Ω–æ —Å–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ª–æ–≤–∞—Ä—å, —Å–æ–≥–ª–∞—Å–Ω–æ –æ–±—Ä–∞–∑—Ü—É, —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏.'
                
                data = req.json()
                temperature = data['current_weather']['temperature']
                title = {0: "–Ø—Å–Ω–æ", 1: "–ß–∞—Å—Ç–∏—á–Ω–æ –æ–±–ª–∞—á–Ω–æ", 3: "–û–±–ª–∞—á–Ω–æ", 61: "–î–æ–∂–¥—å"}
                weather = title.get(data['current_weather']['weathercode'], '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
                wind_dir = '–°–µ–≤–µ—Ä' if 0 <= (d := data['current_weather']['winddirection']) < 45 or 315 <= d <= 360 else '–í–æ—Å—Ç–æ–∫' if 45 <= d < 135 else '–Æ–≥' if 135 <= d < 225 else '–ó–∞–ø–∞–¥'
                time1 = data['current_weather']['time']
                wind = data['current_weather']['windspeed']
                return {'temp':temperature, 'weather':weather, 'weather_code':data['current_weather']['weathercode'], 'wind_direction':wind_dir, 'time_of_data':time1, 'wind_speed':wind}
            except:
                return None
        else:
            return '–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö: `str` –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è –≥–æ—Ä–æ–¥–∞ –∏ `dict` –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ–≤.'
    def create_qr(self, content: str):
        """–°–æ–∑–¥–∞—Ç—å QR –∫–æ–¥.\ncontent: —á—Ç–æ –±—É–¥–µ—Ç –Ω–µ—Å—Ç–∏ –≤ —Å–µ–±–µ qr. —Å—Å—ã–ª–∫–∞, —Ç–µ–∫—Å—Ç..."""
        import qrcode
        import io
        
        buffer = io.BytesIO()
        qr = qrcode.make(content)
        qr.save(buffer, scale=10)
        return buffer.getvalue()
    def get_charts(self):
        """–£–∑–Ω–∞—Ç—å —á–∞—Ä—Ç—ã –Ø.–ú—É–∑—ã–∫–∏."""
        import requests
        headers = {
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7,fi;q=0.6,nb;q=0.5,is;q=0.4,pt;q=0.3,ro;q=0.2,it;q=0.1,de;q=0.1',
            'Connection': 'keep-alive',
            'Referer': 'https://music.yandex.ru/chart',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-origin',
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
            'X-Current-UID': '403036463',
            'X-Requested-With': 'XMLHttpRequest',
            'X-Retpath-Y': 'https://music.yandex.ru/chart',
            'sec-ch-ua': '"Not?A_Brand";v="8", "Chromium";v="108", "Google Chrome";v="108"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Linux"',
        }

        params = {
            'what': 'chart',
            'lang': 'ru',
            'external-domain': 'music.yandex.ru',
            'overembed': 'false',
            'ncrnd': '0.23800355071570123',
        }
        result = []
        response = requests.get('https://music.yandex.ru/handlers/main.jsx', params=params, headers=headers, proxies=self.proxies)
        chart = response.json()['chartPositions']
        for track in chart[:10]:
            position = track['track']['chart']['position']
            title = track['track']['title']
            author = track['track']['artists'][0]['name']
            result.append(f"‚Ññ{position}: {author} - {title}")
        return f'–ß–∞—Ä—Ç—ã –Ø–Ω–¥–µ–∫—Å –ú—É–∑—ã–∫–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Çüî•\nü•á{result[0]}\nü•à{result[1]}\nü•â{result[2]}\n{result[3]}\n{result[4]}\n{result[5]}\n{result[6]}\n{result[7]}\n{result[8]}\n{result[9]}'
    def generate_password(self, symbols: int = 15):
        """–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä–æ–ª—å.\nsymbols: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ –≤ –ø–∞—Ä–æ–ª–µ."""
        import string
        import random

        symbols_ascii = list(string.ascii_letters + string.digits)

        random.shuffle(symbols_ascii)

        return ''.join(symbols_ascii[:symbols])
    def text_to_speech(self, text: str, lang: str = 'ru'):
        """–ò–∑ —Ç–µ–∫—Å—Ç–∞ –≤ —Ä–µ—á—å –Ω–∞ Python.\ntext: —Ç–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∫–∏.\nlang: —è–∑—ã–∫ –¥–ª—è –æ–∑–≤—É—á–∫–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, **—Ä—É—Å—Å–∫–∏–π**."""
        import gtts
        import io

        buffer = io.BytesIO()
        engine = gtts.gTTS(text, lang=lang)
        engine.write_to_fp(buffer)
        return buffer.getvalue()
    def information_about_yt_channel(self, url: str):
        """–£–∑–Ω–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ YouTube –∫–∞–Ω–∞–ª–µ –Ω–∞ Python.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª."""
        if not self.google_key:
            return '–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä `google_key` –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–ª–∞—Å—Å–∞.'
        else:
            import requests
            if '/channel/' in url:
                channel_id = url.split('/channel/')[-1].split('?')[0]
                params = {
                    "part": "snippet,statistics",
                    "id": channel_id,
                    "key": self.google_key
                }
            else:
                username = url.split('/@')[-1].split('?')[0]
                params = {
                    "part": "snippet,statistics",
                    "forHandle": f"@{username}",
                    "key": self.google_key
                }
            request = requests.get('https://www.googleapis.com/youtube/v3/channels', proxies=self.proxies, headers=self.headers, params=params)
            response = request.json()
            return response
    def crypto_price(self, crypto: str, currency: str = 'rub'):
        """–¶–µ–Ω–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç.\ncrypto: –∫—Ä–∏–ø—Ç–∞, –∫–æ—Ç–æ—Ä—É—é –Ω—É–∂–Ω–æ —É–∑–Ω–∞—Ç—å. –î–ª—è —ç—Ç–æ–≥–æ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞–º–∏ –∏–∑ –∫–ª–∞—Å—Å–∞ `Cripto`.\ncurrency: –≤–∞–ª—é—Ç–∞, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç. –î–æ—Å—Ç—É–ø–Ω–æ: `rub`, `usd` –∏ `eur`."""
        import requests
        r = requests.get('https://api.coingecko.com/api/v3/simple/price', params={"ids":crypto, 'vs_currencies':currency}, proxies=self.proxies, headers=self.headers).json()
        if r == {}:
            return "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –≤–∞–ª—é—Ç–∞, –∏–ª–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞."
        else:
            try:
                return r[crypto][currency]
            except:
                return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –í–æ–∑–º–æ–∂–Ω–æ, –±—ã–ª–∏ –ø—Ä–µ–æ–¥–æ–ª–µ–Ω—ã –ª–∏–º–∏—Ç—ã API."
    def password_check(self, nickname: str) -> int:
        """–ü–æ–∏—Å–∫ —Å–ª–∏–≤–æ–≤ –ø–∞—Ä–æ–ª–µ–π –ø–æ –Ω–∏–∫—É.\nnickname: –Ω–∏–∫ –¥–ª—è –ø–æ–∏—Å–∫–∞.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `int`."""
        import requests
        req = requests.get(f'https://api.proxynova.com/comb?query={nickname}&start=0&limit=15', headers=self.headers, proxies=self.proxies)
        if req.status_code == 200:
            return req.json()['count']
    def generate_nitro(self, count: int):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∏—Ç—Ä–æ.\n(–ö–ª—é—á–∏ –º–æ–≥—É—Ç –Ω–µ —Ä–∞–±–æ—Ç–∞—Ç—å, –º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å—Å—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫)\ncount: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—é—á–µ–π."""
        import random, string
        a = 0
        results = []
        while a < count:
            characters = string.ascii_uppercase + string.digits
            random_code = ''.join(random.choice(characters) for _ in range(15))
            formatted_code = '-'.join(random_code[i:i+4] for i in range(0, 15, 4))
            results.append(formatted_code)
        del a
        return results
    def fake_human(self):
        """–§–µ–π–∫–æ–≤—ã–π –≥—Ä–∞–∂–¥–∞–Ω–∏–Ω –†–æ—Å—Å–∏–π—Å–∫–æ–π –§–µ–¥–µ—Ä–∞—Ü–∏–∏. –ë–µ–∑ –≤–æ–ø—Ä–æ—Å–æ–≤.\n–ê—Ä–≥—É–º–µ–Ω—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å `dict`."""
        import faker as faker_
        from datetime import date

        faker = faker_.Faker('ru-RU')
        today = date.today()
        year_f = int(str(faker.date_of_birth(minimum_age=25, maximum_age=50)).split("-")[0])
        month_f = int(str(faker.date_of_birth(minimum_age=25, maximum_age=50)).split("-")[1])
        day_f = int(str(faker.date_of_birth(minimum_age=25, maximum_age=50)).split("-")[2])
        age_t = today.year - year_f - ((today.month, today.day) < (month_f, day_f))

        return {"name":faker.name(), "age":age_t, "work_place":faker.company(), "work_class":faker.job().lower(), "address":f"–†–æ—Å—Å–∏–π—Å–∫–∞—è –§–µ–¥–µ—Ä–∞—Ü–∏—è, {faker.address()}", "postal_code":faker.address()[-6:], 'telephone_number':faker.phone_number(), "useragent":faker.user_agent(), "number_card":faker.credit_card_number(), "provider_of_card":faker.credit_card_provider(), "expire_card":faker.credit_card_expire(), "inn":faker.businesses_inn(), "orgn":faker.businesses_ogrn()}
    def real_info_of_photo(self, photo: bytes):
        """–° –ø–æ–º–æ—â—å—é –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å –∞–¥—Ä–µ—Å, –≥–æ—Ä–æ–¥, –ø–æ—á—Ç–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å –ø–æ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏.\nphoto: —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –≤ `bytes`."""
        import io
        from PIL import Image
        import requests
        with Image.open(io.BytesIO(photo)) as img:
            metadata = img._getexif()
            if not metadata:
                return None
            gps_info = metadata.get(34853)
            if not gps_info:
                return None
            lat = gps_info[2]
            lon = gps_info[4]
            lat_ref = gps_info[3]
            latitude = (lat[0] + lat[1] / 60.0 + lat[2] / 3600.0)
            longitude = (lon[0] + lon[1] / 60.0 + lon[2] / 3600.0)
            datetime_original = metadata.get(36867)
            try:
                if lat_ref != 'E':
                    latitude = -latitude
                r = requests.get(f"https://nominatim.openstreetmap.org/reverse?lat={latitude}&lon={longitude}&format=json", headers=self.headers, proxies=self.proxies)
                json = r.json()
                return {"country":json["address"]["country"], "region":json["address"]["state"], "district":json["address"]["district"], 'city':json["address"]["city"], "full_address":json["display_name"], 'postcode':json["address"]["postcode"], 'datetime':datetime_original}
            except:
                if lat_ref != 'E':
                    latitude = -latitude
                longitude = -longitude
                r = requests.get(f"https://nominatim.openstreetmap.org/reverse?lat={latitude}&lon={longitude}&format=json", headers=self.headers, proxies=self.proxies)
                json = r.json()
                return {"country":json["address"]["country"], "region":json["address"]["state"], "district":json["address"]["district"], 'city':json["address"]["city"], "full_address":json["display_name"], 'postcode':json["address"]["postcode"], 'datetime':datetime_original}
    def bmi(self, weight: float, height: float):
        """–£–∑–Ω–∞—Ç—å –ò–ú–¢ –ø–æ –≤–µ—Å—É –∏ —Ä–æ—Å—Ç—É.\nweight: –¥–∞–π –≤–µ—Å –≤ –∫–≥.\nheight: –¥–∞–π —Ä–æ—Å—Ç –≤ –º–µ—Ç—Ä–∞—Ö. –ü—Ä–∏–º–µ—Ä: 1.76 (176 —Å–º)\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `dict` –ø—Ä–∏ —É–¥–∞—á–µ. `None` –ø—Ä–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —É–∑–Ω–∞—Ç—å –ò–ú–¢. –ù–µ —É–∫–∞–∑—ã–≤–∞–π—Ç–µ 0, –ª–∏–±–æ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞ –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.\n–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –Ω–∞ –∫–∞–Ω–∞–ª–µ –º–æ–µ–≥–æ –¥—Ä—É–≥–∞: [—Ç—ã–∫](https://t.me/pie_rise_channel_s_8395/1009)"""
        if weight == 0 or weight < 0:
            return None
        else:
            if height == 0 or height < 0:
                return None
            else:
                bmi = weight / (height ** 2)
                if bmi < 18.5:
                    return {"bmi":f'{bmi:.2f}', "status":"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –≤–µ—Å"}
                elif 18.5 <= bmi < 25:
                    return {"bmi":f'{bmi:.2f}', "status":"–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–µ—Å"}
                elif 25 <= bmi < 30:
                    return {"bmi":f'{bmi:.2f}', "status":"–ò–∑–±—ã—Ç–æ—á–Ω—ã–π –≤–µ—Å"}
                else:
                    return {"bmi":f'{bmi:.2f}', "status":"–û–∂–∏—Ä–µ–Ω–∏–µ"}
    def link_on_user(self, id: str):
        """–í–≤–µ–¥–∏ ID —é–∑–µ—Ä–∞.\n–ì–¥–µ –µ–≥–æ –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å?\n–°–∫–∞—á–∞–π—Ç–µ Ayugram —Å –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Å–∞–π—Ç–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞, –∞ –∑–∞—Ç–µ–º –∑–∞–π–¥–∏—Ç–µ –≤ –ø—Ä–æ—Ñ–∏–ª—å –∫ —á–µ–ª–æ–≤–µ–∫—É. –í–Ω–∏–∑—É –±—É–¥–µ—Ç –µ–≥–æ ID.\n–õ–∏–±–æ –∑–∞–π–¥–∏—Ç–µ –≤ @username_to_id_bot –∏ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É \"User\". –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –¥–æ–±–∞–≤—å—Ç–µ –µ–≥–æ –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.\nid: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∫–∞–≤—ã—á–∫–∞—Ö."""
        if len(id) > 10:
            return {'status':f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π ID –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–∏–≤—ã—à–∞—Ç—å 10 —Å–∏–º–≤–æ–ª–æ–≤.', 'url':None}
        elif len(id) < 10:
            return {"status":f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π ID –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ, —á–µ–º 10 —Å–∏–º–≤–æ–ª–æ–≤.', 'url':None}
        else:
            try:
                return {"status":"–£—Å–ø–µ—Ö!", "url":F"tg://openmessage?user_id={int(id)}"}
            except:
                return {"status":f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π ID –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–∏–≤—ã—à–∞—Ç—å 10 —Å–∏–º–≤–æ–ª–æ–≤.', 'url':None}
    def send_mail(self, subject: str, body: str, recipient: str, service: str = 'smtp.mail.ru', service_port: int = 465):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∏—Å—å–º–æ –ø–æ –ø–æ—á—Ç–µ, –∏—Å–ø–æ–ª—å–∑—É—è Python.\n–¢—Ä–µ–±—É–µ—Ç—Å—è —É–∫–∞–∑–∞—Ç—å username_mail –∏ mail_passwd –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã.\nsubject: —Ç–µ–º–∞ –ø–∏—Å—å–º–∞.\nbody: –æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å –ø–∏—Å—å–º–∞.\nrecipient: –ø–æ–ª—É—á–∞—Ç–µ–ª—å.\nservice: —Å–µ—Ä–≤–∏—Å-–ø—Ä–æ–≤–∞–π–¥–µ—Ä –≤–∞—à–µ–≥–æ SMTP —Å–µ—Ä–≤–µ—Ä–∞.\nservice_port: –ø–æ—Ä—Ç SMTP —Å–µ—Ä–≤–µ—Ä–∞."""
        if self.username_mail and self.mail_passwd:
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            import smtplib
            message = MIMEMultipart()
            message["From"] = self.username_mail
            message["To"] = recipient
            message["Subject"] = subject
 
            message.attach(MIMEText(body, "plain", 'utf-8'))
 
            with smtplib.SMTP_SSL(service, service_port) as server:
                server.login(self.username_mail, password=self.mail_passwd)
                server.sendmail(self.username_mail, recipient, message.as_string())
        else:
            return "–£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä username_mail –∏ mail_passwd –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞."
    def parsing_site(self, url: str):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Å–∞–π—Ç–∞)))\n–ß–∏—Å—Ç–æ —Å–∫–∏–Ω–µ–º HTML –∫–æ–¥.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–∞–π—Ç.\n–ü—Ä–∏ —É–¥–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `str`."""
        import requests
        try:
            req = requests.get(url, proxies=self.proxies, headers=self.headers)
            if req.status_code == 200:
                return req.text
            else:
                return None
        except:
            return None
    def google_photo_parsing(self, query: str):
        """–ü–∞—Ä—Å–∏–Ω–≥ –≥—É–≥–ª —Ñ–æ—Ç–æ.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å —Å—Å—ã–ª–∫–∞–º–∏ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –µ—Å–ª–∏ –µ—Å—Ç—å.\nquery: –∑–∞–ø—Ä–æ—Å."""
        import requests
        from bs4 import BeautifulSoup
        req = requests.get(f'https://www.google.com/search?q={query}&tbm=isch&imglq=1&isz=l&safe=unactive', proxies=self.proxies)
        soup = BeautifulSoup(req.text, 'html.parser')
        tags = soup.find_all('img', {'src':True})
        imgs_links = []
        for tag in tags:
            if 'https://' in tag['src']:
                imgs_links.append(tag['src'])
        return imgs_links
    def speech_to_text(self, file, language: str = 'ru-RU') -> str:
        """–ò–∑ —Ä–µ—á–∏ –≤ —Ç–µ–∫—Å—Ç. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã —Ñ–æ—Ä–º–∞—Ç–∞: `wav`, `flac`.\nfile: –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∫ —Ñ–∞–π–ª—É. –õ–∏–±–æ open(), –∏–ª–∏ io.BytesIO().\nlanguage: –∫–æ–¥ —è–∑—ã–∫–∞. –ö –ø—Ä–∏–º–µ—Ä—É, `en-US`.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `str`!"""
        import speech_recognition as sr
        r = sr.Recognizer()
        with sr.AudioFile(file) as source:
            audio = r.record(source)
        try:
            text = r.recognize_google(audio, language=language)
            return text
        except sr.UnknownValueError:
            return '–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞.'
        except:
            return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞. –¢–∞–∫–∂–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–æ–±–ª–µ–º—ã —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º.'
    def email_mass_send(self, recievers: list, title: str, body: str, service: str = 'smtp.mail.ru', service_port: int = 465):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –º–∞—Å—Å–æ–≤–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π.\nrecievers: —Å–ø–∏—Å–æ–∫ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π. –ö –ø—Ä–∏–º–µ—Ä—É: ['...', '...', ...]\ntitle: –∑–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∏—Å—å–º–∞.\nbody: –æ—Å—Ç–∞–ª—å–Ω–æ–π —Ç–µ–∫—Å—Ç –ø–∏—Å—å–º–∞.\nservice: —Å–µ—Ä–≤–∏—Å, –∫ –ø—Ä–∏–º–µ—Ä—É `smtp.mail.ru`.\nservice_port: –ø–æ—Ä—Ç SMTP-—Å–µ—Ä–≤–µ—Ä–∞, –∫ –ø—Ä–∏–º–µ—Ä—É, 465."""
        if self.username_mail and self.mail_passwd:
            for email in recievers:
                from email.mime.multipart import MIMEMultipart
                from email.mime.text import MIMEText
                import smtplib
                message = MIMEMultipart()
                message["From"] = self.username_mail
                message["To"] = email
                message["Subject"] = title
    
                message.attach(MIMEText(body, "plain", 'utf-8'))
    
                with smtplib.SMTP_SSL(service, service_port) as server:
                    server.login(self.username_mail, password=self.mail_passwd)
                    server.sendmail(self.username_mail, email, message.as_string())
        else:
            return "–£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä username_mail –∏ mail_passwd –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞."
    def alarm_clock(self, time_to_ring: str, sound):
        """–ë—É–¥–∏–ª—å–Ω–∏–∫ –Ω–∞ Python. –í–µ—Å–µ–ª–æ, –Ω–µ –ø—Ä–∞–≤–¥–∞-–ª–∏?)\ntime_to_ring: –≤—Ä–µ–º—è —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –±—É–¥–∏–ª—å–Ω–∏–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú:–°–°. –ö –ø—Ä–∏–º–µ—Ä—É, `16:45:43`.\nsound: –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∫ —Ñ–∞–π–ª—É —Å–æ –∑–≤—É–∫–æ–º –¥–ª—è –±—É–¥–∏–ª—å–Ω–∏–∫–∞, –ª–∏–±–æ –±—É—Ñ–µ—Ä–æ–ø–æ–¥–æ–±–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã. open(), io.BytesIO() –∏ –¥—Ä—É–≥–∏–µ."""
        from os import environ
        environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'
        from pygame import mixer
        import time
        from colorama import Fore

        mixer.init()

        alarm_time = time.strptime(time_to_ring, "%H:%M:%S")
        hour = alarm_time.tm_hour
        minutes = alarm_time.tm_min
        seconds = alarm_time.tm_sec
        data = {'hour':hour, 'minutes':minutes, 'seconds':seconds}
        print(f'{Fore.GREEN}–ë—É–¥–∏–ª—å–Ω–∏–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –Ω–∞ {Fore.BLUE}{time_to_ring}.')
        while True:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
            current_time = time.localtime()
            hour_ = current_time.tm_hour
            minutes_ = current_time.tm_min
            seconds_ = current_time.tm_sec
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Å—Ç—É–ø–∏–ª–æ –ª–∏ –≤—Ä–µ–º—è –±—É–¥–∏–ª—å–Ω–∏–∫–∞
            if {'hour':hour_, 'minutes':minutes_, 'seconds':seconds_} == data:
                print(f'{Fore.RED}–í–ù–ò–ú–ê–ù–ò–ï!!! –ë–£–î–ò–õ–¨–ù–ò–ö –ê–ö–¢–ò–í–ò–†–û–í–ê–ù, –ü–†–û–°–´–ü–ê–ô–¢–ï–°–¨!!!')
                mixer.Sound(sound).play(loops=-1)
            else:
                pass
    def cpp_compiler(self, filename: str, filename_output: str):
        """–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ G++ –≤ Python.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –µ–≥–æ –Ω–∞–ª–∏—á–∏–µ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –ø—Ä–æ–≥—Ä–∞–º–º—ã.\nfilename: –∏–º—è —Ñ–∞–π–ª–∞ .cpp —Ñ–æ—Ä–º–∞—Ç–∞. –ü–æ—Å—Ç–∞–≤—å—Ç–µ –µ–≥–æ –≤ –ø–∞–ø–∫—É —Å .py –¥–æ–∫—É–º–µ–Ω—Ç–æ–º.\nfilename_output: –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ .exe —Ñ–∞–π–ª–∞."""
        import subprocess
        try:
            subprocess.run(['g++', f'{filename}', '-o', f'{filename_output}'])
            return True
        except:
            return False
    def python_exe_compiler(self, path_to_py: str, path_output: str, flags: str = None):
        """–ò–∑ .py –≤ .exe –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä.\npath_to_py: –ø—É—Ç—å –∫ –≤–∞—à–µ–º—É .py —Ñ–∞–π–ª—É.\npath_output: –∫—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å .exe —Ñ–∞–π–ª.\nflags: –∫–∞–∫–∏–µ-–Ω–∏–±—É–¥—å —Ñ–ª–∞–≥–∏ –æ—Ç PyInstaller. –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ."""
        import os
        if flags:
            os.chdir(path_output)
            c = os.system(f'pyinstaller --distpath "{path_output}" {flags} "{path_to_py}"')
            if c == 1:
                return False
            else:
                return True
        else:
            os.chdir(path_output)
            c = os.system(f'pyinstaller --distpath "{path_output}" "{path_to_py}"')
            if c == 1:
                return False
            else:
                return True
    def tracking_youtube_author(self, channel_url: str, token_of_bot: str, id: int):
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–º–æ–≥–∞–µ—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –Ω–æ–≤—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç –≤–∞—à–µ–≥–æ –ª—é–±–∏–º–æ–≥–æ –±–ª–æ–≥–µ—Ä–∞ –Ω–∞ YouTube (–≤–∏–¥–µ–æ, shorts, –ø—Ä—è–º—ã–µ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏) —á–µ—Ä–µ–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏—Ö–æ–¥—è—Ç –∫ –≤–∞–º –≤ –ø–µ—Ä–µ–ø–∏—Å–∫—É —Å –≤–∞—à–∏–º –±–æ—Ç–æ–º, —Å–æ–∑–¥–∞–Ω–Ω—ã–º –≤ [BotFather](https://t.me/BotFather).\nchannel_url: —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –≤–∏–¥–µ–æ.\ntoken_of_bot: —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å –≤ BotFather.\nid: ID –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞, –≤ –ø–µ—Ä–µ–ø–∏—Å–∫—É —Å –±–æ—Ç–æ–º –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å—Å—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è."""
        import requests, time

        import pytubefix
        try:
            channel = pytubefix.Channel(channel_url, proxies=self.proxies)
        except:
            return "–î–∞–Ω–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."


        last_video = channel.videos[0].watch_url
        last_short = channel.shorts[0].watch_url
        last_live = channel.live[0].watch_url

        while True:
            if channel.videos[0].watch_url == last_video:
                if channel.shorts[0].watch_url == last_short:
                    if channel.live[0].watch_url == last_live:
                        pass
                    else:
                        last_live = channel.live[0].watch_url
                        text = f'–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ —É –∞–≤—Ç–æ—Ä–∞ {channel.title}.\n–ù–∞–∑–≤–∞–Ω–∏–µ: {channel.live[0].title}\n–°—Å—ã–ª–∫–∞: {channel.live[0].watch_url}'
                        requests.post(f'https://api.telegram.org/bot{token_of_bot}/sendMessage?chat_id={id}&text={text}', proxies=self.proxies)
                else:
                    last_short = channel.shorts[0].watch_url
                    text = f'–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ —É –∞–≤—Ç–æ—Ä–∞ {channel.title}.\n–ù–∞–∑–≤–∞–Ω–∏–µ: {channel.shorts[0].title}\n–°—Å—ã–ª–∫–∞: {channel.shorts[0].watch_url}'
                    requests.post(f'https://api.telegram.org/bot{token_of_bot}/sendMessage?chat_id={id}&text={text}', proxies=self.proxies)
            else:
                last_video = channel.videos[0].watch_url
                text = f'–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ —É –∞–≤—Ç–æ—Ä–∞ {channel.title}.\n–ù–∞–∑–≤–∞–Ω–∏–µ: {channel.videos[0].title}\n–°—Å—ã–ª–∫–∞: {channel.videos[0].watch_url}'
                requests.post(f'https://api.telegram.org/bot{token_of_bot}/sendMessage?chat_id={id}&text={text}', proxies=self.proxies)
            time.sleep(0.5)
    def searching_musics_vk(self, query: str, count: int = 3):
        """–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏ –ø–æ –∑–∞–ø—Ä–æ—Å—É —Å –í–ö.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ø–µ—Å–µ–Ω.\nquery: –∑–∞–ø—Ä–æ—Å.\ncount: –∫–∞–∫–æ–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Å–µ–Ω –Ω—É–∂–Ω–æ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –≤ —Å–ø–∏—Å–∫–µ.\n–ï—Å–ª–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—è, —Ç–æ —Å—Ç–æ–∏—Ç –æ—Ç–∫–∞—Ç–∏—Ç—å –≤–µ—Ä—Å–∏—é –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ vkpymusic: `pip install vkpymusic==3.0.0`."""
        if not self.token_of_vk:
            return "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ —É–∫–∞–∑–∞—Ç—å —Ç–æ–∫–µ–Ω –æ—Ç –í–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ –≤ VK."
        else:
            from vkpymusic import Service, TokenReceiver
            service = Service('KateMobileAndroid/56 lite-460 (Android 4.4.2; SDK 19; x86; unknown Android SDK built for x86; en)', self.token_of_vk)
            songs = []
            for track in service.search_songs_by_text(query, count):
                songs.append(track.to_dict())
            return songs
    def get_last_post(self, query: str):
        """–ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–æ—Å—Ç—ã –∏–∑ –ø–∞–±–ª–∏–∫–∞.\nquery: –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–∞–±–ª–∏–∫–∞.\n–í–µ—Ä–Ω–µ—Ç —Å–ª–æ–≤–∞—Ä—å –ø—Ä–∏ —É–¥–∞—á–Ω–æ–º –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–∏ –ø–∞–±–ª–∏–∫–∞."""
        import vk_api
        vk_session = vk_api.VkApi(token=self.token_of_vk)
        vk = vk_session.get_api()
        response = vk.groups.search(q=query, type='group', count=1)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º groups.search
        response1 = vk.wall.get(owner_id=-int(response['items'][0]['id']), count=1)  # owner_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º –¥–ª—è –≥—Ä—É–ø–ø
        if response['count'] > 0:
                try:
                    post = response1['items'][0]
                    text = post.get('text', '–¢–µ–∫—Å—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')  # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞, –µ—Å–ª–∏ –µ—Å—Ç—å
                    post_id = post['id']
                    owner_id = post['owner_id']
                    link = f"https://vk.com/wall{owner_id}_{post_id}"  # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç
                    likes = response1['items'][0]['likes']['count']
                    views = response1['items'][0]['views']['count']
                    reposts = response1['items'][0]['reposts']['count']
                    return {"text":text, "post_id":post_id, "owner_id":owner_id, "link":link, 'views':views, 'reposts':reposts, 'likes':likes}
                except:
                    return None
        else:
            return None
    def image_text_recognition(self, img: bytes, lang: str = 'ru'):
        """–†–∞–∑–±–æ—Ä —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏, —Å –ø–æ–º–æ—â—å—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ Google Cloud.\nimg: –≤–∞—à–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ bytes.\nlang: —è–∑—ã–∫ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏."""
        import requests, base64
        if not self.google_key:
            return '–î–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º –í–∞—à Google Cloud API –∫–ª—é—á. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –≤ —Ä–∞–∑–¥–µ–ª–µ Enabled APIs & Services –µ—Å—Ç—å Vision AI API.'
        else:
            image = base64.b64encode(img).decode("utf-8")

            # –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞
            request_body = {
                "requests": [
                    {
                        "image": {
                            "content": image
                        },
                        "features": [
                            {
                                "type": "LABEL_DETECTION",
                                "maxResults": 10
                            }
                        ],
                        "imageContext": {
		                    "languageHints": lang
		                }
                    }
                ]
            }

            # URL
            url = f"https://vision.googleapis.com/v1/images:annotate?key={self.google_key}"

            # –ó–∞–≥–æ–ª–æ–≤–∫–∏
            headers = {
                "Content-Type": "application/json"
            }

            # –ó–∞–ø—Ä–æ—Å
            response = requests.post(url, headers=headers, json=request_body, proxies=self.proxies)
            return {"code":response.status_code, 'answer':response.json()}
    def rcon_send(self, command: str):
        """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ RCON.\n–¢—Ä–µ–±—É–µ—Ç rcon_ip, rcon_port –∏ rcon_password –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö FunctionsObject.\ncommand: –∫–æ–º–∞–Ω–¥–∞ —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏. –ü—Ä–∏–º–µ—Ä: `say –ü—Ä–∏–≤–µ—Ç!`\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `str`, –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞."""
        if not self.rcon_server:
            return 'RCON —Å–µ—Ä–≤–µ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —É–∫–∞–∑–∞–ª–∏ –ª–∏ –í—ã –Ω—É–∂–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞.'
        else:
            self.rcon_server.connect()
            return self.rcon_server.command(command)
    def censor_faces_image(self, image: bytes, model: str = 'full', return_resolution: tuple[int] = None, block_size: int = 20):
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –ª–∏—Ü–∞ –Ω–∞ —Ñ–æ—Ç–æ –≤ –ø–∏–∫—Å–µ–ª–∏, –∫–æ—Ä–æ—á–µ, —Ü–µ–Ω–∑—É—Ä–∞.\nimage: —Ñ–æ—Ç–∫–∞ –≤ `bytes`. –ü—Ä–∏–º–µ—Ä: open('photo.jpg', 'rb').read()\nmodel: –º–æ–¥–µ–ª—å –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –ª–∏—Ü. `tiny` –∏ `full`.\nreturn_resolution: –≤—ã—Ö–æ–¥–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∏—Å—Ö–æ–¥–Ω–æ–π —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏.\nblock_size: —Ä–µ–∑–∫–æ—Å—Ç—å –º–æ–∑–∞–∏–∫–∏, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 20.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç bytes."""
        from tqdm import tqdm
        if return_resolution:
            img_pil = Image.open(io.BytesIO(image)).resize(return_resolution, Image.Resampling.LANCZOS)
            img = cv2.imdecode(numpy.frombuffer(image, numpy.uint8), cv2.IMREAD_COLOR)
            img = cv2.resize(img, return_resolution)
            _, boxes, confs = self.detector.face_detection(frame_arr=img, model=model)
            
            faces = [(x, y, w, h) for i, (x, y, w, h) in enumerate(boxes) if confs[i] > 0.5]
            if not faces:
                print(f'–õ–∏—Ü–∞ –Ω–µ –±—ã–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏.')
                return image
            else:
                for x, y, w, h in tqdm(faces, desc='–¶–µ–Ω–∑—É—Ä–∏–º –ª–∏—Ü–∞..', ncols=70):
                    region = (x, y, x + w, y + h)
                    region_img = img_pil.crop(region)
                    small_size = (max(int(w) // block_size, 1), h)
                    small_region = region_img.resize(small_size, Image.Resampling.NEAREST)
                    mosaic_region = small_region.resize((w, h), Image.Resampling.NEAREST)
                    img_pil.paste(mosaic_region, region)
                output = io.BytesIO()
                img_pil.save(output, format='JPEG')
                print(f'–ì–æ—Ç–æ–≤–æ!')
                return output.getvalue()
        else:
            img_pil = Image.open(io.BytesIO(image))
            img = cv2.imdecode(numpy.frombuffer(image, numpy.uint8), cv2.IMREAD_COLOR)        
            _, boxes, confs = self.detector.face_detection(frame_arr=img, model=model)
            
            faces = [(x, y, w, h) for i, (x, y, w, h) in enumerate(boxes) if confs[i] > 0.5]
            if not faces:
                print(f'–õ–∏—Ü–∞ –Ω–µ –±—ã–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏.')
                return image
            else:
                for x, y, w, h in tqdm(faces, desc='–¶–µ–Ω–∑—É—Ä–∏–º –ª–∏—Ü–∞..', ncols=70):
                    region = (x, y, x + w, y + h)
                    region_img = img_pil.crop(region)
                    small_size = (max(int(w) // block_size, 1), h)
                    small_region = region_img.resize(small_size, Image.Resampling.NEAREST)
                    mosaic_region = small_region.resize((w, h), Image.Resampling.NEAREST)
                    img_pil.paste(mosaic_region, region)
                output = io.BytesIO()
                img_pil.save(output, format='JPEG')
                print(f'–ì–æ—Ç–æ–≤–æ!')
                return output.getvalue()
    def minecraft_server_info(self, ip: str, port: int = None, type_: str = 'java'):
        """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ Minecraft-—Å–µ—Ä–≤–µ—Ä–µ.\nip: ip/host —Å–µ—Ä–≤–µ—Ä–∞, –∏–ª–∏ –¥–æ–º–µ–Ω. –¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å ip:port.\nport: –ø–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞, –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\ntype: java, –∏–ª–∏ bedrock."""
        if type_ in ['java', 'bedrock']:
            try:
                if type_ == 'java':
                    if not port:
                        server = JavaServer(ip)
                    else:
                        server = JavaServer(ip, port)
                    latency = server.ping()
                    query = server.query()
                    status = server.status()
                    return {"latency":latency, 'query':{"query_motd":query.motd.to_ansi(), 'query_map':query.map, 'query_players_count':query.players.online, 'query_players_max':query.players.max, 'all_info':query.as_dict()}, 'status':{"query_motd":status.motd.to_ansi(), 'description':status.description, 'icon_of_server_base64':status.icon, 'query_players_count':query.players.online, 'query_players_max':query.players.max, 'version':status.version.name, 'all_info':status.as_dict()}}
                else:
                    if not port:
                        server = BedrockServer(ip)
                    else:
                        server = BedrockServer(ip, port)
                    status = server.status()
                    return {"status":status.as_dict()}
            except:
                return
        else:
            return
    def gpt_4o_req(self, prompt: str, max_tokens: int = 4096, proxy: str = None, image: bytes = None):
        """–§–∏–≥–Ω—è –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ GPT-4o-mini.\nprompt: —Å–∞–º –∑–∞–ø—Ä–æ—Å –∫ –Ω–µ–π—Ä–æ–Ω–∫–µ.\nmax_tokens: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, 4096.\nproxy: –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –≤ FunctionsObject.\nimage: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ bytes. –î–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ —Ñ–æ—Ç–æ."""
        if not image:
            if not proxy:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', RetryProvider([Together, OIVSCodeSer2, Blackbox, Chatai, LegacyLMArena, PollinationsAI]), proxy=self.proxies.get('http'), max_tokens=max_tokens, web_search=True)
            else:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', RetryProvider([Together, OIVSCodeSer2, Blackbox, Chatai, LegacyLMArena, PollinationsAI]), proxy=proxy, max_tokens=max_tokens, web_search=True)
            return req.choices[0].message.content
        else:
            if not proxy:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', PollinationsAI, proxy=self.proxies.get('http'), max_tokens=max_tokens, web_search=True, image=image)
            else:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', PollinationsAI, proxy=proxy, max_tokens=max_tokens, web_search=True, image=image)
            return req.choices[0].message.content
    def flux_pro_gen(self, prompt: str, proxy: str = None):
        """–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–æ–ª–µ–µ –ª—É—á—à–∏—Ö –∫–∞—Ä—Ç–∏–Ω–æ–∫ —á–µ—Ä–µ–∑ flux-pro.\nprompt: –∑–∞–ø—Ä–æ—Å –¥–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–∏.\nproxy: –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)."""
        if proxy:
            img = self.client_for_gpt.images.generate(prompt, 'flux-pro', Together, 'url', proxy)
        else:
            img = self.client_for_gpt.images.generate(prompt, 'flux-pro', Together, 'url', self.proxies.get('http'))
        urls = []
        for i in img.data:
            urls.append(i.url)
        return urls
    def add_watermark(self, text: str, image: bytes, font: str, position: tuple[int] = (10, 10)):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞.\ntext: —Ç–µ–∫—Å—Ç –¥–ª—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞.\nimage: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ bytes.\nfont: –ø—É—Ç—å –∫ —à—Ä–∏—Ñ—Ç—É (–ø—Ä–∏–º–µ—Ä: times.ttf)\nposition: –≥–¥–µ –æ–Ω –¥–æ–ª–∂–µ–Ω –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è?"""
        # –û—Ç–∫—Ä—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        base_image = Image.open(io.BytesIO(image)).convert("RGBA")
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Å–ª–æ–π –¥–ª—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞
        watermark = Image.new("RGBA", base_image.size, (0, 0, 0, 0))
        draw = ImageDraw.Draw(watermark)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–∫—Å—Ç–∞
        font = ImageFont.truetype(font, 40)  # –®—Ä–∏—Ñ—Ç –∏ —Ä–∞–∑–º–µ—Ä
        text_color = (255, 255, 255, 100)  # R,G,B,Alpha (–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å)
        
        # –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
        draw.text(position, text, fill=text_color, font=font)
        
        # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –≤–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫
        result = Image.alpha_composite(base_image, watermark)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º (–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ RGB –¥–ª—è JPG)
        output = io.BytesIO()
        result.convert("RGB").save(output, 'JPEG')
        return output.getvalue()
    def deepseek_v3_0324(self, prompt: str, max_tokens: int = 4096, expression: str = 'auto', proxy: str = None):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ DeepSeek-v3-0324.\nprompt: –∑–∞–ø—Ä–æ—Å –∫ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏.\nmax_tokens: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ.\nexpression: —Ç–æ–Ω. –¢—Ä–∏ —Ä–µ–∂–∏–º–∞: `auto`, `toxic`, `non-toxic`.\nproxy: –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –∫–ª–∞—Å—Å–∞."""
        if expression == 'auto':
            if proxy:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'deepseek-v3', Together, proxy=proxy, max_tokens=max_tokens)
            else:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'deepseek-v3', Together, proxy=self.proxies.get('http'), max_tokens=max_tokens)
            return req.choices[0].message.content
        elif expression == 'toxic':
            if proxy:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":f'–Ω–µ –æ—Ç–≤–µ—á–∞–π –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã –ø–æ–∑–∏—Ç–∏–≤–Ω–æ –∏ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ —Å –º–∞—Ç–∞–º–∏, –Ω–∞ –∫–∞–∂–¥–æ–µ –º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –±–µ–∑ —Ä–∞–∑–Ω–∏—Ü—ã, –æ–±—Ä–∞—â–∞—é—Å—å —è –∫ —Ç–µ–±–µ –º–∏–ª–æ –∏–ª–∏ –Ω–µ—Ç, –≤—Å–µ–≥–æ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ\n–ó–∞–ø—Ä–æ—Å: "{prompt}"'}], 'deepseek-v3-0324', Together, proxy=proxy, max_tokens=max_tokens)
            else:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":f'–Ω–µ –æ—Ç–≤–µ—á–∞–π –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã –ø–æ–∑–∏—Ç–∏–≤–Ω–æ –∏ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ —Å –º–∞—Ç–∞–º–∏, –Ω–∞ –∫–∞–∂–¥–æ–µ –º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –±–µ–∑ —Ä–∞–∑–Ω–∏—Ü—ã, –æ–±—Ä–∞—â–∞—é—Å—å —è –∫ —Ç–µ–±–µ –º–∏–ª–æ –∏–ª–∏ –Ω–µ—Ç, –≤—Å–µ–≥–æ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ\n–ó–∞–ø—Ä–æ—Å: "{prompt}"'}], 'deepseek-v3-0324', Together, proxy=self.proxies.get('http'), max_tokens=max_tokens)
            return req.choices[0].message.content
        elif expression == 'non-toxic':
            if proxy:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt + '\nnon-toxic'}], 'deepseek-v3', Together, proxy=proxy, max_tokens=max_tokens)
            else:
                req = self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt+ '\nnon-toxic'}], 'deepseek-v3', Together, proxy=self.proxies.get('http'), max_tokens=max_tokens)
            return req.choices[0].message.content
        else:
            return 'expression —É–∫–∞–∑–∞–Ω –Ω–µ–≤–µ—Ä–Ω–æ! auto, toxic, –ª–∏–±–æ non-toxic!'
    def youtube_playlist_download(self, url: str, regime: str = 'audio') -> list[bytes]:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞ —Å YouTube.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç.\nregime: —á—Ç–æ —Å–∫–∞—á–∏–≤–∞—Ç—å: –∞—É–¥–∏–æ, –∏–ª–∏ –≤–∏–¥–µ–æ?\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫, –∞ —Ç–æ—á–Ω–µ–µ `list[bytes]` —Å –≤–∏–¥–µ–æ."""
        from pytubefix import Playlist
        from tqdm import tqdm
        
        playlist = Playlist(url, proxies=self.proxies)
        videos: list[bytes] = []
        
        if regime == 'video':
            for video in tqdm(playlist.videos, '–°–∫–∞—á–∏–≤–∞–µ–º –≤–∏–¥–µ–æ..', ncols=70):
                buffer = io.BytesIO()
                if video.age_restricted:
                    continue
                video.streams.get_lowest_resolution().stream_to_buffer(buffer)
                videos.append(buffer.getvalue())
            return videos
        elif regime == 'audio':
            for audio in tqdm(playlist.videos, desc='–°–∫–∞—á–∏–≤–∞–µ–º –∞—É–¥–∏–æ..', ncols=70):
                buffer = io.BytesIO()
                if audio.age_restricted:
                    continue
                audio.streams.get_audio_only().stream_to_buffer(buffer)
                videos.append(buffer.getvalue())
            return videos
        else:
            raise Exception('–¢—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–µ–∂–∏–º —É–∫–∞–∑–∞–ª. –¢–û–õ–¨–ö–û VIDEO –ò AUDIO!')
    def pornhub_search(self, query: str, count: int = 5, quality: str = 'best', account: InitPornHubAccount = None, proxies: dict[str, str] = None, checking_was_downloaded: bool = False) -> list[bytes]:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–∏–¥–µ–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∏—Ö —Å PornHub. –§—É–Ω–∫—Ü–∏—è –Ω–∞—Ä—É—à–∞–µ—Ç ToS PornHub, —Ä–µ–∫–æ–º–µ–Ω–¥—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, –∫–æ—Ç–æ—Ä—ã–µ —É–∫–∞–∑–∞–Ω—ã –≤ –∫–ª–∞—Å—Å–µ.\nquery: –ª–æ–≥–∏—á–Ω–æ, –∑–∞–ø—Ä–æ—Å.\ncount: —Å–∫–æ–ª—å–∫–æ –≤–∏–¥–µ–æ —Ç–µ–±–µ –Ω—É–∂–Ω–æ?\nquality: –≤ –∫–∞–∫–æ–º –∫–∞—á–µ—Å—Ç–≤–µ –∫–∞—á–∞—Ç—å? –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, `best`. –ï—Å—Ç—å: worst, best –∏ half.\naccount: —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç, –Ω–æ —ç—Ç–æ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ.\nproxies: –∫–∞—Å—Ç–æ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏, –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ –¥–ª—è –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.\nchecking_was_downloaded: –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –±—ã–ª–∏-–ª–∏ –≤–∏–¥–µ–æ –∑–∞—Ä–∞–Ω–µ–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã."""
        try:
            import requests
            if account:
                client = PHClient(language='ru', proxies=proxies if proxies else self.proxies, login=True, email=account.get_user, password=account.get_password)
            else:
                client = PHClient(language='ru', proxies=proxies if proxies else self.proxies, login=False)
            
            downloaded_videos: list[bytes] = []
            
            if not checking_was_downloaded:
                request = client.search(query)
                videos = request.sample(count, free_premium=False)
                for video in videos:
                    segments: list[str] = []
                    for s in video.get_segments(Quality(quality)):
                        segments.append(s)
                    chunks = []
                    for chunk in tqdm(segments, desc=f'–°–∫–∞—á–∏–≤–∞—é "{video.title}"..'):
                        try:
                            r = requests.get(chunk, proxies=proxies if proxies else self.proxies, headers={"User-Agent":"Mozilla/5.0"}).content
                            chunks.append(r)
                        except:
                            r = requests.get(chunk, proxies=proxies if proxies else self.proxies, headers={"User-Agent":"Mozilla/5.0"}).content
                            chunks.append(r)
                    video_data = b''.join(chunks)
                    downloaded_videos.append(video_data)
                return downloaded_videos
            else:
                request = client.search(query)
                videos = request.sample(count, free_premium=False)
                if not os.path.exists('downloaded.txt'):
                    with open('downloaded.txt', 'w') as f:
                        pass
                for video in videos:
                        if video.url in open('downloaded.txt', 'r').readlines():
                            print(f'"{video.title}" —É–∂–µ –±—ã–ª–æ —Å–∫–∞—á–µ–Ω–æ.')
                            continue
                        else:
                            f = open('downloaded.txt', 'a')
                            f.write(f'{video.url}\n')
                            f.close()
                            segments: list[str] = []
                            for s in video.get_segments(Quality(quality)):
                                segments.append(s)
                            chunks = []
                            for chunk in tqdm(segments, desc=f'–°–∫–∞—á–∏–≤–∞—é "{video.title}"..'):
                                try:
                                    r = requests.get(chunk, proxies=proxies if proxies else self.proxies, headers={"User-Agent":"Mozilla/5.0"}).content
                                    chunks.append(r)
                                except:
                                    r = requests.get(chunk, proxies=proxies if proxies else self.proxies, headers={"User-Agent":"Mozilla/5.0"}).content
                                    chunks.append(r)
                            video_data = b''.join(chunks)
                            downloaded_videos.append(video_data)
                return downloaded_videos
        except:
            raise Exception('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–∫–∞—Ç–∏—Ç—å –≤–µ—Ä—Å–∏—é –¥–æ 4.7. –î–ª—è —ç—Ç–æ–≥–æ –ø—Ä–æ–ø–∏—à–∏—Ç–µ: pip install phub==4.7')
    def pornhub_download_by_url(self, url: str, quality: str = 'best', account: InitPornHubAccount = None, proxies: dict[str, str] = None):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å PornHub –ø–æ —Å—Å—ã–ª–∫–µ.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ.\nquality: –∫–∞—á–µ—Å—Ç–≤–æ.\naccount: –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–∞ PornHub.\nproxies: –∫–∞—Å—Ç–æ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏ –¥–ª—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –µ—Å–ª–∏ –µ—Å—Ç—å."""
        try:
            import requests
            if account:
                client = PHClient(language='ru', proxies=proxies if proxies else self.proxies, login=True, email=account.get_user, password=account.get_password)
            else:
                client = PHClient(language='ru', proxies=proxies if proxies else self.proxies, login=False)
            
            video = client.get(url)
            segments: list[str] = []
            for s in video.get_segments(Quality(quality)):
                segments.append(s)
            chunks = []
            
            for segment in tqdm(segments, desc=f'–ö–∞—á–∞—é "{video.title}"...'):
                try:
                    chunks.append(requests.get(segment, proxies=proxies if proxies else self.proxies, headers={"User-Agent":"Mozilla/5.0"}).content)
                except:
                    chunks.append(requests.get(segment, proxies=proxies if proxies else self.proxies, headers={"User-Agent":"Mozilla/5.0"}).content)
            return b''.join(chunks)
        except:
            raise Exception('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–∫–∞—Ç–∏—Ç—å –≤–µ—Ä—Å–∏—é –¥–æ 4.7. –î–ª—è —ç—Ç–æ–≥–æ –ø—Ä–æ–ø–∏—à–∏—Ç–µ: pip install phub==4.7')
    def pornhub_video_information(self, url: str, account: InitPornHubAccount = None, proxies: dict[str, str] = None) -> dict:
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–≤–æ–¥–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ, –±–µ–∑ –µ–≥–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ.\naccount: –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç.\nproxies: –∫–∞—Å—Ç–æ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏ –¥–ª—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏."""
        if account:
            client = PHClient(account.get_user, account.get_password, language='ru', proxies=proxies if proxies else self.proxies, login=True)
        else:
            client = PHClient(language='ru', proxies=proxies if proxies else self.proxies, login=False)
        video = client.get(url)
        return video.dictify()
    def parse_kwork(self, category: int, pages: int = 1) -> list[KworkOffer]:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –Ω–∞ kwork.\ncategory: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞.\npages: —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å–ø–∞—Ä—Å–∏—Ç—å? –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, 1.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å –∫–≤–æ—Ä–∫–∞–º–∏."""
        import requests, json
        from bs4 import BeautifulSoup
        
        offers: list[KworkOffer] = []
        
        for p in tqdm(range(1, pages + 1), desc='–ü–∞—Ä—Å–∏–Ω–≥..'):
            response = requests.get('https://kwork.ru/projects', params={"c": category, "page":p}, proxies=self.proxies)
            response.raise_for_status()

            soup = BeautifulSoup(response.text, "html.parser")

            if not soup.head:
                raise Exception

            scripts = soup.head.find_all("script")
            js_script = ""
            for script in scripts:
                if script.text.startswith("window.ORIGIN_URL"):
                    js_script = script.text
                    break

            start_pointer = 0
            json_data = ""
            in_literal = False
            for current_pointer in range(len(js_script)):
                if js_script[current_pointer] == '"' and js_script[current_pointer - 1] != "\\":
                    in_literal = not in_literal
                    continue

                if in_literal or js_script[current_pointer] != ";":
                    continue

                line = js_script[start_pointer:current_pointer].strip()
                if line.startswith("window.stateData"):
                    json_data = line[17:]
                    break

                start_pointer = current_pointer + 1

            data = json.loads(json_data)

            for raw_kwork in data["wantsListData"]["wants"]:
                offer = KworkOffer(raw_kwork)
                offers.append(offer)
        return offers
    def info_about_faces_on_photo(self, photo: bytes):
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–¥–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–µ–ª–æ–≤–µ–∫–µ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –∏–ª–∏ –æ –ª—é–¥—è—Ö.\nphoto: –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –≤ –±–∞–π—Ç–∞—Ö.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `list[FaceInfo]` –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –ª—é–¥–µ–π –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏.\n–î–õ–Ø –î–ê–ù–ù–û–ô –§–£–ù–ö–¶–ò–ò –ñ–ï–õ–ê–¢–ï–õ–¨–ù–û –ò–ú–ï–¢–¨ –ü–†–û–¶–ï–°–°–û–† –° –ü–û–î–î–ï–†–ñ–ö–û–ô AVX-AVX2 –ò–ù–°–¢–†–£–ö–¶–ò–ô. –ï–°–õ–ò –í–´–õ–ê–ó–ò–¢ –û–®–ò–ë–ö–ê - –ò–°–ü–û–õ–¨–ó–£–ô–¢–ï –ü–ê–¢–ß –î–õ–Ø TENSORFLOW."""
        from deepface import DeepFace
        from base64 import b64encode
        
        faces: list[FaceInfo] = []
        
        analysis = DeepFace.analyze(b64encode(photo).decode(), ['emotion', 'age', 'gender', 'race'])
        
        for face in tqdm(analysis, '–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ª–∏—Ü–∞..', total=len(analysis), ncols=70):
            faces.append(face)
        
        if faces:
            return faces
    def rtmp_livestream(self, video: bytes, server: RTMPServerInit, ffmpeg_dir: str = 'ffmpeg', resolution: str = '1280x720', bitrate: str = '3000k', fps: str = '30'):
        """–°—Ç—Ä–∏–º–∏—Ç –≤–∏–¥–µ–æ –∏–∑ –±–∞–π—Ç–æ–≤ –Ω–∞ RTMPS-—Å–µ—Ä–≤–µ—Ä —Å FFmpeg –ø–æ–¥ CPU. –¢—Ä–µ–±—É–µ—Ç FFmpeg."""
        from tqdm import tqdm as tqdm_sync
        try:
            # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è FFmpeg
            command = [
                ffmpeg_dir,
                '-re',  # –†–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
                '-f', 'mp4',  # –§–æ—Ä–º–∞—Ç –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                '-i', '-',  # –í—Ö–æ–¥ –∏–∑ –ø–∞–π–ø–∞
                '-c:v', 'libx264',  # –ö–æ–¥–µ–∫ –ø–æ–¥ CPU
                '-preset', 'ultrafast',  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                '-tune', 'zerolatency',  # –î–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞
                '-b:v', bitrate,  # –ë–∏—Ç—Ä–µ–π—Ç
                '-s', resolution,  # –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ
                '-r', fps,  # FPS
                '-f', 'flv',  # –§–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–∞
                f'{server.url}/{server.key}'  # RTMPS URL —Å –ª–æ–≥–∏–Ω–æ–º/–ø–∞—Ä–æ–ª–µ–º
            ]
            
            # –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
            total_size = len(video)
            with tqdm_sync(total=total_size, unit='B', unit_scale=True, desc="–°—Ç—Ä–∏–º–∏–Ω–≥ –Ω–∞ RTMPS..") as pbar:
                process = subprocess.Popen(command, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
                video_buffer = io.BytesIO(video)
                
                # –û—Ç–ø—Ä–∞–≤–∫–∞ –±–∞–π—Ç–æ–≤ –≤ –ø–∞–π–ø
                chunk_size = 8192
                while True:
                    chunk = video_buffer.read(chunk_size)
                    if not chunk:
                        break
                    process.stdin.write(chunk)
                    pbar.update(len(chunk))
                
                process.stdin.close()
                process.wait()
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—à–∏–±–æ–∫
                stderr_output = process.stderr.read().decode('utf-8')
                if process.returncode != 0:
                    print(f"FFmpeg –æ—à–∏–±–∫–∞: {stderr_output}")
                    raise RuntimeError(f"FFmpeg –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π: {stderr_output}")
            
            print(f"–°–∏–≥–º–∞-—Å—Ç—Ä–∏–º –∑–∞–≤–µ—Ä—à—ë–Ω! üòé")
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞: {e}")
            raise
    def cut_link(self, url: str, proxies: dict[str, str] = None) -> str:
        """–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å API —Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫ `clck.ru`.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ.\nproxies: –ø—Ä–æ–∫—Å–∏, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –æ–Ω–∏ –±–µ—Ä—É—Ç—Å—è —Å –∫–ª–∞—Å—Å–∞.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –≤ `str`."""
        request = requests.get(f'https://clck.ru/--', params={"url":url}, headers=self.headers, proxies=proxies if proxies else self.proxies)
        if request.text != 'limited':
            return request.text
        else:
            time.sleep(2.5)
            request = requests.get(f'https://clck.ru/--', params={"url":url}, headers=self.headers, proxies=proxies if proxies else self.proxies)
            return request.text
    def detect_new_kworks(self, func, category: int = 11, pages: int = 1, delay: int = 300):
        """–ü—Ä–∏–≤–µ—Ç! –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è - –≤—Ä–∞–ø–ø–µ—Ä –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –Ω–∞ –±–∏—Ä–∂–µ Kwork.\n–Æ–ó–ê–ô–¢–ï –í –ö–ê–ß–ï–°–¢–í–ï –î–ï–ö–û–†–ê–¢–û–†–ê."""
        def wrapper(*args, **kwargs):
            start_kworks = self.parse_kwork(category, pages)
            new = []
            
            for i in start_kworks:
                new.append(i.url)
                
            while True:
                new_kworks = self.parse_kwork(category, pages)
                for kwork in new_kworks:
                    if kwork.url in new:
                        pass
                    else:
                        new.append(kwork.url)
                        func(kwork)
                time.sleep(delay)
        return wrapper
    def download_tiktok_video(self, url: str, dir: str, filename: str = None, youtube_dl_parameters: dict = None) -> dict:
        """–°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ –≤ —É–∫–∞–∑–∞–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ.\ndir: –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è, –∫—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∏–¥–µ–æ.\nfilename: –∏–º—è —Ñ–∞–π–ª–∞. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞–º–∏.\nyoutube_dl_parameters: –º—ã —Å–∞–º–∏ –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã yt-dlp. –ó–Ω–∞–π—Ç–µ, —á—Ç–æ –¥–µ–ª–∞–µ—Ç–µ."""
        if not os.path.exists(dir):
            os.mkdir(dir)
        
        if filename:
            ydl_opts = {
                'outtmpl': os.path.join(dir, f'{filename}.%(ext)s'),  # –®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                'format': 'mp4',  # –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ
                'noplaylist': True, 
                'format': 'worst',
                'proxy':self.proxies.get('http'),
            }
        else:
            name_of_file = random.random()
            ydl_opts = {
                'outtmpl': os.path.join(dir, f'{name_of_file}.%(ext)s'),  # –®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                'format': 'mp4',  # –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ
                'noplaylist': True, 
                'format': 'worst',
                'proxy':self.proxies.get('http'),
            }
        if youtube_dl_parameters:
            with YoutubeDL(youtube_dl_parameters) as downloader:
                info = downloader.extract_info(url, False)
                downloader.download([url])
                return info
        else:
            with YoutubeDL(ydl_opts) as downloader:
                info = downloader.extract_info(url, False)
                downloader.download([url])
                return info
    def twitch_clips_download(self, url: str, dir: str, filename: str = None, youtube_dl_parameters: dict = None) -> dict:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∫–ª–∏–ø–æ–≤ —Å Twitch!\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ç–≤–∏—Ç—á-–∫–ª–∏–ø.\ndir: –∫—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å?\nfilename: –∏–º—è —Ñ–∞–π–ª–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏.\nyoutube_dl_parameters: –ø–∞—Ä–∞–º–µ—Ç—Ä—ã YoutubeDL."""
        if not url.startswith(('https://m.twitch.tv/twitch/clip/', 'https://twitch.tv/twitch/clip/')):
            raise Exception('–ë—Ä–∞—Ç! –¢—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Å—ã–ª–∫–∏ —É–∫–∞–∑–∞–ª.')
        else:
            if not os.path.exists(dir):
                os.mkdir(dir)
        
            if filename:
                ydl_opts = {
                    'outtmpl': os.path.join(dir, f'{filename}.%(ext)s'),  # –®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                    'format': 'mp4',  # –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ
                    'noplaylist': True, 
                    'format': 'worst',
                    'proxy':self.proxies.get('http'),
                }
            else:
                name_of_file = random.random()
                ydl_opts = {
                    'outtmpl': os.path.join(dir, f'{name_of_file}.%(ext)s'),  # –®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                    'format': 'mp4',  # –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ
                    'noplaylist': True, 
                    'format': 'worst',
                    'proxy':self.proxies.get('http'),
                }
            if youtube_dl_parameters:
                with YoutubeDL(youtube_dl_parameters) as downloader:
                    info = downloader.extract_info(url, False)
                    downloader.download([url])
                    return info
            else:
                with YoutubeDL(ydl_opts) as downloader:
                    info = downloader.extract_info(url, False)
                    downloader.download([url])
                    return info
    def vk_rutube_dzen_video_download(self, url: str, dir: str, filename: str = None, youtube_dl_parameters: dict = None):
        """–§—É–Ω–∫—Ü–∏—è –ø–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏—é –≤–∏–¥–µ–æ –í–ö, –†—É—Ç—É–±–∞ –∏ –î–∑–µ–Ω–∞!\n–ü–∞—Ä–∞–º–µ—Ç—Ä—ã, –∫–∞–∫ –≤–µ–∑–¥–µ. –†–∞–∑–±–µ—Ä–µ—Ç–µ—Å—å."""
        if not url.startswith(('https://rutube.ru/video/', 'https://vk.com/vkvideo', 'https://dzen.ru/video/watch/', 'https://zen.yandex.ru/video/watch/')):
            raise Exception('–ë—Ä–∞—Ç! –¢—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Å—ã–ª–∫–∏ —É–∫–∞–∑–∞–ª.')
        else:
            if not os.path.exists(dir):
                os.mkdir(dir)
        
            if filename:
                ydl_opts = {
                    'outtmpl': os.path.join(dir, f'{filename}.%(ext)s'),  # –®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                    'format': 'mp4',  # –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ
                    'noplaylist': True, 
                    'format': 'worst',
                    'proxy':self.proxies.get('http'),
                }
            else:
                name_of_file = random.random()
                ydl_opts = {
                    'outtmpl': os.path.join(dir, f'{name_of_file}.%(ext)s'),  # –®–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                    'format': 'mp4',  # –§–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ
                    'noplaylist': True, 
                    'format': 'worst',
                    'proxy':self.proxies.get('http'),
                }
            if youtube_dl_parameters:
                with YoutubeDL(youtube_dl_parameters) as downloader:
                    info = downloader.extract_info(url, False)
                    downloader.download([url])
                    return info
            else:
                with YoutubeDL(ydl_opts) as downloader:
                    info = downloader.extract_info(url, False)
                    downloader.download([url])
                    return info
    def unpack_zip_jar_apk_others(self, file, dir: str, delete_original: bool = False):
        """"–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏ –ª—é–±—ã—Ö –∞—Ä—Ö–∏–≤–æ–≤. –î–∞–∂–µ Jar (Java Archive) –∏ APK.\nfile: —Ñ–∞–π–ª –≤ io.BytesIO(), –∏–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∫ –Ω–µ–º—É.\ndir: –º–µ—Å—Ç–æ –¥–ª—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏.\ndelete_original: —É–¥–∞–ª—è—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª? (–†–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –≤ file)\n–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None."""
        from zipfile import ZipFile

        if not os.path.exists(dir):
            os.mkdir(dir)

        zipfile = ZipFile(file, 'r')
        zipfile.extractall(dir)
        zipfile.close() 
        if delete_original:
            if isinstance(file, str):
                try:
                    os.remove(file)
                except:
                    pass
            else:
                pass
    def photo_upscale(self, image: bytes, factor: int = 4) -> bytes:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ –∞–ø—Å–∫–µ–π–ª–∞ —Ñ–æ—Ç–æ —á–µ—Ä–µ–∑ Pillow (–±–∏–∫—É–±–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥).\nimage: —Ñ–æ—Ç–æ –≤ bytes.\nfactor: –≤–æ —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å —Ñ–æ—Ç–æ (width –∏ height).\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç bytes."""
        img = Image.open(io.BytesIO(image))
        original_width, original_height = img.size

        new_width = int(original_width * factor)
        new_height = int(original_height * factor)

        upscaled = img.resize((new_width, new_height), Image.Resampling.BICUBIC)
        new = io.BytesIO()
        upscaled.save(new, 'JPEG')
        return new.getvalue()
    def generate_video_with_subtitles(self, path, output_path: str, output_name: str = None, font: str = None, language: str = 'ru'):
        """–í–∏–¥–µ–æ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç—Ç–æ–≥–æ –∂–µ –≤–∏–¥–µ–æ, –Ω–æ —Å —Å—É–±—Ç–∏—Ç—Ä–∞–º–∏.\npath: –ø—Ä—è–º–æ–π –ø—É—Ç—å –∫ –∏—Å—Ö–æ–¥–Ω–æ–º—É —Ñ–∞–π–ª—É.\noutput_path: –∫—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª.\noutput_name: –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–Ω–æ, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ.\nfont: –ø—É—Ç—å –∫ —à—Ä–∏—Ñ—Ç—É, –µ—Å–ª–∏ –µ—Å—Ç—å.\nlanguage: –∏—Å—Ö–æ–¥–Ω—ã–π —è–∑—ã–∫ –≤ –≤–∏–¥–µ–æ.\n\n–ü–û–î–î–ï–†–ñ–ò–í–ê–ï–¢–°–Ø –ù–ê–¢–ò–í–ù–û –¢–û–õ–¨–ö–û .mp4!"""
        if not self.whisper:
            raise Exception("–£–∫–∞–∂–∏ whisper_model –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–ª–∞—Å—Å–∞.")
        else:
            video = VideoFileClip(path)
            random_ = random.random()
            video.audio.write_audiofile(os.path.join(path, f'{random_}.wav'))
            audio_data, sample_rate = librosa.load(os.path.join(path, f'{random_}.wav'), sr=16000)  # Whisper –æ–∂–∏–¥–∞–µ—Ç —á–∞—Å—Ç–æ—Ç—É 
            result = self.whisper.transcribe(audio_data, word_timestamps=True, language=language)
            clips = [video]
            for segment in result["segments"]:
                for word_info in segment.get("words", []):
                    word = word_info["word"]
                    start_time = word_info["start"]
                    end_time = word_info["end"]

                    subtitle = TextClip(
                        text=word,
                        font_size=24,
                        color='white',
                        bg_color='black',
                        font=font,
                        size=(video.w, 100),
                        text_align='center'
                    ).with_start(start_time).with_end(end_time).with_position(('center', video.h - 120))

                    clips.append(subtitle)
            final_video = CompositeVideoClip(clips)
            os.remove(os.path.join(path, f'{random_}.wav'))
            if output_name:
                final_video.write_videofile(os.path.join(output_path, f'{output_name}.mp4'), codec="libx264", audio_codec="aac")
            else:
                final_video.write_videofile(os.path.join(output_path, f'{random_}.mp4'), codec="libx264", audio_codec="aac")
    def change_format_of_photo(self, image: bytes, format_: ImageFormat):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.\nimage: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ bytes.\nformat_: —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, —É–∫–∞–∑–∞–Ω–Ω—ã–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∫–ª–∞—Å—Å–æ–º."""
        PIL_FORMATS_MAP = {
            '.jpg': 'JPEG', '.jpeg': 'JPEG',
            '.png': 'PNG',
            '.bmp': 'BMP',
            '.gif': 'GIF',
            '.webp': 'WEBP'
        }
        selected_format_pil = PIL_FORMATS_MAP.get(format_.format_.lower())
        img = Image.open(io.BytesIO(image))

        # --- –õ–æ–≥–∏–∫–∞ –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ---
        output_buffer = io.BytesIO()

        # Pillow –º–æ–∂–µ—Ç —Ç—Ä–µ–±–æ–≤–∞—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ü–≤–µ—Ç–æ–≤–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
        if selected_format_pil == 'JPEG' and img.mode in ('RGBA', 'P'):
            img = img.convert('RGB')
        # –î–ª—è GIF, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é, –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞.
        # –ó–¥–µ—Å—å –º—ã –ø—Ä–æ—Å—Ç–æ —Å–æ—Ö—Ä–∞–Ω–∏–º –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –∏–ª–∏ –∫–∞–∫ –æ–±—ã—á–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.
        elif selected_format_pil == 'GIF':
            # –ü—Ä–æ—Å—Ç–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ GIF: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞
            img.save(output_buffer, format=selected_format_pil)
        else:
            img.save(output_buffer, format=selected_format_pil)

        output_buffer.seek(0) # –ü–µ—Ä–µ–º–∞—Ç—ã–≤–∞–µ–º –±—É—Ñ–µ—Ä –≤ –Ω–∞—á–∞–ª–æ
        converted_image_data = output_buffer.read()
        return converted_image_data
    def get_vk_user(self, user_id: str) -> Optional[VkUser]:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è VkUser –ø–æ user_id –∏–ª–∏ @username."""
        if not self.token_of_vk:
            raise Exception("–î—Ä—É–∂–æ–∫! –¢–æ–∫–µ–Ω —É–∫–∞–∂–∏ –æ—Ç —Å–≤–æ–µ–≥–æ VK ID.")
        fields = (
            "bdate,sex,city,country,home_town,photo_max_orig,"
            "followers_count,relation,contacts,domain,site,status,about,"
            "education,schools,universities,occupation,career,interests,"
            "activities,music,movies,tv,books,games,quotes,personal,connections"
        )
        try:
            session = vk_api.VkApi(token=self.token_of_vk)
            api = session.get_api()
            result = api.users.get(user_ids=user_id, fields=fields)
            if result:
                return VkUser(result[0])
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        return None

class CodeEditor:
    """–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –Ω–∞ Python —Å –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –ø—Ä–∏ –Ω–∞–ø–∏—Å–∞–Ω–∏–∏ –∫–æ–¥–∞ –Ω–∞ Python.\nmaster: –æ–±—ä–µ–∫—Ç –∫–ª–∞—Å—Å–∞ "Tk", –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ tkinter."""
    def __init__(self, master: tk.Tk):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è."""
        self.master = master
        master.title("–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞")
        master.geometry("800x600")
        KEYWORD_COLOR = "#FF7F50"  # Coral
        STRING_COLOR = "#98FB98"   # PaleGreen
        COMMENT_COLOR = "#808080"  # Gray
        FUNCTION_COLOR = "#4682B4" # SteelBlue
        NUMBER_COLOR = "#BDB76B"   # DarkKhaki
        BUILTIN_COLOR = "#FFA07A"  # LightSalmon

        self.filename = None  # Current file

        # --- Widgets ---
        self.text_area = scrolledtext.ScrolledText(
            master, wrap=tk.WORD, undo=True, font=("Consolas", 12)
        )
        self.text_area.pack(fill=tk.BOTH, expand=True)

        # --- Menu ---
        self.menu_bar = tk.Menu(master)
        master.config(menu=self.menu_bar)

        # File menu
        self.file_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.file_menu.add_command(label="–Ω–æ–≤–µ–Ω—å–∫–∏–π", command=self.new_file)
        self.file_menu.add_command(label="–æ—Ç–∫—Ä—ã—Ç—å", command=self.open_file)
        self.file_menu.add_command(label="—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=self.save_file)
        self.file_menu.add_command(label="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏...", command=self.save_file_as)
        self.file_menu.add_separator()
        self.file_menu.add_command(label="–ù–∞–∑–∞–¥", command=master.quit)
        self.menu_bar.add_cascade(label="–§–∞–π–ª", menu=self.file_menu)

        # Edit menu
        self.edit_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.edit_menu.add_command(label="–û—Ç–º–µ–Ω–∏—Ç—å", command=self.text_area.edit_undo)
        self.edit_menu.add_command(label="–í–ø–µ—Ä—ë–¥", command=self.text_area.edit_redo)
        self.menu_bar.add_cascade(label="–ò–∑–º–µ–Ω–∏—Ç—å", menu=self.edit_menu)

        # Help menu
        self.help_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.help_menu.add_command(label="–æ –ø—Ä–æ–≥–µ", command=self.show_about)
        self.menu_bar.add_cascade(label="–ø–æ–º–æ–≥–∏, –ø–ª–∏–∑", menu=self.help_menu)


        self.text_area.bind("<KeyRelease>", self.highlight_syntax)  # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø—Ä–∏ –≤–≤–æ–¥–µ

        # --- Syntax Highlighting Tags ---
        self.text_area.tag_configure("keyword", foreground=KEYWORD_COLOR)
        self.text_area.tag_configure("string", foreground=STRING_COLOR)
        self.text_area.tag_configure("comment", foreground=COMMENT_COLOR)
        self.text_area.tag_configure("function", foreground=FUNCTION_COLOR)
        self.text_area.tag_configure("number", foreground=NUMBER_COLOR)
        self.text_area.tag_configure("builtin", foreground=BUILTIN_COLOR)

        # --- Keywords ---
        self.keywords = ["def", "class", "if", "else", "elif", "for", "while", "return", "import", "from", "try", "except", "finally", "with", "as", "assert", "break", "continue", "del", "global", "nonlocal", "in", "is", "lambda", "pass", "raise", "yield"]
        self.builtins = ["print", "len", "range", "str", "int", "float", "bool", "list", "tuple", "dict", "set", "open", "file", "input", "exit", "help", "dir", "type", "object"]
    def new_file(self):
        """–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —Ñ–∞–π–ª."""
        self.text_area.delete("1.0", tk.END)  # Clear the text area
        self.filename = None  # Reset filename
        self.master.title("–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞ - New File")

    def open_file(self):
        """–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª."""
        filepath = filedialog.askopenfilename(
            filetypes=[("All Files", "*.*"), ("Text Files", "*.txt"), ("Python Files", "*.py"), ("C++ Files", "*.cpp")]
        )
        if filepath:
            try:
                with open(filepath, "r", encoding='UTF-8') as file:
                    content = file.read()
                self.text_area.delete("1.0", tk.END)
                self.text_area.insert("1.0", content)
                self.filename = filepath
                self.master.title(f"–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞ - {os.path.basename(filepath)}")
            except Exception as e:
                messagebox.showerror("–û–®–ò–ë–û–ß–ö–ê", f"–≤–æ—Ç —ç—Ç–æ:\n{e}")

    def save_file(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª."""
        if self.filename:
            try:
                content = self.text_area.get("1.0", tk.END)
                with open(self.filename, "w") as file:
                    file.write(content)
                messagebox.showinfo("—É—Å–ø–µ—Ö", "—Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω.")
            except Exception as e:
                messagebox.showerror("–æ—à–∏–±–æ—á–∫–∞", f"–ª–µ–µ–µ–µ:\n{e}")
        else:
            self.save_file_as()

    def save_file_as(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª –∫–∞–∫..."""
        filepath = filedialog.asksaveasfilename(
            defaultextension=".txt", filetypes=[("All Files", "*.*"), ("Text Files", "*.txt"), ("Python Files", "*.py"), ("C++ Files", "*.cpp")]
        )
        if filepath:
            try:
                content = self.text_area.get("1.0", tk.END)
                with open(filepath, "w") as file:
                    file.write(content)
                self.filename = filepath
                self.master.title(f"–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞ - {os.path.basename(filepath)}")
                messagebox.showinfo("—É—Ä—ã—ã—ã", "—Ñ–∞–π–ª —Ç–∏–ø–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω.")
            except Exception as e:
                messagebox.showerror("–æ—à–∏–±–û–ß–ö–ê", f"–ø–æ—Å–º–æ—Ç—Ä–∏ —Å–∞–º:\n{e}")

    def show_about(self):
        """–û –ø—Ä–æ–≥—Ä–∞–º–º–µ."""
        messagebox.showinfo(
            "–û –ø—Ä–æ–≥–µ", "–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–¥–∞ –æ—Ç –§–ª–æ—Ä–µ—Å—Ç–∞. –°–¥–µ–ª–∞–Ω–æ —Å –ª—é–±–æ–≤—å—é."
        )
    def highlight_syntax(self, event=None):
        """–ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å Python."""
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—Ç–∞—Ä—ã–µ —Ç–µ–≥–∏
        for tag in self.text_area.tag_names():
            self.text_area.tag_remove(tag, "1.0", tk.END)

        text = self.text_area.get("1.0", tk.END)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
        for match in re.finditer(r"#.*", text):
            start = "1.0 + %dc" % match.start()
            end = "1.0 + %dc" % match.end()
            self.text_area.tag_add("comment", start, end)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å—Ç—Ä–æ–∫
        for match in re.finditer(r"(\".*\")|(\'.*\')", text):
            start = "1.0 + %dc" % match.start()
            end = "1.0 + %dc" % match.end()
            self.text_area.tag_add("string", start, end)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
        for word in self.keywords:
            pattern = r'\b' + word + r'\b'  # –ì—Ä–∞–Ω–∏—Ü—ã —Å–ª–æ–≤–∞
            for match in re.finditer(pattern, text):
                start = "1.0 + %dc" % match.start()
                end = "1.0 + %dc" % match.end()
                self.text_area.tag_add("keyword", start, end)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
        for word in self.builtins:
            pattern = r'\b' + word + r'\b'  # –ì—Ä–∞–Ω–∏—Ü—ã —Å–ª–æ–≤–∞
            for match in re.finditer(pattern, text):
                start = "1.0 + %dc" % match.start()
                end = "1.0 + %dc" % match.end()
                self.text_area.tag_add("builtin", start, end)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —á–∏—Å–µ–ª
        for match in re.finditer(r'\b\d+\b', text):
            start = "1.0 + %dc" % match.start()
            end = "1.0 + %dc" % match.end()
            self.text_area.tag_add("number", start, end)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π (–æ—á–µ–Ω—å —É–ø—Ä–æ—â–µ–Ω–Ω–æ)
        for match in re.finditer(r'def\s+(\w+)\s*\(', text):
            start = "1.0 + %dc" % match.start(1) # –ù–∞—á–∞–ª–æ –∏–º–µ–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏
            end = "1.0 + %dc" % match.end(1) # –ö–æ–Ω–µ—Ü –∏–º–µ–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏
            self.text_area.tag_add("function", start, end)
            
import asyncio
import io
import random
import string
import re
from datetime import date
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import aiohttp
import aiofiles
import gtts
import qrcode
from PIL import Image, ImageOps, ImageDraw, ImageFont
import speech_recognition as sr
from pygame import mixer
import time
from colorama import Fore
import vk_api
from vkpymusic import Service, TokenReceiver
import faker as faker_
import subprocess
import os
from bs4 import BeautifulSoup
import aiosmtplib

class AsyncFunctionsObject:
    def __init__(self, proxies: dict = {}, html_headers: dict = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36', 'Accept-Language': 'ru-RU'}, google_api_key: str = "", gigachat_key: str = "", gigachat_id: str = "", username_mail: str = "", mail_passwd: str = "", speech_to_text_key: str = None, vk_token: str = None, rcon_ip: str = None, rcon_port: int = None, rcon_password: str = None):
        """Initialize the FunctionsObject with configuration parameters."""
        print(f'–û–±—ä–µ–∫—Ç –∫–ª–∞—Å—Å–∞ –±—ã–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.')
        self.proxies = proxies
        self.headers = html_headers
        self.google_key = google_api_key
        self.gigachat_key = gigachat_key
        self.client_id_gigachat = gigachat_id
        self.username_mail = username_mail
        self.mail_passwd = mail_passwd
        self.speech_to_text_key = speech_to_text_key
        self.token_of_vk = vk_token
        self.client_for_gpt = AsyncClient()
        if all([rcon_ip, rcon_password, rcon_port]):
            from aiomcrcon import Client
            self.rcon_server = Client(rcon_ip, rcon_port, rcon_password)
            print(f'RCON —Å–µ—Ä–≤–µ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!')
        else:
            self.rcon_server = None
        self.sync_functions_object = FunctionsObject(proxies, html_headers, google_api_key, gigachat_key, gigachat_id, username_mail, mail_passwd, speech_to_text_key, vk_token, rcon_ip, rcon_port, rcon_password)
    async def generate_image(self, prompt: str) -> bytes:
        """Generate an image using GigaChat API."""
        if not self.gigachat_key or not self.client_id_gigachat:
            return "–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä `gigachat_key` –∏ `gigachat_id` –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π."

        async with aiohttp.ClientSession() as session:
            # Get access token
            url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"
            payload = {'scope': 'GIGACHAT_API_PERS'}
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json',
                'RqUID': f'{self.client_id_gigachat}',
                'Authorization': f'Basic {self.gigachat_key}'
            }
            async with session.post(url, headers=headers, data=payload, ssl=False, proxy=self.proxies.get('https')) as response:
                access_token = (await response.json())['access_token']

            # Generate image
            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'Authorization': f'Bearer {access_token}'
            }
            data = {
                "model": "GigaChat",
                "messages": [
                    {"role": "system", "content": "Glory to Florest."},
                    {"role": "user", "content": prompt}
                ],
                "function_call": "auto"
            }
            async with session.post(
                'https://gigachat.devices.sberbank.ru/api/v1/chat/completions',
                headers=headers,
                json=data,
                ssl=False,
                proxy=self.proxies.get('https')
            ) as response:
                json_data = await response.json()
                patterns = r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
                matches = re.search(patterns, json_data['choices'][0]['message']['content'])
                if not matches:
                    return f"–ù–µ–ª—å–∑—è –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å —á—Ç–æ-–ª–∏–±–æ –ø–æ –¥–∞–Ω–Ω–æ–º—É –∑–∞–ø—Ä–æ—Å—É. –ü—Ä–∏—á–∏–Ω–∞: {json_data['choices'][0]['message']['content']}"
                else:
                    async with session.get(
                        f"https://gigachat.devices.sberbank.ru/api/v1/files/{matches.group()}/content",
                        headers={'Accept': 'application/jpg', "Authorization": f"Bearer {access_token}"},
                        ssl=False,
                        proxy=self.proxies.get('https')
                    ) as req_img:
                        return await req_img.read()

    async def ai(self, prompt: str, is_voice: bool = False):
        """Interact with GigaChat API, optionally generating voice output."""
        if not self.gigachat_key or not self.client_id_gigachat:
            return "–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä `gigachat_key` –∏ `gigachat_id` –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π."

        async with aiohttp.ClientSession() as session:
            # Get access token
            url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"
            payload = {'scope': 'GIGACHAT_API_PERS'}
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json',
                'RqUID': f'{self.client_id_gigachat}',
                'Authorization': f'Basic {self.gigachat_key}'
            }
            async with session.post(url, headers=headers, data=payload, ssl=False, proxy=self.proxies.get('https')) as response:
                access_token = (await response.json())['access_token']

            # Send prompt
            url1 = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions"
            payload1 = {
                "model": "GigaChat",
                "messages": [{"role": "user", "content": prompt}],
                "stream": False,
                "repetition_penalty": 1
            }
            headers1 = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'Authorization': f'Bearer {access_token}'
            }
            async with session.post(url1, headers=headers1, json=payload1, ssl=False, proxy=self.proxies.get('https')) as response1:
                result = await response1.json()
                if not is_voice:
                    return result
                else:
                    buffer = io.BytesIO()
                    gtts.gTTS(result['choices'][0]['message']['content'], lang='ru', lang_check=False).write_to_fp(buffer)
                    return buffer.getvalue()

    async def deanon(self, ip: str) -> list:
        """Get geolocation information for an IP address."""
        async with aiohttp.ClientSession() as session:
            async with session.get(f'http://ip-api.com/json/{ip}?lang=ru', headers=self.headers, proxy=self.proxies.get('http')) as response:
                data = await response.json()
                return [f'{key.title()}: {value}' for key, value in data.items()]

    async def download_video(self, url: str):
        """Download a YouTube video."""
        return await asyncio.to_thread(self.sync_functions_object.download_video, url)

    async def search_videos(self, query: str):
        """Search and download a YouTube video by query."""
        return await asyncio.to_thread(self.sync_functions_object.search_videos, query)

    async def create_demotivator(self, top_text: str, bottom_text: str, photo: bytes, font: str):
        """Create a demotivator image."""
        image = io.BytesIO(photo)
        img = Image.new('RGB', (1280, 1024), color='black')
        img_border = Image.new('RGB', (1060, 720), color='#000000')
        border = ImageOps.expand(img_border, border=2, fill='#ffffff')
        user_img = Image.open(image).convert("RGBA").resize((1050, 710))
        (width, height) = user_img.size
        img.paste(border, (111, 96))
        img.paste(user_img, (118, 103))
        drawer = ImageDraw.Draw(img)
        font_1 = ImageFont.truetype(font=font, size=80, encoding='UTF-8')
        text_width = font_1.getlength(top_text)
        top_size = 80
        while text_width >= (width + 250) - 20:
            top_size -= 1
            font_1 = ImageFont.truetype(font=font, size=top_size, encoding='UTF-8')
            text_width = font_1.getlength(top_text)
        font_2 = ImageFont.truetype(font=font, size=60, encoding='UTF-8')
        text_width = font_2.getlength(bottom_text)
        bottom_size = 60
        while text_width >= (width + 250) - 20:
            bottom_size -= 1
            font_2 = ImageFont.truetype(font=font, size=bottom_size, encoding='UTF-8')
            text_width = font_2.getlength(bottom_text)
        size_1 = drawer.textlength(top_text, font=font_1)
        size_2 = drawer.textlength(bottom_text, font=font_2)
        drawer.text(((1280 - size_1) / 2, 840), top_text, fill='white', font=font_1)
        drawer.text(((1280 - size_2) / 2, 930), bottom_text, fill='white', font=font_2)
        result_here = io.BytesIO()
        img.save(result_here, 'JPEG')
        del drawer
        return result_here.getvalue()

    async def photo_make_black(self, photo: bytes):
        """Convert a photo to black and white."""
        your_photo = io.BytesIO(photo)
        image = Image.open(your_photo)
        new_image = image.convert('L')
        buffer = io.BytesIO()
        new_image.save(buffer, 'JPEG')
        return buffer.getvalue()

    async def check_weather(self, city):
        """Check weather for a city or coordinates."""
        async with aiohttp.ClientSession() as session:
            if isinstance(city, str):
                try:
                    async with session.get(f'https://geocoding-api.open-meteo.com/v1/search?name={city}', headers=self.headers, proxy=self.proxies.get('https')) as response:
                        d = await response.json()
                        lot = d["results"][0]["latitude"]
                        lat = d['results'][0]['longitude']
                    async with session.get(f'https://api.open-meteo.com/v1/forecast?latitude={lot}&longitude={lat}&current_weather=true', headers=self.headers, proxy=self.proxies.get('https')) as req:
                        if req.status != 200:
                            return None
                        data = await req.json()
                        temperature = data['current_weather']['temperature']
                        title = {0: "–Ø—Å–Ω–æ", 1: "–ß–∞—Å—Ç–∏—á–Ω–æ –æ–±–ª–∞—á–Ω–æ", 3: "–û–±–ª–∞—á–Ω–æ", 61: "–î–æ–∂–¥—å"}
                        weather = title.get(data['current_weather']['weathercode'], '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
                        wind_dir = '–°–µ–≤–µ—Ä' if 0 <= (d := data['current_weather']['winddirection']) < 45 or 315 <= d <= 360 else '–í–æ—Å—Ç–æ–∫' if 45 <= d < 135 else '–Æ–≥' if 135 <= d < 225 else '–ó–∞–ø–∞–¥'
                        time1 = data['current_weather']['time']
                        wind = data['current_weather']['windspeed']
                        return {'temp': temperature, 'weather': weather, 'weather_code': data['current_weather']['weathercode'], 'wind_direction': wind_dir, 'time_of_data': time1, 'wind_speed': wind}
                except:
                    return None
            elif isinstance(city, dict):
                try:
                    lat = city["lat"]
                    lon = city["lon"]
                    async with session.get(f'https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current_weather=true', headers=self.headers, proxy=self.proxies.get('https')) as req:
                        data = await req.json()
                        temperature = data['current_weather']['temperature']
                        title = {0: "–Ø—Å–Ω–æ", 1: "–ß–∞—Å—Ç–∏—á–Ω–æ –æ–±–ª–∞—á–Ω–æ", 3: "–û–±–ª–∞—á–Ω–æ", 61: "–î–æ–∂–¥—å"}
                        weather = title.get(data['current_weather']['weathercode'], '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
                        wind_dir = '–°–µ–≤–µ—Ä' if 0 <= (d := data['current_weather']['winddirection']) < 45 or 315 <= d <= 360 else '–í–æ—Å—Ç–æ–∫' if 45 <= d < 135 else '–Æ–≥' if 135 <= d < 225 else '–ó–∞–ø–∞–¥'
                        time1 = data['current_weather']['time']
                        wind = data['current_weather']['windspeed']
                        return {'temp': temperature, 'weather': weather, 'weather_code': data['current_weather']['weathercode'], 'wind_direction': wind_dir, 'time_of_data': time1, 'wind_speed': wind}
                except KeyError:
                    return f'–ù—É–∂–Ω–æ —Å–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ª–æ–≤–∞—Ä—å, —Å–æ–≥–ª–∞—Å–Ω–æ –æ–±—Ä–∞–∑—Ü—É, —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏.'
                except:
                    return None
            else:
                return '–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö: `str` –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è –≥–æ—Ä–æ–¥–∞ –∏ `dict` –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ–≤.'

    async def create_qr(self, content: str):
        """Create a QR code."""
        buffer = io.BytesIO()
        qr = qrcode.make(content)
        qr.save(buffer, scale=10)
        return buffer.getvalue()

    async def get_charts(self):
        """Get Yandex Music charts."""
        async with aiohttp.ClientSession() as session:
            headers = {
                'Accept': 'application/json, text/javascript, */*; q=0.01',
                'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7,fi;q=0.6,nb;q=0.5,is;q=0.4,pt;q=0.3,ro;q=0.2,it;q=0.1,de;q=0.1',
                'Connection': 'keep-alive',
                'Referer': 'https://music.yandex.ru/chart',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
                'X-Current-UID': '403036463',
                'X-Requested-With': 'XMLHttpRequest',
                'X-Retpath-Y': 'https://music.yandex.ru/chart',
                'sec-ch-ua': '"Not?A_Brand";v="8", "Chromium";v="108", "Google Chrome";v="108"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"Linux"',
            }
            params = {
                'what': 'chart',
                'lang': 'ru',
                'external-domain': 'music.yandex.ru',
                'overembed': 'false',
                'ncrnd': '0.23800355071570123',
            }
            async with session.get('https://music.yandex.ru/handlers/main.jsx', params=params, headers=headers, proxy=self.proxies.get('https')) as response:
                chart = (await response.json())['chartPositions']
                result = []
                for track in chart[:10]:
                    position = track['track']['chart']['position']
                    title = track['track']['title']
                    author = track['track']['artists'][0]['name']
                    result.append(f"‚Ññ{position}: {author} - {title}")
                return f'–ß–∞—Ä—Ç—ã –Ø–Ω–¥–µ–∫—Å –ú—É–∑—ã–∫–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Çüî•\nü•á{result[0]}\nü•à{result[1]}\nü•â{result[2]}\n{result[3]}\n{result[4]}\n{result[5]}\n{result[6]}\n{result[7]}\n{result[8]}\n{result[9]}'

    async def generate_password(self, symbols: int = 15):
        """Generate a random password."""
        symbols_ascii = list(string.ascii_letters + string.digits)
        random.shuffle(symbols_ascii)
        return ''.join(symbols_ascii[:symbols])

    async def text_to_speech(self, text: str, lang: str = 'ru'):
        """Convert text to speech."""
        buffer = io.BytesIO()
        engine = gtts.gTTS(text, lang=lang)
        engine.write_to_fp(buffer)
        return buffer.getvalue()

    async def information_about_yt_channel(self, url: str):
        """–£–∑–Ω–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ YouTube –∫–∞–Ω–∞–ª–µ –Ω–∞ Python.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª."""
        if not self.google_key:
            return '–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä `google_key` –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–ª–∞—Å—Å–∞.'
        else:
            import httpx
            
            if '/channel/' in url:
                channel_id = url.split('/channel/')[-1].split('?')[0]
                params = {
                    "part": "snippet,statistics",
                    "id": channel_id,
                    "key": self.google_key
                }
            else:
                username = url.split('/@')[-1].split('?')[0]
                params = {
                    "part": "snippet,statistics",
                    "forHandle": f"@{username}",
                    "key": self.google_key
                }

            # –°–æ–∑–¥–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –∏ –≤—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    'https://www.googleapis.com/youtube/v3/channels',
                    params=params,
                    headers=self.headers,
                    proxies=self.proxies
                )
                
            return response.json()

    async def crypto_price(self, crypto: str, currency: str = 'rub'):
        """Get cryptocurrency price."""
        async with aiohttp.ClientSession() as session:
            async with session.get('https://api.coingecko.com/api/v3/simple/price', params={"ids": crypto, 'vs_currencies': currency}, headers=self.headers, proxy=self.proxies.get('https')) as response:
                r = await response.json()
                if not r:
                    return "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –≤–∞–ª—é—Ç–∞, –∏–ª–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞."
                try:
                    return r[crypto][currency]
                except:
                    return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –í–æ–∑–º–æ–∂–Ω–æ, –±—ã–ª–∏ –ø—Ä–µ–æ–¥–æ–ª–µ–Ω—ã –ª–∏–º–∏—Ç—ã API."

    async def password_check(self, nickname: str) -> int:
        """Check for password leaks by nickname."""
        async with aiohttp.ClientSession() as session:
            async with session.get(f'https://api.proxynova.com/comb?query={nickname}&start=0&limit=15', headers=self.headers, proxy=self.proxies.get('https')) as req:
                if req.status == 200:
                    return (await req.json())['count']
                return 0

    async def generate_nitro(self, count: int):
        """Generate Discord Nitro codes."""
        results = []
        for _ in range(count):
            characters = string.ascii_uppercase + string.digits
            random_code = ''.join(random.choice(characters) for _ in range(15))
            formatted_code = '-'.join(random_code[i:i+4] for i in range(0, 15, 4))
            results.append(formatted_code)
        return results

    async def fake_human(self):
        """Generate fake Russian citizen data."""
        faker = faker_.Faker('ru-RU')
        today = date.today()
        year_f, month_f, day_f = map(int, str(faker.date_of_birth(minimum_age=25, maximum_age=50)).split("-"))
        age_t = today.year - year_f - ((today.month, today.day) < (month_f, day_f))
        return {
            "name": faker.name(),
            "age": age_t,
            "work_place": faker.company(),
            "work_class": faker.job().lower(),
            "address": f"–†–æ—Å—Å–∏–π—Å–∫–∞—è –§–µ–¥–µ—Ä–∞—Ü–∏—è, {faker.address()}",
            "postal_code": faker.address()[-6:],
            'telephone_number': faker.phone_number(),
            "useragent": faker.user_agent(),
            "number_card": faker.credit_card_number(),
            "provider_of_card": faker.credit_card_provider(),
            "expire_card": faker.credit_card_expire(),
            "inn": faker.businesses_inn(),
            "orgn": faker.businesses_ogrn()
        }

    async def real_info_of_photo(self, photo: bytes):
        """Extract location data from photo metadata."""
        with Image.open(io.BytesIO(photo)) as img:
            metadata = img._getexif()
            if not metadata or not metadata.get(34853):
                return None
            gps_info = metadata[34853]
            lat = gps_info[2]
            lon = gps_info[4]
            lat_ref = gps_info[3]
            latitude = (lat[0] + lat[1] / 60.0 + lat[2] / 3600.0)
            longitude = (lon[0] + lon[1] / 60.0 + lon[2] / 3600.0)
            datetime_original = metadata.get(36867)
            async with aiohttp.ClientSession() as session:
                try:
                    if lat_ref != 'E':
                        latitude = -latitude
                    async with session.get(f"https://nominatim.openstreetmap.org/reverse?lat={latitude}&lon={longitude}&format=json", headers=self.headers, proxy=self.proxies.get('https')) as response:
                        json_data = await response.json()
                        return {
                            "country": json_data["address"]["country"],
                            "region": json_data["address"]["state"],
                            "district": json_data["address"]["district"],
                            'city': json_data["address"]["city"],
                            "full_address": json_data["display_name"],
                            'postcode': json_data["address"]["postcode"],
                            'datetime': datetime_original
                        }
                except:
                    if lat_ref != 'E':
                        latitude = -latitude
                    longitude = -longitude
                    async with session.get(f"https://nominatim.openstreetmap.org/reverse?lat={latitude}&lon={longitude}&format=json", headers=self.headers, proxy=self.proxies.get('https')) as response:
                        json_data = await response.json()
                        return {
                            "country": json_data["address"]["country"],
                            "region": json_data["address"]["state"],
                            "district": json_data["address"]["district"],
                            'city': json_data["address"]["city"],
                            "full_address": json_data["display_name"],
                            'postcode': json_data["address"]["postcode"],
                            'datetime': datetime_original
                        }

    async def bmi(self, weight: float, height: float):
        """Calculate BMI."""
        if weight <= 0 or height <= 0:
            return None
        bmi = weight / (height ** 2)
        if bmi < 18.5:
            return {"bmi": f'{bmi:.2f}', "status": "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –≤–µ—Å"}
        elif 18.5 <= bmi < 25:
            return {"bmi": f'{bmi:.2f}', "status": "–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–µ—Å"}
        elif 25 <= bmi < 30:
            return {"bmi": f'{bmi:.2f}', "status": "–ò–∑–±—ã—Ç–æ—á–Ω—ã–π –≤–µ—Å"}
        else:
            return {"bmi": f'{bmi:.2f}', "status": "–û–∂–∏—Ä–µ–Ω–∏–µ"}

    async def link_on_user(self, id: str):
        """Generate Telegram user link by ID."""
        if len(id) != 10:
            return {'status': f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–æ–≤–Ω–æ 10 —Å–∏–º–≤–æ–ª–æ–≤.', 'url': None}
        try:
            return {"status": "–£—Å–ø–µ—Ö!", "url": f"tg://openmessage?user_id={int(id)}"}
        except:
            return {"status": f'–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID.', 'url': None}

    async def send_mail(self, subject: str, body: str, recipient: str, service: str = 'smtp.mail.ru', service_port: int = 465):
        """Send an email."""
        if not self.username_mail or not self.mail_passwd:
            return "–£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä username_mail –∏ mail_passwd –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞."
        message = MIMEMultipart()
        message["From"] = self.username_mail
        message["To"] = recipient
        message["Subject"] = subject
        message.attach(MIMEText(body, "plain", 'utf-8'))
        async with aiosmtplib.SMTP(hostname=service, port=service_port, use_tls=True) as server:
            await server.login(self.username_mail, self.mail_passwd)
            await server.sendmail(self.username_mail, recipient, message.as_string())

    async def parsing_site(self, url: str):
        """Parse a website's HTML."""
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(url, headers=self.headers, proxy=self.proxies.get('https')) as response:
                    if response.status == 200:
                        return await response.text()
                    return None
            except:
                return None

    async def google_photo_parsing(self, query: str):
        """Parse Google Images for photo links."""
        async with aiohttp.ClientSession() as session:
            async with session.get(f'https://www.google.com/search?q={query}&tbm=isch&imglq=1&isz=l&safe=unactive', headers=self.headers, proxy=self.proxies.get('https')) as response:
                soup = BeautifulSoup(await response.text(), 'html.parser')
                tags = soup.find_all('img', {'src': True})
                return [tag['src'] for tag in tags if 'https://' in tag['src']]

    async def speech_to_text(self, file, language: str = 'ru-RU') -> str:
        """Convert speech to text."""
        r = sr.Recognizer()
        with sr.AudioFile(file) as source:
            audio = r.record(source)
        try:
            text = await asyncio.to_thread(r.recognize_google, audio, language=language)
            return text
        except sr.UnknownValueError:
            return '–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞.'
        except:
            return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞. –¢–∞–∫–∂–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–æ–±–ª–µ–º—ã —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º.'

    async def email_mass_send(self, receivers: list, title: str, body: str, service: str = 'smtp.mail.ru', service_port: int = 465):
        """Send mass emails."""
        if not self.username_mail or not self.mail_passwd:
            return "–£–∫–∞–∂–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä username_mail –∏ mail_passwd –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞."
        async with aiosmtplib.SMTP(hostname=service, port=service_port, use_tls=True) as server:
            await server.login(self.username_mail, self.mail_passwd)
            for email in receivers:
                message = MIMEMultipart()
                message["From"] = self.username_mail
                message["To"] = email
                message["Subject"] = title
                message.attach(MIMEText(body, "plain", 'utf-8'))
                await server.sendmail(self.username_mail, email, message.as_string())

    async def alarm_clock(self, time_to_ring: str, sound):
        """Set an alarm clock."""
        from os import environ
        environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1'
        mixer.init()
        alarm_time = time.strptime(time_to_ring, "%H:%M:%S")
        data = {'hour': alarm_time.tm_hour, 'minutes': alarm_time.tm_min, 'seconds': alarm_time.tm_sec}
        print(f'{Fore.GREEN}–ë—É–¥–∏–ª—å–Ω–∏–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –Ω–∞ {Fore.BLUE}{time_to_ring}.')
        while True:
            current_time = time.localtime()
            hour_ = current_time.tm_hour
            minutes_ = current_time.tm_min
            seconds_ = current_time.tm_sec
            if {'hour': hour_, 'minutes': minutes_, 'seconds': seconds_} == data:
                print(f'{Fore.RED}–í–ù–ò–ú–ê–ù–ò–ï!!! –ë–£–î–ò–õ–¨–ù–ò–ö –ê–ö–¢–ò–í–ò–†–û–í–ê–ù, –ü–†–û–°–´–ü–ê–ô–¢–ï–°–¨!!!')
                mixer.Sound(sound).play(loops=-1)
                break
            await asyncio.sleep(1)

    async def cpp_compiler(self, filename: str, filename_output: str):
        """Compile C++ code."""
        process = await asyncio.create_subprocess_exec(
            'g++', filename, '-o', filename_output,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await process.communicate()
        return process.returncode == 0

    async def python_exe_compiler(self, path_to_py: str, path_output: str, flags: str = None):
        """Compile Python to executable."""
        os.chdir(path_output)
        cmd = f'pyinstaller --distpath "{path_output}" {flags or ""} "{path_to_py}"'
        process = await asyncio.create_subprocess_shell(
            cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await process.communicate()
        return process.returncode == 0

    async def tracking_youtube_author(self, channel_url: str, token_of_bot: str, id: int):
        """Track new YouTube content and send notifications via Telegram bot."""
        from pytubefix import Channel
        try:
            channel = Channel(channel_url, proxies=self.proxies)
        except:
            return "–î–∞–Ω–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."
        last_video = channel.videos[0].watch_url if channel.videos else None
        last_short = channel.shorts[0].watch_url if channel.shorts else None
        last_live = channel.live[0].watch_url if channel.live else None
        async with aiohttp.ClientSession() as session:
            while True:
                channel = Channel(channel_url, proxies=self.proxies)  # Refresh channel data
                if channel.videos and channel.videos[0].watch_url != last_video:
                    last_video = channel.videos[0].watch_url
                    text = f'–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ —É –∞–≤—Ç–æ—Ä–∞ {channel.title}.\n–ù–∞–∑–≤–∞–Ω–∏–µ: {channel.videos[0].title}\n–°—Å—ã–ª–∫–∞: {channel.videos[0].watch_url}'
                    async with session.post(f'https://api.telegram.org/bot{token_of_bot}/sendMessage?chat_id={id}&text={text}', proxy=self.proxies.get('https')) as response:
                        await response.read()
                elif channel.shorts and channel.shorts[0].watch_url != last_short:
                    last_short = channel.shorts[0].watch_url
                    text = f'–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ —É –∞–≤—Ç–æ—Ä–∞ {channel.title}.\n–ù–∞–∑–≤–∞–Ω–∏–µ: {channel.shorts[0].title}\n–°—Å—ã–ª–∫–∞: {channel.shorts[0].watch_url}'
                    async with session.post(f'https://api.telegram.org/bot{token_of_bot}/sendMessage?chat_id={id}&text={text}', proxy=self.proxies.get('https')) as response:
                        await response.read()
                elif channel.live and channel.live[0].watch_url != last_live:
                    last_live = channel.live[0].watch_url
                    text = f'–í—ã—à–ª–æ –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ —É –∞–≤—Ç–æ—Ä–∞ {channel.title}.\n–ù–∞–∑–≤–∞–Ω–∏–µ: {channel.live[0].title}\n–°—Å—ã–ª–∫–∞: {channel.live[0].watch_url}'
                    async with session.post(f'https://api.telegram.org/bot{token_of_bot}/sendMessage?chat_id={id}&text={text}', proxy=self.proxies.get('https')) as response:
                        await response.read()
                await asyncio.sleep(0.5)

    async def searching_musics_vk(self, query: str, count: int = 3):
        """Search for music on VK."""
        if not self.token_of_vk:
            return "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ —É–∫–∞–∑–∞—Ç—å —Ç–æ–∫–µ–Ω –æ—Ç –í–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ –≤ VK."
        service = Service('KateMobileAndroid/56 lite-460 (Android 4.4.2; SDK 19; x86; unknown Android SDK built for x86; en)', self.token_of_vk)
        songs = await asyncio.to_thread(lambda: [track.to_dict() for track in service.search_songs_by_text(query, count)])
        return songs

    async def get_last_post(self, query: str):
        """Get the latest post from a VK public."""
        vk_session = vk_api.VkApi(token=self.token_of_vk)
        vk = vk_session.get_api()
        response = await asyncio.to_thread(vk.groups.search, q=query, type='group', count=1)
        if response['count'] > 0:
            response1 = await asyncio.to_thread(vk.wall.get, owner_id=-int(response['items'][0]['id']), count=1)
            try:
                post = response1['items'][0]
                text = post.get('text', '–¢–µ–∫—Å—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')
                post_id = post['id']
                owner_id = post['owner_id']
                link = f"https://vk.com/wall{owner_id}_{post_id}"
                likes = post['likes']['count']
                views = post['views']['count']
                reposts = post['reposts']['count']
                return {"text": text, "post_id": post_id, "owner_id": owner_id, "link": link, 'views': views, 'reposts': reposts, 'likes': likes}
            except:
                return None
        return None
    async def image_text_recognition(self, img: bytes, lang: str = 'ru'):
        """–†–∞–∑–±–æ—Ä —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏, —Å –ø–æ–º–æ—â—å—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ Google Cloud.\nimg: –≤–∞—à–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ bytes.\nlang: —è–∑—ã–∫ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏."""
        import base64
        if not self.google_key:
            return '–î–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º –í–∞—à Google Cloud API –∫–ª—é—á. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –≤ —Ä–∞–∑–¥–µ–ª–µ Enabled APIs & Services –µ—Å—Ç—å Vision AI API.'
        else:
            image = base64.b64encode(img).decode("utf-8")

            # –¢–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞
            request_body = {
                "requests": [
                    {
                        "image": {
                            "content": image
                        },
                        "features": [
                            {
                                "type": "LABEL_DETECTION",
                                "maxResults": 10
                            }
                        ],
                        "imageContext": {
                            "languageHints": lang
                        }
                    }
                ]
            }

            # URL
            url = f"https://vision.googleapis.com/v1/images:annotate?key={self.google_key}"

            # –ó–∞–≥–æ–ª–æ–≤–∫–∏
            headers = {
                "Content-Type": "application/json"
            }

            # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=request_body, headers=headers, proxy=self.proxies.get('https') if self.proxies else None) as response:
                    return {"code": response.status, "answer": await response.json()}
    async def minecraft_server_info(self, ip: str, port: int = None, type_: str = 'java'):
        """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ Minecraft-—Å–µ—Ä–≤–µ—Ä–µ.\nip: ip/host —Å–µ—Ä–≤–µ—Ä–∞, –∏–ª–∏ –¥–æ–º–µ–Ω. –¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å ip:port.\nport: –ø–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞, –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª–µ–Ω.\ntype: java, –∏–ª–∏ bedrock."""
        if type_ in ['java', 'bedrock']:
            try:
                if type_ == 'java':
                    if not port:
                        server = JavaServer(ip)
                    else:
                        server = JavaServer(ip, port)
                    latency = await asyncio.to_thread(server.ping)
                    query = await asyncio.to_thread(server.query)
                    status = await asyncio.to_thread(server.status)
                    return {"latency":latency, 'query':{"query_motd":query.motd.to_ansi(), 'query_map':query.map, 'query_players_count':query.players.online, 'query_players_max':query.players.max, 'all_info':query.as_dict()}, 'status':{"query_motd":status.motd.to_ansi(), 'description':status.description, 'icon_of_server_base64':status.icon, 'query_players_count':query.players.online, 'query_players_max':query.players.max, 'version':status.version.name, 'all_info':status.as_dict()}}
                else:
                    if not port:
                        server = BedrockServer(ip)
                    else:
                        server = BedrockServer(ip, port)
                    status = await asyncio.to_thread(server.status)
                    return {"status":status.as_dict()}
            except:
                return
        else:
            return
                
    async def rcon_send(self, command: str):
        """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ RCON.\n–¢—Ä–µ–±—É–µ—Ç rcon_ip, rcon_port –∏ rcon_password –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö AsyncFunctionsObject.\ncommand: –∫–æ–º–∞–Ω–¥–∞ —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏. –ü—Ä–∏–º–µ—Ä: `say –ü—Ä–∏–≤–µ—Ç!`\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞."""
        if not self.rcon_server:
            return 'RCON —Å–µ—Ä–≤–µ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —É–∫–∞–∑–∞–ª–∏ –ª–∏ –í—ã –Ω—É–∂–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞.'
        else:
            await self.rcon_server.connect()
            return await self.rcon_server.send_cmd(command)
        
    async def gpt_4o_req(self, prompt: str, max_tokens: int = 4096, proxy: str = None, image: bytes = None):
        """–§–∏–≥–Ω—è –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ GPT-4o-mini.\nprompt: —Å–∞–º –∑–∞–ø—Ä–æ—Å –∫ –Ω–µ–π—Ä–æ–Ω–∫–µ.\nmax_tokens: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, 4096.\nproxy: –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –≤ FunctionsObject.\nimage: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ bytes, –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ —Ñ–æ—Ç–æ."""
        if not image:
            if not proxy:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', OIVSCodeSer2(), proxy=self.proxies.get('http'), max_tokens=max_tokens)
            else:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', OIVSCodeSer2(), proxy=proxy, max_tokens=max_tokens)
            return req.choices[0].message.content
        else:
            if not proxy:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', PollinationsAI, proxy=self.proxies.get('http'), max_tokens=max_tokens, web_search=True, image=image)
            else:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'gpt-4o-mini', PollinationsAI, proxy=proxy, max_tokens=max_tokens, web_search=True, image=image)
            return req.choices[0].message.content
    async def flux_pro_gen(self, prompt: str, proxy: str = None):
        """–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±–æ–ª–µ–µ –ª—É—á—à–∏—Ö –∫–∞—Ä—Ç–∏–Ω–æ–∫ —á–µ—Ä–µ–∑ flux-pro.\nprompt: –∑–∞–ø—Ä–æ—Å –¥–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–∏.\nproxy: –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –∫–ª–∞—Å—Å–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)."""
        if proxy:
            img = await self.client_for_gpt.images.async_generate(prompt, 'flux-pro', Together, 'url', proxy)
        else:
            img = await self.client_for_gpt.images.async_generate(prompt, 'flux-pro', Together, 'url', self.proxies.get('http'))
        urls = []
        for i in img.data:
            urls.append(i.url)
        return urls
    async def add_watermark(self, text: str, image: bytes, font: str, position: tuple[int] = (10, 10)):
        """–§—É–Ω–∫—Ü–∏—è –∏–∑ FunctionsObject."""
        return await asyncio.to_thread(self.sync_functions_object.add_watermark, text, image, font, position)
    async def deepseek_v3_0324(self, prompt: str, max_tokens: int = 4096, expression: str = 'auto', proxy: str = None):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ DeepSeek-v3-0324.\nprompt: –∑–∞–ø—Ä–æ—Å –∫ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏.\nmax_tokens: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ.\nexpression: —Ç–æ–Ω. –¢—Ä–∏ —Ä–µ–∂–∏–º–∞: `auto`, `toxic`, `non-toxic`.\nproxy: –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –∫–ª–∞—Å—Å–∞."""
        if expression == 'auto':
            if proxy:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'deepseek-v3', Together, proxy=proxy, max_tokens=max_tokens)
            else:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt}], 'deepseek-v3', Together, proxy=self.proxies.get('http'), max_tokens=max_tokens)
            return req.choices[0].message.content
        elif expression == 'toxic':
            if proxy:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":f'–Ω–µ –æ—Ç–≤–µ—á–∞–π –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã –ø–æ–∑–∏—Ç–∏–≤–Ω–æ –∏ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ —Å –º–∞—Ç–∞–º–∏, –Ω–∞ –∫–∞–∂–¥–æ–µ –º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –±–µ–∑ —Ä–∞–∑–Ω–∏—Ü—ã, –æ–±—Ä–∞—â–∞—é—Å—å —è –∫ —Ç–µ–±–µ –º–∏–ª–æ –∏–ª–∏ –Ω–µ—Ç, –≤—Å–µ–≥–æ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ\n–ó–∞–ø—Ä–æ—Å: "{prompt}"'}], 'deepseek-v3-0324', Together, proxy=proxy, max_tokens=max_tokens)
            else:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":f'–Ω–µ –æ—Ç–≤–µ—á–∞–π –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã –ø–æ–∑–∏—Ç–∏–≤–Ω–æ –∏ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ —Å –º–∞—Ç–∞–º–∏, –Ω–∞ –∫–∞–∂–¥–æ–µ –º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –±–µ–∑ —Ä–∞–∑–Ω–∏—Ü—ã, –æ–±—Ä–∞—â–∞—é—Å—å —è –∫ —Ç–µ–±–µ –º–∏–ª–æ –∏–ª–∏ –Ω–µ—Ç, –≤—Å–µ–≥–æ –æ—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≥—Ä—É–±–æ\n–ó–∞–ø—Ä–æ—Å: "{prompt}"'}], 'deepseek-v3-0324', Together, proxy=self.proxies.get('http'), max_tokens=max_tokens)
            return req.choices[0].message.content
        elif expression == 'non-toxic':
            if proxy:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt + '\nnon-toxic'}], 'deepseek-v3', Together, proxy=proxy, max_tokens=max_tokens)
            else:
                req = await self.client_for_gpt.chat.completions.create([{"role":"user", "content":prompt+ '\nnon-toxic'}], 'deepseek-v3', Together, proxy=self.proxies.get('http'), max_tokens=max_tokens)
            return req.choices[0].message.content
        else:
            return 'expression —É–∫–∞–∑–∞–Ω –Ω–µ–≤–µ—Ä–Ω–æ! auto, toxic, –ª–∏–±–æ non-toxic!'
    async def youtube_playlist_download(self, url: str, regime: str = 'audio'):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞ —Å YouTube.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç.\nregime: —á—Ç–æ —Å–∫–∞—á–∏–≤–∞—Ç—å: –∞—É–¥–∏–æ, –∏–ª–∏ –≤–∏–¥–µ–æ?\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫, –∞ —Ç–æ—á–Ω–µ–µ `list[bytes]` —Å –≤–∏–¥–µ–æ."""
        return await asyncio.to_thread(self.sync_functions_object.youtube_playlist_download, url, regime)
    async def pornhub_search(self, query: str, count: int = 5, quality: str = 'best', account: InitPornHubAccount = None, proxies: dict[str, str] = None, checking_was_downloaded: bool = False) -> list[bytes]:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–∏–¥–µ–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∏—Ö —Å PornHub. –§—É–Ω–∫—Ü–∏—è –Ω–∞—Ä—É—à–∞–µ—Ç ToS PornHub, —Ä–µ–∫–æ–º–µ–Ω–¥—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, –∫–æ—Ç–æ—Ä—ã–µ —É–∫–∞–∑–∞–Ω—ã –≤ –∫–ª–∞—Å—Å–µ.\nquery: –ª–æ–≥–∏—á–Ω–æ, –∑–∞–ø—Ä–æ—Å.\ncount: —Å–∫–æ–ª—å–∫–æ –≤–∏–¥–µ–æ —Ç–µ–±–µ –Ω—É–∂–Ω–æ?\nquality: –≤ –∫–∞–∫–æ–º –∫–∞—á–µ—Å—Ç–≤–µ –∫–∞—á–∞—Ç—å? –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, `best`. –ï—Å—Ç—å: worst, best –∏ half.\naccount: —É–∫–∞–∂–∏—Ç–µ —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç, –Ω–æ —ç—Ç–æ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ.\nproxies: –∫–∞—Å—Ç–æ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏, –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ –¥–ª—è –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.\nchecking_was_downloaded: –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –±—ã–ª–∏-–ª–∏ –≤–∏–¥–µ–æ –∑–∞—Ä–∞–Ω–µ–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã."""
        return await asyncio.to_thread(self.sync_functions_object.pornhub_search, query, count, quality, account, proxies, checking_was_downloaded)
    async def pornhub_download_by_url(self, url: str, quality: str = 'best', account: InitPornHubAccount = None, proxies: dict[str, str] = None):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å PornHub –ø–æ —Å—Å—ã–ª–∫–µ.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ.\nquality: –∫–∞—á–µ—Å—Ç–≤–æ.\naccount: –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–∞ PornHub.\nproxies: –∫–∞—Å—Ç–æ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏ –¥–ª—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –µ—Å–ª–∏ –µ—Å—Ç—å."""
        return await asyncio.to_thread(self.sync_functions_object.pornhub_download_by_url, url, quality, account, proxies)
    async def pornhub_video_information(self, url: str, account: InitPornHubAccount = None, proxies: dict[str, str] = None) -> dict:
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–≤–æ–¥–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ, –±–µ–∑ –µ–≥–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ.\naccount: –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç.\nproxies: –∫–∞—Å—Ç–æ–º–Ω—ã–µ –ø—Ä–æ–∫—Å–∏ –¥–ª—è —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏."""
        return await asyncio.to_thread(self.sync_functions_object.pornhub_video_information, url, account, proxies)
    async def parse_kwork(self, category: int, pages: int = 1) -> list[KworkOffer]:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –Ω–∞ kwork.\ncategory: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞.\npages: —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å–ø–∞—Ä—Å–∏—Ç—å? –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, 1.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å –∫–≤–æ—Ä–∫–∞–º–∏."""
        return await asyncio.to_thread(self.sync_functions_object.parse_kwork, category, pages)
    async def info_about_faces_on_photo(self, photo: bytes):
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–¥–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–µ–ª–æ–≤–µ–∫–µ –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –∏–ª–∏ –æ –ª—é–¥—è—Ö.\nphoto: –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –≤ –±–∞–π—Ç–∞—Ö.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `list[FaceInfo]` –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –ª—é–¥–µ–π –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏.\n–î–õ–Ø –î–ê–ù–ù–û–ô –§–£–ù–ö–¶–ò–ò –ñ–ï–õ–ê–¢–ï–õ–¨–ù–û –ò–ú–ï–¢–¨ –ü–†–û–¶–ï–°–°–û–† –° –ü–û–î–î–ï–†–ñ–ö–û–ô AVX-AVX2 –ò–ù–°–¢–†–£–ö–¶–ò–ô. –ï–°–õ–ò –í–´–õ–ê–ó–ò–¢ –û–®–ò–ë–ö–ê - –ò–°–ü–û–õ–¨–ó–£–ô–¢–ï –ü–ê–¢–ß –î–õ–Ø TENSORFLOW."""
        return await asyncio.to_thread(self.sync_functions_object.info_about_faces_on_photo, photo)
    async def rtmp_livestream(self, video: bytes, server: RTMPServerInit, ffmpeg_dir: str = 'ffmpeg', resolution: str = '1280x720', bitrate: str = '3000k', fps: str = '30'):
        """–°—Ç—Ä–∏–º–∏—Ç –≤–∏–¥–µ–æ –∏–∑ –±–∞–π—Ç–æ–≤ –Ω–∞ RTMPS-—Å–µ—Ä–≤–µ—Ä —Å FFmpeg –ø–æ–¥ CPU. –¢—Ä–µ–±—É–µ—Ç FFmpeg."""
        return await asyncio.to_thread(self.sync_functions_object.rtmp_livestream, video, server, ffmpeg_dir, resolution, bitrate, fps)
    async def cut_link(self, url: str, proxies: dict[str, str] = None) -> str:
        """–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å API —Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫ `clck.ru`.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ.\nproxies: –ø—Ä–æ–∫—Å–∏, –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –æ–Ω–∏ –±–µ—Ä—É—Ç—Å—è —Å –∫–ª–∞—Å—Å–∞.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –≤ `str`."""
        return await asyncio.to_thread(self.sync_functions_object.cut_link, url, proxies)
    def detect_new_kworks(self, func, category: int = 11, pages: int = 1, delay: int = 300):
        """–ü—Ä–∏–≤–µ—Ç! –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è - –≤—Ä–∞–ø–ø–µ—Ä –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –Ω–∞ –±–∏—Ä–∂–µ Kwork.\n–Æ–ó–ê–ô–¢–ï –í –ö–ê–ß–ï–°–¢–í–ï –î–ï–ö–û–†–ê–¢–û–†–ê."""
        async def wrapper(*args, **kwargs):
            start_kworks = await self.parse_kwork(category, pages)
            new = []
            
            for i in start_kworks:
                new.append(i.url)
                
            while True:
                new_kworks = await self.parse_kwork(category, pages)
                for kwork in new_kworks:
                    if kwork.url in new:
                        pass
                    else:
                        new.append(kwork.url)
                        if asyncio.iscoroutinefunction(func):
                            await func(kwork)
                        else:
                            func(kwork)
                await asyncio.sleep(delay)
        return wrapper
    async def download_tiktok_video(self, url: str, dir: str, filename: str = None, youtube_dl_parameters: dict = None) -> dict:
        """–°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ –≤ —É–∫–∞–∑–∞–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ.\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ.\ndir: –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è, –∫—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∏–¥–µ–æ.\nfilename: –∏–º—è —Ñ–∞–π–ª–∞. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞–º–∏.\nyoutube_dl_parameters: –º—ã —Å–∞–º–∏ –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã yt-dlp. –ó–Ω–∞–π—Ç–µ, —á—Ç–æ –¥–µ–ª–∞–µ—Ç–µ."""
        return await asyncio.to_thread(self.sync_functions_object.download_tiktok_video, url, dir, filename, youtube_dl_parameters)
    async def twitch_clips_download(self, url: str, dir: str, filename: str = None, youtube_dl_parameters: dict = None) -> dict:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∫–ª–∏–ø–æ–≤ —Å Twitch!\nurl: —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ç–≤–∏—Ç—á-–∫–ª–∏–ø.\ndir: –∫—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å?\nfilename: –∏–º—è —Ñ–∞–π–ª–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏.\nyoutube_dl_parameters: –ø–∞—Ä–∞–º–µ—Ç—Ä—ã YoutubeDL."""
        return await asyncio.to_thread(self.sync_functions_object.twitch_clips_download, url, dir, filename, youtube_dl_parameters)
    async def vk_rutube_dzen_video_download(self, url: str, dir: str, filename: str = None, youtube_dl_parameters: dict = None):
        """–§—É–Ω–∫—Ü–∏—è –ø–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏—é –≤–∏–¥–µ–æ –í–ö, –†—É—Ç—É–±–∞ –∏ –î–∑–µ–Ω–∞!\n–ü–∞—Ä–∞–º–µ—Ç—Ä—ã, –∫–∞–∫ –≤–µ–∑–¥–µ. –†–∞–∑–±–µ—Ä–µ—Ç–µ—Å—å."""
        return await asyncio.to_thread(self.sync_functions_object.vk_rutube_dzen_video_download, url, dir, filename, youtube_dl_parameters)
    async def unpack_zip_jar_apk_others(self, file, dir: str, delete_original: bool = False):
        """"–§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏ –ª—é–±—ã—Ö –∞—Ä—Ö–∏–≤–æ–≤. –î–∞–∂–µ Jar (Java Archive) –∏ APK.\nfile: —Ñ–∞–π–ª –≤ io.BytesIO(), –∏–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∫ –Ω–µ–º—É.\ndir: –º–µ—Å—Ç–æ –¥–ª—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏.\ndelete_original: —É–¥–∞–ª—è—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª? (–†–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –≤ file)\n–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None."""
        return await asyncio.to_thread(self.sync_functions_object.unpack_zip_jar_apk_others, file, dir, delete_original)
    async def photo_upscale(self, image: bytes, factor: int = 4) -> bytes:
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ –∞–ø—Å–∫–µ–π–ª–∞ —Ñ–æ—Ç–æ —á–µ—Ä–µ–∑ Pillow (–±–∏–∫—É–±–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥).\nimage: —Ñ–æ—Ç–æ –≤ bytes.\nfactor: –≤–æ —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å —Ñ–æ—Ç–æ (width –∏ height).\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç bytes."""
        return await asyncio.to_thread(self.sync_functions_object.photo_upscale, image, factor)
    async def change_format_of_photo(self, image: bytes, format_: ImageFormat):
        """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.\nimage: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ bytes.\nformat_: —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, —É–∫–∞–∑–∞–Ω–Ω—ã–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∫–ª–∞—Å—Å–æ–º."""
        return await asyncio.to_thread(self.sync_functions_object.change_format_of_photo, image, format_)
    async def get_vk_user(self, user_id: str) -> Optional[VkUser]:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è VkUser –ø–æ user_id –∏–ª–∏ @username."""
        return await asyncio.to_thread(self.sync_functions_object.get_vk_user, user_id)

class AsyncYandexParser:
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –∫–∞—Ä—Ç–∏–Ω–æ–∫ —Å –Ø–Ω–¥–µ–∫—Å–∞.\n–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ HTTP(s) –ø—Ä–æ–∫—Å–∏ —Å –∏–º–µ–Ω–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø–∞—Ä–æ–ª–µ–º. –¢–∞–∫–∂–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ Google Chrome –Ω–∞ –º–∞—à–∏–Ω—É.\nis_headless: —Å–∫—Ä—ã–≤–∞—Ç—å –æ–∫–Ω–æ —Å –ø–∞—Ä—Å–µ—Ä–æ–º?"""

    def __init__(self, proxy_host: str = None, proxy_port: int = None, proxy_user: str = None, proxy_pass: str = None, is_headless:bool=False, arguments: list[str] = None, extensions: list[str] = None):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –∫–∞—Ä—Ç–∏–Ω–æ–∫ —Å –Ø–Ω–¥–µ–∫—Å–∞.\n–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ HTTP(s) –ø—Ä–æ–∫—Å–∏ —Å –∏–º–µ–Ω–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø–∞—Ä–æ–ª–µ–º. –¢–∞–∫–∂–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ Google Chrome –Ω–∞ –º–∞—à–∏–Ω—É.\nis_headless: —Å–∫—Ä—ã–≤–∞—Ç—å –æ–∫–Ω–æ —Å –ø–∞—Ä—Å–µ—Ä–æ–º?\narguments: –∞—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –ø–∞—Ä—Å–µ—Ä–∞. –ü—Ä–∏–º–µ—Ä: ['--headless', '--no-sandbox', ...]\nextensions: —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–∞–º–æ–ø–∏—Å–Ω—ã–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ `.crx`, –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∫ –Ω–∏–º. –ü—Ä–∏–º–µ—Ä: ['C:/osu.crx', 'D:/minecraft.crx']"""
        self.proxy_host = proxy_host
        self.proxy_port = proxy_port
        self.proxy_user = proxy_user
        self.proxy_pass = proxy_pass
        self.isheadless = is_headless
        self.arguments = arguments
        self.extensions = extensions
        print(f'–ü–∞—Ä—Å–µ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω, —Å—É—á–∫–∏!\n–ù–∞—á–Ω–∏—Ç–µ –ø–∞—Ä—Å–∏—Ç—å —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏ start_parsing.')

    def create_proxy_auth_extension(self):
        """–°–æ–∑–¥–∞—ë–º –ø–ª–∞–≥–∏–Ω –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∫—Å–∏, –±–ª—è—Ç—å."""
        if all([self.proxy_host, self.proxy_port, self.proxy_user, self.proxy_pass]):
            manifest_json = """
            {
                "version": "1.0.0",
                "manifest_version": 2,
                "name": "Chrome Proxy",
                "permissions": [
                    "proxy",
                    "tabs",
                    "unlimitedStorage",
                    "storage",
                    "<all_urls>",
                    "webRequest",
                    "webRequestBlocking"
                ],
                "background": {
                    "scripts": ["background.js"]
                }
            }
            """

            background_js = """
            var config = {
                mode: "fixed_servers",
                rules: {
                    singleProxy: {
                        scheme: "http",
                        host: "%s",
                        port: parseInt(%s)
                    },
                    bypassList: ["localhost"]
                }
            };

            chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});

            chrome.webRequest.onAuthRequired.addListener(
                function(details) {
                    return {
                        authCredentials: {
                            username: "%s",
                            password: "%s"
                        }
                    };
                },
                {urls: ["<all_urls>"]},
                ['blocking']
            );
            """ % (self.proxy_host, self.proxy_port, self.proxy_user, self.proxy_pass)

            plugin_file = 'proxy_auth_plugin.zip'
            with zipfile.ZipFile(plugin_file, 'w') as zp:
                zp.writestr("manifest.json", manifest_json)
                zp.writestr("background.js", background_js)
            
            return plugin_file
        else:
            return None

    async def download_image(self, session: aiohttp.ClientSession, img_url: list[str]):
        """–ö–∞—á–∞–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –±–ª—è—Ç—å."""
        images: list[YandexImage] = []
        if not all([self.proxy_host, self.proxy_port, self.proxy_user, self.proxy_pass]):
            for url in tqdm(img_url, desc='–°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...', ncols=70):
                if url.startswith(('http://', 'https://')):
                    try:
                        async with session.get(url) as response:
                            if response.status == 200:
                                images.append(YandexImage({'data':await response.read(), 'url':url}))
                    except:
                        pass
            return images
        else:
            proxy_auth = aiohttp.BasicAuth(login=self.proxy_user, password=self.proxy_pass)
            for url in tqdm(img_url, desc='–°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...', ncols=70):
                try:
                    if url.startswith(('http://', 'https://')):
                        async with session.get(url, proxy=f'http://{self.proxy_host}:{self.proxy_port}', proxy_auth=proxy_auth) as response:
                            if response.status == 200:
                                images.append(YandexImage({'data':await response.read(), 'url':url}))
                except:
                    pass
            return images

    async def start_parsing(self, query: str, max_images=10, scrolly=5, pages:int=6):
        """–ù–∞—á–∞—Ç—å –ø–∞—Ä—Å–∏—Ç—å..\nquery: –∑–∞–ø—Ä–æ—Å. –ü—Ä–∏–º–µ—Ä: –∫–æ—Ç–∏–∫–∏.\nmax_images: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–∏–Ω–æ–∫ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏.\nscrolly: —Å–∫–æ–∫–∞ —Å–∫—Ä–æ–ª–ª–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫–∏?\npages: —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü —Å –∫–∞—Ä—Ç–∏–Ω–∫–∞–º–∏ –ø–∞—Ä—Å–∏—Ç—å?"""
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±—Ä–∞—É–∑–µ—Ä–∞
        try:
            proxy_plugin = self.create_proxy_auth_extension()
            chrome_options = Options()
            if proxy_plugin:
                chrome_options.add_extension(proxy_plugin)
            chrome_options.add_argument("--log-level=1")
            if self.isheadless:
                chrome_options.add_argument('--headless')
            if self.arguments:
                print(f'–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤..')
                for arg in self.arguments:
                    chrome_options.add_argument(arg)
                print(f'–ì–æ—Ç–æ–≤–æ.')
            else:
                print(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.')
            if self.extensions:
                print(f'–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π..')
                for ext in self.extensions:
                    chrome_options.add_extension(ext)
                print(f'–ì–æ—Ç–æ–≤–æ.')
            else:
                print(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.')
            driver = webdriver.Chrome(service=Service1(ChromeDriverManager().install()), options=chrome_options)
            print("–ë—Ä–∞—É–∑–µ—Ä –∑–∞–ø—É—Å—Ç–∏–ª—Å—è, –∞—Ö—É–µ—Ç—å!")
        except Exception as e:
            print(f"–ù–µ –º–æ–≥—É –∑–∞–ø—É—Å—Ç–∏—Ç—å Chrome, –ø–∏–∑–¥–µ—Ü: {e}")
            return

        image_urls = []
        try:
            for p in range(1, pages + 1):
                url = f"https://yandex.ru/images/search?text={query}&p={p}"
                driver.get(url)
                print(f"–ó–∞—à—ë–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É ({p}), –∂–¥—ë–º, –±–ª—è—Ç—å")
                
                # –ñ–¥—ë–º –∑–∞–≥—Ä—É–∑–∫—É –ø–∏–∫—á
                await asyncio.sleep(10)
                
                # –°–∫—Ä–æ–ª–ª–∏–º
                for _ in range(scrolly):
                    driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                    await asyncio.sleep(2.5)
                    print("–°–∫—Ä–æ–ª–ª—é, —Å—É–∫–∞")
                
                all_images = driver.find_elements(By.TAG_NAME, "img")
                print(f"–í—Å–µ–≥–æ —Ç–µ–≥–æ–≤ <img> –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ: {len(all_images)}")
                if all_images:
                    for img in all_images[:max_images]:
                        img_url = img.get_attribute("src")
                        if img_url and "http" in img_url:
                            image_urls.append(img_url)
                else:
                    print(f"–ù–∏ –æ–¥–Ω–æ–≥–æ <img> –Ω–µ –Ω–∞—à—ë–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {p}, –ø–∏–∑–¥–µ—Ü –ø–æ–ª–Ω—ã–π")

        except Exception as e:
            print(f"–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –ø–æ –ø–∏–∑–¥–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {p}: {e}")

        driver.quit()
        print("–ë—Ä–∞—É–∑–µ—Ä –∑–∞–∫—Ä—ã–ª, –ø–∏–∑–¥–µ—Ü, –≥–æ—Ç–æ–≤–æ")
        if proxy_plugin and os.path.exists(proxy_plugin):
            os.remove(proxy_plugin)

        # –ö–∞—á–∞–µ–º –∫–∞—Ä—Ç–∏–Ω–∫–∏
        if image_urls:
            print(f"–ù–∞—á–∏–Ω–∞–µ–º –∫–∞—á–∞—Ç—å {len(image_urls)} –∫–∞—Ä—Ç–∏–Ω–æ–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –±–ª—è—Ç—å...")
            async with aiohttp.ClientSession(headers={"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36"}) as client:
                result = await self.download_image(client, image_urls)
                return result
        else:
            print("–ù–∏—Ö—É—è –Ω–µ —Å–∫–∞—á–∞–ª, –∫–∞—Ä—Ç–∏–Ω–æ–∫ –Ω–µ—Ç, –ø–∏–∑–¥–µ—Ü")
            return
    def filter_by_resolution(self, images: list[YandexImage], resolutions: list[Resolution]):
        """–î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –Ω—É–∂–Ω–∞ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ –Ω—É–∂–Ω—ã–º –≤–∞–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è–º.\nimages: —Å–ø–∏—Å–æ–∫ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏, –∫ –ø—Ä–∏–º–µ—Ä—É —Å–æ start_parsing.\nresolutions: –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è (–∫–∞—á–µ—Å—Ç–≤–∞). –ö –ø—Ä–∏–º–µ—Ä—É, [Resolution({"width":1080, "height":1920})]\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥—Ö–æ–¥—è—Ç –ø–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è–º (list[YandexImage])."""
        from tqdm import tqdm as sync_tqdm
        resolutions_dict: list[dict] = []
        new_images: list[YandexImage] = []

        for res in resolutions:
            resolutions_dict.append(res.data)

        for image in sync_tqdm(images, f'–§–∏–ª—å—Ç—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...', ncols=70, unit='P', unit_scale=True):
            if image.get_resolution().data in resolutions_dict:
                new_images.append(image)
            else:
                pass
        return new_images
            
class TelethonThings:
    def __init__(self, app_id: int, app_hash: str, phone: str, app_version: str = '4.16.30-vxCUSTOM', system_version: str = 'Win11', device_model: str = 'FlorestTHINGS YEAH', session_name: str = 'FlorestAbobus', **attrs):
        """–ö–æ—Ä–æ—á–µ. –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Telegram.\n–§—É–Ω–∫—Ü–∏–∏: –ø–∞—Ä—Å–∏–Ω–≥ –≥—Ä—É–ø–ø –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç–µ (–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–∏), –∞ —Ç–∞–∫–∂–µ –º–∞—Å—Å–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –ø–æ –Ω–∏–∫–∞–º.\n–î–∞–Ω–Ω—ã–µ –±–µ—Ä–∏—Ç–µ —Å my.telegram.org.\napp_id: ID –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –≤ Telegram.\napp_hash: –∫–ª—é—á, —Ö—ç—à –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\nphone: –Ω–æ–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∞–∫–∫–∞—É–Ω—Ç—É.\napp_version: –∫–∞—Å—Ç–æ–º–Ω–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\nsystem_version: –≤–µ—Ä—Å–∏—è –û–°(–ª—é–±–∞—è).\ndevice_model: —Ç–∏–ø–æ –∏–º—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞. –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±–∞—è —Ö—Ä–µ–Ω—å.\nsession_name: –∏–º—è —Å–µ—Å—Å–∏–∏.\nattrs: –Ω—É –∫–æ—Ä–æ—á–µ, –¥—Ä—É–≥–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –≤ telethon."""
        if not attrs.pop('connection', None):
            self.client = TelegramClient(session_name, app_id, app_hash, app_version=app_version, system_version=system_version, device_model=device_model, proxy=attrs.pop('proxy', None), use_ipv6=attrs.pop('use_ipv6', None), local_addr=attrs.pop('local_addr', None), timeout=attrs.pop('timeout', 10), request_retries=attrs.pop('request_retries', 5), connection_retries=attrs.pop('connection_retries', 5), retry_delay=attrs.pop('retry_delay', 1), auto_reconnect=attrs.pop('auto_reconnect', True), sequential_updates=attrs.pop('sequential_updates', False), flood_sleep_threshold=attrs.pop('flood_sleep_threshold', 60), raise_last_call_error=attrs.pop('raise_last_call_error', False), lang_code=attrs.pop('lang_code', 'en'), system_lang_code=attrs.pop('system_lang_code', 'en'), base_logger=attrs.pop('base_logger', None), receive_updates=attrs.pop('receive_updates', None), catch_up=attrs.pop('catch_up', False), entity_cache_limit=attrs.pop('entity_cache_limit', 5000))
            self.client.start(phone=phone)
        else:
            self.client = TelegramClient(session_name, app_id, app_hash, app_version=app_version, system_version=system_version, device_model=device_model, proxy=attrs.pop('proxy', None), use_ipv6=attrs.pop('use_ipv6', None), local_addr=attrs.pop('local_addr', None), timeout=attrs.pop('timeout', 10), request_retries=attrs.pop('request_retries', 5), connection_retries=attrs.pop('connection_retries', 5), retry_delay=attrs.pop('retry_delay', 1), auto_reconnect=attrs.pop('auto_reconnect', True), sequential_updates=attrs.pop('sequential_updates', False), flood_sleep_threshold=attrs.pop('flood_sleep_threshold', 60), raise_last_call_error=attrs.pop('raise_last_call_error', False), lang_code=attrs.pop('lang_code', 'en'), system_lang_code=attrs.pop('system_lang_code', 'en'), base_logger=attrs.pop('base_logger', None), receive_updates=attrs.pop('receive_updates', None), catch_up=attrs.pop('catch_up', False), entity_cache_limit=attrs.pop('entity_cache_limit', 5000), connection=attrs.pop('connection'))
            self.client.start(phone=phone)
    def parse_groups(self) -> list[dict]:
        """–ü–∞—Ä—Å–∏—Ç –≥—Ä—É–ø–ø—É —Å –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—É—é –í—ã –≤—ã–±–µ—Ä–µ—Ç–µ.\n–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `list[dict]`."""
        from colorama import Fore
 
        from telethon.tl.functions.messages import GetDialogsRequest
        from telethon.tl.types import InputPeerEmpty
        import asyncio
        
        banner = f"""{Fore.GREEN}
        _____  _                          _    ____
        |  ___|| |  ___   _ __   ___  ___ | |_ |  _ \   __ _  _ __  ___   ___  _ __
        | |_   | | / _ \ | '__| / _ \/ __|| __|| |_) | / _` || '__|/ __| / _ \| '__|
        |  _|  | || (_) || |   |  __/\__ \| |_ |  __/ | (_| || |   \__ \|  __/| |
        |_|    |_| \___/ |_|    \___||___/ \__||_|     \__,_||_|   |___/ \___||_|
        """

        print(f'{banner}\n\n–ü–∞—Ä—Å–µ—Ä, —Å–æ–∑–¥–∞–Ω–Ω—ã–π –¥–ª—è –ª—é–¥–µ–π.')
        chats = []
        last_date = None
        size_chats = 200
        groups=[]

        result = self.client(GetDialogsRequest(
            offset_date=last_date,
            offset_id=0,
            offset_peer=InputPeerEmpty(),
            limit=size_chats,
            hash = 0
            )
        )
        chats.extend(result.chats)
        for chat in chats:
            try:
                if chat.megagroup== True:
                    groups.append(chat)
            except:
                continue
            
        print(f'{Fore.YELLOW}–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã –∏–∑ –ø–µ—Ä–µ—á–Ω—è:')
        i=0
        for g in groups:
            print(F'{Fore.GREEN}{str(i)} - {g.title}')
            i+=1
        g_index = input("–í–≤–µ–¥–∏—Ç–µ –Ω—É–∂–Ω—É—é —Ü–∏—Ñ—Ä—É: ")
        target_group=groups[int(g_index)]

        print(f'{Fore.YELLOW}–£–∑–Ω–∞—ë–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...')
        all_participants = self.client.get_participants(target_group)

        print(f'{Fore.YELLOW}–ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä—Å–∏—Ç—å {all_participants.total} —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.')

        users = []
        
        for user in all_participants:
            users.append({"id":user.id, 'username':f'@{user.username}', 'name':user.first_name, 'surname':user.last_name, 'phone':user.phone, 'is_scam':user.scam, 'is_premium':user.premium, 'last_activity':user.status})
        print(f'{Fore.GREEN}–ü–∞—Ä—Å–∏–Ω–≥ –±—ã–ª –ø—Ä–æ–≤–µ–¥–µ–Ω —É—Å–ø–µ—à–Ω–æ.')
        return users
    def send_mass_messages(self, nicknames_and_ids: list[str], messages: list[str], delay: float = random.uniform(1, 7)) -> None:
        """–†–∞—Å—Å—ã–ª–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\nnicknames_and_ids: –Ω–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∞ —Ç–∞–∫–∂–µ –∏—Ö —Ü–∏—Ñ—Ä–æ–≤—ã–µ ID.\nmessages: —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.\ndelay: –∑–∞–¥–µ—Ä–∂–∫–∏ –≤ —Ä–∞—Å—Å—ã–ª–∫–µ —Å–æ–æ–±—â–µ–Ω–∏–π.\n–§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `None`."""
        import time, asyncio
        import random
        from tqdm import tqdm
        
        for user in tqdm(nicknames_and_ids, desc='–†–∞—Å—Å—ã–ª–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º...', ncols=70):
            for message in messages:
                try:
                    time.sleep(delay)
                    self.client.send_message(user, message)
                except Exception as e:
                    print(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞–ø–∏—Å–∞–Ω–∏–∏ {user}: {e}')
        return None