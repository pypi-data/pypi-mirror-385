# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.create_eval_dto import CreateEvalDto
from ..types.create_eval_dto_messages_item import CreateEvalDtoMessagesItem
from ..types.eval import Eval
from ..types.eval_paginated_response import EvalPaginatedResponse
from ..types.eval_run import EvalRun
from ..types.eval_run_paginated_response import EvalRunPaginatedResponse
from .raw_client import AsyncRawEvalClient, RawEvalClient
from .types.create_eval_run_dto_target import CreateEvalRunDtoTarget
from .types.eval_controller_get_paginated_request_sort_order import EvalControllerGetPaginatedRequestSortOrder
from .types.eval_controller_get_runs_paginated_request_sort_order import EvalControllerGetRunsPaginatedRequestSortOrder
from .types.update_eval_dto_messages_item import UpdateEvalDtoMessagesItem

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class EvalClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawEvalClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawEvalClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawEvalClient
        """
        return self._raw_client

    def eval_controller_get_paginated(
        self,
        *,
        id: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[EvalControllerGetPaginatedRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EvalPaginatedResponse:
        """
        Parameters
        ----------
        id : typing.Optional[str]

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[EvalControllerGetPaginatedRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalPaginatedResponse


        Examples
        --------
        import datetime

        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_get_paginated(
            id="id",
            page=1.1,
            sort_order="ASC",
            limit=1.1,
            created_at_gt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            created_at_lt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            created_at_ge=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            created_at_le=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_gt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_lt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_ge=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_le=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
        )
        """
        _response = self._raw_client.eval_controller_get_paginated(
            id=id,
            page=page,
            sort_order=sort_order,
            limit=limit,
            created_at_gt=created_at_gt,
            created_at_lt=created_at_lt,
            created_at_ge=created_at_ge,
            created_at_le=created_at_le,
            updated_at_gt=updated_at_gt,
            updated_at_lt=updated_at_lt,
            updated_at_ge=updated_at_ge,
            updated_at_le=updated_at_le,
            request_options=request_options,
        )
        return _response.data

    def eval_controller_create(
        self,
        *,
        messages: typing.Sequence[CreateEvalDtoMessagesItem],
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Eval:
        """
        Parameters
        ----------
        messages : typing.Sequence[CreateEvalDtoMessagesItem]
            This is the mock conversation that will be used to evaluate the flow of the conversation.

            Mock Messages are used to simulate the flow of the conversation

            Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls

        name : typing.Optional[str]
            This is the name of the eval.
            It helps identify what the eval is checking for.

        description : typing.Optional[str]
            This is the description of the eval.
            This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        from vapi import ChatEvalAssistantMessageMock, Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_create(
            messages=[ChatEvalAssistantMessageMock()],
        )
        """
        _response = self._raw_client.eval_controller_create(
            messages=messages, name=name, description=description, request_options=request_options
        )
        return _response.data

    def eval_controller_get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Eval:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_get(
            id="id",
        )
        """
        _response = self._raw_client.eval_controller_get(id, request_options=request_options)
        return _response.data

    def eval_controller_remove(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Eval:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_remove(
            id="id",
        )
        """
        _response = self._raw_client.eval_controller_remove(id, request_options=request_options)
        return _response.data

    def eval_controller_update(
        self,
        id: str,
        *,
        messages: typing.Optional[typing.Sequence[UpdateEvalDtoMessagesItem]] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        type: typing.Optional[typing.Literal["chat.mockConversation"]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Eval:
        """
        Parameters
        ----------
        id : str

        messages : typing.Optional[typing.Sequence[UpdateEvalDtoMessagesItem]]
            This is the mock conversation that will be used to evaluate the flow of the conversation.

            Mock Messages are used to simulate the flow of the conversation

            Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls

        name : typing.Optional[str]
            This is the name of the eval.
            It helps identify what the eval is checking for.

        description : typing.Optional[str]
            This is the description of the eval.
            This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.

        type : typing.Optional[typing.Literal["chat.mockConversation"]]
            This is the type of the eval.
            Currently it is fixed to `chat.mockConversation`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_update(
            id="id",
        )
        """
        _response = self._raw_client.eval_controller_update(
            id, messages=messages, name=name, description=description, type=type, request_options=request_options
        )
        return _response.data

    def eval_controller_get_run(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> EvalRun:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalRun


        Examples
        --------
        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_get_run(
            id="id",
        )
        """
        _response = self._raw_client.eval_controller_get_run(id, request_options=request_options)
        return _response.data

    def eval_controller_remove_run(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EvalRun:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalRun


        Examples
        --------
        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_remove_run(
            id="id",
        )
        """
        _response = self._raw_client.eval_controller_remove_run(id, request_options=request_options)
        return _response.data

    def eval_controller_get_runs_paginated(
        self,
        *,
        id: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[EvalControllerGetRunsPaginatedRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EvalRunPaginatedResponse:
        """
        Parameters
        ----------
        id : typing.Optional[str]

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[EvalControllerGetRunsPaginatedRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalRunPaginatedResponse


        Examples
        --------
        import datetime

        from vapi import Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_get_runs_paginated(
            id="id",
            page=1.1,
            sort_order="ASC",
            limit=1.1,
            created_at_gt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            created_at_lt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            created_at_ge=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            created_at_le=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_gt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_lt=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_ge=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at_le=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
        )
        """
        _response = self._raw_client.eval_controller_get_runs_paginated(
            id=id,
            page=page,
            sort_order=sort_order,
            limit=limit,
            created_at_gt=created_at_gt,
            created_at_lt=created_at_lt,
            created_at_ge=created_at_ge,
            created_at_le=created_at_le,
            updated_at_gt=updated_at_gt,
            updated_at_lt=updated_at_lt,
            updated_at_ge=updated_at_ge,
            updated_at_le=updated_at_le,
            request_options=request_options,
        )
        return _response.data

    def eval_controller_run(
        self,
        *,
        target: CreateEvalRunDtoTarget,
        eval: typing.Optional[CreateEvalDto] = OMIT,
        eval_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        target : CreateEvalRunDtoTarget
            This is the target that will be run against the eval

        eval : typing.Optional[CreateEvalDto]
            This is the transient eval that will be run

        eval_id : typing.Optional[str]
            This is the id of the eval that will be run.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]


        Examples
        --------
        from vapi import EvalRunTargetAssistant, Vapi

        client = Vapi(
            token="YOUR_TOKEN",
        )
        client.eval.eval_controller_run(
            target=EvalRunTargetAssistant(),
        )
        """
        _response = self._raw_client.eval_controller_run(
            target=target, eval=eval, eval_id=eval_id, request_options=request_options
        )
        return _response.data


class AsyncEvalClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawEvalClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawEvalClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawEvalClient
        """
        return self._raw_client

    async def eval_controller_get_paginated(
        self,
        *,
        id: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[EvalControllerGetPaginatedRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EvalPaginatedResponse:
        """
        Parameters
        ----------
        id : typing.Optional[str]

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[EvalControllerGetPaginatedRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalPaginatedResponse


        Examples
        --------
        import asyncio
        import datetime

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_get_paginated(
                id="id",
                page=1.1,
                sort_order="ASC",
                limit=1.1,
                created_at_gt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                created_at_lt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                created_at_ge=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                created_at_le=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_gt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_lt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_ge=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_le=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_get_paginated(
            id=id,
            page=page,
            sort_order=sort_order,
            limit=limit,
            created_at_gt=created_at_gt,
            created_at_lt=created_at_lt,
            created_at_ge=created_at_ge,
            created_at_le=created_at_le,
            updated_at_gt=updated_at_gt,
            updated_at_lt=updated_at_lt,
            updated_at_ge=updated_at_ge,
            updated_at_le=updated_at_le,
            request_options=request_options,
        )
        return _response.data

    async def eval_controller_create(
        self,
        *,
        messages: typing.Sequence[CreateEvalDtoMessagesItem],
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Eval:
        """
        Parameters
        ----------
        messages : typing.Sequence[CreateEvalDtoMessagesItem]
            This is the mock conversation that will be used to evaluate the flow of the conversation.

            Mock Messages are used to simulate the flow of the conversation

            Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls

        name : typing.Optional[str]
            This is the name of the eval.
            It helps identify what the eval is checking for.

        description : typing.Optional[str]
            This is the description of the eval.
            This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi, ChatEvalAssistantMessageMock

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_create(
                messages=[ChatEvalAssistantMessageMock()],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_create(
            messages=messages, name=name, description=description, request_options=request_options
        )
        return _response.data

    async def eval_controller_get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Eval:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_get(id, request_options=request_options)
        return _response.data

    async def eval_controller_remove(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Eval:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_remove(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_remove(id, request_options=request_options)
        return _response.data

    async def eval_controller_update(
        self,
        id: str,
        *,
        messages: typing.Optional[typing.Sequence[UpdateEvalDtoMessagesItem]] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        type: typing.Optional[typing.Literal["chat.mockConversation"]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Eval:
        """
        Parameters
        ----------
        id : str

        messages : typing.Optional[typing.Sequence[UpdateEvalDtoMessagesItem]]
            This is the mock conversation that will be used to evaluate the flow of the conversation.

            Mock Messages are used to simulate the flow of the conversation

            Evaluation Messages are used as checkpoints in the flow where the model's response to previous conversation needs to be evaluated to check the content and tool calls

        name : typing.Optional[str]
            This is the name of the eval.
            It helps identify what the eval is checking for.

        description : typing.Optional[str]
            This is the description of the eval.
            This helps describe the eval and its purpose in detail. It will not be used to evaluate the flow of the conversation.

        type : typing.Optional[typing.Literal["chat.mockConversation"]]
            This is the type of the eval.
            Currently it is fixed to `chat.mockConversation`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Eval


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_update(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_update(
            id, messages=messages, name=name, description=description, type=type, request_options=request_options
        )
        return _response.data

    async def eval_controller_get_run(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EvalRun:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalRun


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_get_run(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_get_run(id, request_options=request_options)
        return _response.data

    async def eval_controller_remove_run(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> EvalRun:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalRun


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_remove_run(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_remove_run(id, request_options=request_options)
        return _response.data

    async def eval_controller_get_runs_paginated(
        self,
        *,
        id: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[EvalControllerGetRunsPaginatedRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EvalRunPaginatedResponse:
        """
        Parameters
        ----------
        id : typing.Optional[str]

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[EvalControllerGetRunsPaginatedRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        EvalRunPaginatedResponse


        Examples
        --------
        import asyncio
        import datetime

        from vapi import AsyncVapi

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_get_runs_paginated(
                id="id",
                page=1.1,
                sort_order="ASC",
                limit=1.1,
                created_at_gt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                created_at_lt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                created_at_ge=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                created_at_le=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_gt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_lt=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_ge=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at_le=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_get_runs_paginated(
            id=id,
            page=page,
            sort_order=sort_order,
            limit=limit,
            created_at_gt=created_at_gt,
            created_at_lt=created_at_lt,
            created_at_ge=created_at_ge,
            created_at_le=created_at_le,
            updated_at_gt=updated_at_gt,
            updated_at_lt=updated_at_lt,
            updated_at_ge=updated_at_ge,
            updated_at_le=updated_at_le,
            request_options=request_options,
        )
        return _response.data

    async def eval_controller_run(
        self,
        *,
        target: CreateEvalRunDtoTarget,
        eval: typing.Optional[CreateEvalDto] = OMIT,
        eval_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Dict[str, typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        target : CreateEvalRunDtoTarget
            This is the target that will be run against the eval

        eval : typing.Optional[CreateEvalDto]
            This is the transient eval that will be run

        eval_id : typing.Optional[str]
            This is the id of the eval that will be run.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Dict[str, typing.Optional[typing.Any]]


        Examples
        --------
        import asyncio

        from vapi import AsyncVapi, EvalRunTargetAssistant

        client = AsyncVapi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.eval.eval_controller_run(
                target=EvalRunTargetAssistant(),
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.eval_controller_run(
            target=target, eval=eval, eval_id=eval_id, request_options=request_options
        )
        return _response.data
