# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..types.json_schema import JsonSchema
from ..types.structured_output import StructuredOutput
from ..types.structured_output_paginated_response import StructuredOutputPaginatedResponse
from .types.create_structured_output_dto_model import CreateStructuredOutputDtoModel
from .types.structured_output_controller_find_all_request_sort_order import (
    StructuredOutputControllerFindAllRequestSortOrder,
)
from .types.update_structured_output_dto_model import UpdateStructuredOutputDtoModel

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawStructuredOutputsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def structured_output_controller_find_all(
        self,
        *,
        id: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[StructuredOutputControllerFindAllRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutputPaginatedResponse]:
        """
        Parameters
        ----------
        id : typing.Optional[str]
            This will return structured outputs where the id matches the specified value.

        name : typing.Optional[str]
            This will return structured outputs where the name matches the specified value.

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[StructuredOutputControllerFindAllRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutputPaginatedResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            "structured-output",
            method="GET",
            params={
                "id": id,
                "name": name,
                "page": page,
                "sortOrder": sort_order,
                "limit": limit,
                "createdAtGt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "createdAtLt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "createdAtGe": serialize_datetime(created_at_ge) if created_at_ge is not None else None,
                "createdAtLe": serialize_datetime(created_at_le) if created_at_le is not None else None,
                "updatedAtGt": serialize_datetime(updated_at_gt) if updated_at_gt is not None else None,
                "updatedAtLt": serialize_datetime(updated_at_lt) if updated_at_lt is not None else None,
                "updatedAtGe": serialize_datetime(updated_at_ge) if updated_at_ge is not None else None,
                "updatedAtLe": serialize_datetime(updated_at_le) if updated_at_le is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutputPaginatedResponse,
                    construct_type(
                        type_=StructuredOutputPaginatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_create(
        self,
        *,
        name: str,
        schema: JsonSchema,
        model: typing.Optional[CreateStructuredOutputDtoModel] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        name : str
            This is the name of the structured output.

        schema : JsonSchema
            This is the JSON Schema definition for the structured output.

            This is required when creating a structured output. Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        model : typing.Optional[CreateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            "structured-output",
            method="POST",
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=CreateStructuredOutputDtoModel, direction="write"
                ),
                "name": name,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_find_one(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_remove(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_update(
        self,
        id: str,
        *,
        schema_override: str,
        model: typing.Optional[UpdateStructuredOutputDtoModel] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        schema: typing.Optional[JsonSchema] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        schema_override : str

        model : typing.Optional[UpdateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        name : typing.Optional[str]
            This is the name of the structured output.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        schema : typing.Optional[JsonSchema]
            This is the JSON Schema definition for the structured output.

            Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="PATCH",
            params={
                "schemaOverride": schema_override,
            },
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=UpdateStructuredOutputDtoModel, direction="write"
                ),
                "name": name,
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawStructuredOutputsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def structured_output_controller_find_all(
        self,
        *,
        id: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[StructuredOutputControllerFindAllRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutputPaginatedResponse]:
        """
        Parameters
        ----------
        id : typing.Optional[str]
            This will return structured outputs where the id matches the specified value.

        name : typing.Optional[str]
            This will return structured outputs where the name matches the specified value.

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[StructuredOutputControllerFindAllRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutputPaginatedResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "structured-output",
            method="GET",
            params={
                "id": id,
                "name": name,
                "page": page,
                "sortOrder": sort_order,
                "limit": limit,
                "createdAtGt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "createdAtLt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "createdAtGe": serialize_datetime(created_at_ge) if created_at_ge is not None else None,
                "createdAtLe": serialize_datetime(created_at_le) if created_at_le is not None else None,
                "updatedAtGt": serialize_datetime(updated_at_gt) if updated_at_gt is not None else None,
                "updatedAtLt": serialize_datetime(updated_at_lt) if updated_at_lt is not None else None,
                "updatedAtGe": serialize_datetime(updated_at_ge) if updated_at_ge is not None else None,
                "updatedAtLe": serialize_datetime(updated_at_le) if updated_at_le is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutputPaginatedResponse,
                    construct_type(
                        type_=StructuredOutputPaginatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_create(
        self,
        *,
        name: str,
        schema: JsonSchema,
        model: typing.Optional[CreateStructuredOutputDtoModel] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        name : str
            This is the name of the structured output.

        schema : JsonSchema
            This is the JSON Schema definition for the structured output.

            This is required when creating a structured output. Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        model : typing.Optional[CreateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "structured-output",
            method="POST",
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=CreateStructuredOutputDtoModel, direction="write"
                ),
                "name": name,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_find_one(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_remove(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_update(
        self,
        id: str,
        *,
        schema_override: str,
        model: typing.Optional[UpdateStructuredOutputDtoModel] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        schema: typing.Optional[JsonSchema] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        schema_override : str

        model : typing.Optional[UpdateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        name : typing.Optional[str]
            This is the name of the structured output.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        schema : typing.Optional[JsonSchema]
            This is the JSON Schema definition for the structured output.

            Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="PATCH",
            params={
                "schemaOverride": schema_override,
            },
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=UpdateStructuredOutputDtoModel, direction="write"
                ),
                "name": name,
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
