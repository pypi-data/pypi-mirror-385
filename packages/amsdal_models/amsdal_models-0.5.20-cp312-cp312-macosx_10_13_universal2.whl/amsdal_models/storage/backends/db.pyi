from _typeshed import Incomplete
from amsdal_models.storage.base import Storage as Storage
from amsdal_models.storage.errors import StorageError as StorageError
from amsdal_models.storage.helpers import build_storage_address as build_storage_address
from amsdal_models.storage.types import FileProtocol as FileProtocol
from collections.abc import Iterator
from contextlib import contextmanager
from types import TracebackType
from typing import Any, BinaryIO, IO, Self

class AsyncFileWrapper:
    _bio: Incomplete
    def __init__(self, bio: IO[Any]) -> None: ...
    async def __aenter__(self) -> Self: ...
    async def __aexit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None) -> None: ...
    async def read(self, n: int = -1) -> bytes: ...
    async def close(self) -> None: ...
    async def seek(self, offset: int, whence: int = 0) -> int: ...
    async def tell(self) -> int: ...

class DBStorage(Storage):
    '''
    In-database storage backend.

    This backend "stores" file bytes within the File model\'s `data` field itself.
    - save(): reads bytes from the provided content stream and assigns to file.data.
    - open(): returns a BytesIO stream over file.data.
    - url(): returns a non-public placeholder URL (db://<filename>).

    Since bytes are kept on the model, this backend keeps a local copy to prevent
    persistence layer from clearing payload.
    '''
    keeps_local_copy: bool
    def save(self, file: FileProtocol, content: BinaryIO) -> str: ...
    def open(self, file: FileProtocol, mode: str = 'rb') -> IO[Any]: ...
    def delete(self, file: FileProtocol) -> None: ...
    def exists(self, file: FileProtocol) -> bool: ...
    def url(self, file: FileProtocol) -> str: ...
    async def asave(self, file: FileProtocol, content: BinaryIO) -> str: ...
    async def aopen(self, file: FileProtocol, mode: str = 'rb') -> AsyncFileWrapper: ...
    async def adelete(self, file: FileProtocol) -> None: ...
    async def aexists(self, file: FileProtocol) -> bool: ...
    async def aurl(self, file: FileProtocol) -> str: ...
    @staticmethod
    @contextmanager
    def _ensure_open(binary: BinaryIO, mode: str = 'rb') -> Iterator[IO[Any]]: ...
    def _ensure_bytes(self, content: BinaryIO) -> bytes: ...
    def _validate_mode(self, mode: str) -> None: ...
