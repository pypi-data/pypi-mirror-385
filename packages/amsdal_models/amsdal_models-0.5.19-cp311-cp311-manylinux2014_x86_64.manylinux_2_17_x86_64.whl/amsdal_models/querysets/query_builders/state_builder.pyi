import amsdal_glue as glue
from _typeshed import Incomplete
from amsdal_models.classes.annotations import CosineDistance as CosineDistance, InnerProduct as InnerProduct, L1Distance as L1Distance, L2Distance as L2Distance
from amsdal_models.classes.relationships.constants import FOREIGN_KEYS as FOREIGN_KEYS, PRIMARY_KEY as PRIMARY_KEY, PRIMARY_KEY_FIELDS as PRIMARY_KEY_FIELDS
from amsdal_models.classes.relationships.meta.primary_key import build_metadata_primary_key as build_metadata_primary_key
from amsdal_models.classes.relationships.meta.references import build_fk_db_fields as build_fk_db_fields
from amsdal_models.querysets.query_builders.common import ModelType as ModelType, QueryBuilder as QueryBuilder
from amsdal_utils.query.utils import Q
from collections.abc import Callable as Callable
from typing import Any

logger: Incomplete

def _field_shortcut(field_name: str) -> glue.Field: ...
def _separated_fields(alias: str, prop_name: str) -> Callable[[str], str]: ...

class StateQueryBuilder(QueryBuilder):
    def transform(self) -> glue.QueryStatement: ...
    def build_annotations(self) -> list[glue.AnnotationQuery]: ...
    def transform_count(self, total_alias: str = 'total_count', count_field: str = '*') -> glue.QueryStatement: ...
    def build_joins(self, parent_alias: str, parent_model: type['ModelType'], select_related: dict[tuple[str, type['ModelType'], str], Any] | None) -> list[glue.JoinQuery] | None: ...
    def build_where(self, model: type['ModelType'], conditions: Q | None, select_related: dict[tuple[str, type['ModelType'], str], Any] | None = None) -> glue.Conditions | None: ...
    def _backpropagate_conditions(self, conditions: list[glue.Condition | glue.Conditions]) -> list[glue.Condition | glue.Conditions]: ...
    def _backpropagate_condition(self, condition: glue.Condition | glue.Conditions) -> glue.Condition | glue.Conditions: ...
    def build_order_by(self) -> list[glue.OrderByQuery] | None: ...
    @classmethod
    def _build_aliased_field_reference(cls, prop_name: str, model: type['ModelType'], alias: Callable[[str], str], table_name: str | None = None) -> list[glue.FieldReferenceAliased]: ...
    @classmethod
    def _build_nested_only(cls, select_related: dict[tuple[str, type['ModelType'], str], Any]) -> list[glue.FieldReferenceAliased]: ...
