# v0.0.4 - Major Refactor: Decoupling, Styling, and Rendering Pipeline
A refactor is the correct long-term solution. You've asked for the "best way," and based on external documentation and best practices, that means focusing on **decoupling**, **centralized styling**, and a **layered rendering pipeline**.

Here is a full refactoring plan based on those principles, backed by the resources you requested.

-----

### Phase 1: Decouple Communication with Signals & Slots

**Goal:** Remove all global variables (`current_app_instance`) and monkey-patching. This is the most critical refactor.

**Why (The "Best Practice"):**
The official Qt documentation and best practices emphasize "loose coupling". Your `CanvasWidget` shouldn't know or care that a status bar exists. It should just *emit a signal* when its state changes. This makes your `CanvasWidget` reusable, testable, and robust.

**Resource:** [Qt for Python Signals & Slots Documentation](https://doc.qt.io/qtforpython-6/overviews/qtcore-signalsandslots.html)
**How-To:**

1.  **In `src/ingot/views/canvas.py` (The Emitter):**

      * Import `pyqtSignal` and `QPoint`, `QColor` from `PyQt6.QtCore` and `PyQt6.QtGui`.
      * **Define the Signal:** At the `CanvasWidget` class level, create a signal. This is your new "data firehose."
        ```python
        class CanvasWidget(QWidget):
            status_updated = pyqtSignal(dict) # Our new signal
            
            def __init__(self, ...):
                # ...
        ```
      * **Emit in `mouseMoveEvent`:** Replace the `global current_app_instance` block.
        ```python
        def mouseMoveEvent(self, event):
            # ... (all your existing logic to get rel_x, rel_y, _current_color)
            
            status_data = {
                "pos": self._mouse_pos,
                "relative": QPoint(rel_x, rel_y),
                "color": self._current_color,
                "zoom": self._zoom_level
            }
            self.status_updated.emit(status_data) # Fire the signal
            
            # ... (keep self.update() and super().mouseMoveEvent(event))
            # DELETE the global current_app_instance block
        ```
      * **Emit in `set_zoom_level`:** Do the same. Replace the global block with an emit.
        ```python
        def set_zoom_level(self, zoom_level):
            # ... (your existing zoom logic)
            self.update()

            status_data = {
                "pos": self._mouse_pos,
                "relative": self.get_center_offset(), # Use existing methods
                "color": self._current_color,
                "zoom": self._zoom_level
            }
            self.status_updated.emit(status_data) # Fire the signal
            
            # DELETE the global current_app_instance block
        ```

2.  **In `src/ingot/display.py` (The Receiver):**

      * Create one new public "slot" in your `StatusBar` class that takes the dictionary.
        ```python
        from PyQt6.QtCore import pyqtSlot, QPoint
        from PyQt6.QtGui import QColor

        class StatusBar(QWidget):
            # ...
            
            @pyqtSlot(dict)
            def update_from_canvas(self, data: dict):
                """A public slot to receive all data from the canvas."""
                # Use .get() for safety, providing defaults
                pos = data.get("pos", QPoint(0, 0))
                rel = data.get("relative", QPoint(0, 0))
                color = data.get("color", QColor(255, 255, 255, 255))
                zoom = data.get("zoom", 1.0)
                
                pos_str = f"({pos.x()}, {pos.y()})"
                center_str = f"({rel.x()}, {rel.y()})"
                color_str = f"({color.red()}, {color.green()}, {color.blue()}, {color.alpha()})"
                
                # Call your existing private-like methods
                self.update_coordinates(pos_str, center_str)
                self.update_color(color_str)
                self.update_zoom(zoom)
        ```

3.  **In `src/ingot/app.py` & `src/ingot/workspaces/canvas.py` (The Connector):**

      * **`IngotApp`:** Pass the status bar's new slot to the workspace.
        ```python
        # In IngotApp.__init__
        self.workspace = CanvasWorkspace(
            view_config=view_config,
            canvas_config=canvas_config,
            update_slot=self.status_bar.update_from_canvas # Pass the slot
        )
        # DELETE the update_status_bar_from_canvas and update_status_bar_coordinates methods
        ```
      * **`CanvasWorkspace`:** Accept the slot and use it.
        ```python
        # In CanvasWorkspace.__init__
        def __init__(self, view_config: dict, canvas_config: dict | None = None, update_slot=None):
            # ...
            self._update_slot = update_slot # Store the slot
            super().__init__(view_config)

        # In CanvasWorkspace.new_tab
        def new_tab(self):
            # ... (after original_content_widget is created)
            
            # This is the connection
            if self._update_slot and hasattr(original_content_widget, 'status_updated'):
                original_content_widget.status_updated.connect(self._update_slot)

            # ... (rest of the method)
        ```

4.  **In `examples/main_tester.py` (Cleanup):**

      * **DELETE** the entire `setup_canvas_mouse_tracking` function.
      * **DELETE** the `main_window.workspace.currentChanged.connect(...)` line.
      * **DELETE** the lines that set `ingot.views.canvas.current_app_instance`.

-----

### Phase 2: Centralize Styling in SASS

**Goal:** Fix the status bar UI by removing *all* hardcoded `setStyleSheet` calls from your Python code and placing them in your `theme.scss` file.

**Why (The "Best Practice"):**
Your app will be impossible to theme if styles are scattered in Python files. The "best way" is to have SASS/QSS be the *single source of truth* for all styling.

**Resource:** [Qt Style Sheets Reference](https://doc.qt.io/qt-6/stylesheet-reference.html)
**How-To:**

1.  **In `src/ingot/display.py`:**
      * **DELETE** all `setStyleSheet` calls from `StatusBar.setup_ui` (for `zoom_label`, `coords_label`, etc.).
      * **MODIFY** `update_color` to *only* set the background color, not the border. The border should be in SASS.
        ```python
        # In StatusBar.update_color
        self.color_visualization.setStyleSheet(f"background-color: rgba({r}, {g}, {b}, {a});")
        # In the except block:
        self.color_visualization.setStyleSheet("background-color: rgb(255, 255, 255);")
        ```
2.  **In `resources/themes/theme.scss`:**
      * Add styles for the status bar and its children at the end of the file.
        ```scss
        /*
         * Status Bar
         */
        QWidget#ingotStatusBar {
          color: $foreground; /* Fixes black text */
          border-top: 1px solid $border;
          font-size: 12px;
        }

        QWidget#ingotStatusBar QLabel {
          color: $foreground; /* Explicitly set label color */
        }

        /* The rich text in the color label */
        QWidget#ingotColorLabel {
          font-size: 12px;
        }

        /* The color swatch */
        QWidget#ingotColorVisualization {
          border: 1px solid $foreground-dark;
          min-width: 20px; /* Ensure it doesn't collapse */
        }
        ```

-----

### Phase 3: Implement Layered Rendering (Zoom & Gizmos)

**Goal:** Fix zoom and draw your gizmos by implementing `paintEvent` correctly.

**Why (The "Best Practice"):**
The correct way to zoom a `QWidget` is to apply a scale transformation to the `QPainter` itself inside `paintEvent`. You should *not* scale the `QImage` or widget, as that is slow and inefficient. This also allows you to draw gizmos that scale with the zoom.

**Resource:** [QPainter Transformations](https://www.bogotobogo.com/Qt/Qt5_QPainter_Transformation.php) and [Stack Overflow on inverse scaling for gizmos](https://stackoverflow.com/questions/78990116/how-to-keep-qpixamp-quality-in-qpainterdrawpixmap-when-qpainterscalex-y-is).
**How-To:**

1.  **In `src/ingot/views/canvas.py` (Base `CanvasWidget`):**
      * This is the core fix. Add the main `paintEvent` to the base class.
        ```python
        from PyQt6.QtGui import QPainter, QPen, QColor
        from PyQt6.QtCore import Qt

        class CanvasWidget(QWidget):
            # ... (signal and init)

            def paintEvent(self, event):
                """
                Main paint event. Handles zoom and layers.
                DO NOT OVERRIDE. Subclasses should override _draw_content.
                """
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                
                painter.save() # Save the painter's state
                
                # --- 1. APPLY ZOOM ---
                # This is the fix for your zoom.
                painter.scale(self._zoom_level, self._zoom_level)

                # --- 2. DRAW BASE GIZMOS (Center) ---
                # We make the pen width inverse to the zoom, so it stays 2px wide
                center_pen = QPen(
                    QColor(100, 100, 100, 150),  # Dark gray
                    2 / self._zoom_level,        # Your 2px width request
                    Qt.PenStyle.SolidLine
                )
                painter.setPen(center_pen)
                
                center_x, center_y = self._canvas_center.x(), self._canvas_center.y()
                painter.drawLine(center_x, 0, center_x, self.height()) # Vertical
                painter.drawLine(0, center_y, self.width(), center_y)  # Horizontal

                # --- 3. DRAW SUBCLASS CONTENT ---
                # This calls GradientCanvasWidget._draw_content()
                self._draw_content(painter)

                # --- 4. DRAW OVERLAY GIZMOS (Mouse Scope) ---
                # This pen also scales inversely to stay 1px wide
                scope_pen = QPen(
                    QColor(150, 150, 150, 200),  # Light gray
                    1 / self._zoom_level,        # Your 1px width request
                    Qt.PenStyle.DotLine         # Dotted for "scope" feel
                )
                painter.setPen(scope_pen)
                
                mouse_x, mouse_y = self._mouse_pos.x(), self._mouse_pos.y()
                painter.drawLine(mouse_x, 0, mouse_x, self.height()) # Vertical
                painter.drawLine(0, mouse_y, self.width(), mouse_y)  # Horizontal

                painter.restore() # Restore painter to pre-scaled state
                painter.end()

            def _draw_content(self, painter: QPainter):
                """
                Subclasses must override this method to paint their content.
                """
                pass # Base class draws nothing
            
            # ... (rest of your methods: mouseMoveEvent, etc.)
        ```
2.  **In `src/ingot/views/canvas.py` (Subclasses):**
      * Rename `paint_content` to `_draw_content` in both `GradientCanvasWidget` and `SmallWidgetCanvasWidget`.
        ```python
        class GradientCanvasWidget(CanvasWidget):
            # ...
            def _draw_content(self, painter): # Renamed from paint_content
                # ... (all your gradient drawing logic)
                
        class SmallWidgetCanvasWidget(CanvasWidget):
            # ...
            def _draw_content(self, painter): # Renamed from paint_content
                # ... (pass or draw other things)
        ```

-----

### `v0.0.5`: Advanced DX and Interactivity

**Goal:** Implement a VS Code-style sidebar system and add tools that make the framework easier for other developers to use.

  * **Step 1: Design the "Activity Bar" and View Container**

      * **What:** Implement a system where a thin vertical bar on the left (the "Activity Bar") contains icons that switch the content of the entire left-side panel.
      * **Technical Details:**
          * The main left side panel will now contain a `QStackedWidget`. This widget holds all the possible sidebar views (e.g., Explorer, Search, Debug).
          * The "Activity Bar" will be a new, very thin widget placed to the left of the `QStackedWidget`. It will contain `QPushButtons` with icons.
          * Clicking a button on the Activity Bar will call `self.stacked_widget.setCurrentIndex(...)` to show the corresponding view.

  * **Step 2: Create a Sidebar View Manager**

      * **What:** A system for developers to register their own custom sidebars.
      * **Technical Details:**
          * Create a new `SidebarManager` class.
          * It will have a method like `register_view(icon_path, name, widget_factory)`.
          * The manager will be responsible for creating the Activity Bar buttons and adding the instantiated widgets to the `QStackedWidget`.

  * **Step 3: Implement an Explicit Focus System**

      * **What:** A centralized manager to track which part of the application has focus.
      * **Technical Details:**
          * Create a `FocusManager` class.
          * In `IngotApp`, connect to the global focus signal: `QApplication.instance().focusChanged.connect(self.focus_manager.on_focus_changed)`.
          * The `on_focus_changed(old_widget, new_widget)` method can be used to track history, which can make the Back/Forward navigation (from Phase 1) much more robust, as it could also track focus changes between sidebars and the main workspace.

  * **Step 4: Auto-Generate a Settings/Shortcuts Page**

      * **What:** Create a new view that can be opened from the menu, which automatically lists all registered actions and their shortcuts.
      * **Technical Details:**
          * This is a pure DX win. The `ActionManager` already holds a dictionary of all actions (`self._actions`).
          * Create a new view (e.g., `SettingsView`).
          * Inside it, iterate through `current_app_instance.action_manager._actions.values()`.
          * For each `QAction`, get its `text()` and `shortcut().toString()`.
          * Display this information in a `QTableWidget` for a clean, organized view.

By following this phased approach, you can systematically build out these advanced features while keeping the project organized and manageable. Good luck\!