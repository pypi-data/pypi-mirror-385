// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SPOT_HIKYUU_FLAT_H_
#define FLATBUFFERS_GENERATED_SPOT_HIKYUU_FLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace hikyuu {
namespace flat {

struct Spot;
struct SpotBuilder;

struct SpotList;
struct SpotListBuilder;

struct Spot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MARKET = 4,
    VT_CODE = 6,
    VT_NAME = 8,
    VT_DATETIME = 10,
    VT_YESTERDAY_CLOSE = 12,
    VT_OPEN = 14,
    VT_HIGH = 16,
    VT_LOW = 18,
    VT_CLOSE = 20,
    VT_AMOUNT = 22,
    VT_VOLUME = 24,
    VT_BID = 26,
    VT_BID_AMOUNT = 28,
    VT_ASK = 30,
    VT_ASK_AMOUNT = 32
  };
  const ::flatbuffers::String *market() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MARKET);
  }
  const ::flatbuffers::String *code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CODE);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *datetime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATETIME);
  }
  double yesterday_close() const {
    return GetField<double>(VT_YESTERDAY_CLOSE, 0.0);
  }
  double open() const {
    return GetField<double>(VT_OPEN, 0.0);
  }
  double high() const {
    return GetField<double>(VT_HIGH, 0.0);
  }
  double low() const {
    return GetField<double>(VT_LOW, 0.0);
  }
  double close() const {
    return GetField<double>(VT_CLOSE, 0.0);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  double volume() const {
    return GetField<double>(VT_VOLUME, 0.0);
  }
  const ::flatbuffers::Vector<double> *bid() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_BID);
  }
  const ::flatbuffers::Vector<double> *bid_amount() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_BID_AMOUNT);
  }
  const ::flatbuffers::Vector<double> *ask() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ASK);
  }
  const ::flatbuffers::Vector<double> *ask_amount() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ASK_AMOUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MARKET) &&
           verifier.VerifyString(market()) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DATETIME) &&
           verifier.VerifyString(datetime()) &&
           VerifyField<double>(verifier, VT_YESTERDAY_CLOSE, 8) &&
           VerifyField<double>(verifier, VT_OPEN, 8) &&
           VerifyField<double>(verifier, VT_HIGH, 8) &&
           VerifyField<double>(verifier, VT_LOW, 8) &&
           VerifyField<double>(verifier, VT_CLOSE, 8) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<double>(verifier, VT_VOLUME, 8) &&
           VerifyOffset(verifier, VT_BID) &&
           verifier.VerifyVector(bid()) &&
           VerifyOffset(verifier, VT_BID_AMOUNT) &&
           verifier.VerifyVector(bid_amount()) &&
           VerifyOffset(verifier, VT_ASK) &&
           verifier.VerifyVector(ask()) &&
           VerifyOffset(verifier, VT_ASK_AMOUNT) &&
           verifier.VerifyVector(ask_amount()) &&
           verifier.EndTable();
  }
};

struct SpotBuilder {
  typedef Spot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_market(::flatbuffers::Offset<::flatbuffers::String> market) {
    fbb_.AddOffset(Spot::VT_MARKET, market);
  }
  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {
    fbb_.AddOffset(Spot::VT_CODE, code);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Spot::VT_NAME, name);
  }
  void add_datetime(::flatbuffers::Offset<::flatbuffers::String> datetime) {
    fbb_.AddOffset(Spot::VT_DATETIME, datetime);
  }
  void add_yesterday_close(double yesterday_close) {
    fbb_.AddElement<double>(Spot::VT_YESTERDAY_CLOSE, yesterday_close, 0.0);
  }
  void add_open(double open) {
    fbb_.AddElement<double>(Spot::VT_OPEN, open, 0.0);
  }
  void add_high(double high) {
    fbb_.AddElement<double>(Spot::VT_HIGH, high, 0.0);
  }
  void add_low(double low) {
    fbb_.AddElement<double>(Spot::VT_LOW, low, 0.0);
  }
  void add_close(double close) {
    fbb_.AddElement<double>(Spot::VT_CLOSE, close, 0.0);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(Spot::VT_AMOUNT, amount, 0.0);
  }
  void add_volume(double volume) {
    fbb_.AddElement<double>(Spot::VT_VOLUME, volume, 0.0);
  }
  void add_bid(::flatbuffers::Offset<::flatbuffers::Vector<double>> bid) {
    fbb_.AddOffset(Spot::VT_BID, bid);
  }
  void add_bid_amount(::flatbuffers::Offset<::flatbuffers::Vector<double>> bid_amount) {
    fbb_.AddOffset(Spot::VT_BID_AMOUNT, bid_amount);
  }
  void add_ask(::flatbuffers::Offset<::flatbuffers::Vector<double>> ask) {
    fbb_.AddOffset(Spot::VT_ASK, ask);
  }
  void add_ask_amount(::flatbuffers::Offset<::flatbuffers::Vector<double>> ask_amount) {
    fbb_.AddOffset(Spot::VT_ASK_AMOUNT, ask_amount);
  }
  explicit SpotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Spot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Spot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Spot> CreateSpot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> market = 0,
    ::flatbuffers::Offset<::flatbuffers::String> code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> datetime = 0,
    double yesterday_close = 0.0,
    double open = 0.0,
    double high = 0.0,
    double low = 0.0,
    double close = 0.0,
    double amount = 0.0,
    double volume = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> bid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> bid_amount = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> ask = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> ask_amount = 0) {
  SpotBuilder builder_(_fbb);
  builder_.add_volume(volume);
  builder_.add_amount(amount);
  builder_.add_close(close);
  builder_.add_low(low);
  builder_.add_high(high);
  builder_.add_open(open);
  builder_.add_yesterday_close(yesterday_close);
  builder_.add_ask_amount(ask_amount);
  builder_.add_ask(ask);
  builder_.add_bid_amount(bid_amount);
  builder_.add_bid(bid);
  builder_.add_datetime(datetime);
  builder_.add_name(name);
  builder_.add_code(code);
  builder_.add_market(market);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Spot> CreateSpotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *market = nullptr,
    const char *code = nullptr,
    const char *name = nullptr,
    const char *datetime = nullptr,
    double yesterday_close = 0.0,
    double open = 0.0,
    double high = 0.0,
    double low = 0.0,
    double close = 0.0,
    double amount = 0.0,
    double volume = 0.0,
    const std::vector<double> *bid = nullptr,
    const std::vector<double> *bid_amount = nullptr,
    const std::vector<double> *ask = nullptr,
    const std::vector<double> *ask_amount = nullptr) {
  auto market__ = market ? _fbb.CreateString(market) : 0;
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto datetime__ = datetime ? _fbb.CreateString(datetime) : 0;
  auto bid__ = bid ? _fbb.CreateVector<double>(*bid) : 0;
  auto bid_amount__ = bid_amount ? _fbb.CreateVector<double>(*bid_amount) : 0;
  auto ask__ = ask ? _fbb.CreateVector<double>(*ask) : 0;
  auto ask_amount__ = ask_amount ? _fbb.CreateVector<double>(*ask_amount) : 0;
  return hikyuu::flat::CreateSpot(
      _fbb,
      market__,
      code__,
      name__,
      datetime__,
      yesterday_close,
      open,
      high,
      low,
      close,
      amount,
      volume,
      bid__,
      bid_amount__,
      ask__,
      ask_amount__);
}

struct SpotList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpotListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPOT = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<hikyuu::flat::Spot>> *spot() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<hikyuu::flat::Spot>> *>(VT_SPOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPOT) &&
           verifier.VerifyVector(spot()) &&
           verifier.VerifyVectorOfTables(spot()) &&
           verifier.EndTable();
  }
};

struct SpotListBuilder {
  typedef SpotList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_spot(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<hikyuu::flat::Spot>>> spot) {
    fbb_.AddOffset(SpotList::VT_SPOT, spot);
  }
  explicit SpotListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpotList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpotList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpotList> CreateSpotList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<hikyuu::flat::Spot>>> spot = 0) {
  SpotListBuilder builder_(_fbb);
  builder_.add_spot(spot);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SpotList> CreateSpotListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<hikyuu::flat::Spot>> *spot = nullptr) {
  auto spot__ = spot ? _fbb.CreateVector<::flatbuffers::Offset<hikyuu::flat::Spot>>(*spot) : 0;
  return hikyuu::flat::CreateSpotList(
      _fbb,
      spot__);
}

inline const hikyuu::flat::SpotList *GetSpotList(const void *buf) {
  return ::flatbuffers::GetRoot<hikyuu::flat::SpotList>(buf);
}

inline const hikyuu::flat::SpotList *GetSizePrefixedSpotList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<hikyuu::flat::SpotList>(buf);
}

inline bool VerifySpotListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<hikyuu::flat::SpotList>(nullptr);
}

inline bool VerifySizePrefixedSpotListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<hikyuu::flat::SpotList>(nullptr);
}

inline void FinishSpotListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<hikyuu::flat::SpotList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSpotListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<hikyuu::flat::SpotList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat
}  // namespace hikyuu

#endif  // FLATBUFFERS_GENERATED_SPOT_HIKYUU_FLAT_H_
