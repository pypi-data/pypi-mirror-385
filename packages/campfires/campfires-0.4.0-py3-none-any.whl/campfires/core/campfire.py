"""
Campfire class for orchestrating multimodal LLM workflows.
"""

import asyncio
import logging
import yaml
from typing import List, Dict, Any, Optional, Callable, Union
from datetime import datetime, timedelta
from pathlib import Path

from .torch import Torch
from .camper import Camper
from ..party_box.box_driver import BoxDriver
from ..mcp.protocol import MCPProtocol


logger = logging.getLogger(__name__)


class Campfire:
    """
    A Campfire orchestrates a group of Campers (models/tools) to process
    torches (data) and pass results via MCP to other campfires.
    
    Each campfire has a specific purpose and contains one or more campers
    that work together to process incoming torches and generate new ones.
    """
    
    def __init__(
        self,
        name: str,
        campers: List[Camper],
        party_box: BoxDriver,
        mcp_protocol: Optional[MCPProtocol] = None,
        config: Dict[str, Any] = None
    ):
        """
        Initialize a Campfire.
        
        Args:
            name: Unique name for this campfire
            campers: List of campers in this campfire
            party_box: Storage driver for assets
            mcp_protocol: MCP protocol for communication
            config: Additional configuration
        """
        self.name = name
        self.campers = campers
        self.party_box = party_box
        self.mcp_protocol = mcp_protocol
        self.config = config or {}
        
        # State management
        self.is_running = False
        self.processed_torches: Dict[str, Torch] = {}
        self.torch_queue: asyncio.Queue = asyncio.Queue()
        
        # Configuration
        self.max_concurrent_tasks = self.config.get('max_concurrent_tasks', 3)
        self.torch_ttl = self.config.get('torch_ttl_hours', 24)
        self.auto_cleanup = self.config.get('auto_cleanup', True)
        
        # Callbacks
        self.on_torch_processed: Optional[Callable[[Torch], None]] = None
        self.on_error: Optional[Callable[[Exception, Torch], None]] = None
        
        # Setup campers
        for camper in self.campers:
            camper.set_party_box(self.party_box)
            camper.set_campfire_name(self.name)
    
    async def start(self) -> None:
        """Start the campfire processing loop."""
        if self.is_running:
            logger.warning(f"Campfire {self.name} is already running")
            return
        
        self.is_running = True
        logger.info(f"Starting campfire: {self.name}")
        
        # Start processing tasks
        tasks = []
        for i in range(self.max_concurrent_tasks):
            task = asyncio.create_task(self._processing_loop())
            tasks.append(task)
        
        # Start cleanup task if enabled
        if self.auto_cleanup:
            cleanup_task = asyncio.create_task(self._cleanup_loop())
            tasks.append(cleanup_task)
        
        # Subscribe to MCP channels if protocol is available
        if self.mcp_protocol:
            await self._setup_mcp_subscriptions()
        
        # Wait for all tasks to complete
        try:
            await asyncio.gather(*tasks)
        except asyncio.CancelledError:
            logger.info(f"Campfire {self.name} processing cancelled")
        finally:
            self.is_running = False
    
    async def stop(self) -> None:
        """Stop the campfire processing."""
        logger.info(f"Stopping campfire: {self.name}")
        self.is_running = False
        
        # Cancel any pending tasks
        for task in asyncio.all_tasks():
            if not task.done() and task.get_name().startswith(f"campfire_{self.name}"):
                task.cancel()
    
    async def process_torch(self, torch: Torch) -> List[Torch]:
        """
        Process a single torch through all campers.
        
        Args:
            torch: Input torch to process
            
        Returns:
            List of output torches generated by campers
        """
        logger.info(f"Processing torch {torch.torch_id} in campfire {self.name}")
        
        try:
            output_torches = []
            
            # Process through each camper
            for camper in self.campers:
                logger.debug(f"Processing torch with camper: {camper.__class__.__name__}")
                
                try:
                    # Process the torch
                    result_torches = await camper.process(torch)
                    
                    if result_torches:
                        if isinstance(result_torches, Torch):
                            result_torches = [result_torches]
                        
                        for result_torch in result_torches:
                            # Set source campfire
                            result_torch.source_campfire = self.name
                            result_torch.metadata['processed_by'] = camper.__class__.__name__
                            result_torch.metadata['parent_torch_id'] = torch.torch_id
                            
                            output_torches.append(result_torch)
                            
                            # Send via MCP if available
                            if self.mcp_protocol:
                                await self._send_torch_via_mcp(result_torch)
                
                except Exception as e:
                    logger.error(f"Error processing torch with {camper.__class__.__name__}: {e}")
                    if self.on_error:
                        self.on_error(e, torch)
                    continue
            
            # Store processed torch
            self.processed_torches[torch.torch_id] = torch
            
            # Call callback if set
            if self.on_torch_processed:
                self.on_torch_processed(torch)
            
            logger.info(f"Generated {len(output_torches)} output torches from {torch.torch_id}")
            return output_torches
            
        except Exception as e:
            logger.error(f"Error processing torch {torch.torch_id}: {e}")
            if self.on_error:
                self.on_error(e, torch)
            return []
    
    async def add_torch(self, torch: Torch) -> None:
        """
        Add a torch to the processing queue.
        
        Args:
            torch: Torch to add to queue
        """
        await self.torch_queue.put(torch)
        logger.debug(f"Added torch {torch.torch_id} to queue")
    
    async def add_torch_from_data(
        self,
        claim: str,
        path: Optional[str] = None,
        confidence: float = 1.0,
        metadata: Dict[str, Any] = None,
        channel: str = "default"
    ) -> Torch:
        """
        Create and add a torch from raw data.
        
        Args:
            claim: Main claim or content
            path: Optional path to asset
            confidence: Confidence score (0.0 to 1.0)
            metadata: Additional metadata
            channel: MCP channel for the torch
            
        Returns:
            Created torch
        """
        torch = Torch(
            claim=claim,
            path=path,
            confidence=confidence,
            metadata=metadata or {},
            channel=channel,
            source_campfire=self.name
        )
        
        await self.add_torch(torch)
        return torch
    
    async def _processing_loop(self) -> None:
        """Main processing loop for handling torches."""
        while self.is_running:
            try:
                # Wait for a torch with timeout
                torch = await asyncio.wait_for(
                    self.torch_queue.get(),
                    timeout=1.0
                )
                
                # Process the torch
                await self.process_torch(torch)
                
                # Mark task as done
                self.torch_queue.task_done()
                
            except asyncio.TimeoutError:
                # No torch available, continue loop
                continue
            except Exception as e:
                logger.error(f"Error in processing loop: {e}")
                await asyncio.sleep(1)
    
    async def _cleanup_loop(self) -> None:
        """Cleanup loop for removing old torches."""
        while self.is_running:
            try:
                await asyncio.sleep(3600)  # Run every hour
                await self._cleanup_old_torches()
            except Exception as e:
                logger.error(f"Error in cleanup loop: {e}")
    
    async def _cleanup_old_torches(self) -> None:
        """Remove torches older than TTL."""
        cutoff_time = datetime.utcnow() - timedelta(hours=self.torch_ttl)
        
        to_remove = []
        for torch_id, torch in self.processed_torches.items():
            if torch.timestamp < cutoff_time:
                to_remove.append(torch_id)
        
        for torch_id in to_remove:
            del self.processed_torches[torch_id]
        
        if to_remove:
            logger.info(f"Cleaned up {len(to_remove)} old torches")
    
    async def _setup_mcp_subscriptions(self) -> None:
        """Setup MCP channel subscriptions."""
        if not self.mcp_protocol:
            return
        
        # Subscribe to channels this campfire should listen to
        channels = self.config.get('subscribe_channels', [])
        for channel in channels:
            await self.mcp_protocol.subscribe(channel, self._handle_mcp_torch)
    
    async def _handle_mcp_torch(self, message: Dict[str, Any]) -> None:
        """
        Handle incoming torch from MCP.
        
        Args:
            message: MCP message containing torch data
        """
        try:
            torch = Torch.from_mcp_message(message)
            await self.add_torch(torch)
        except Exception as e:
            logger.error(f"Error handling MCP torch: {e}")
    
    async def _send_torch_via_mcp(self, torch: Torch) -> None:
        """
        Send a torch via MCP.
        
        Args:
            torch: Torch to send
        """
        if not self.mcp_protocol:
            return
        
        try:
            message = torch.to_mcp_message()
            await self.mcp_protocol.send_message(torch.channel, message)
        except Exception as e:
            logger.error(f"Error sending torch via MCP: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """
        Get campfire statistics.
        
        Returns:
            Dictionary with campfire stats
        """
        return {
            'name': self.name,
            'is_running': self.is_running,
            'campers_count': len(self.campers),
            'processed_torches_count': len(self.processed_torches),
            'queue_size': self.torch_queue.qsize(),
            'campers': [camper.__class__.__name__ for camper in self.campers]
        }
    
    def __str__(self) -> str:
        """String representation of the campfire."""
        return f"Campfire({self.name}, {len(self.campers)} campers)"
    
    def __repr__(self) -> str:
        """Detailed string representation."""
        return (f"Campfire(name='{self.name}', "
                f"campers={[c.__class__.__name__ for c in self.campers]}, "
                f"running={self.is_running})")
    
    def to_yaml_config(self) -> Dict[str, Any]:
        """
        Export campfire configuration to a YAML-compatible dictionary.
        
        Returns:
            Dictionary containing campfire configuration in YAML format
        """
        # Extract camper configurations
        campers_config = []
        for camper in self.campers:
            camper_config = {
                'type': camper.__class__.__name__,
                'name': camper.name,
                'config': camper.config.copy() if hasattr(camper, 'config') else {}
            }
            
            # Add role information if available
            if hasattr(camper, '_role'):
                camper_config['role'] = camper._role
            
            # Add RAG document path if available
            if hasattr(camper, '_rag_document_path') and camper._rag_document_path:
                camper_config['rag_document_path'] = camper._rag_document_path
            
            # Add LLM configuration if available
            if hasattr(camper, '_llm_config') and camper._llm_config:
                camper_config['llm_config'] = {
                    'model': camper._llm_config.model,
                    'temperature': camper._llm_config.temperature,
                    'max_tokens': camper._llm_config.max_tokens,
                    'top_p': camper._llm_config.top_p,
                    'frequency_penalty': camper._llm_config.frequency_penalty,
                    'presence_penalty': camper._llm_config.presence_penalty
                }
            
            # Add multimodal capabilities if available
            if hasattr(camper, 'supported_content_types'):
                camper_config['supported_content_types'] = [
                    ct.value for ct in camper.supported_content_types
                ]
            
            campers_config.append(camper_config)
        
        # Build the YAML configuration
        yaml_config = {
            'version': '1.0',
            'kind': 'CampfireManifest',
            'metadata': {
                'name': self.name,
                'description': f'Campfire configuration for {self.name}',
                'created_at': datetime.utcnow().isoformat(),
                'campfire_class': self.__class__.__name__
            },
            'spec': {
                'name': self.name,
                'campers': campers_config,
                'config': self.config.copy(),
                'environment': {
                    'max_concurrent_tasks': str(self.max_concurrent_tasks),
                    'torch_ttl_hours': str(self.torch_ttl),
                    'auto_cleanup': str(self.auto_cleanup).lower()
                },
                'resources': {
                    'memory': 'medium',  # Default values
                    'cpu': 'medium',
                    'timeout_minutes': 30
                },
                'networking': {},
                'volumes': []
            }
        }
        
        # Add party box configuration if available
        if self.party_box:
            yaml_config['spec']['party_box'] = {
                'type': self.party_box.__class__.__name__,
                'config': getattr(self.party_box, 'config', {})
            }
        
        # Add MCP configuration if available
        if self.mcp_protocol:
            yaml_config['spec']['mcp'] = {
                'enabled': True,
                'channels': self.config.get('subscribe_channels', [])
            }
        
        return yaml_config
    
    def save_to_yaml(self, file_path: str) -> None:
        """
        Save campfire configuration to a YAML file.
        
        Args:
            file_path: Path where to save the YAML configuration file
        """
        yaml_config = self.to_yaml_config()
        
        # Ensure directory exists
        path = Path(file_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write YAML file
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.dump(yaml_config, f, default_flow_style=False, indent=2, sort_keys=False)
        
        logger.info(f"Campfire configuration saved to: {file_path}")
    
    @classmethod
    def from_yaml_config(cls, yaml_config: Dict[str, Any], party_box: BoxDriver, 
                        mcp_protocol: Optional[MCPProtocol] = None) -> 'Campfire':
        """
        Create a campfire instance from YAML configuration.
        
        Args:
            yaml_config: YAML configuration dictionary
            party_box: Party box driver instance
            mcp_protocol: Optional MCP protocol instance
            
        Returns:
            Campfire instance created from configuration
        """
        from .factory import CampfireFactory  # Import here to avoid circular imports
        
        spec = yaml_config.get('spec', {})
        metadata = yaml_config.get('metadata', {})
        
        name = spec.get('name', metadata.get('name', 'unnamed_campfire'))
        config = spec.get('config', {})
        
        # Extract environment variables
        env = spec.get('environment', {})
        if env:
            config.update({
                'max_concurrent_tasks': int(env.get('max_concurrent_tasks', 3)),
                'torch_ttl_hours': int(env.get('torch_ttl_hours', 24)),
                'auto_cleanup': env.get('auto_cleanup', 'true').lower() == 'true'
            })
        
        # Create campers from configuration
        campers = []
        campers_config = spec.get('campers', [])
        
        for camper_config in campers_config:
            # This would need to be implemented with a camper factory
            # For now, we'll create a placeholder
            logger.warning(f"Camper creation from YAML not fully implemented for type: {camper_config.get('type')}")
        
        # Create campfire instance
        campfire = cls(
            name=name,
            campers=campers,
            party_box=party_box,
            mcp_protocol=mcp_protocol,
            config=config
        )
        
        return campfire
    
    @classmethod
    def load_from_yaml(cls, file_path: str, party_box: BoxDriver, 
                      mcp_protocol: Optional[MCPProtocol] = None) -> 'Campfire':
        """
        Load campfire configuration from a YAML file.
        
        Args:
            file_path: Path to the YAML configuration file
            party_box: Party box driver instance
            mcp_protocol: Optional MCP protocol instance
            
        Returns:
            Campfire instance loaded from file
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            yaml_config = yaml.safe_load(f)
        
        logger.info(f"Loading campfire configuration from: {file_path}")
        return cls.from_yaml_config(yaml_config, party_box, mcp_protocol)


class CampfireManager:
    """
    Manager for multiple campfires, handling coordination and routing.
    """
    
    def __init__(self, mcp_protocol: Optional[MCPProtocol] = None):
        """
        Initialize the campfire manager.
        
        Args:
            mcp_protocol: Shared MCP protocol for all campfires
        """
        self.campfires: Dict[str, Campfire] = {}
        self.mcp_protocol = mcp_protocol
        self.is_running = False
    
    def add_campfire(self, campfire: Campfire) -> None:
        """
        Add a campfire to the manager.
        
        Args:
            campfire: Campfire to add
        """
        self.campfires[campfire.name] = campfire
        
        # Set MCP protocol if not already set
        if self.mcp_protocol and not campfire.mcp_protocol:
            campfire.mcp_protocol = self.mcp_protocol
    
    async def start_all(self) -> None:
        """Start all campfires."""
        self.is_running = True
        
        tasks = []
        for campfire in self.campfires.values():
            task = asyncio.create_task(campfire.start())
            tasks.append(task)
        
        await asyncio.gather(*tasks)
    
    async def stop_all(self) -> None:
        """Stop all campfires."""
        self.is_running = False
        
        tasks = []
        for campfire in self.campfires.values():
            task = asyncio.create_task(campfire.stop())
            tasks.append(task)
        
        await asyncio.gather(*tasks)
    
    def get_campfire(self, name: str) -> Optional[Campfire]:
        """Get a campfire by name."""
        return self.campfires.get(name)
    
    def get_all_stats(self) -> Dict[str, Any]:
        """Get stats for all campfires."""
        return {
            'manager_running': self.is_running,
            'campfires_count': len(self.campfires),
            'campfires': {name: cf.get_stats() for name, cf in self.campfires.items()}
        }
    
    def save_campfire_manifest(self, campfire_name: str, manifest_path: str) -> None:
        """
        Save a specific campfire's configuration to a YAML manifest file.
        
        Args:
            campfire_name: Name of the campfire to save
            manifest_path: Full path where to save the manifest file
            
        Raises:
            KeyError: If campfire with given name doesn't exist
        """
        if campfire_name not in self.campfires:
            raise KeyError(f"Campfire '{campfire_name}' not found in manager")
        
        campfire = self.campfires[campfire_name]
        campfire.save_to_yaml(manifest_path)
        logger.info(f"Saved campfire '{campfire_name}' manifest to: {manifest_path}")
    
    def save_all_manifests(self, base_directory: str, filename_template: str = "{name}.yaml") -> Dict[str, str]:
        """
        Save all campfires' configurations to YAML manifest files.
        
        Args:
            base_directory: Directory where to save all manifest files
            filename_template: Template for filenames, {name} will be replaced with campfire name
            
        Returns:
            Dictionary mapping campfire names to their saved file paths
        """
        base_path = Path(base_directory)
        base_path.mkdir(parents=True, exist_ok=True)
        
        saved_files = {}
        for name, campfire in self.campfires.items():
            filename = filename_template.format(name=name)
            file_path = base_path / filename
            campfire.save_to_yaml(str(file_path))
            saved_files[name] = str(file_path)
        
        logger.info(f"Saved {len(saved_files)} campfire manifests to: {base_directory}")
        return saved_files
    
    def load_campfire_from_manifest(self, manifest_path: str, party_box: 'BoxDriver', 
                                   campfire_name: Optional[str] = None) -> str:
        """
        Load a campfire from a YAML manifest file and add it to the manager.
        
        Args:
            manifest_path: Path to the YAML manifest file
            party_box: Party box driver instance for the campfire
            campfire_name: Optional custom name for the campfire (overrides manifest name)
            
        Returns:
            Name of the loaded campfire
            
        Raises:
            FileNotFoundError: If manifest file doesn't exist
            ValueError: If campfire with same name already exists
        """
        if not Path(manifest_path).exists():
            raise FileNotFoundError(f"Manifest file not found: {manifest_path}")
        
        # Load campfire from YAML
        campfire = Campfire.load_from_yaml(manifest_path, party_box, self.mcp_protocol)
        
        # Use custom name if provided
        if campfire_name:
            campfire.name = campfire_name
        
        # Check for name conflicts
        if campfire.name in self.campfires:
            raise ValueError(f"Campfire with name '{campfire.name}' already exists in manager")
        
        # Add to manager
        self.add_campfire(campfire)
        logger.info(f"Loaded campfire '{campfire.name}' from manifest: {manifest_path}")
        
        return campfire.name
    
    def load_manifests_from_directory(self, manifests_directory: str, party_box: 'BoxDriver', 
                                     pattern: str = "*.yaml") -> List[str]:
        """
        Load all YAML manifest files from a directory.
        
        Args:
            manifests_directory: Directory containing manifest files
            party_box: Party box driver instance for campfires
            pattern: File pattern to match (default: "*.yaml")
            
        Returns:
            List of loaded campfire names
            
        Raises:
            FileNotFoundError: If directory doesn't exist
        """
        manifest_dir = Path(manifests_directory)
        if not manifest_dir.exists():
            raise FileNotFoundError(f"Manifests directory not found: {manifests_directory}")
        
        loaded_campfires = []
        manifest_files = list(manifest_dir.glob(pattern))
        
        for manifest_file in manifest_files:
            try:
                campfire_name = self.load_campfire_from_manifest(
                    str(manifest_file), party_box
                )
                loaded_campfires.append(campfire_name)
            except Exception as e:
                logger.warning(f"Failed to load manifest {manifest_file}: {e}")
                continue
        
        logger.info(f"Loaded {len(loaded_campfires)} campfires from directory: {manifests_directory}")
        return loaded_campfires
    
    def export_manager_state(self, export_path: str) -> Dict[str, Any]:
        """
        Export the entire manager state including all campfires to a directory structure.
        
        Args:
            export_path: Base directory where to export the manager state
            
        Returns:
            Dictionary containing export metadata
        """
        export_dir = Path(export_path)
        export_dir.mkdir(parents=True, exist_ok=True)
        
        # Create subdirectories
        manifests_dir = export_dir / "manifests"
        manifests_dir.mkdir(exist_ok=True)
        
        # Save all campfire manifests
        saved_manifests = self.save_all_manifests(str(manifests_dir))
        
        # Create manager metadata
        manager_metadata = {
            'export_timestamp': datetime.utcnow().isoformat(),
            'manager_stats': self.get_all_stats(),
            'campfires_count': len(self.campfires),
            'manifest_files': saved_manifests,
            'export_version': '1.0'
        }
        
        # Save manager metadata
        metadata_file = export_dir / "manager_metadata.yaml"
        with open(metadata_file, 'w', encoding='utf-8') as f:
            yaml.dump(manager_metadata, f, default_flow_style=False, indent=2)
        
        logger.info(f"Exported manager state to: {export_path}")
        return manager_metadata
    
    def import_manager_state(self, import_path: str, party_box: 'BoxDriver', 
                           clear_existing: bool = False) -> Dict[str, Any]:
        """
        Import manager state from a previously exported directory structure.
        
        Args:
            import_path: Base directory containing exported manager state
            party_box: Party box driver instance for campfires
            clear_existing: Whether to clear existing campfires before importing
            
        Returns:
            Dictionary containing import results
        """
        import_dir = Path(import_path)
        if not import_dir.exists():
            raise FileNotFoundError(f"Import directory not found: {import_path}")
        
        # Clear existing campfires if requested
        if clear_existing:
            self.campfires.clear()
            logger.info("Cleared existing campfires before import")
        
        # Load manager metadata
        metadata_file = import_dir / "manager_metadata.yaml"
        if metadata_file.exists():
            with open(metadata_file, 'r', encoding='utf-8') as f:
                metadata = yaml.safe_load(f)
        else:
            metadata = {}
        
        # Load campfire manifests
        manifests_dir = import_dir / "manifests"
        loaded_campfires = []
        
        if manifests_dir.exists():
            loaded_campfires = self.load_manifests_from_directory(
                str(manifests_dir), party_box
            )
        
        import_results = {
            'import_timestamp': datetime.utcnow().isoformat(),
            'loaded_campfires': loaded_campfires,
            'loaded_count': len(loaded_campfires),
            'original_metadata': metadata
        }
        
        logger.info(f"Imported manager state from: {import_path}")
        return import_results