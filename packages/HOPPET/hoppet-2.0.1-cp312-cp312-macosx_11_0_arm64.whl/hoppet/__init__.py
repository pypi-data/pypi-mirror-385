# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""

A Higher Order Perturbative Parton Evolution Toolkit

HOPPET is a Fortran package for carrying out DGLAP evolution and other 
common manipulations of parton distribution functions (PDFs).

Citation:
G.P. Salam, J. Rojo, 'A Higher Order Perturbative Parton Evolution Toolkit (HOPPET)', 
Comput. Phys. Commun. 180 (2009) 120-156, arXiv:0804.3755

and                                                       

A. Karlberg, P. Nason, G.P. Salam, G. Zanderighi & F. Dreyer (arXiv:2510.XXXXX). 

Example:

   import hoppet as hp
   import numpy as np
   
   def main():
       dy = 0.1    
       nloop = 3
       # Start hoppet
       hp.Start(dy, nloop)
       
       asQ0 = 0.35
       Q0 = np.sqrt(2.0)
       # Do the evolution. 
       hp.Evolve(asQ0, Q0, nloop, 1.0, hp.BenchmarkPDFunpol, Q0)
   
       # Evaluate the PDFs at some x values and print them
       xvals = [1e-5,1e-4,1e-3,1e-2,0.1,0.3,0.5,0.7,0.9]
       Q = 100.0
   
       print('')
       print('           Evaluating PDFs at Q =',Q, ' GeV')
       print('    x      u-ubar      d-dbar    2(ubr+dbr)    c+cbar       gluon')
       for ix in range(9):
           pdf_array = hp.Eval(xvals[ix], Q)
           print('{:7.1E} {:11.4E} {:11.4E} {:11.4E} {:11.4E} {:11.4E}'.format(
               xvals[ix],
               pdf_array[6 + 2] - pdf_array[6 - 2], 
               pdf_array[6 + 1] - pdf_array[6 - 1], 
               2 * (pdf_array[6 - 1] + pdf_array[6 - 2]),
               pdf_array[6 - 4] + pdf_array[6 + 4],
               pdf_array[6 + 0]
           ))

   
       hp.DeleteAll()
   
For more examples look at https://github.com/hoppet-code/hoppet/tree/master/example_py	

"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _hoppet_swig
else:
    import _hoppet_swig

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



__version__ = "2.0.1"
__author__ = "Frederic Dreyer, Alexander Karlberg, Paolo Nason, Juan Rojo, Gavin Salam, Giulia Zanderighi"


def SetFFN(fixed_nf):
    r"""
    Set things up to be a fixed-flavour number scheme with the given
    fixed_nf number of flavours
    """
    return _hoppet_swig.SetFFN(fixed_nf)

def SetVFN(mc, mb, mt):
    r"""
    Set things up to be a variable-flavour number scheme with the given
    quark (pole) masses. Now deprecated; use hoppetSetPoleMassVFN instead
    """
    return _hoppet_swig.SetVFN(mc, mb, mt)

def SetPoleMassVFN(mc, mb, mt):
    r"""
    Set things up to be a variable-flavour number scheme with the
    given quark (pole) masses. Thresholds are crossed at the pole
    masses, both for the coupling and the PDF evolution.
    """
    return _hoppet_swig.SetPoleMassVFN(mc, mb, mt)

def SetMSbarMassVFN(mc, mb, mt):
    r"""
    Set things up to be a variable-flavour number scheme with the given
    quark (MSbar) masses. Thresholds are crossed at the MSbar
    masses, both for the coupling and the PDF evolution.
    """
    return _hoppet_swig.SetMSbarMassVFN(mc, mb, mt)

def SetApproximateDGLAPN3LO(splitting_variant):
    r"""Arrange for the use of various approximate N3LO splitting functions."""
    return _hoppet_swig.SetApproximateDGLAPN3LO(splitting_variant)

def SetSplittingNNLO(splitting_variant):
    r"""Arrange for the use of various NNLO splitting functions."""
    return _hoppet_swig.SetSplittingNNLO(splitting_variant)

def SetSplittingN3LO(splitting_variant):
    r"""Arrange for the use of various N3LO splitting functions."""
    return _hoppet_swig.SetSplittingN3LO(splitting_variant)

def SetN3LOnfthresholds(variant):
    r"""Arrange for the use of N3LO mass thresholds or not."""
    return _hoppet_swig.SetN3LOnfthresholds(variant)

def SetYLnlnQInterpOrders(yorder, lnlnQorder):
    r"""Override the default interpolation order in y and lnlnQ."""
    return _hoppet_swig.SetYLnlnQInterpOrders(yorder, lnlnQorder)

def SetCoupling(asQ0, Q0alphas, nloop):
    return _hoppet_swig.SetCoupling(asQ0, Q0alphas, nloop)

def PreEvolve(asQ0, Q0alphas, nloop, muR_Q, Q0pdf):
    r"""Prepare a cached evolution"""
    return _hoppet_swig.PreEvolve(asQ0, Q0alphas, nloop, muR_Q, Q0pdf)

def AlphaS(Q):
    r"""Return the coupling at scale Q"""
    return _hoppet_swig.AlphaS(Q)

def EvalFortranIFlv(x, Q, iflv_starts_minus6):
    r"""
    the interface to get a single flavour, which takes iflv
    starting from -6. This is the direct Fortran interface.
    The C++ interface is hoppetEvalIFlv below, which takes the
    hoppet iflv constants, which have been shifted by +6
    to make them non-negative and match the indices to be used
    with hoppetEval
    """
    return _hoppet_swig.EvalFortranIFlv(x, Q, iflv_starts_minus6)

def EvalIFlv(x, Q, iflv):
    r"""
    Return xf(x,Q) for the flavour indicated by iflv, which should
    be one of the hoppet iflv_* constants (iflv_g, iflv_d,
    iflv_ubar, etc.)
    """
    return _hoppet_swig.EvalIFlv(x, Q, iflv)

def StartStrFct(order_max):
    r"""
    ----------------------------------------------------------------------
     Setup of constants and parameters needed for structure functions
    """
    return _hoppet_swig.StartStrFct(order_max)

def WriteLHAPDFGrid(basename, pdf_index):
    r"""
    Write out the contents of tables(0) (assumed to be the PDF) in the
    LHAPDF format
    """
    return _hoppet_swig.WriteLHAPDFGrid(basename, pdf_index)

def version():
    r"""
    Return the version of hoppet as a std::string
    :rtype: string
    :return: The version string
    """
    return _hoppet_swig.version()

def init_global_pdf():
    return _hoppet_swig.init_global_pdf()

def free_global_pdf():
    return _hoppet_swig.free_global_pdf()

def init_global_str_fnc():
    return _hoppet_swig.init_global_str_fnc()

def free_global_str_fnc():
    return _hoppet_swig.free_global_str_fnc()

def pdf_to_array(pdf):
    return _hoppet_swig.pdf_to_array(pdf)

def str_fnc_to_array(str_fnc):
    return _hoppet_swig.str_fnc_to_array(str_fnc)

def SetQED(withqed, qcdqed, plq):
    r"""

    Enable or disable QED evolution with photon and lepton PDFs.

    Parameters:
      withqed (int): 1 to enable QED evolution, 0 to disable
      qcdqed (int): Treatment of QCD-QED coupling (implementation-specific)
      plq (int): 1 to enable lepton splitting function

    Note: Must be called before Start() as it modifies global PDF settings.

    """
    return _hoppet_swig.SetQED(withqed, qcdqed, plq)

def Start(dy, nloop):
    r"""

    Initialize HOPPET evolution tables with basic parameters.

    Parameters:
      dy (float): Step size in ln(1/x). Typical range: 0.1-0.25
      nloop (int): Maximum number of loops (1=LO, 2=NLO, 3=NNLO, 4=N3LO)

    Note: This is the basic initialization. For more control, use StartExtended().

    """
    return _hoppet_swig.Start(dy, nloop)

def StartExtended(ymax, dy, Qmin, Qmax, dlnlnQ, nloop, order, factscheme):
    r"""

    Initialize HOPPET evolution tables with extended parameters.

    Parameters:
      ymax (float): Highest value of ln(1/x) user wants to access
      dy (float): Internal ln(1/x) grid spacing (0.1-0.25 is sensible)
      Qmin (float): Lower limit of Q range [GeV]
      Qmax (float): Upper limit of Q range [GeV]  
      dlnlnQ (float): Internal table spacing in ln(ln(Q)) (e.g. dy/4)
      nloop (int): Maximum number of loops (1=LO, 2=NLO, 3=NNLO, 4=N3LO)
      order (int): Order of numerical interpolation (e.g. -6)
      factscheme (int): Factorization scheme identifier

    This provides full control over the evolution grid setup.

    """
    return _hoppet_swig.StartExtended(ymax, dy, Qmin, Qmax, dlnlnQ, nloop, order, factscheme)

def InitStrFct(order_max, separate_orders, xR, xF):
    r"""

    Initialize structure function calculations.

    Parameters:
      order_max (int): Maximum perturbative order
      separate_orders (int): Whether to separate by order
      xR (float): Renormalization scale factor
      xF (float): Factorization scale factor

    """
    return _hoppet_swig.InitStrFct(order_max, separate_orders, xR, xF)

def InitStrFctFlav(order_max, separate_orders, xR, xF):
    r"""

    Initialize flavour-decomposed structure function calculations.

    Parameters:
      order_max (int): Maximum perturbative order
      separate_orders (int): Whether to separate by order  
      xR (float): Renormalization scale factor
      xF (float): Factorization scale factor

    """
    return _hoppet_swig.InitStrFctFlav(order_max, separate_orders, xR, xF)

def DeleteAll():
    r"""

    Clean up and free all HOPPET internal arrays and memory.

    Call this at the end of your program to free resources.

    """
    return _hoppet_swig.DeleteAll()

def Assign(callback):
    r"""

    Assign a PDF function to HOPPET without evolution.

    Parameters:
      callback (callable): Python function with signature callback(x, Q) 
                           returning array of 13 PDF values

    The callback should return PDFs in HOPPET order:
    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]

    """
    return _hoppet_swig.Assign(callback)

def Evolve(asQ0, Q0alphas, nloop, muR_Q, callback, Q0pdf):
    r"""

    Evolve PDFs from initial scale Q0 to all scales in the grid.

    Parameters:
      asQ0 (float): Strong coupling at initial scale
      Q0alphas (float): Reference scale for alpha_s [GeV]
      nloop (int): Number of loops for evolution
      muR_Q (float): Renormalization scale ratio (muR/Q)
      callback (callable): PDF function with signature callback(x, Q)
      Q0pdf (float): Initial scale for PDF [GeV]

    The callback should return PDFs in HOPPET order:
    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]

    """
    return _hoppet_swig.Evolve(asQ0, Q0alphas, nloop, muR_Q, callback, Q0pdf)

def CachedEvolve(callback):
    r"""

    Perform a cached evolution.

    Parameters:
      callback (callable): PDF function with signature callback(x, Q)
                           returning array of 13 PDF values

    More efficient than Evolve() when doing multiple evolutions. Needs a call to PreEvolve() first.

    """
    return _hoppet_swig.CachedEvolve(callback)

def Eval(x, Q):
    r"""

    Evaluate evolved PDFs at given x and Q.

    Parameters:
      x (float): Bjorken x value (0 < x < 1)
      Q (float): Energy scale [GeV]

    Returns:
      list: Array of 13 PDF values in HOPPET order:
            [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]

    """
    return _hoppet_swig.Eval(x, Q)

def EvalSplit(x, Q, iloop, nf):
    r"""

     Return the value of 

        [P(iloop,nf) \otimes pdf] (x,Q)

     where P(iloop,nf) is the iloop-splitting function for the given
     value of nf, and pdf is our internally stored pdf.

     The normalisation is such that the nloop dglap evolution equation is

         dpdf/dlnQ^2 = sum_{iloop=1}^nloop 
                            (alphas/(2*pi))^iloop * P(iloop,nf) \otimes pdf

     Note that each time nf changes relative to a previous call for the
     same iloop, the convolution has to be repeated for the whole
     table. So for efficient results when requiring multiple nf values,
     calls with the same nf value should be grouped together.

     In particular, for repeated calls with the same value of nf, the
     convolutions are carried out only on the first call (i.e. once for
     each value of iloop). Multiple calls with different values for
     iloop can be carried out without problems.

     Note that iloop can also be of the form ij or ijk, which means
     P(i)*P(j)*pdf or P(i)*P(j)*P(k)*pdf. The sum of i+j+k is currently
     bounded to be <= 4.

     The number of loops must be consistent with iloop

    Parameters:
      x (float): Bjorken x value (0 < x < 1)
      Q (float): Energy scale [GeV]
      iloop (int): Perturbative order (1=LO, 2=NLO, etc.)
      nf (int): Number of active flavours

    Returns:
      list: Array of 13 PDF values at specified order and nf

    """
    return _hoppet_swig.EvalSplit(x, Q, iloop, nf)

def BenchmarkPDFunpol(x, Q):
    r"""

    Evaluate the unpolarized benchmark PDF set.

    Parameters:
      x (float): Bjorken x value (0 < x < 1)  
      Q (float): Energy scale [GeV]

    Returns:
      list: Array of 13 benchmark PDF values

    Useful for testing and validation against known results.

    """
    return _hoppet_swig.BenchmarkPDFunpol(x, Q)

def StrFct(x, Q, muR_in, muF_in):
    r"""

    Calculate structure functions with specified scales.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of structure function values

    """
    return _hoppet_swig.StrFct(x, Q, muR_in, muF_in)

def StrFctNoMu(x, Q):
    r"""

    Calculate structure functions with default scale choices.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV] (used for both muR and muF)

    Returns:
      list: Array of structure function values

    """
    return _hoppet_swig.StrFctNoMu(x, Q)

def StrFctLO(x, Q, muR_in, muF_in):
    r"""

    Calculate leading-order structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of LO structure function values

    """
    return _hoppet_swig.StrFctLO(x, Q, muR_in, muF_in)

def StrFctNLO(x, Q, muR_in, muF_in):
    r"""

    Calculate next-to-leading-order structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of NLO structure function values

    """
    return _hoppet_swig.StrFctNLO(x, Q, muR_in, muF_in)

def StrFctFlav(x, Q, muR_in, muF_in, flav):
    r"""

    Calculate flavour-decomposed structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]
      flav (int): Flavour index

    Returns:
      list: Array of structure function values for specified flavour

    """
    return _hoppet_swig.StrFctFlav(x, Q, muR_in, muF_in, flav)

def StrFctNoMuFlav(x, Q, flav):
    r"""

    Calculate flavour-decomposed structure functions with default scales.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]  
      flav (int): Flavour index

    Returns:
      list: Array of structure function values for specified flavour

    """
    return _hoppet_swig.StrFctNoMuFlav(x, Q, flav)

def StrFctLOFlav(x, Q, muR_in, muF_in, flav):
    r"""

    Calculate LO flavour-decomposed structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]
      flav (int): Flavour index

    Returns:
      list: Array of LO structure function values for specified flavour

    """
    return _hoppet_swig.StrFctLOFlav(x, Q, muR_in, muF_in, flav)

def StrFctNLOFlav(x, Q, muR_in, muF_in, flav):
    r"""

    Calculate NLO flavour-decomposed structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]
      flav (int): Flavour index

    Returns:
      list: Array of NLO structure function values for specified flavour

    """
    return _hoppet_swig.StrFctNLOFlav(x, Q, muR_in, muF_in, flav)

def StrFctNNLO(x, Q, muR_in, muF_in):
    r"""

    Calculate next-to-next-to-leading-order structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]  
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of NNLO structure function values

    """
    return _hoppet_swig.StrFctNNLO(x, Q, muR_in, muF_in)

def StrFctN3LO(x, Q, muR_in, muF_in):
    r"""

    Calculate next-to-next-to-next-to-leading-order structure functions.

    Parameters:
      x (float): Bjorken x value
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of N3LO structure function values

    """
    return _hoppet_swig.StrFctN3LO(x, Q, muR_in, muF_in)

cvar = _hoppet_swig.cvar
iF1Wp = cvar.iF1Wp
iF2Wp = cvar.iF2Wp
iF3Wp = cvar.iF3Wp
iF1Wm = cvar.iF1Wm
iF2Wm = cvar.iF2Wm
iF3Wm = cvar.iF3Wm
iF1Z = cvar.iF1Z
iF2Z = cvar.iF2Z
iF3Z = cvar.iF3Z
iF1EM = cvar.iF1EM
iF2EM = cvar.iF2EM
iF1gZ = cvar.iF1gZ
iF2gZ = cvar.iF2gZ
iF3gZ = cvar.iF3gZ
scale_choice_fixed = cvar.scale_choice_fixed
scale_choice_Q = cvar.scale_choice_Q
scale_choice_arbitrary = cvar.scale_choice_arbitrary
nnlo_splitting_exact = cvar.nnlo_splitting_exact
nnlo_splitting_param = cvar.nnlo_splitting_param
nnlo_splitting_Nfitav = cvar.nnlo_splitting_Nfitav
nnlo_splitting_Nfiterr1 = cvar.nnlo_splitting_Nfiterr1
nnlo_splitting_Nfiterr2 = cvar.nnlo_splitting_Nfiterr2
n3lo_splitting_exact = cvar.n3lo_splitting_exact
n3lo_splitting_param = cvar.n3lo_splitting_param
n3lo_splitting_Nfitav = cvar.n3lo_splitting_Nfitav
n3lo_splitting_Nfiterr1 = cvar.n3lo_splitting_Nfiterr1
n3lo_splitting_Nfiterr2 = cvar.n3lo_splitting_Nfiterr2
n3lo_splitting_approximation_up_to_2310_05744 = cvar.n3lo_splitting_approximation_up_to_2310_05744
n3lo_splitting_approximation_up_to_2404_09701 = cvar.n3lo_splitting_approximation_up_to_2404_09701
n3lo_splitting_approximation_up_to_2410_08089 = cvar.n3lo_splitting_approximation_up_to_2410_08089
nnlo_nfthreshold_exact = cvar.nnlo_nfthreshold_exact
nnlo_nfthreshold_param = cvar.nnlo_nfthreshold_param
n3lo_nfthreshold_on = cvar.n3lo_nfthreshold_on
n3lo_nfthreshold_off = cvar.n3lo_nfthreshold_off
factscheme_MSbar = cvar.factscheme_MSbar
factscheme_DIS = cvar.factscheme_DIS
factscheme_PolMSbar = cvar.factscheme_PolMSbar
factscheme_FragMSbar = cvar.factscheme_FragMSbar
iflv_g = cvar.iflv_g
iflv_d = cvar.iflv_d
iflv_u = cvar.iflv_u
iflv_s = cvar.iflv_s
iflv_c = cvar.iflv_c
iflv_b = cvar.iflv_b
iflv_t = cvar.iflv_t
iflv_dbar = cvar.iflv_dbar
iflv_ubar = cvar.iflv_ubar
iflv_sbar = cvar.iflv_sbar
iflv_cbar = cvar.iflv_cbar
iflv_bbar = cvar.iflv_bbar
iflv_tbar = cvar.iflv_tbar
iflv_photon = cvar.iflv_photon
iflv_electron = cvar.iflv_electron
iflv_muon = cvar.iflv_muon
iflv_tau = cvar.iflv_tau

