from typing import Any, Callable, Dict, Mapping, Optional, Sequence, Tuple, Union

import numpy as np
import numpy.typing as npt

import aadc.ndarray

# Declare classes
class Functions:
    def __init__(self) -> None: ...
    def start_recording(self) -> None: ...
    def stop_recording(self) -> None: ...
    def get_number_of_required_random_variables(self) -> int: ...
    def print_passive_extract_locations(self) -> None: ...
    def recording_stats(self, func_name: str = "PYTHON") -> str: ...
    def stop_on_active_to_passive(self) -> None: ...

class ThreadPool:
    def __init__(self, num_threads: int) -> None: ...
    def num_threads(self) -> int: ...

class Argument:
    def __init__(self, index: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: "Argument") -> bool: ...
    def __hash__(self) -> int: ...

class Result:
    def __init__(self, index: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: "Result") -> bool: ...
    def __hash__(self) -> int: ...

class idouble:  # noqa: N801
    def __init__(self, val: float) -> None: ...
    def __float__(self) -> float: ...
    # Declare fake array method to pose as NumPy _SupportsArray (necessary for use in ufuncs and array functions)
    def __array__(self, dtype: npt.DTypeLike = None, copy: Optional[bool] = None) -> np.ndarray: ...
    def is_active(self) -> bool: ...
    def mark_as_input(self) -> Argument: ...
    def mark_as_output(self) -> Result: ...
    def mark_as_diff(self) -> Argument: ...
    def mark_as_input_no_diff(self) -> Argument: ...
    def val(self) -> float: ...
    def passive(self) -> float: ...

    # Adding type hints for dunder methods defined via macros
    def __add__(self, other: "idouble") -> "idouble": ...  # type hint for __add__
    def __sub__(self, other: "idouble") -> "idouble": ...  # type hint for __sub__
    def __mul__(self, other: "idouble") -> "idouble": ...  # type hint for __mul__
    def __truediv__(self, other: "idouble") -> "idouble": ...  # type hint for __truediv__
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: "idouble") -> bool: ...  # type hint for __lt__
    def __le__(self, other: "idouble") -> bool: ...  # type hint for __le__
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: "idouble") -> bool: ...  # type hint for __gt__
    def __ge__(self, other: "idouble") -> bool: ...  # type hint for __ge__

    # Adding type hints for the remaining dunder methods
    def __copy__(self) -> "idouble": ...  # type hint for __copy__
    def __deepcopy__(self, memo: Optional[dict] = None) -> "idouble": ...  # type hint for __deepcopy__
    def __repr__(self) -> str: ...  # type hint for __repr__
    def __round__(self, n: int = 0) -> "idouble": ...  # type hint for __round__
    def __neg__(self) -> "idouble": ...  # type hint for __neg__
    def __pos__(self) -> "idouble": ...  # type hint for __pos__
    def __abs__(self) -> "idouble": ...  # type hint for __abs__

    # Add missing math methods
    def acos(self) -> "idouble": ...
    def acosh(self) -> "idouble": ...
    def arccos(self) -> "idouble": ...
    def arccosh(self) -> "idouble": ...
    def arcsin(self) -> "idouble": ...
    def arcsinh(self) -> "idouble": ...
    def arctan(self) -> "idouble": ...
    def arctanh(self) -> "idouble": ...
    def asin(self) -> "idouble": ...
    def asinh(self) -> "idouble": ...
    def atan(self) -> "idouble": ...
    def atan2(self, other: Union["idouble", float]) -> "idouble": ...
    def atanh(self) -> "idouble": ...
    def cbrt(self) -> "idouble": ...
    def ceil(self) -> "idouble": ...
    def conjugate(self) -> "idouble": ...
    def copysign(self, other: Union["idouble", float]) -> "idouble": ...
    def cos(self) -> "idouble": ...
    def cosh(self) -> "idouble": ...
    def erf(self) -> "idouble": ...
    def erfc(self) -> "idouble": ...
    def exp(self) -> "idouble": ...
    def exp2(self) -> "idouble": ...
    def expm1(self) -> "idouble": ...
    def floor(self) -> "idouble": ...
    def isfinite(self) -> bool: ...
    def isinf(self) -> bool: ...
    def isnan(self) -> bool: ...
    def log(self) -> "idouble": ...
    def log10(self) -> "idouble": ...
    def log1p(self) -> "idouble": ...
    def log2(self) -> "idouble": ...
    def pow(self, other: Union["idouble", float]) -> "idouble": ...
    def sin(self) -> "idouble": ...
    def sinh(self) -> "idouble": ...
    def sqrt(self) -> "idouble": ...
    def tan(self) -> "idouble": ...
    def tanh(self) -> "idouble": ...
    def to_int(self) -> int: ...
    def trunc(self) -> "idouble": ...

    # Add missing arithmetic operators
    def __iadd__(self, other: Union["idouble", float]) -> "idouble": ...
    def __idiv__(self, other: Union["idouble", float]) -> "idouble": ...
    def __imul__(self, other: Union["idouble", float]) -> "idouble": ...
    def __isub__(self, other: Union["idouble", float]) -> "idouble": ...
    def __radd__(self, other: float) -> "idouble": ...
    def __req__(self, other: object) -> bool: ...
    def __rge__(self, other: float) -> bool: ...
    def __rgt__(self, other: float) -> bool: ...
    def __rle__(self, other: float) -> bool: ...
    def __rlt__(self, other: float) -> bool: ...
    def __rmul__(self, other: float) -> "idouble": ...
    def __rne__(self, other: object) -> bool: ...
    def __rpow__(self, other: float) -> "idouble": ...
    def __rsub__(self, other: float) -> "idouble": ...
    def __rtruediv__(self, other: float) -> "idouble": ...

    # Add missing NumPy array interface methods
    def __array_function__(self, func: Any, types: Any, args: Any, kwargs: Any) -> Any: ...
    def __array_ufunc__(
        self, ufunc: Any, method: str, *inputs: Any, out: Optional[Any] = None, **kwargs: Any
    ) -> Any: ...

class ibool:  # noqa: N801
    def __init__(self, val: bool) -> None: ...
    def __bool__(self) -> bool: ...
    def __array__(self, dtype: npt.DTypeLike = None, copy: Optional[bool] = None) -> np.ndarray: ...
    def __array_function__(self, func: Any, types: Any, args: Any, kwargs: Any) -> Any: ...
    def __array_ufunc__(
        self, ufunc: Any, method: str, *inputs: Any, out: Optional[Any] = None, **kwargs: Any
    ) -> Any: ...
    def is_active(self) -> bool: ...
    def val(self) -> bool: ...

    # Adding type hints for dunder methods defined via macros
    def __copy__(self) -> "ibool": ...
    def __deepcopy__(self, memo: Optional[dict] = None) -> "ibool": ...
    def __invert__(self) -> "ibool": ...
    def __and__(self, other: Union["ibool", bool]) -> "ibool": ...
    def __rand__(self, other: bool) -> "ibool": ...
    def __or__(self, other: Union["ibool", bool]) -> "ibool": ...
    def __ror__(self, other: bool) -> "ibool": ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class iint:  # noqa: N801
    def __init__(self, val: int) -> None: ...
    def __int__(self) -> int: ...
    def __array__(self, dtype: npt.DTypeLike = None, copy: Optional[bool] = None) -> np.ndarray: ...
    def is_active(self) -> bool: ...
    def val(self) -> int: ...

    # Adding type hints for dunder methods defined via macros
    def __add__(self, other: Union["iint", int]) -> "iint": ...
    def __radd__(self, other: int) -> "iint": ...
    def __sub__(self, other: Union["iint", int]) -> "iint": ...
    def __rsub__(self, other: int) -> "iint": ...
    def __mul__(self, other: Union["iint", int]) -> "iint": ...
    def __rmul__(self, other: int) -> "iint": ...
    def __iadd__(self, other: Union["iint", int]) -> "iint": ...
    def __isub__(self, other: Union["iint", int]) -> "iint": ...
    def __imul__(self, other: Union["iint", int]) -> "iint": ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: Union["iint", int]) -> bool: ...
    def __le__(self, other: Union["iint", int]) -> bool: ...
    def __gt__(self, other: Union["iint", int]) -> bool: ...
    def __ge__(self, other: Union["iint", int]) -> bool: ...
    def __copy__(self) -> "iint": ...
    def __deepcopy__(self, memo: Optional[dict] = None) -> "iint": ...
    def __rlt__(self, other: int) -> bool: ...
    def __rle__(self, other: int) -> bool: ...
    def __rgt__(self, other: int) -> bool: ...
    def __rge__(self, other: int) -> bool: ...
    def __req__(self, other: object) -> bool: ...
    def __rne__(self, other: object) -> bool: ...
    def __array_function__(self, func: Any, types: Any, args: Any, kwargs: Any) -> Any: ...
    def __array_ufunc__(
        self, ufunc: Any, method: str, *inputs: Any, out: Optional[Any] = None, **kwargs: Any
    ) -> Any: ...

class VectorFunctionWithAD:
    def __init__(
        self,
        funcs: Functions,
        args: Sequence[Argument] | npt.NDArray[np.object_],
        res: Sequence[Result] | npt.NDArray[np.object_],
        *,
        param_args: Sequence[Argument] | npt.NDArray[np.object_] = ...,
        batch_param_args: Sequence[Argument] | npt.NDArray[np.object_] = ...,
        num_threads: int = 1,
    ) -> None: ...
    def evaluate(
        self, x: npt.NDArray[np.float64] | Sequence[float]
    ) -> Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64]]: ...
    def set_params(self, params: npt.NDArray[np.float64] | Sequence[float]) -> None: ...
    def set_batch_params(self, batch_params: npt.NDArray[np.float64] | Sequence[float]) -> None: ...

class VectorFunctionWithJacobian:
    def __init__(
        self,
        funcs: Functions,
        args: Sequence[Argument] | npt.NDArray[np.object_],
        param_args: Sequence[Argument],
        res: Sequence[Result] | npt.NDArray[np.object_],
        **options: Any,
    ) -> None: ...
    def func(self, x: npt.NDArray[np.float64] | Sequence[float]) -> npt.NDArray[np.float64]: ...
    def jac(self, x: npt.NDArray[np.float64] | Sequence[float]) -> npt.NDArray[np.float64]: ...
    def set_params(self, params: npt.NDArray[np.float64] | Sequence[float]) -> None: ...

class passive:  # noqa: N801
    def __init__(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None: ...

def evaluate(
    funcs: Functions,
    request: Mapping[Result, Sequence[Argument] | npt.NDArray[np.object_]],
    inputs: Mapping[Argument, npt.ArrayLike],
    pool: ThreadPool,
) -> Tuple[Dict[Result, npt.NDArray[np.float64]], Dict[Result, Dict[Argument, npt.NDArray[np.float64]]]]: ...
def evaluate_sums(
    funcs: Functions,
    request: Mapping[Result, Sequence[Argument] | npt.NDArray[np.object_]],
    inputs: Mapping[Argument, npt.ArrayLike],
    pool: ThreadPool,
) -> Tuple[Dict[Result, npt.NDArray[np.float64]], Dict[Result, Dict[Argument, npt.NDArray[np.float64]]]]: ...
def _evaluate_matrix_inputs(
    funcs: Functions,
    request: Sequence[Tuple[Result, Sequence[npt.NDArray[np.object_]] | npt.NDArray[np.object_]]],
    inputs: Sequence[Tuple[npt.NDArray[np.object_], npt.NDArray[np.float64]]],
    num_threads: int,
) -> Tuple[
    npt.NDArray[np.float64],
    Sequence[Tuple[Result, Sequence[Argument] | npt.NDArray[np.object_], npt.NDArray[np.float64]]],
]: ...
def is_recording() -> bool: ...
def version() -> str: ...
def mark_variable_as_random_input(val: float) -> idouble: ...
def get_array_input_argument() -> int: ...
def get(inputs: Sequence[idouble] | aadc.ndarray.AADCArray, idx: iint) -> idouble: ...

# Add math submodule type hints
class math:  # noqa: N801
    @staticmethod
    def equal_to(
        a: Union[idouble, iint, ibool], b: Union[idouble, iint, ibool, float, int, bool]
    ) -> Union[bool, ibool]: ...
    @staticmethod
    def not_equal(
        a: Union[idouble, iint, ibool], b: Union[idouble, iint, ibool, float, int, bool]
    ) -> Union[bool, ibool]: ...
    @staticmethod
    def less(a: Union[idouble, iint], b: Union[idouble, iint, float, int]) -> bool: ...
    @staticmethod
    def greater(a: Union[idouble, iint], b: Union[idouble, iint, float, int]) -> bool: ...
    @staticmethod
    def geq(a: Union[idouble, iint], b: Union[idouble, iint, float, int]) -> bool: ...
    @staticmethod
    def leq(a: Union[idouble, iint], b: Union[idouble, iint, float, int]) -> bool: ...
    @staticmethod
    def add(a: Union[idouble, iint], b: Union[idouble, iint, float, int]) -> Union[idouble, iint]: ...
    @staticmethod
    def subtract(a: Union[idouble, iint], b: Union[idouble, iint, float, int]) -> Union[idouble, iint]: ...

    # Two argument math functions
    @staticmethod
    def atan2(a: Union[idouble, float], b: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def copysign(a: Union[idouble, float], b: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def pow(a: Union[idouble, float], b: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def min(a: Union[idouble, iint, float, int], b: Union[idouble, iint, float, int]) -> Union[idouble, iint]: ...
    @staticmethod
    def max(a: Union[idouble, iint, float, int], b: Union[idouble, iint, float, int]) -> Union[idouble, iint]: ...

    # Single argument math functions
    @staticmethod
    def abs(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def exp(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def exp2(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def expm1(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def log(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def log2(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def log10(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def log1p(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def sqrt(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def trunc(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def floor(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def ceil(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def sin(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def cos(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def tan(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def asin(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def acos(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def atan(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def sinh(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def cosh(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def tanh(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def asinh(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def acosh(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def atanh(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def erf(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def erfc(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def cbrt(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def cdf_normal(x: Union[idouble, float]) -> idouble: ...
    @staticmethod
    def sign(x: Union[idouble, float]) -> idouble: ...

# Add missing classes and functions
class ExternalFunction:
    pass

Kernel = Functions  # Kernel is an alias for Functions

class VectorFunction:
    pass

def iand(a: ibool, b: ibool) -> ibool: ...
def iif(cond: ibool, a: Any, b: Any) -> Any: ...
def inot(a: ibool) -> ibool: ...
def ior(a: ibool, b: ibool) -> ibool: ...
def lower_bound(inputs: Sequence[float], x: idouble) -> iint: ...


class OptimizationResult:
    """Result object from optimization functions like least_squares."""
    x: Sequence[idouble]  # Solution vector
    cost: idouble         # Final cost value
    iterations: int       # Number of iterations
    success: bool         # Whether optimization succeeded
    message: str          # Status message
    nfev: int             # Number of function evaluations

def levenberg_marquardt(
    func: Callable[[Sequence[idouble]], Sequence[idouble]],
    x0: npt.ArrayLike,
    ftol: float = 1e-8,
    xtol: float = 1e-8,
    gtol: float = 1e-8,
    max_nfev: int = -1,
    verbose: int = 0
) -> OptimizationResult:
    """
    Simplified Levenberg-Marquardt implementation for AADC.

    Parameters
    ----------
    func : callable
        Function which computes the vector of residuals
    x0 : array_like
        Initial guess for parameters
    ftol : float, optional
        Tolerance for termination by the change in the cost function
    xtol : float, optional
        Tolerance for termination by the change of the independent variables
    gtol : float, optional
        Tolerance for termination by the norm of the gradient
    max_nfev : int, optional
        Maximum number of function evaluations. -1 means no limit
    verbose : int, optional
        Level of algorithm's verbosity (0, 1, or 2)

    Returns
    -------
    OptimizationResult
        The optimization result with solution vector and diagnostics
    """
    ...

def root_scalar(
    f: Callable[[idouble], idouble],
    *,
    x0: float = 0.0,
    method: str = "newton",
    xtol: float = 1e-15,
    maxiter: int = 100
) -> idouble:
    """
    Find a root of a scalar function using Newton's method.

    Parameters
    ----------
    f : callable
        A function that takes an idouble and returns an idouble
    x0 : float, optional
        Initial guess
    method : str, optional
        Method of root finding. Currently only 'newton' is supported
    xtol : float, optional
        Tolerance for termination by the change in x
    maxiter : int, optional
        Maximum number of iterations

    Returns
    -------
    idouble
        The root of the function

    Raises
    ------
    ValueError
        If method is not 'newton'
    """
    ...

def least_squares(
    fun: Callable[[Sequence[idouble]], Sequence[idouble]],
    x0: npt.ArrayLike,
    *,
    method: str = "lm",
    ftol: float = 1e-8,
    xtol: float = 1e-8,
    gtol: float = 1e-8,
    max_nfev: int = -1,
    verbose: int = 0
) -> OptimizationResult:
    """
    Solves a nonlinear least-squares problem using Levenberg-Marquardt algorithm.

    Parameters
    ----------
    fun : callable
        Function which computes the vector of residuals. Must take x as first argument.
    x0 : array_like with shape (n,)
        Initial guess on independent variables.
    method : str, optional
        Only 'lm' is supported for Levenberg-Marquardt.
    ftol : float, optional
        Tolerance for termination by the change in the cost function.
    xtol : float, optional
        Tolerance for termination by the change of the independent variables.
    gtol : float, optional
        Tolerance for termination by the norm of the gradient.
    max_nfev : int, optional
        Maximum number of function evaluations. -1 means no limit.
    verbose : {0, 1, 2}, optional
        Level of algorithm's verbosity.

    Returns
    -------
    OptimizationResult
        Result of the optimization containing solution vector and diagnostics.

    Raises
    ------
    ValueError
        If method is not 'lm', bounds are specified, or non-linear loss function is used.
    """
    ...
