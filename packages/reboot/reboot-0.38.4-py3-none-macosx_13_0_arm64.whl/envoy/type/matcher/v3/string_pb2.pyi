"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.type.matcher.v3.regex_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class StringMatcher(google.protobuf.message.Message):
    """[#protodoc-title: String matcher]

    Specifies the way to match a string.
    [#next-free-field: 8]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXACT_FIELD_NUMBER: builtins.int
    PREFIX_FIELD_NUMBER: builtins.int
    SUFFIX_FIELD_NUMBER: builtins.int
    SAFE_REGEX_FIELD_NUMBER: builtins.int
    CONTAINS_FIELD_NUMBER: builtins.int
    IGNORE_CASE_FIELD_NUMBER: builtins.int
    exact: builtins.str
    """The input string must match exactly the string specified here.

    Examples:

    * ``abc`` only matches the value ``abc``.
    """
    prefix: builtins.str
    """The input string must have the prefix specified here.
    Note: empty prefix is not allowed, please use regex instead.

    Examples:

    * ``abc`` matches the value ``abc.xyz``
    """
    suffix: builtins.str
    """The input string must have the suffix specified here.
    Note: empty prefix is not allowed, please use regex instead.

    Examples:

    * ``abc`` matches the value ``xyz.abc``
    """
    contains: builtins.str
    """The input string must have the substring specified here.
    Note: empty contains match is not allowed, please use regex instead.

    Examples:

    * ``abc`` matches the value ``xyz.abc.def``
    """
    ignore_case: builtins.bool
    """If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. This
    has no effect for the safe_regex match.
    For example, the matcher ``data`` will match both input string ``Data`` and ``data`` if set to true.
    """
    @property
    def safe_regex(self) -> envoy.type.matcher.v3.regex_pb2.RegexMatcher:
        """The input string must match the regular expression specified here."""

    def __init__(
        self,
        *,
        exact: builtins.str = ...,
        prefix: builtins.str = ...,
        suffix: builtins.str = ...,
        safe_regex: envoy.type.matcher.v3.regex_pb2.RegexMatcher | None = ...,
        contains: builtins.str = ...,
        ignore_case: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["contains", b"contains", "exact", b"exact", "match_pattern", b"match_pattern", "prefix", b"prefix", "safe_regex", b"safe_regex", "suffix", b"suffix"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["contains", b"contains", "exact", b"exact", "ignore_case", b"ignore_case", "match_pattern", b"match_pattern", "prefix", b"prefix", "safe_regex", b"safe_regex", "suffix", b"suffix"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["match_pattern", b"match_pattern"]) -> typing.Literal["exact", "prefix", "suffix", "safe_regex", "contains"] | None: ...

global___StringMatcher = StringMatcher

@typing.final
class ListStringMatcher(google.protobuf.message.Message):
    """Specifies a list of ways to match a string."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATTERNS_FIELD_NUMBER: builtins.int
    @property
    def patterns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StringMatcher]: ...
    def __init__(
        self,
        *,
        patterns: collections.abc.Iterable[global___StringMatcher] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["patterns", b"patterns"]) -> None: ...

global___ListStringMatcher = ListStringMatcher
