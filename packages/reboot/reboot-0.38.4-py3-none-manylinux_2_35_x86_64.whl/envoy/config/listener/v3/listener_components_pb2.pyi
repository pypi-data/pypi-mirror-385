"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.config.core.v3.address_pb2
import envoy.config.core.v3.base_pb2
import envoy.config.core.v3.config_source_pb2
import envoy.type.v3.range_pb2
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Filter(google.protobuf.message.Message):
    """[#protodoc-title: Listener components]
    Listener :ref:`configuration overview <config_listeners>`

    [#next-free-field: 6]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPED_CONFIG_FIELD_NUMBER: builtins.int
    CONFIG_DISCOVERY_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The name of the filter configuration."""
    @property
    def typed_config(self) -> google.protobuf.any_pb2.Any:
        """Filter specific configuration which depends on the filter being
        instantiated. See the supported filters for further documentation.
        [#extension-category: envoy.filters.network]
        """

    @property
    def config_discovery(self) -> envoy.config.core.v3.config_source_pb2.ExtensionConfigSource:
        """Configuration source specifier for an extension configuration discovery
        service. In case of a failure and without the default configuration, the
        listener closes the connections.
        [#not-implemented-hide:]
        """

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        typed_config: google.protobuf.any_pb2.Any | None = ...,
        config_discovery: envoy.config.core.v3.config_source_pb2.ExtensionConfigSource | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["config_discovery", b"config_discovery", "config_type", b"config_type", "typed_config", b"typed_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["config_discovery", b"config_discovery", "config_type", b"config_type", "name", b"name", "typed_config", b"typed_config"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["config_type", b"config_type"]) -> typing.Literal["typed_config", "config_discovery"] | None: ...

global___Filter = Filter

@typing.final
class FilterChainMatch(google.protobuf.message.Message):
    """Specifies the match criteria for selecting a specific filter chain for a
    listener.

    In order for a filter chain to be selected, *ALL* of its criteria must be
    fulfilled by the incoming connection, properties of which are set by the
    networking stack and/or listener filters.

    The following order applies:

    1. Destination port.
    2. Destination IP address.
    3. Server name (e.g. SNI for TLS protocol),
    4. Transport protocol.
    5. Application protocols (e.g. ALPN for TLS protocol).
    6. Directly connected source IP address (this will only be different from the source IP address
       when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol
       listener filter <config_listener_filters_proxy_protocol>`).
    7. Source type (e.g. any, local or external network).
    8. Source IP address.
    9. Source port.

    For criteria that allow ranges or wildcards, the most specific value in any
    of the configured filter chains that matches the incoming connection is going
    to be used (e.g. for SNI ``www.example.com`` the most specific match would be
    ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
    chain without ``server_names`` requirements).

    A different way to reason about the filter chain matches:
    Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps.
    In each step, filter chains which most specifically matches the attributes continue to the next step.
    The listener guarantees at most 1 filter chain is left after all of the steps.

    Example:

    For destination port, filter chains specifying the destination port of incoming traffic are the
    most specific match. If none of the filter chains specifies the exact destination port, the filter
    chains which do not specify ports are the most specific match. Filter chains specifying the
    wrong port can never be the most specific match.

    [#comment: Implemented rules are kept in the preference order, with deprecated fields
    listed at the end, because that's how we want to list them in the docs.

    [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
    [#next-free-field: 14]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ConnectionSourceType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ConnectionSourceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FilterChainMatch._ConnectionSourceType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ANY: FilterChainMatch._ConnectionSourceType.ValueType  # 0
        """Any connection source matches."""
        SAME_IP_OR_LOOPBACK: FilterChainMatch._ConnectionSourceType.ValueType  # 1
        """Match a connection originating from the same host."""
        EXTERNAL: FilterChainMatch._ConnectionSourceType.ValueType  # 2
        """Match a connection originating from a different host."""

    class ConnectionSourceType(_ConnectionSourceType, metaclass=_ConnectionSourceTypeEnumTypeWrapper): ...
    ANY: FilterChainMatch.ConnectionSourceType.ValueType  # 0
    """Any connection source matches."""
    SAME_IP_OR_LOOPBACK: FilterChainMatch.ConnectionSourceType.ValueType  # 1
    """Match a connection originating from the same host."""
    EXTERNAL: FilterChainMatch.ConnectionSourceType.ValueType  # 2
    """Match a connection originating from a different host."""

    DESTINATION_PORT_FIELD_NUMBER: builtins.int
    PREFIX_RANGES_FIELD_NUMBER: builtins.int
    ADDRESS_SUFFIX_FIELD_NUMBER: builtins.int
    SUFFIX_LEN_FIELD_NUMBER: builtins.int
    DIRECT_SOURCE_PREFIX_RANGES_FIELD_NUMBER: builtins.int
    SOURCE_TYPE_FIELD_NUMBER: builtins.int
    SOURCE_PREFIX_RANGES_FIELD_NUMBER: builtins.int
    SOURCE_PORTS_FIELD_NUMBER: builtins.int
    SERVER_NAMES_FIELD_NUMBER: builtins.int
    TRANSPORT_PROTOCOL_FIELD_NUMBER: builtins.int
    APPLICATION_PROTOCOLS_FIELD_NUMBER: builtins.int
    address_suffix: builtins.str
    """If non-empty, an IP address and suffix length to match addresses when the
    listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
    [#not-implemented-hide:]
    """
    source_type: global___FilterChainMatch.ConnectionSourceType.ValueType
    """Specifies the connection source IP match type. Can be any, local or external network."""
    transport_protocol: builtins.str
    """If non-empty, a transport protocol to consider when determining a filter chain match.
    This value will be compared against the transport protocol of a new connection, when
    it's detected by one of the listener filters.

    Suggested values include:

    * ``raw_buffer`` - default, used when no transport protocol is detected,
    * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
      when TLS protocol is detected.
    """
    @property
    def destination_port(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Optional destination port to consider when use_original_dst is set on the
        listener in determining a filter chain match.
        """

    @property
    def prefix_ranges(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.address_pb2.CidrRange]:
        """If non-empty, an IP address and prefix length to match addresses when the
        listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
        """

    @property
    def suffix_len(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """[#not-implemented-hide:]"""

    @property
    def direct_source_prefix_ranges(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.address_pb2.CidrRange]:
        """The criteria is satisfied if the directly connected source IP address of the downstream
        connection is contained in at least one of the specified subnets. If the parameter is not
        specified or the list is empty, the directly connected source IP address is ignored.
        """

    @property
    def source_prefix_ranges(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.address_pb2.CidrRange]:
        """The criteria is satisfied if the source IP address of the downstream
        connection is contained in at least one of the specified subnets. If the
        parameter is not specified or the list is empty, the source IP address is
        ignored.
        """

    @property
    def source_ports(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The criteria is satisfied if the source port of the downstream connection
        is contained in at least one of the specified ports. If the parameter is
        not specified, the source port is ignored.
        """

    @property
    def server_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
        a filter chain match. Those values will be compared against the server names of a new
        connection, when detected by one of the listener filters.

        The server name will be matched against all wildcard domains, i.e. ``www.example.com``
        will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.

        Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
        The value ``*`` is also not supported, and ``server_names`` should be omitted instead.

        .. attention::

          See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
          information.
        """

    @property
    def application_protocols(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
        determining a filter chain match. Those values will be compared against the application
        protocols of a new connection, when detected by one of the listener filters.

        Suggested values include:

        * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
          <config_listener_filters_tls_inspector>`,
        * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`

        .. attention::

          Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
          application protocol detection based on the requested
          `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.

          However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
          and matching on values other than ``h2`` is going to lead to a lot of false negatives,
          unless all connecting clients are known to use ALPN.
        """

    def __init__(
        self,
        *,
        destination_port: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        prefix_ranges: collections.abc.Iterable[envoy.config.core.v3.address_pb2.CidrRange] | None = ...,
        address_suffix: builtins.str = ...,
        suffix_len: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        direct_source_prefix_ranges: collections.abc.Iterable[envoy.config.core.v3.address_pb2.CidrRange] | None = ...,
        source_type: global___FilterChainMatch.ConnectionSourceType.ValueType = ...,
        source_prefix_ranges: collections.abc.Iterable[envoy.config.core.v3.address_pb2.CidrRange] | None = ...,
        source_ports: collections.abc.Iterable[builtins.int] | None = ...,
        server_names: collections.abc.Iterable[builtins.str] | None = ...,
        transport_protocol: builtins.str = ...,
        application_protocols: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["destination_port", b"destination_port", "suffix_len", b"suffix_len"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address_suffix", b"address_suffix", "application_protocols", b"application_protocols", "destination_port", b"destination_port", "direct_source_prefix_ranges", b"direct_source_prefix_ranges", "prefix_ranges", b"prefix_ranges", "server_names", b"server_names", "source_ports", b"source_ports", "source_prefix_ranges", b"source_prefix_ranges", "source_type", b"source_type", "suffix_len", b"suffix_len", "transport_protocol", b"transport_protocol"]) -> None: ...

global___FilterChainMatch = FilterChainMatch

@typing.final
class FilterChain(google.protobuf.message.Message):
    """A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
    various other parameters.
    [#next-free-field: 10]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class OnDemandConfiguration(google.protobuf.message.Message):
        """The configuration for on-demand filter chain. If this field is not empty in FilterChain message,
        a filter chain will be built on-demand.
        On-demand filter chains help speedup the warming up of listeners since the building and initialization of
        an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain.
        Filter chains that are not often used can be set as on-demand.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        REBUILD_TIMEOUT_FIELD_NUMBER: builtins.int
        @property
        def rebuild_timeout(self) -> google.protobuf.duration_pb2.Duration:
            """The timeout to wait for filter chain placeholders to complete rebuilding.
            1. If this field is set to 0, timeout is disabled.
            2. If not specified, a default timeout of 15s is used.
            Rebuilding will wait until dependencies are ready, have failed, or this timeout is reached.
            Upon failure or timeout, all connections related to this filter chain will be closed.
            Rebuilding will start again on the next new connection.
            """

        def __init__(
            self,
            *,
            rebuild_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["rebuild_timeout", b"rebuild_timeout"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["rebuild_timeout", b"rebuild_timeout"]) -> None: ...

    FILTER_CHAIN_MATCH_FIELD_NUMBER: builtins.int
    FILTERS_FIELD_NUMBER: builtins.int
    USE_PROXY_PROTO_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    TRANSPORT_SOCKET_FIELD_NUMBER: builtins.int
    TRANSPORT_SOCKET_CONNECT_TIMEOUT_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    ON_DEMAND_CONFIGURATION_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The unique name (or empty) by which this filter chain is known.
    Note: :ref:`filter_chain_matcher
    <envoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher>`
    requires that filter chains are uniquely named within a listener.
    """
    @property
    def filter_chain_match(self) -> global___FilterChainMatch:
        """The criteria to use when matching a connection to this filter chain."""

    @property
    def filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Filter]:
        """A list of individual network filters that make up the filter chain for
        connections established with the listener. Order matters as the filters are
        processed sequentially as connection events happen. Note: If the filter
        list is empty, the connection will close by default.

        For QUIC listeners, network filters other than HTTP Connection Manager (HCM)
        can be created, but due to differences in the connection implementation compared
        to TCP, the onData() method will never be called. Therefore, network filters
        for QUIC listeners should only expect to do work at the start of a new connection
        (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain.
        """

    @property
    def use_proxy_proto(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Whether the listener should expect a PROXY protocol V1 header on new
        connections. If this option is enabled, the listener will assume that that
        remote address of the connection is the one specified in the header. Some
        load balancers including the AWS ELB support this option. If the option is
        absent or set to false, Envoy will use the physical peer address of the
        connection as the remote address.

        This field is deprecated. Add a
        :ref:`PROXY protocol listener filter <config_listener_filters_proxy_protocol>`
        explicitly instead.
        """

    @property
    def metadata(self) -> envoy.config.core.v3.base_pb2.Metadata:
        """[#not-implemented-hide:] filter chain metadata."""

    @property
    def transport_socket(self) -> envoy.config.core.v3.base_pb2.TransportSocket:
        """Optional custom transport socket implementation to use for downstream connections.
        To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
        :ref:`DownstreamTlsContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>` in the ``typed_config``.
        If no transport socket configuration is specified, new connections
        will be set up with plaintext.
        [#extension-category: envoy.transport_sockets.downstream]
        """

    @property
    def transport_socket_connect_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """If present and nonzero, the amount of time to allow incoming connections to complete any
        transport socket negotiations. If this expires before the transport reports connection
        establishment, the connection is summarily closed.
        """

    @property
    def on_demand_configuration(self) -> global___FilterChain.OnDemandConfiguration:
        """[#not-implemented-hide:] The configuration to specify whether the filter chain will be built on-demand.
        If this field is not empty, the filter chain will be built on-demand.
        Otherwise, the filter chain will be built normally and block listener warming.
        """

    def __init__(
        self,
        *,
        filter_chain_match: global___FilterChainMatch | None = ...,
        filters: collections.abc.Iterable[global___Filter] | None = ...,
        use_proxy_proto: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        metadata: envoy.config.core.v3.base_pb2.Metadata | None = ...,
        transport_socket: envoy.config.core.v3.base_pb2.TransportSocket | None = ...,
        transport_socket_connect_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        name: builtins.str = ...,
        on_demand_configuration: global___FilterChain.OnDemandConfiguration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter_chain_match", b"filter_chain_match", "metadata", b"metadata", "on_demand_configuration", b"on_demand_configuration", "transport_socket", b"transport_socket", "transport_socket_connect_timeout", b"transport_socket_connect_timeout", "use_proxy_proto", b"use_proxy_proto"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter_chain_match", b"filter_chain_match", "filters", b"filters", "metadata", b"metadata", "name", b"name", "on_demand_configuration", b"on_demand_configuration", "transport_socket", b"transport_socket", "transport_socket_connect_timeout", b"transport_socket_connect_timeout", "use_proxy_proto", b"use_proxy_proto"]) -> None: ...

global___FilterChain = FilterChain

@typing.final
class ListenerFilterChainMatchPredicate(google.protobuf.message.Message):
    """Listener filter chain match configuration. This is a recursive structure which allows complex
    nested match configurations to be built using various logical operators.

    Examples:

    * Matches if the destination port is 3306.

    .. code-block:: yaml

     destination_port_range:
      start: 3306
      end: 3307

    * Matches if the destination port is 3306 or 15000.

    .. code-block:: yaml

     or_match:
       rules:
         - destination_port_range:
             start: 3306
             end: 3307
         - destination_port_range:
             start: 15000
             end: 15001

    [#next-free-field: 6]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class MatchSet(google.protobuf.message.Message):
        """A set of match configurations used for logical operations."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RULES_FIELD_NUMBER: builtins.int
        @property
        def rules(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ListenerFilterChainMatchPredicate]:
            """The list of rules that make up the set."""

        def __init__(
            self,
            *,
            rules: collections.abc.Iterable[global___ListenerFilterChainMatchPredicate] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["rules", b"rules"]) -> None: ...

    OR_MATCH_FIELD_NUMBER: builtins.int
    AND_MATCH_FIELD_NUMBER: builtins.int
    NOT_MATCH_FIELD_NUMBER: builtins.int
    ANY_MATCH_FIELD_NUMBER: builtins.int
    DESTINATION_PORT_RANGE_FIELD_NUMBER: builtins.int
    any_match: builtins.bool
    """The match configuration will always match."""
    @property
    def or_match(self) -> global___ListenerFilterChainMatchPredicate.MatchSet:
        """A set that describes a logical OR. If any member of the set matches, the match configuration
        matches.
        """

    @property
    def and_match(self) -> global___ListenerFilterChainMatchPredicate.MatchSet:
        """A set that describes a logical AND. If all members of the set match, the match configuration
        matches.
        """

    @property
    def not_match(self) -> global___ListenerFilterChainMatchPredicate:
        """A negation match. The match configuration will match if the negated match condition matches."""

    @property
    def destination_port_range(self) -> envoy.type.v3.range_pb2.Int32Range:
        """Match destination port. Particularly, the match evaluation must use the recovered local port if
        the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
        """

    def __init__(
        self,
        *,
        or_match: global___ListenerFilterChainMatchPredicate.MatchSet | None = ...,
        and_match: global___ListenerFilterChainMatchPredicate.MatchSet | None = ...,
        not_match: global___ListenerFilterChainMatchPredicate | None = ...,
        any_match: builtins.bool = ...,
        destination_port_range: envoy.type.v3.range_pb2.Int32Range | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["and_match", b"and_match", "any_match", b"any_match", "destination_port_range", b"destination_port_range", "not_match", b"not_match", "or_match", b"or_match", "rule", b"rule"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["and_match", b"and_match", "any_match", b"any_match", "destination_port_range", b"destination_port_range", "not_match", b"not_match", "or_match", b"or_match", "rule", b"rule"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["rule", b"rule"]) -> typing.Literal["or_match", "and_match", "not_match", "any_match", "destination_port_range"] | None: ...

global___ListenerFilterChainMatchPredicate = ListenerFilterChainMatchPredicate

@typing.final
class ListenerFilter(google.protobuf.message.Message):
    """[#next-free-field: 6]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPED_CONFIG_FIELD_NUMBER: builtins.int
    CONFIG_DISCOVERY_FIELD_NUMBER: builtins.int
    FILTER_DISABLED_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The name of the filter configuration."""
    @property
    def typed_config(self) -> google.protobuf.any_pb2.Any:
        """Filter specific configuration which depends on the filter being
        instantiated. See the supported filters for further documentation.
        [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]
        """

    @property
    def config_discovery(self) -> envoy.config.core.v3.config_source_pb2.ExtensionConfigSource:
        """Configuration source specifier for an extension configuration discovery
        service. In case of a failure and without the default configuration, the
        listener closes the connections.
        """

    @property
    def filter_disabled(self) -> global___ListenerFilterChainMatchPredicate:
        """Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
        See :ref:`ListenerFilterChainMatchPredicate <envoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate>`
        for further examples.
        """

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        typed_config: google.protobuf.any_pb2.Any | None = ...,
        config_discovery: envoy.config.core.v3.config_source_pb2.ExtensionConfigSource | None = ...,
        filter_disabled: global___ListenerFilterChainMatchPredicate | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["config_discovery", b"config_discovery", "config_type", b"config_type", "filter_disabled", b"filter_disabled", "typed_config", b"typed_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["config_discovery", b"config_discovery", "config_type", b"config_type", "filter_disabled", b"filter_disabled", "name", b"name", "typed_config", b"typed_config"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["config_type", b"config_type"]) -> typing.Literal["typed_config", "config_discovery"] | None: ...

global___ListenerFilter = ListenerFilter
