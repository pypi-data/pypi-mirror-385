"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.config.core.v3.socket_option_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Pipe(google.protobuf.message.Message):
    """[#protodoc-title: Network addresses]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATH_FIELD_NUMBER: builtins.int
    MODE_FIELD_NUMBER: builtins.int
    path: builtins.str
    """Unix Domain Socket path. On Linux, paths starting with '@' will use the
    abstract namespace. The starting '@' is replaced by a null byte by Envoy.
    Paths starting with '@' will result in an error in environments other than
    Linux.
    """
    mode: builtins.int
    """The mode for the Pipe. Not applicable for abstract sockets."""
    def __init__(
        self,
        *,
        path: builtins.str = ...,
        mode: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["mode", b"mode", "path", b"path"]) -> None: ...

global___Pipe = Pipe

@typing.final
class EnvoyInternalAddress(google.protobuf.message.Message):
    """The address represents an envoy internal listener.
    [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SERVER_LISTENER_NAME_FIELD_NUMBER: builtins.int
    ENDPOINT_ID_FIELD_NUMBER: builtins.int
    server_listener_name: builtins.str
    """Specifies the :ref:`name <envoy_v3_api_field_config.listener.v3.Listener.name>` of the
    internal listener.
    """
    endpoint_id: builtins.str
    """Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
    single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
    example, may be set to the final destination IP for the target internal listener.
    """
    def __init__(
        self,
        *,
        server_listener_name: builtins.str = ...,
        endpoint_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["address_name_specifier", b"address_name_specifier", "server_listener_name", b"server_listener_name"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address_name_specifier", b"address_name_specifier", "endpoint_id", b"endpoint_id", "server_listener_name", b"server_listener_name"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["address_name_specifier", b"address_name_specifier"]) -> typing.Literal["server_listener_name"] | None: ...

global___EnvoyInternalAddress = EnvoyInternalAddress

@typing.final
class SocketAddress(google.protobuf.message.Message):
    """[#next-free-field: 7]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Protocol:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ProtocolEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SocketAddress._Protocol.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TCP: SocketAddress._Protocol.ValueType  # 0
        UDP: SocketAddress._Protocol.ValueType  # 1

    class Protocol(_Protocol, metaclass=_ProtocolEnumTypeWrapper): ...
    TCP: SocketAddress.Protocol.ValueType  # 0
    UDP: SocketAddress.Protocol.ValueType  # 1

    PROTOCOL_FIELD_NUMBER: builtins.int
    ADDRESS_FIELD_NUMBER: builtins.int
    PORT_VALUE_FIELD_NUMBER: builtins.int
    NAMED_PORT_FIELD_NUMBER: builtins.int
    RESOLVER_NAME_FIELD_NUMBER: builtins.int
    IPV4_COMPAT_FIELD_NUMBER: builtins.int
    protocol: global___SocketAddress.Protocol.ValueType
    address: builtins.str
    """The address for this socket. :ref:`Listeners <config_listeners>` will bind
    to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
    to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
    It is possible to distinguish a Listener address via the prefix/suffix matching
    in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
    within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
    controls the source address of outbound connections. For :ref:`clusters
    <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
    address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
    (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
    via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
    """
    port_value: builtins.int
    named_port: builtins.str
    """This is only valid if :ref:`resolver_name
    <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
    named resolver is capable of named port resolution.
    """
    resolver_name: builtins.str
    """The name of the custom resolver. This must have been registered with Envoy. If
    this is empty, a context dependent default applies. If the address is a concrete
    IP address, no resolution will occur. If address is a hostname this
    should be set for resolution other than DNS. Specifying a custom resolver with
    ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
    """
    ipv4_compat: builtins.bool
    """When binding to an IPv6 address above, this enables `IPv4 compatibility
    <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
    allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
    IPv6 space as ``::FFFF:<IPv4-address>``.
    """
    def __init__(
        self,
        *,
        protocol: global___SocketAddress.Protocol.ValueType = ...,
        address: builtins.str = ...,
        port_value: builtins.int = ...,
        named_port: builtins.str = ...,
        resolver_name: builtins.str = ...,
        ipv4_compat: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["named_port", b"named_port", "port_specifier", b"port_specifier", "port_value", b"port_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address", b"address", "ipv4_compat", b"ipv4_compat", "named_port", b"named_port", "port_specifier", b"port_specifier", "port_value", b"port_value", "protocol", b"protocol", "resolver_name", b"resolver_name"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["port_specifier", b"port_specifier"]) -> typing.Literal["port_value", "named_port"] | None: ...

global___SocketAddress = SocketAddress

@typing.final
class TcpKeepalive(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEEPALIVE_PROBES_FIELD_NUMBER: builtins.int
    KEEPALIVE_TIME_FIELD_NUMBER: builtins.int
    KEEPALIVE_INTERVAL_FIELD_NUMBER: builtins.int
    @property
    def keepalive_probes(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Maximum number of keepalive probes to send without response before deciding
        the connection is dead. Default is to use the OS level configuration (unless
        overridden, Linux defaults to 9.)
        """

    @property
    def keepalive_time(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The number of seconds a connection needs to be idle before keep-alive probes
        start being sent. Default is to use the OS level configuration (unless
        overridden, Linux defaults to 7200s (i.e., 2 hours.)
        """

    @property
    def keepalive_interval(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The number of seconds between keep-alive probes. Default is to use the OS
        level configuration (unless overridden, Linux defaults to 75s.)
        """

    def __init__(
        self,
        *,
        keepalive_probes: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        keepalive_time: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        keepalive_interval: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["keepalive_interval", b"keepalive_interval", "keepalive_probes", b"keepalive_probes", "keepalive_time", b"keepalive_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["keepalive_interval", b"keepalive_interval", "keepalive_probes", b"keepalive_probes", "keepalive_time", b"keepalive_time"]) -> None: ...

global___TcpKeepalive = TcpKeepalive

@typing.final
class ExtraSourceAddress(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ADDRESS_FIELD_NUMBER: builtins.int
    SOCKET_OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def address(self) -> global___SocketAddress:
        """The additional address to bind."""

    @property
    def socket_options(self) -> envoy.config.core.v3.socket_option_pb2.SocketOptionsOverride:
        """Additional socket options that may not be present in Envoy source code or
        precompiled binaries. If specified, this will override the
        :ref:`socket_options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
        in the BindConfig. If specified with no
        :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
        or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
        it means no socket option will apply.
        """

    def __init__(
        self,
        *,
        address: global___SocketAddress | None = ...,
        socket_options: envoy.config.core.v3.socket_option_pb2.SocketOptionsOverride | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["address", b"address", "socket_options", b"socket_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address", b"address", "socket_options", b"socket_options"]) -> None: ...

global___ExtraSourceAddress = ExtraSourceAddress

@typing.final
class BindConfig(google.protobuf.message.Message):
    """[#next-free-field: 6]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOURCE_ADDRESS_FIELD_NUMBER: builtins.int
    FREEBIND_FIELD_NUMBER: builtins.int
    SOCKET_OPTIONS_FIELD_NUMBER: builtins.int
    EXTRA_SOURCE_ADDRESSES_FIELD_NUMBER: builtins.int
    ADDITIONAL_SOURCE_ADDRESSES_FIELD_NUMBER: builtins.int
    @property
    def source_address(self) -> global___SocketAddress:
        """The address to bind to when creating a socket."""

    @property
    def freebind(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
        flag is set to true, allows the :ref:`source_address
        <envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
        that is not configured on the system running Envoy. When this flag is set
        to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
        flag is not set (default), the socket is not modified, i.e. the option is
        neither enabled nor disabled.
        """

    @property
    def socket_options(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.socket_option_pb2.SocketOption]:
        """Additional socket options that may not be present in Envoy source code or
        precompiled binaries.
        """

    @property
    def extra_source_addresses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExtraSourceAddress]:
        """Extra source addresses appended to the address specified in the `source_address`
        field. This enables to specify multiple source addresses. Currently, only one extra
        address can be supported, and the extra address should have a different IP version
        with the address in the `source_address` field. The address which has the same IP
        version with the target host's address IP version will be used as bind address. If more
        than one extra address specified, only the first address matched IP version will be
        returned. If there is no same IP version address found, the address in the `source_address`
        will be returned.
        """

    @property
    def additional_source_addresses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SocketAddress]:
        """Deprecated by
        :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
        """

    def __init__(
        self,
        *,
        source_address: global___SocketAddress | None = ...,
        freebind: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        socket_options: collections.abc.Iterable[envoy.config.core.v3.socket_option_pb2.SocketOption] | None = ...,
        extra_source_addresses: collections.abc.Iterable[global___ExtraSourceAddress] | None = ...,
        additional_source_addresses: collections.abc.Iterable[global___SocketAddress] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["freebind", b"freebind", "source_address", b"source_address"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["additional_source_addresses", b"additional_source_addresses", "extra_source_addresses", b"extra_source_addresses", "freebind", b"freebind", "socket_options", b"socket_options", "source_address", b"source_address"]) -> None: ...

global___BindConfig = BindConfig

@typing.final
class Address(google.protobuf.message.Message):
    """Addresses specify either a logical or physical address and port, which are
    used to tell Envoy where to bind/listen, connect to upstream and find
    management servers.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOCKET_ADDRESS_FIELD_NUMBER: builtins.int
    PIPE_FIELD_NUMBER: builtins.int
    ENVOY_INTERNAL_ADDRESS_FIELD_NUMBER: builtins.int
    @property
    def socket_address(self) -> global___SocketAddress: ...
    @property
    def pipe(self) -> global___Pipe: ...
    @property
    def envoy_internal_address(self) -> global___EnvoyInternalAddress:
        """Specifies a user-space address handled by :ref:`internal listeners
        <envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
        """

    def __init__(
        self,
        *,
        socket_address: global___SocketAddress | None = ...,
        pipe: global___Pipe | None = ...,
        envoy_internal_address: global___EnvoyInternalAddress | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["address", b"address", "envoy_internal_address", b"envoy_internal_address", "pipe", b"pipe", "socket_address", b"socket_address"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address", b"address", "envoy_internal_address", b"envoy_internal_address", "pipe", b"pipe", "socket_address", b"socket_address"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["address", b"address"]) -> typing.Literal["socket_address", "pipe", "envoy_internal_address"] | None: ...

global___Address = Address

@typing.final
class CidrRange(google.protobuf.message.Message):
    """CidrRange specifies an IP Address and a prefix length to construct
    the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ADDRESS_PREFIX_FIELD_NUMBER: builtins.int
    PREFIX_LEN_FIELD_NUMBER: builtins.int
    address_prefix: builtins.str
    """IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``."""
    @property
    def prefix_len(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Length of prefix, e.g. 0, 32. Defaults to 0 when unset."""

    def __init__(
        self,
        *,
        address_prefix: builtins.str = ...,
        prefix_len: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["prefix_len", b"prefix_len"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["address_prefix", b"address_prefix", "prefix_len", b"prefix_len"]) -> None: ...

global___CidrRange = CidrRange
