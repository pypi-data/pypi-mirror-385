"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.config.core.v3.address_pb2
import envoy.config.core.v3.extension_pb2
import envoy.extensions.transport_sockets.tls.v3.common_pb2
import envoy.extensions.transport_sockets.tls.v3.secret_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class UpstreamTlsContext(google.protobuf.message.Message):
    """[#protodoc-title: TLS transport socket]
    [#extension: envoy.transport_sockets.tls]
    The TLS contexts below provide the transport socket configuration for upstream/downstream TLS.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMMON_TLS_CONTEXT_FIELD_NUMBER: builtins.int
    SNI_FIELD_NUMBER: builtins.int
    ALLOW_RENEGOTIATION_FIELD_NUMBER: builtins.int
    MAX_SESSION_KEYS_FIELD_NUMBER: builtins.int
    sni: builtins.str
    """SNI string to use when creating TLS backend connections."""
    allow_renegotiation: builtins.bool
    """If true, server-initiated TLS renegotiation will be allowed.

    .. attention::

      TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
    """
    @property
    def common_tls_context(self) -> global___CommonTlsContext:
        """Common TLS context settings.

        .. attention::

          Server certificate verification is not enabled by default. Configure
          :ref:`trusted_ca<envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
          verification.
        """

    @property
    def max_session_keys(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
        for TLSv1.2 and older) to store for the purpose of session resumption.

        Defaults to 1, setting this to 0 disables session resumption.
        """

    def __init__(
        self,
        *,
        common_tls_context: global___CommonTlsContext | None = ...,
        sni: builtins.str = ...,
        allow_renegotiation: builtins.bool = ...,
        max_session_keys: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["common_tls_context", b"common_tls_context", "max_session_keys", b"max_session_keys"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["allow_renegotiation", b"allow_renegotiation", "common_tls_context", b"common_tls_context", "max_session_keys", b"max_session_keys", "sni", b"sni"]) -> None: ...

global___UpstreamTlsContext = UpstreamTlsContext

@typing.final
class DownstreamTlsContext(google.protobuf.message.Message):
    """[#next-free-field: 10]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _OcspStaplePolicy:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OcspStaplePolicyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[DownstreamTlsContext._OcspStaplePolicy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LENIENT_STAPLING: DownstreamTlsContext._OcspStaplePolicy.ValueType  # 0
        """OCSP responses are optional. If an OCSP response is absent
        or expired, the associated certificate will be used for
        connections without an OCSP staple.
        """
        STRICT_STAPLING: DownstreamTlsContext._OcspStaplePolicy.ValueType  # 1
        """OCSP responses are optional. If an OCSP response is absent,
        the associated certificate will be used without an
        OCSP staple. If a response is provided but is expired,
        the associated certificate will not be used for
        subsequent connections. If no suitable certificate is found,
        the connection is rejected.
        """
        MUST_STAPLE: DownstreamTlsContext._OcspStaplePolicy.ValueType  # 2
        """OCSP responses are required. Configuration will fail if
        a certificate is provided without an OCSP response. If a
        response expires, the associated certificate will not be
        used connections. If no suitable certificate is found, the
        connection is rejected.
        """

    class OcspStaplePolicy(_OcspStaplePolicy, metaclass=_OcspStaplePolicyEnumTypeWrapper): ...
    LENIENT_STAPLING: DownstreamTlsContext.OcspStaplePolicy.ValueType  # 0
    """OCSP responses are optional. If an OCSP response is absent
    or expired, the associated certificate will be used for
    connections without an OCSP staple.
    """
    STRICT_STAPLING: DownstreamTlsContext.OcspStaplePolicy.ValueType  # 1
    """OCSP responses are optional. If an OCSP response is absent,
    the associated certificate will be used without an
    OCSP staple. If a response is provided but is expired,
    the associated certificate will not be used for
    subsequent connections. If no suitable certificate is found,
    the connection is rejected.
    """
    MUST_STAPLE: DownstreamTlsContext.OcspStaplePolicy.ValueType  # 2
    """OCSP responses are required. Configuration will fail if
    a certificate is provided without an OCSP response. If a
    response expires, the associated certificate will not be
    used connections. If no suitable certificate is found, the
    connection is rejected.
    """

    COMMON_TLS_CONTEXT_FIELD_NUMBER: builtins.int
    REQUIRE_CLIENT_CERTIFICATE_FIELD_NUMBER: builtins.int
    REQUIRE_SNI_FIELD_NUMBER: builtins.int
    SESSION_TICKET_KEYS_FIELD_NUMBER: builtins.int
    SESSION_TICKET_KEYS_SDS_SECRET_CONFIG_FIELD_NUMBER: builtins.int
    DISABLE_STATELESS_SESSION_RESUMPTION_FIELD_NUMBER: builtins.int
    SESSION_TIMEOUT_FIELD_NUMBER: builtins.int
    OCSP_STAPLE_POLICY_FIELD_NUMBER: builtins.int
    FULL_SCAN_CERTS_ON_SNI_MISMATCH_FIELD_NUMBER: builtins.int
    disable_stateless_session_resumption: builtins.bool
    """Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    the keys specified through either :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
    or :ref:`session_ticket_keys_sds_secret_config <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    If this config is set to false and no keys are explicitly configured, the TLS server will issue
    TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    implication that sessions cannot be resumed across hot restarts or on different hosts.
    """
    ocsp_staple_policy: global___DownstreamTlsContext.OcspStaplePolicy.ValueType
    """Config for whether to use certificates if they do not have
    an accompanying OCSP response or if the response expires at runtime.
    Defaults to LENIENT_STAPLING
    """
    @property
    def common_tls_context(self) -> global___CommonTlsContext:
        """Common TLS context settings."""

    @property
    def require_client_certificate(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """If specified, Envoy will reject connections without a valid client
        certificate.
        """

    @property
    def require_sni(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """If specified, Envoy will reject connections without a valid and matching SNI.
        [#not-implemented-hide:]
        """

    @property
    def session_ticket_keys(self) -> envoy.extensions.transport_sockets.tls.v3.common_pb2.TlsSessionTicketKeys:
        """TLS session ticket key settings."""

    @property
    def session_ticket_keys_sds_secret_config(self) -> envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig:
        """Config for fetching TLS session ticket keys via SDS API."""

    @property
    def session_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """If specified, ``session_timeout`` will change the maximum lifetime (in seconds) of the TLS session.
        Currently this value is used as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
        Only seconds can be specified (fractional seconds are ignored).
        """

    @property
    def full_scan_certs_on_sni_mismatch(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Multiple certificates are allowed in Downstream transport socket to serve different SNI.
        If the client provides SNI but no such cert matched, it will decide to full scan certificates or not based on this config.
        Defaults to false. See more details in :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>`.
        """

    def __init__(
        self,
        *,
        common_tls_context: global___CommonTlsContext | None = ...,
        require_client_certificate: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        require_sni: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        session_ticket_keys: envoy.extensions.transport_sockets.tls.v3.common_pb2.TlsSessionTicketKeys | None = ...,
        session_ticket_keys_sds_secret_config: envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig | None = ...,
        disable_stateless_session_resumption: builtins.bool = ...,
        session_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        ocsp_staple_policy: global___DownstreamTlsContext.OcspStaplePolicy.ValueType = ...,
        full_scan_certs_on_sni_mismatch: google.protobuf.wrappers_pb2.BoolValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["common_tls_context", b"common_tls_context", "disable_stateless_session_resumption", b"disable_stateless_session_resumption", "full_scan_certs_on_sni_mismatch", b"full_scan_certs_on_sni_mismatch", "require_client_certificate", b"require_client_certificate", "require_sni", b"require_sni", "session_ticket_keys", b"session_ticket_keys", "session_ticket_keys_sds_secret_config", b"session_ticket_keys_sds_secret_config", "session_ticket_keys_type", b"session_ticket_keys_type", "session_timeout", b"session_timeout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["common_tls_context", b"common_tls_context", "disable_stateless_session_resumption", b"disable_stateless_session_resumption", "full_scan_certs_on_sni_mismatch", b"full_scan_certs_on_sni_mismatch", "ocsp_staple_policy", b"ocsp_staple_policy", "require_client_certificate", b"require_client_certificate", "require_sni", b"require_sni", "session_ticket_keys", b"session_ticket_keys", "session_ticket_keys_sds_secret_config", b"session_ticket_keys_sds_secret_config", "session_ticket_keys_type", b"session_ticket_keys_type", "session_timeout", b"session_timeout"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["session_ticket_keys_type", b"session_ticket_keys_type"]) -> typing.Literal["session_ticket_keys", "session_ticket_keys_sds_secret_config", "disable_stateless_session_resumption"] | None: ...

global___DownstreamTlsContext = DownstreamTlsContext

@typing.final
class TlsKeyLog(google.protobuf.message.Message):
    """TLS key log configuration.
    The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATH_FIELD_NUMBER: builtins.int
    LOCAL_ADDRESS_RANGE_FIELD_NUMBER: builtins.int
    REMOTE_ADDRESS_RANGE_FIELD_NUMBER: builtins.int
    path: builtins.str
    """The path to save the TLS key log."""
    @property
    def local_address_range(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.address_pb2.CidrRange]:
        """The local IP address that will be used to filter the connection which should save the TLS key log
        If it is not set, any local IP address  will be matched.
        """

    @property
    def remote_address_range(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.address_pb2.CidrRange]:
        """The remote IP address that will be used to filter the connection which should save the TLS key log
        If it is not set, any remote IP address will be matched.
        """

    def __init__(
        self,
        *,
        path: builtins.str = ...,
        local_address_range: collections.abc.Iterable[envoy.config.core.v3.address_pb2.CidrRange] | None = ...,
        remote_address_range: collections.abc.Iterable[envoy.config.core.v3.address_pb2.CidrRange] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["local_address_range", b"local_address_range", "path", b"path", "remote_address_range", b"remote_address_range"]) -> None: ...

global___TlsKeyLog = TlsKeyLog

@typing.final
class CommonTlsContext(google.protobuf.message.Message):
    """TLS context shared by both client and server TLS contexts.
    [#next-free-field: 16]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class CertificateProvider(google.protobuf.message.Message):
        """Config for Certificate provider to get certificates. This provider should allow certificates to be
        fetched/refreshed over the network asynchronously with respect to the TLS handshake.

        DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
        move it out of CommonTlsContext and into common.proto, similar to the existing
        CertificateProviderPluginInstance message.

        [#not-implemented-hide:]
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        TYPED_CONFIG_FIELD_NUMBER: builtins.int
        name: builtins.str
        """opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
        a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
        """
        @property
        def typed_config(self) -> envoy.config.core.v3.extension_pb2.TypedExtensionConfig: ...
        def __init__(
            self,
            *,
            name: builtins.str = ...,
            typed_config: envoy.config.core.v3.extension_pb2.TypedExtensionConfig | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["config", b"config", "typed_config", b"typed_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["config", b"config", "name", b"name", "typed_config", b"typed_config"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["config", b"config"]) -> typing.Literal["typed_config"] | None: ...

    @typing.final
    class CertificateProviderInstance(google.protobuf.message.Message):
        """Similar to CertificateProvider above, but allows the provider instances to be configured on
        the client side instead of being sent from the control plane.

        DEPRECATED: This message was moved outside of CommonTlsContext
        and now lives in common.proto.

        [#not-implemented-hide:]
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        INSTANCE_NAME_FIELD_NUMBER: builtins.int
        CERTIFICATE_NAME_FIELD_NUMBER: builtins.int
        instance_name: builtins.str
        """Provider instance name. This name must be defined in the client's configuration (e.g., a
        bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
        field that would be sent in the CertificateProvider message if the config was sent by the
        control plane). If not present, defaults to "default".

        Instance names should generally be defined not in terms of the underlying provider
        implementation (e.g., "file_watcher") but rather in terms of the function of the
        certificates (e.g., "foo_deployment_identity").
        """
        certificate_name: builtins.str
        """Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
        a root-certificate (validation context) or "example.com" to specify a certificate for a
        particular domain. Not all provider instances will actually use this field, so the value
        defaults to the empty string.
        """
        def __init__(
            self,
            *,
            instance_name: builtins.str = ...,
            certificate_name: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["certificate_name", b"certificate_name", "instance_name", b"instance_name"]) -> None: ...

    @typing.final
    class CombinedCertificateValidationContext(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        DEFAULT_VALIDATION_CONTEXT_FIELD_NUMBER: builtins.int
        VALIDATION_CONTEXT_SDS_SECRET_CONFIG_FIELD_NUMBER: builtins.int
        VALIDATION_CONTEXT_CERTIFICATE_PROVIDER_FIELD_NUMBER: builtins.int
        VALIDATION_CONTEXT_CERTIFICATE_PROVIDER_INSTANCE_FIELD_NUMBER: builtins.int
        @property
        def default_validation_context(self) -> envoy.extensions.transport_sockets.tls.v3.common_pb2.CertificateValidationContext:
            """How to validate peer certificates."""

        @property
        def validation_context_sds_secret_config(self) -> envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig:
            """Config for fetching validation context via SDS API. Note SDS API allows certificates to be
            fetched/refreshed over the network asynchronously with respect to the TLS handshake.
            """

        @property
        def validation_context_certificate_provider(self) -> global___CommonTlsContext.CertificateProvider:
            """Certificate provider for fetching CA certs. This will populate the
            ``default_validation_context.trusted_ca`` field.
            [#not-implemented-hide:]
            """

        @property
        def validation_context_certificate_provider_instance(self) -> global___CommonTlsContext.CertificateProviderInstance:
            """Certificate provider instance for fetching CA certs. This will populate the
            ``default_validation_context.trusted_ca`` field.
            [#not-implemented-hide:]
            """

        def __init__(
            self,
            *,
            default_validation_context: envoy.extensions.transport_sockets.tls.v3.common_pb2.CertificateValidationContext | None = ...,
            validation_context_sds_secret_config: envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig | None = ...,
            validation_context_certificate_provider: global___CommonTlsContext.CertificateProvider | None = ...,
            validation_context_certificate_provider_instance: global___CommonTlsContext.CertificateProviderInstance | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["default_validation_context", b"default_validation_context", "validation_context_certificate_provider", b"validation_context_certificate_provider", "validation_context_certificate_provider_instance", b"validation_context_certificate_provider_instance", "validation_context_sds_secret_config", b"validation_context_sds_secret_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["default_validation_context", b"default_validation_context", "validation_context_certificate_provider", b"validation_context_certificate_provider", "validation_context_certificate_provider_instance", b"validation_context_certificate_provider_instance", "validation_context_sds_secret_config", b"validation_context_sds_secret_config"]) -> None: ...

    TLS_PARAMS_FIELD_NUMBER: builtins.int
    TLS_CERTIFICATES_FIELD_NUMBER: builtins.int
    TLS_CERTIFICATE_SDS_SECRET_CONFIGS_FIELD_NUMBER: builtins.int
    TLS_CERTIFICATE_PROVIDER_INSTANCE_FIELD_NUMBER: builtins.int
    TLS_CERTIFICATE_CERTIFICATE_PROVIDER_FIELD_NUMBER: builtins.int
    TLS_CERTIFICATE_CERTIFICATE_PROVIDER_INSTANCE_FIELD_NUMBER: builtins.int
    VALIDATION_CONTEXT_FIELD_NUMBER: builtins.int
    VALIDATION_CONTEXT_SDS_SECRET_CONFIG_FIELD_NUMBER: builtins.int
    COMBINED_VALIDATION_CONTEXT_FIELD_NUMBER: builtins.int
    VALIDATION_CONTEXT_CERTIFICATE_PROVIDER_FIELD_NUMBER: builtins.int
    VALIDATION_CONTEXT_CERTIFICATE_PROVIDER_INSTANCE_FIELD_NUMBER: builtins.int
    ALPN_PROTOCOLS_FIELD_NUMBER: builtins.int
    CUSTOM_HANDSHAKER_FIELD_NUMBER: builtins.int
    KEY_LOG_FIELD_NUMBER: builtins.int
    @property
    def tls_params(self) -> envoy.extensions.transport_sockets.tls.v3.common_pb2.TlsParameters:
        """TLS protocol versions, cipher suites etc."""

    @property
    def tls_certificates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.extensions.transport_sockets.tls.v3.common_pb2.TlsCertificate]:
        """Only a single TLS certificate is supported in client contexts. In server contexts,
        :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
        same context to allow both RSA and ECDSA certificates and support SNI-based selection.

        Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
        and ``tls_certificate_provider_instance`` may be used.
        [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
        not legal to put a repeated field in a oneof. In the next major version, we should rework
        this to avoid this problem.]
        """

    @property
    def tls_certificate_sds_secret_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig]:
        """Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
        fetched/refreshed over the network asynchronously with respect to the TLS handshake.

        The same number and types of certificates as :ref:`tls_certificates <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
        are valid in the the certificates fetched through this setting.

        Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
        and ``tls_certificate_provider_instance`` may be used.
        [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
        not legal to put a repeated field in a oneof. In the next major version, we should rework
        this to avoid this problem.]
        """

    @property
    def tls_certificate_provider_instance(self) -> envoy.extensions.transport_sockets.tls.v3.common_pb2.CertificateProviderPluginInstance:
        """Certificate provider instance for fetching TLS certs.

        Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
        and ``tls_certificate_provider_instance`` may be used.
        [#not-implemented-hide:]
        """

    @property
    def tls_certificate_certificate_provider(self) -> global___CommonTlsContext.CertificateProvider:
        """Certificate provider for fetching TLS certificates.
        [#not-implemented-hide:]
        """

    @property
    def tls_certificate_certificate_provider_instance(self) -> global___CommonTlsContext.CertificateProviderInstance:
        """Certificate provider instance for fetching TLS certificates.
        [#not-implemented-hide:]
        """

    @property
    def validation_context(self) -> envoy.extensions.transport_sockets.tls.v3.common_pb2.CertificateValidationContext:
        """How to validate peer certificates."""

    @property
    def validation_context_sds_secret_config(self) -> envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig:
        """Config for fetching validation context via SDS API. Note SDS API allows certificates to be
        fetched/refreshed over the network asynchronously with respect to the TLS handshake.
        """

    @property
    def combined_validation_context(self) -> global___CommonTlsContext.CombinedCertificateValidationContext:
        """Combined certificate validation context holds a default CertificateValidationContext
        and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
        and default CertificateValidationContext are merged into a new CertificateValidationContext
        for validation. This merge is done by Message::MergeFrom(), so dynamic
        CertificateValidationContext overwrites singular fields in default
        CertificateValidationContext, and concatenates repeated fields to default
        CertificateValidationContext, and logical OR is applied to boolean fields.
        """

    @property
    def validation_context_certificate_provider(self) -> global___CommonTlsContext.CertificateProvider:
        """Certificate provider for fetching validation context.
        [#not-implemented-hide:]
        """

    @property
    def validation_context_certificate_provider_instance(self) -> global___CommonTlsContext.CertificateProviderInstance:
        """Certificate provider instance for fetching validation context.
        [#not-implemented-hide:]
        """

    @property
    def alpn_protocols(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Supplies the list of ALPN protocols that the listener should expose. In
        practice this is likely to be set to one of two values (see the
        :ref:`codec_type
        <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
        parameter in the HTTP connection manager for more information):

        * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
        * "http/1.1" If the listener is only going to support HTTP/1.1.

        There is no default for this parameter. If empty, Envoy will not expose ALPN.
        """

    @property
    def custom_handshaker(self) -> envoy.config.core.v3.extension_pb2.TypedExtensionConfig:
        """Custom TLS handshaker. If empty, defaults to native TLS handshaking
        behavior.
        """

    @property
    def key_log(self) -> global___TlsKeyLog:
        """TLS key log configuration"""

    def __init__(
        self,
        *,
        tls_params: envoy.extensions.transport_sockets.tls.v3.common_pb2.TlsParameters | None = ...,
        tls_certificates: collections.abc.Iterable[envoy.extensions.transport_sockets.tls.v3.common_pb2.TlsCertificate] | None = ...,
        tls_certificate_sds_secret_configs: collections.abc.Iterable[envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig] | None = ...,
        tls_certificate_provider_instance: envoy.extensions.transport_sockets.tls.v3.common_pb2.CertificateProviderPluginInstance | None = ...,
        tls_certificate_certificate_provider: global___CommonTlsContext.CertificateProvider | None = ...,
        tls_certificate_certificate_provider_instance: global___CommonTlsContext.CertificateProviderInstance | None = ...,
        validation_context: envoy.extensions.transport_sockets.tls.v3.common_pb2.CertificateValidationContext | None = ...,
        validation_context_sds_secret_config: envoy.extensions.transport_sockets.tls.v3.secret_pb2.SdsSecretConfig | None = ...,
        combined_validation_context: global___CommonTlsContext.CombinedCertificateValidationContext | None = ...,
        validation_context_certificate_provider: global___CommonTlsContext.CertificateProvider | None = ...,
        validation_context_certificate_provider_instance: global___CommonTlsContext.CertificateProviderInstance | None = ...,
        alpn_protocols: collections.abc.Iterable[builtins.str] | None = ...,
        custom_handshaker: envoy.config.core.v3.extension_pb2.TypedExtensionConfig | None = ...,
        key_log: global___TlsKeyLog | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["combined_validation_context", b"combined_validation_context", "custom_handshaker", b"custom_handshaker", "key_log", b"key_log", "tls_certificate_certificate_provider", b"tls_certificate_certificate_provider", "tls_certificate_certificate_provider_instance", b"tls_certificate_certificate_provider_instance", "tls_certificate_provider_instance", b"tls_certificate_provider_instance", "tls_params", b"tls_params", "validation_context", b"validation_context", "validation_context_certificate_provider", b"validation_context_certificate_provider", "validation_context_certificate_provider_instance", b"validation_context_certificate_provider_instance", "validation_context_sds_secret_config", b"validation_context_sds_secret_config", "validation_context_type", b"validation_context_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["alpn_protocols", b"alpn_protocols", "combined_validation_context", b"combined_validation_context", "custom_handshaker", b"custom_handshaker", "key_log", b"key_log", "tls_certificate_certificate_provider", b"tls_certificate_certificate_provider", "tls_certificate_certificate_provider_instance", b"tls_certificate_certificate_provider_instance", "tls_certificate_provider_instance", b"tls_certificate_provider_instance", "tls_certificate_sds_secret_configs", b"tls_certificate_sds_secret_configs", "tls_certificates", b"tls_certificates", "tls_params", b"tls_params", "validation_context", b"validation_context", "validation_context_certificate_provider", b"validation_context_certificate_provider", "validation_context_certificate_provider_instance", b"validation_context_certificate_provider_instance", "validation_context_sds_secret_config", b"validation_context_sds_secret_config", "validation_context_type", b"validation_context_type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["validation_context_type", b"validation_context_type"]) -> typing.Literal["validation_context", "validation_context_sds_secret_config", "combined_validation_context", "validation_context_certificate_provider", "validation_context_certificate_provider_instance"] | None: ...

global___CommonTlsContext = CommonTlsContext
