"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.config.core.v3.base_pb2
import envoy.config.core.v3.extension_pb2
import envoy.type.matcher.v3.string_pb2
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class TlsParameters(google.protobuf.message.Message):
    """[#protodoc-title: Common TLS configuration]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _TlsProtocol:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TlsProtocolEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[TlsParameters._TlsProtocol.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TLS_AUTO: TlsParameters._TlsProtocol.ValueType  # 0
        """Envoy will choose the optimal TLS version."""
        TLSv1_0: TlsParameters._TlsProtocol.ValueType  # 1
        """TLS 1.0"""
        TLSv1_1: TlsParameters._TlsProtocol.ValueType  # 2
        """TLS 1.1"""
        TLSv1_2: TlsParameters._TlsProtocol.ValueType  # 3
        """TLS 1.2"""
        TLSv1_3: TlsParameters._TlsProtocol.ValueType  # 4
        """TLS 1.3"""

    class TlsProtocol(_TlsProtocol, metaclass=_TlsProtocolEnumTypeWrapper): ...
    TLS_AUTO: TlsParameters.TlsProtocol.ValueType  # 0
    """Envoy will choose the optimal TLS version."""
    TLSv1_0: TlsParameters.TlsProtocol.ValueType  # 1
    """TLS 1.0"""
    TLSv1_1: TlsParameters.TlsProtocol.ValueType  # 2
    """TLS 1.1"""
    TLSv1_2: TlsParameters.TlsProtocol.ValueType  # 3
    """TLS 1.2"""
    TLSv1_3: TlsParameters.TlsProtocol.ValueType  # 4
    """TLS 1.3"""

    TLS_MINIMUM_PROTOCOL_VERSION_FIELD_NUMBER: builtins.int
    TLS_MAXIMUM_PROTOCOL_VERSION_FIELD_NUMBER: builtins.int
    CIPHER_SUITES_FIELD_NUMBER: builtins.int
    ECDH_CURVES_FIELD_NUMBER: builtins.int
    tls_minimum_protocol_version: global___TlsParameters.TlsProtocol.ValueType
    """Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.

    TLS protocol versions below TLSv1_2 require setting compatible ciphers with the
    ``cipher_suites`` setting as the default ciphers no longer include compatible ciphers.

    .. attention::

      Using TLS protocol versions below TLSv1_2 has serious security considerations and risks.
    """
    tls_maximum_protocol_version: global___TlsParameters.TlsProtocol.ValueType
    """Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
    servers.
    """
    @property
    def cipher_suites(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """If specified, the TLS listener will only support the specified `cipher list
        <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
        when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3).

        If not specified, a default list will be used. Defaults are different for server (downstream) and
        client (upstream) TLS configurations.
        Defaults will change over time in response to security considerations; If you care, configure
        it instead of using the default.

        In non-FIPS builds, the default server cipher list is:

        .. code-block:: none

          [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
          [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
          ECDHE-ECDSA-AES256-GCM-SHA384
          ECDHE-RSA-AES256-GCM-SHA384

        In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default server cipher list is:

        .. code-block:: none

          ECDHE-ECDSA-AES128-GCM-SHA256
          ECDHE-RSA-AES128-GCM-SHA256
          ECDHE-ECDSA-AES256-GCM-SHA384
          ECDHE-RSA-AES256-GCM-SHA384

        In non-FIPS builds, the default client cipher list is:

        .. code-block:: none

          [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
          [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
          ECDHE-ECDSA-AES256-GCM-SHA384
          ECDHE-RSA-AES256-GCM-SHA384

        In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default client cipher list is:

        .. code-block:: none

          ECDHE-ECDSA-AES128-GCM-SHA256
          ECDHE-RSA-AES128-GCM-SHA256
          ECDHE-ECDSA-AES256-GCM-SHA384
          ECDHE-RSA-AES256-GCM-SHA384
        """

    @property
    def ecdh_curves(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """If specified, the TLS connection will only support the specified ECDH
        curves. If not specified, the default curves will be used.

        In non-FIPS builds, the default curves are:

        .. code-block:: none

          X25519
          P-256

        In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:

        .. code-block:: none

          P-256
        """

    def __init__(
        self,
        *,
        tls_minimum_protocol_version: global___TlsParameters.TlsProtocol.ValueType = ...,
        tls_maximum_protocol_version: global___TlsParameters.TlsProtocol.ValueType = ...,
        cipher_suites: collections.abc.Iterable[builtins.str] | None = ...,
        ecdh_curves: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["cipher_suites", b"cipher_suites", "ecdh_curves", b"ecdh_curves", "tls_maximum_protocol_version", b"tls_maximum_protocol_version", "tls_minimum_protocol_version", b"tls_minimum_protocol_version"]) -> None: ...

global___TlsParameters = TlsParameters

@typing.final
class PrivateKeyProvider(google.protobuf.message.Message):
    """BoringSSL private key method configuration. The private key methods are used for external
    (potentially asynchronous) signing and decryption operations. Some use cases for private key
    methods would be TPM support and TLS acceleration.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROVIDER_NAME_FIELD_NUMBER: builtins.int
    TYPED_CONFIG_FIELD_NUMBER: builtins.int
    provider_name: builtins.str
    """Private key method provider name. The name must match a
    supported private key method provider type.
    """
    @property
    def typed_config(self) -> google.protobuf.any_pb2.Any: ...
    def __init__(
        self,
        *,
        provider_name: builtins.str = ...,
        typed_config: google.protobuf.any_pb2.Any | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["config_type", b"config_type", "typed_config", b"typed_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["config_type", b"config_type", "provider_name", b"provider_name", "typed_config", b"typed_config"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["config_type", b"config_type"]) -> typing.Literal["typed_config"] | None: ...

global___PrivateKeyProvider = PrivateKeyProvider

@typing.final
class TlsCertificate(google.protobuf.message.Message):
    """[#next-free-field: 9]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CERTIFICATE_CHAIN_FIELD_NUMBER: builtins.int
    PRIVATE_KEY_FIELD_NUMBER: builtins.int
    PKCS12_FIELD_NUMBER: builtins.int
    WATCHED_DIRECTORY_FIELD_NUMBER: builtins.int
    PRIVATE_KEY_PROVIDER_FIELD_NUMBER: builtins.int
    PASSWORD_FIELD_NUMBER: builtins.int
    OCSP_STAPLE_FIELD_NUMBER: builtins.int
    SIGNED_CERTIFICATE_TIMESTAMP_FIELD_NUMBER: builtins.int
    @property
    def certificate_chain(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """The TLS certificate chain.

        If ``certificate_chain`` is a filesystem path, a watch will be added to the
        parent directory for any file moves to support rotation. This currently
        only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via
        SDS.
        """

    @property
    def private_key(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """The TLS private key.

        If ``private_key`` is a filesystem path, a watch will be added to the parent
        directory for any file moves to support rotation. This currently only
        applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS.
        """

    @property
    def pkcs12(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """``Pkcs12`` data containing TLS certificate, chain, and private key.

        If ``pkcs12`` is a filesystem path, the file will be read, but no watch will
        be added to the parent directory, since ``pkcs12`` isn't used by SDS.
        This field is mutually exclusive with ``certificate_chain``, ``private_key`` and ``private_key_provider``.
        This can't be marked as ``oneof`` due to API compatibility reasons. Setting
        both :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>`,
        :ref:`certificate_chain <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.certificate_chain>`,
        or :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>`
        and :ref:`pkcs12 <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12>`
        fields will result in an error. Use :ref:`password
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.password>`
        to specify the password to unprotect the ``PKCS12`` data, if necessary.
        """

    @property
    def watched_directory(self) -> envoy.config.core.v3.base_pb2.WatchedDirectory:
        """If specified, updates of file-based ``certificate_chain`` and ``private_key``
        sources will be triggered by this watch. The certificate/key pair will be
        read together and validated for atomic read consistency (i.e. no
        intervening modification occurred between cert/key read, verified by file
        hash comparisons). This allows explicit control over the path watched, by
        default the parent directories of the filesystem paths in
        ``certificate_chain`` and ``private_key`` are watched if this field is not
        specified. This only applies when a ``TlsCertificate`` is delivered by SDS
        with references to filesystem paths. See the :ref:`SDS key rotation
        <sds_key_rotation>` documentation for further details.
        """

    @property
    def private_key_provider(self) -> global___PrivateKeyProvider:
        """BoringSSL private key method provider. This is an alternative to :ref:`private_key
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field. This can't be
        marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` and
        :ref:`private_key_provider
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` fields will result in an
        error.
        """

    @property
    def password(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """The password to decrypt the TLS private key. If this field is not set, it is assumed that the
        TLS private key is not password encrypted.
        """

    @property
    def ocsp_staple(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """The OCSP response to be stapled with this certificate during the handshake.
        The response must be DER-encoded and may only be  provided via ``filename`` or
        ``inline_bytes``. The response may pertain to only one certificate.
        """

    @property
    def signed_certificate_timestamp(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.DataSource]:
        """[#not-implemented-hide:]"""

    def __init__(
        self,
        *,
        certificate_chain: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        private_key: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        pkcs12: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        watched_directory: envoy.config.core.v3.base_pb2.WatchedDirectory | None = ...,
        private_key_provider: global___PrivateKeyProvider | None = ...,
        password: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        ocsp_staple: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        signed_certificate_timestamp: collections.abc.Iterable[envoy.config.core.v3.base_pb2.DataSource] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["certificate_chain", b"certificate_chain", "ocsp_staple", b"ocsp_staple", "password", b"password", "pkcs12", b"pkcs12", "private_key", b"private_key", "private_key_provider", b"private_key_provider", "watched_directory", b"watched_directory"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["certificate_chain", b"certificate_chain", "ocsp_staple", b"ocsp_staple", "password", b"password", "pkcs12", b"pkcs12", "private_key", b"private_key", "private_key_provider", b"private_key_provider", "signed_certificate_timestamp", b"signed_certificate_timestamp", "watched_directory", b"watched_directory"]) -> None: ...

global___TlsCertificate = TlsCertificate

@typing.final
class TlsSessionTicketKeys(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.DataSource]:
        """Keys for encrypting and decrypting TLS session tickets. The
        first key in the array contains the key to encrypt all new sessions created by this context.
        All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
        by, for example, putting the new key first, and the previous key second.

        If :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
        is not specified, the TLS library will still support resuming sessions via tickets, but it will
        use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
        or on different hosts.

        Each key must contain exactly 80 bytes of cryptographically-secure random data. For
        example, the output of ``openssl rand 80``.

        .. attention::

          Using this feature has serious security considerations and risks. Improper handling of keys
          may result in loss of secrecy in connections, even if ciphers supporting perfect forward
          secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
          discussion. To minimize the risk, you must:

          * Keep the session ticket keys at least as secure as your TLS certificate private keys
          * Rotate session ticket keys at least daily, and preferably hourly
          * Always generate keys using a cryptographically-secure random data source
        """

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[envoy.config.core.v3.base_pb2.DataSource] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___TlsSessionTicketKeys = TlsSessionTicketKeys

@typing.final
class CertificateProviderPluginInstance(google.protobuf.message.Message):
    """Indicates a certificate to be obtained from a named CertificateProvider plugin instance.
    The plugin instances are defined in the client's bootstrap file.
    The plugin allows certificates to be fetched/refreshed over the network asynchronously with
    respect to the TLS handshake.
    [#not-implemented-hide:]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INSTANCE_NAME_FIELD_NUMBER: builtins.int
    CERTIFICATE_NAME_FIELD_NUMBER: builtins.int
    instance_name: builtins.str
    """Provider instance name. If not present, defaults to "default".

    Instance names should generally be defined not in terms of the underlying provider
    implementation (e.g., "file_watcher") but rather in terms of the function of the
    certificates (e.g., "foo_deployment_identity").
    """
    certificate_name: builtins.str
    """Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    a root-certificate (validation context) or "example.com" to specify a certificate for a
    particular domain. Not all provider instances will actually use this field, so the value
    defaults to the empty string.
    """
    def __init__(
        self,
        *,
        instance_name: builtins.str = ...,
        certificate_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["certificate_name", b"certificate_name", "instance_name", b"instance_name"]) -> None: ...

global___CertificateProviderPluginInstance = CertificateProviderPluginInstance

@typing.final
class SubjectAltNameMatcher(google.protobuf.message.Message):
    """Matcher for subject alternative names, to match both type and value of the SAN."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SanType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SanTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SubjectAltNameMatcher._SanType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SAN_TYPE_UNSPECIFIED: SubjectAltNameMatcher._SanType.ValueType  # 0
        EMAIL: SubjectAltNameMatcher._SanType.ValueType  # 1
        DNS: SubjectAltNameMatcher._SanType.ValueType  # 2
        URI: SubjectAltNameMatcher._SanType.ValueType  # 3
        IP_ADDRESS: SubjectAltNameMatcher._SanType.ValueType  # 4

    class SanType(_SanType, metaclass=_SanTypeEnumTypeWrapper):
        """Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match
        against.
        """

    SAN_TYPE_UNSPECIFIED: SubjectAltNameMatcher.SanType.ValueType  # 0
    EMAIL: SubjectAltNameMatcher.SanType.ValueType  # 1
    DNS: SubjectAltNameMatcher.SanType.ValueType  # 2
    URI: SubjectAltNameMatcher.SanType.ValueType  # 3
    IP_ADDRESS: SubjectAltNameMatcher.SanType.ValueType  # 4

    SAN_TYPE_FIELD_NUMBER: builtins.int
    MATCHER_FIELD_NUMBER: builtins.int
    san_type: global___SubjectAltNameMatcher.SanType.ValueType
    """Specification of type of SAN. Note that the default enum value is an invalid choice."""
    @property
    def matcher(self) -> envoy.type.matcher.v3.string_pb2.StringMatcher:
        """Matcher for SAN value."""

    def __init__(
        self,
        *,
        san_type: global___SubjectAltNameMatcher.SanType.ValueType = ...,
        matcher: envoy.type.matcher.v3.string_pb2.StringMatcher | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["matcher", b"matcher"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["matcher", b"matcher", "san_type", b"san_type"]) -> None: ...

global___SubjectAltNameMatcher = SubjectAltNameMatcher

@typing.final
class CertificateValidationContext(google.protobuf.message.Message):
    """[#next-free-field: 17]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _TrustChainVerification:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TrustChainVerificationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CertificateValidationContext._TrustChainVerification.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERIFY_TRUST_CHAIN: CertificateValidationContext._TrustChainVerification.ValueType  # 0
        """Perform default certificate verification (e.g., against CA / verification lists)"""
        ACCEPT_UNTRUSTED: CertificateValidationContext._TrustChainVerification.ValueType  # 1
        """Connections where the certificate fails verification will be permitted.
        For HTTP connections, the result of certificate verification can be used in route matching. (
        see :ref:`validated <envoy_v3_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
        """

    class TrustChainVerification(_TrustChainVerification, metaclass=_TrustChainVerificationEnumTypeWrapper):
        """Peer certificate verification mode."""

    VERIFY_TRUST_CHAIN: CertificateValidationContext.TrustChainVerification.ValueType  # 0
    """Perform default certificate verification (e.g., against CA / verification lists)"""
    ACCEPT_UNTRUSTED: CertificateValidationContext.TrustChainVerification.ValueType  # 1
    """Connections where the certificate fails verification will be permitted.
    For HTTP connections, the result of certificate verification can be used in route matching. (
    see :ref:`validated <envoy_v3_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
    """

    TRUSTED_CA_FIELD_NUMBER: builtins.int
    CA_CERTIFICATE_PROVIDER_INSTANCE_FIELD_NUMBER: builtins.int
    WATCHED_DIRECTORY_FIELD_NUMBER: builtins.int
    VERIFY_CERTIFICATE_SPKI_FIELD_NUMBER: builtins.int
    VERIFY_CERTIFICATE_HASH_FIELD_NUMBER: builtins.int
    MATCH_TYPED_SUBJECT_ALT_NAMES_FIELD_NUMBER: builtins.int
    MATCH_SUBJECT_ALT_NAMES_FIELD_NUMBER: builtins.int
    REQUIRE_SIGNED_CERTIFICATE_TIMESTAMP_FIELD_NUMBER: builtins.int
    CRL_FIELD_NUMBER: builtins.int
    ALLOW_EXPIRED_CERTIFICATE_FIELD_NUMBER: builtins.int
    TRUST_CHAIN_VERIFICATION_FIELD_NUMBER: builtins.int
    CUSTOM_VALIDATOR_CONFIG_FIELD_NUMBER: builtins.int
    ONLY_VERIFY_LEAF_CERT_CRL_FIELD_NUMBER: builtins.int
    MAX_VERIFY_DEPTH_FIELD_NUMBER: builtins.int
    allow_expired_certificate: builtins.bool
    """If specified, Envoy will not reject expired certificates."""
    trust_chain_verification: global___CertificateValidationContext.TrustChainVerification.ValueType
    """Certificate trust chain verification mode."""
    only_verify_leaf_cert_crl: builtins.bool
    """If this option is set to true, only the certificate at the end of the
    certificate chain will be subject to validation by :ref:`CRL <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl>`.
    """
    @property
    def trusted_ca(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """TLS certificate data containing certificate authority certificates to use in verifying
        a presented peer certificate (e.g. server certificate for clusters or client certificate
        for listeners). If not specified and a peer certificate is presented it will not be
        verified. By default, a client certificate is optional, unless one of the additional
        options (:ref:`require_client_certificate
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`,
        :ref:`verify_certificate_spki
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>`,
        :ref:`verify_certificate_hash
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`, or
        :ref:`match_typed_subject_alt_names
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`) is also
        specified.

        It can optionally contain certificate revocation lists, in which case Envoy will verify
        that the presented peer certificate has not been revoked by one of the included CRLs. Note
        that if a CRL is provided for any certificate authority in a trust chain, a CRL must be
        provided for all certificate authorities in that chain. Failure to do so will result in
        verification failure for both revoked and unrevoked certificates from that chain.
        The behavior of requiring all certificates to contain CRLs if any do can be altered by
        setting :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>`
        true. If set to true, only the final certificate in the chain undergoes CRL verification.

        See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
        system CA locations.

        If ``trusted_ca`` is a filesystem path, a watch will be added to the parent
        directory for any file moves to support rotation. This currently only
        applies to dynamic secrets, when the ``CertificateValidationContext`` is
        delivered via SDS.

        X509_V_FLAG_PARTIAL_CHAIN is set by default, so non-root/intermediate ca certificate in ``trusted_ca``
        can be treated as trust anchor as well. It allows verification with building valid partial chain instead
        of a full chain.

        Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.

        [#next-major-version: This field and watched_directory below should ideally be moved into a
        separate sub-message, since there's no point in specifying the latter field without this one.]
        """

    @property
    def ca_certificate_provider_instance(self) -> global___CertificateProviderPluginInstance:
        """Certificate provider instance for fetching TLS certificates.

        Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
        [#not-implemented-hide:]
        """

    @property
    def watched_directory(self) -> envoy.config.core.v3.base_pb2.WatchedDirectory:
        """If specified, updates of a file-based ``trusted_ca`` source will be triggered
        by this watch. This allows explicit control over the path watched, by
        default the parent directory of the filesystem path in ``trusted_ca`` is
        watched if this field is not specified. This only applies when a
        ``CertificateValidationContext`` is delivered by SDS with references to
        filesystem paths. See the :ref:`SDS key rotation <sds_key_rotation>`
        documentation for further details.
        """

    @property
    def verify_certificate_spki(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
        SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
        matches one of the specified values.

        A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
        can be generated with the following command:

        .. code-block:: bash

          $ openssl x509 -in path/to/client.crt -noout -pubkey
            | openssl pkey -pubin -outform DER
            | openssl dgst -sha256 -binary
            | openssl enc -base64
          NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=

        This is the format used in HTTP Public Key Pinning.

        When both:
        :ref:`verify_certificate_hash
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
        :ref:`verify_certificate_spki
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
        a hash matching value from either of the lists will result in the certificate being accepted.

        .. attention::

          This option is preferred over :ref:`verify_certificate_hash
          <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`,
          because SPKI is tied to a private key, so it doesn't change when the certificate
          is renewed using the same private key.
        """

    @property
    def verify_certificate_hash(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
        the SHA-256 of the DER-encoded presented certificate matches one of the specified values.

        A hex-encoded SHA-256 of the certificate can be generated with the following command:

        .. code-block:: bash

          $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
          df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a

        A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
        can be generated with the following command:

        .. code-block:: bash

          $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
          DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A

        Both of those formats are acceptable.

        When both:
        :ref:`verify_certificate_hash
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
        :ref:`verify_certificate_spki
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
        a hash matching value from either of the lists will result in the certificate being accepted.
        """

    @property
    def match_typed_subject_alt_names(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SubjectAltNameMatcher]:
        """An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the
        Subject Alternative Name of the presented certificate matches one of the specified matchers.
        The matching uses "any" semantics, that is to say, the SAN is verified if at least one matcher is
        matched.

        When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
        configured with exact match type in the :ref:`string matcher <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`.
        For example if the certificate has "\\*.example.com" as DNS SAN entry, to allow only "api.example.com",
        it should be configured as shown below.

        .. code-block:: yaml

         match_typed_subject_alt_names:
         - san_type: DNS
           matcher:
             exact: "api.example.com"

        .. attention::

          Subject Alternative Names are easily spoofable and verifying only them is insecure,
          therefore this option must be used together with :ref:`trusted_ca
          <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
        """

    @property
    def match_subject_alt_names(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.type.matcher.v3.string_pb2.StringMatcher]:
        """This field is deprecated in favor of
        :ref:`match_typed_subject_alt_names
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
        Note that if both this field and :ref:`match_typed_subject_alt_names
        <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`
        are specified, the former (deprecated field) is ignored.
        """

    @property
    def require_signed_certificate_timestamp(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """[#not-implemented-hide:] Must present signed certificate time-stamp."""

    @property
    def crl(self) -> envoy.config.core.v3.base_pb2.DataSource:
        """An optional `certificate revocation list
        <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
        (in PEM format). If specified, Envoy will verify that the presented peer
        certificate has not been revoked by this CRL. If this DataSource contains
        multiple CRLs, all of them will be used. Note that if a CRL is provided
        for any certificate authority in a trust chain, a CRL must be provided
        for all certificate authorities in that chain. Failure to do so will
        result in verification failure for both revoked and unrevoked certificates
        from that chain. This default behavior can be altered by setting
        :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>` to
        true.
        """

    @property
    def custom_validator_config(self) -> envoy.config.core.v3.extension_pb2.TypedExtensionConfig:
        """The configuration of an extension specific certificate validator.
        If specified, all validation is done by the specified validator,
        and the behavior of all other validation settings is defined by the specified validator (and may be entirely ignored, unused, and unvalidated).
        Refer to the documentation for the specified validator. If you do not want a custom validation algorithm, do not set this field.
        [#extension-category: envoy.tls.cert_validator]
        """

    @property
    def max_verify_depth(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Defines maximum depth of a certificate chain accepted in verification, the default limit is 100, though this can be system-dependent.
        This number does not include the leaf, so a depth of 1 allows the leaf and one CA certificate. If a trusted issuer appears in the chain,
        but in a depth larger than configured, the certificate validation will fail.
        See `BoringSSL SSL_CTX_set_verify_depth <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_CTX_set_verify_depth>`
        If you use OpenSSL, its behavior is different from BoringSSL, this will define a limit on the number of certificates between the end-entity and trust-anchor certificates.
        Neither the end-entity nor the trust-anchor certificates count against depth.
        See `OpenSSL SSL set_verify_depth <https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_verify_depth.html>`_.
        Trusted issues are specified by setting :ref:`trusted_ca <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`
        """

    def __init__(
        self,
        *,
        trusted_ca: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        ca_certificate_provider_instance: global___CertificateProviderPluginInstance | None = ...,
        watched_directory: envoy.config.core.v3.base_pb2.WatchedDirectory | None = ...,
        verify_certificate_spki: collections.abc.Iterable[builtins.str] | None = ...,
        verify_certificate_hash: collections.abc.Iterable[builtins.str] | None = ...,
        match_typed_subject_alt_names: collections.abc.Iterable[global___SubjectAltNameMatcher] | None = ...,
        match_subject_alt_names: collections.abc.Iterable[envoy.type.matcher.v3.string_pb2.StringMatcher] | None = ...,
        require_signed_certificate_timestamp: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        crl: envoy.config.core.v3.base_pb2.DataSource | None = ...,
        allow_expired_certificate: builtins.bool = ...,
        trust_chain_verification: global___CertificateValidationContext.TrustChainVerification.ValueType = ...,
        custom_validator_config: envoy.config.core.v3.extension_pb2.TypedExtensionConfig | None = ...,
        only_verify_leaf_cert_crl: builtins.bool = ...,
        max_verify_depth: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["ca_certificate_provider_instance", b"ca_certificate_provider_instance", "crl", b"crl", "custom_validator_config", b"custom_validator_config", "max_verify_depth", b"max_verify_depth", "require_signed_certificate_timestamp", b"require_signed_certificate_timestamp", "trusted_ca", b"trusted_ca", "watched_directory", b"watched_directory"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["allow_expired_certificate", b"allow_expired_certificate", "ca_certificate_provider_instance", b"ca_certificate_provider_instance", "crl", b"crl", "custom_validator_config", b"custom_validator_config", "match_subject_alt_names", b"match_subject_alt_names", "match_typed_subject_alt_names", b"match_typed_subject_alt_names", "max_verify_depth", b"max_verify_depth", "only_verify_leaf_cert_crl", b"only_verify_leaf_cert_crl", "require_signed_certificate_timestamp", b"require_signed_certificate_timestamp", "trust_chain_verification", b"trust_chain_verification", "trusted_ca", b"trusted_ca", "verify_certificate_hash", b"verify_certificate_hash", "verify_certificate_spki", b"verify_certificate_spki", "watched_directory", b"watched_directory"]) -> None: ...

global___CertificateValidationContext = CertificateValidationContext
