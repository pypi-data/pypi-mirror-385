import reboot.aio.reboot
import unittest
from reboot.aio.applications import Application
from reboot.aio.http import WebFramework
from reboot.aio.reboot import ApplicationRevision
from rebootdev.aio.auth.token_verifiers import TokenVerifier
from rebootdev.aio.contexts import EffectValidation
from rebootdev.aio.external import ExternalContext
from rebootdev.aio.servicers import Servicer
from typing import Any, Awaitable, Callable, Optional, overload
from unittest import mock


def assert_called_twice_with(
    testcase: unittest.IsolatedAsyncioTestCase,
    mock_obj: mock.Mock,
    *args: Any,
    **kwargs: Any,
) -> None:
    """Asserts that the given mock received exactly two calls, and that they had
    the given arguments.

    This is a useful alternative to `Mock.assert_called_once_with` in the presence
    of effect validation, which will frequently trigger two identical calls to a mock.
    """
    call = mock.call(*args, **kwargs)
    mock_obj.assert_has_calls([call, call])
    testcase.assertEqual(mock_obj.call_count, 2)


class Reboot(reboot.aio.reboot.Reboot):
    """A testing specific version of `Reboot` that takes an `Application`
    instead of explicit keyword args."""

    @overload
    async def up(
        self,
        application: Application,
        *,
        local_envoy: Optional[bool] = None,
        local_envoy_port: int = 0,
        local_envoy_tls: Optional[bool] = None,
        partitions: Optional[int] = None,
        effect_validation: Optional[EffectValidation] = None,
        in_process: bool = False,
    ) -> ApplicationRevision:
        ...

    @overload
    async def up(
        self,
        *,
        revision: Optional[ApplicationRevision] = None,
    ) -> ApplicationRevision:
        ...

    @overload
    async def up(
        self,
        *,
        servicers: list[type[Servicer]],
        # A legacy gRPC servicer type can't be more specific than `type`,
        # because legacy gRPC servicers (as generated by the gRPC `protoc`
        # plugin) do not share any common base class other than `object`.
        legacy_grpc_servicers: Optional[list[type]] = None,
        web_framework: WebFramework,
        token_verifier: Optional[TokenVerifier] = None,
        initialize: Optional[Callable[[ExternalContext],
                                      Awaitable[None]]] = None,
        initialize_bearer_token: Optional[str] = None,
        local_envoy: Optional[bool] = None,
        local_envoy_port: int = 0,
        local_envoy_tls: Optional[bool] = None,
        partitions: Optional[int] = None,
        effect_validation: Optional[EffectValidation] = None,
        in_process: bool = False,
        revision: Optional[ApplicationRevision] = None,
    ) -> ApplicationRevision:
        ...

    async def up(
        self,
        application: Optional[Application] = None,
        *,
        servicers: Optional[list[type[Servicer]]] = None,
        # A legacy gRPC servicer type can't be more specific than `type`,
        # because legacy gRPC servicers (as generated by the gRPC `protoc`
        # plugin) do not share any common base class other than `object`.
        legacy_grpc_servicers: Optional[list[type]] = None,
        web_framework: Optional[WebFramework] = None,
        token_verifier: Optional[TokenVerifier] = None,
        initialize: Optional[Callable[[ExternalContext],
                                      Awaitable[None]]] = None,
        initialize_bearer_token: Optional[str] = None,
        local_envoy: Optional[bool] = None,
        local_envoy_port: int = 0,
        local_envoy_tls: Optional[bool] = None,
        partitions: Optional[int] = None,
        effect_validation: Optional[EffectValidation] = None,
        in_process: bool = False,
        revision: Optional[ApplicationRevision] = None,
    ) -> ApplicationRevision:

        if revision is not None and application is not None:
            raise ValueError(
                "Only one of 'application' OR 'revision' can be passed"
            )

        if servicers is not None:
            raise ValueError("Not expecting 'servicers'")

        if legacy_grpc_servicers is not None:
            raise ValueError("Not expecting 'legacy_grpc_servicers'")

        if web_framework is not None:
            raise ValueError("Not expecting 'web_framework'")

        if token_verifier is not None:
            raise ValueError("Not expecting 'token_verifier'")

        if initialize is not None:
            raise ValueError("Not expecting 'initialize'")

        if initialize_bearer_token is not None:
            raise ValueError("Not expecting 'initialize_bearer_token'")

        if revision is not None:
            if partitions is not None:
                raise ValueError("Not expecting 'partitions'")

            if effect_validation is not None:
                raise ValueError("Not expecting 'effect_validation'")

            return await super().up(
                revision=revision,
            )

        if application is None:
            raise ValueError("Must pass one of 'application' or 'revision'")

        # Should only have `application`, `local_envoy`,
        # `local_envoy_port`, `partitions`, `effect_validation`, or
        # `in_process`.

        # Check if application.http has methods or mounts. If yes,
        # we need a local_envoy to be present to handle these requests.
        if local_envoy is None:
            local_envoy = application.has_http_routes_or_mounts()
        assert local_envoy is not None

        revision = await super().up(
            servicers=application.servicers,
            legacy_grpc_servicers=application.legacy_grpc_servicers,
            web_framework=application.web_framework,
            token_verifier=application.token_verifier,
            initialize=application.initialize,
            initialize_bearer_token=application._initialize_bearer_token,
            local_envoy=local_envoy,
            local_envoy_port=local_envoy_port,
            local_envoy_tls=local_envoy_tls,
            partitions=partitions,
            effect_validation=effect_validation,
            in_process=in_process,
        )

        return revision
