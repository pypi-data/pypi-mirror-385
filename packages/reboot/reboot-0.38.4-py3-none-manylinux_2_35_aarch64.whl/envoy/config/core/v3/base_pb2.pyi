"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.config.core.v3.address_pb2
import envoy.config.core.v3.backoff_pb2
import envoy.config.core.v3.http_uri_pb2
import envoy.type.v3.percent_pb2
import envoy.type.v3.semantic_version_pb2
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.wrappers_pb2
import sys
import typing
import xds.core.v3.context_params_pb2

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _RoutingPriority:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RoutingPriorityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RoutingPriority.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    DEFAULT: _RoutingPriority.ValueType  # 0
    HIGH: _RoutingPriority.ValueType  # 1

class RoutingPriority(_RoutingPriority, metaclass=_RoutingPriorityEnumTypeWrapper):
    """[#protodoc-title: Common types]

    Envoy supports :ref:`upstream priority routing
    <arch_overview_http_routing_priority>` both at the route and the virtual
    cluster level. The current priority implementation uses different connection
    pool and circuit breaking settings for each priority level. This means that
    even for HTTP/2 requests, two physical connections will be used to an
    upstream host. In the future Envoy will likely support true HTTP/2 priority
    over a single upstream connection.
    """

DEFAULT: RoutingPriority.ValueType  # 0
HIGH: RoutingPriority.ValueType  # 1
global___RoutingPriority = RoutingPriority

class _RequestMethod:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RequestMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RequestMethod.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    METHOD_UNSPECIFIED: _RequestMethod.ValueType  # 0
    GET: _RequestMethod.ValueType  # 1
    HEAD: _RequestMethod.ValueType  # 2
    POST: _RequestMethod.ValueType  # 3
    PUT: _RequestMethod.ValueType  # 4
    DELETE: _RequestMethod.ValueType  # 5
    CONNECT: _RequestMethod.ValueType  # 6
    OPTIONS: _RequestMethod.ValueType  # 7
    TRACE: _RequestMethod.ValueType  # 8
    PATCH: _RequestMethod.ValueType  # 9

class RequestMethod(_RequestMethod, metaclass=_RequestMethodEnumTypeWrapper):
    """HTTP request method."""

METHOD_UNSPECIFIED: RequestMethod.ValueType  # 0
GET: RequestMethod.ValueType  # 1
HEAD: RequestMethod.ValueType  # 2
POST: RequestMethod.ValueType  # 3
PUT: RequestMethod.ValueType  # 4
DELETE: RequestMethod.ValueType  # 5
CONNECT: RequestMethod.ValueType  # 6
OPTIONS: RequestMethod.ValueType  # 7
TRACE: RequestMethod.ValueType  # 8
PATCH: RequestMethod.ValueType  # 9
global___RequestMethod = RequestMethod

class _TrafficDirection:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _TrafficDirectionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TrafficDirection.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNSPECIFIED: _TrafficDirection.ValueType  # 0
    """Default option is unspecified."""
    INBOUND: _TrafficDirection.ValueType  # 1
    """The transport is used for incoming traffic."""
    OUTBOUND: _TrafficDirection.ValueType  # 2
    """The transport is used for outgoing traffic."""

class TrafficDirection(_TrafficDirection, metaclass=_TrafficDirectionEnumTypeWrapper):
    """Identifies the direction of the traffic relative to the local Envoy."""

UNSPECIFIED: TrafficDirection.ValueType  # 0
"""Default option is unspecified."""
INBOUND: TrafficDirection.ValueType  # 1
"""The transport is used for incoming traffic."""
OUTBOUND: TrafficDirection.ValueType  # 2
"""The transport is used for outgoing traffic."""
global___TrafficDirection = TrafficDirection

@typing.final
class Locality(google.protobuf.message.Message):
    """Identifies location of where either Envoy runs or where upstream hosts run."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REGION_FIELD_NUMBER: builtins.int
    ZONE_FIELD_NUMBER: builtins.int
    SUB_ZONE_FIELD_NUMBER: builtins.int
    region: builtins.str
    """Region this :ref:`zone <envoy_v3_api_field_config.core.v3.Locality.zone>` belongs to."""
    zone: builtins.str
    """Defines the local service zone where Envoy is running. Though optional, it
    should be set if discovery service routing is used and the discovery
    service exposes :ref:`zone data <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.locality>`,
    either in this message or via :option:`--service-zone`. The meaning of zone
    is context dependent, e.g. `Availability Zone (AZ)
    <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
    on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
    GCP, etc.
    """
    sub_zone: builtins.str
    """When used for locality of upstream hosts, this field further splits zone
    into smaller chunks of sub-zones so they can be load balanced
    independently.
    """
    def __init__(
        self,
        *,
        region: builtins.str = ...,
        zone: builtins.str = ...,
        sub_zone: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["region", b"region", "sub_zone", b"sub_zone", "zone", b"zone"]) -> None: ...

global___Locality = Locality

@typing.final
class BuildVersion(google.protobuf.message.Message):
    """BuildVersion combines SemVer version of extension with free-form build information
    (i.e. 'alpha', 'private-build') as a set of strings.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    @property
    def version(self) -> envoy.type.v3.semantic_version_pb2.SemanticVersion:
        """SemVer version of extension."""

    @property
    def metadata(self) -> google.protobuf.struct_pb2.Struct:
        """Free-form build information.
        Envoy defines several well known keys in the source/common/version/version.h file
        """

    def __init__(
        self,
        *,
        version: envoy.type.v3.semantic_version_pb2.SemanticVersion | None = ...,
        metadata: google.protobuf.struct_pb2.Struct | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["metadata", b"metadata", "version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["metadata", b"metadata", "version", b"version"]) -> None: ...

global___BuildVersion = BuildVersion

@typing.final
class Extension(google.protobuf.message.Message):
    """Version and identification for an Envoy extension.
    [#next-free-field: 7]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    CATEGORY_FIELD_NUMBER: builtins.int
    TYPE_DESCRIPTOR_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    DISABLED_FIELD_NUMBER: builtins.int
    TYPE_URLS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """This is the name of the Envoy filter as specified in the Envoy
    configuration, e.g. envoy.filters.http.router, com.acme.widget.
    """
    category: builtins.str
    """Category of the extension.
    Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
    for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
    acme.com vendor.
    [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
    """
    type_descriptor: builtins.str
    """[#not-implemented-hide:] Type descriptor of extension configuration proto.
    [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
    [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
    """
    disabled: builtins.bool
    """Indicates that the extension is present but was disabled via dynamic configuration."""
    @property
    def version(self) -> global___BuildVersion:
        """The version is a property of the extension and maintained independently
        of other extensions and the Envoy API.
        This field is not set when extension did not provide version information.
        """

    @property
    def type_urls(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Type URLs of extension configuration protos."""

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        category: builtins.str = ...,
        type_descriptor: builtins.str = ...,
        version: global___BuildVersion | None = ...,
        disabled: builtins.bool = ...,
        type_urls: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["version", b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["category", b"category", "disabled", b"disabled", "name", b"name", "type_descriptor", b"type_descriptor", "type_urls", b"type_urls", "version", b"version"]) -> None: ...

global___Extension = Extension

@typing.final
class Node(google.protobuf.message.Message):
    """Identifies a specific Envoy instance. The node identifier is presented to the
    management server, which may use this identifier to distinguish per Envoy
    configuration for serving.
    [#next-free-field: 13]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class DynamicParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> xds.core.v3.context_params_pb2.ContextParams: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: xds.core.v3.context_params_pb2.ContextParams | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    CLUSTER_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    DYNAMIC_PARAMETERS_FIELD_NUMBER: builtins.int
    LOCALITY_FIELD_NUMBER: builtins.int
    USER_AGENT_NAME_FIELD_NUMBER: builtins.int
    USER_AGENT_VERSION_FIELD_NUMBER: builtins.int
    USER_AGENT_BUILD_VERSION_FIELD_NUMBER: builtins.int
    EXTENSIONS_FIELD_NUMBER: builtins.int
    CLIENT_FEATURES_FIELD_NUMBER: builtins.int
    LISTENING_ADDRESSES_FIELD_NUMBER: builtins.int
    id: builtins.str
    """An opaque node identifier for the Envoy node. This also provides the local
    service node name. It should be set if any of the following features are
    used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
    <config_cluster_manager_cds>`, and :ref:`HTTP tracing
    <arch_overview_tracing>`, either in this message or via
    :option:`--service-node`.
    """
    cluster: builtins.str
    """Defines the local service cluster name where Envoy is running. Though
    optional, it should be set if any of the following features are used:
    :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
    verification
    <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.service_name_matcher>`,
    :ref:`runtime override directory <envoy_v3_api_msg_config.bootstrap.v3.Runtime>`,
    :ref:`user agent addition
    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.add_user_agent>`,
    :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
    :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
    <arch_overview_tracing>`, either in this message or via
    :option:`--service-cluster`.
    """
    user_agent_name: builtins.str
    """Free-form string that identifies the entity requesting config.
    E.g. "envoy" or "grpc"
    """
    user_agent_version: builtins.str
    """Free-form string that identifies the version of the entity requesting config.
    E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
    """
    @property
    def metadata(self) -> google.protobuf.struct_pb2.Struct:
        """Opaque metadata extending the node identifier. Envoy will pass this
        directly to the management server.
        """

    @property
    def dynamic_parameters(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, xds.core.v3.context_params_pb2.ContextParams]:
        """Map from xDS resource type URL to dynamic context parameters. These may vary at runtime (unlike
        other fields in this message). For example, the xDS client may have a shard identifier that
        changes during the lifetime of the xDS client. In Envoy, this would be achieved by updating the
        dynamic context on the Server::Instance's LocalInfo context provider. The shard ID dynamic
        parameter then appears in this field during future discovery requests.
        """

    @property
    def locality(self) -> global___Locality:
        """Locality specifying where the Envoy instance is running."""

    @property
    def user_agent_build_version(self) -> global___BuildVersion:
        """Structured version of the entity requesting config."""

    @property
    def extensions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Extension]:
        """List of extensions and their versions supported by the node."""

    @property
    def client_features(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Client feature support list. These are well known features described
        in the Envoy API repository for a given major version of an API. Client features
        use reverse DNS naming scheme, for example ``com.acme.feature``.
        See :ref:`the list of features <client_features>` that xDS client may
        support.
        """

    @property
    def listening_addresses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.address_pb2.Address]:
        """Known listening ports on the node as a generic hint to the management server
        for filtering :ref:`listeners <config_listeners>` to be returned. For example,
        if there is a listener bound to port 80, the list can optionally contain the
        SocketAddress ``(0.0.0.0,80)``. The field is optional and just a hint.
        """

    def __init__(
        self,
        *,
        id: builtins.str = ...,
        cluster: builtins.str = ...,
        metadata: google.protobuf.struct_pb2.Struct | None = ...,
        dynamic_parameters: collections.abc.Mapping[builtins.str, xds.core.v3.context_params_pb2.ContextParams] | None = ...,
        locality: global___Locality | None = ...,
        user_agent_name: builtins.str = ...,
        user_agent_version: builtins.str = ...,
        user_agent_build_version: global___BuildVersion | None = ...,
        extensions: collections.abc.Iterable[global___Extension] | None = ...,
        client_features: collections.abc.Iterable[builtins.str] | None = ...,
        listening_addresses: collections.abc.Iterable[envoy.config.core.v3.address_pb2.Address] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["locality", b"locality", "metadata", b"metadata", "user_agent_build_version", b"user_agent_build_version", "user_agent_version", b"user_agent_version", "user_agent_version_type", b"user_agent_version_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["client_features", b"client_features", "cluster", b"cluster", "dynamic_parameters", b"dynamic_parameters", "extensions", b"extensions", "id", b"id", "listening_addresses", b"listening_addresses", "locality", b"locality", "metadata", b"metadata", "user_agent_build_version", b"user_agent_build_version", "user_agent_name", b"user_agent_name", "user_agent_version", b"user_agent_version", "user_agent_version_type", b"user_agent_version_type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["user_agent_version_type", b"user_agent_version_type"]) -> typing.Literal["user_agent_version", "user_agent_build_version"] | None: ...

global___Node = Node

@typing.final
class Metadata(google.protobuf.message.Message):
    """Metadata provides additional inputs to filters based on matched listeners,
    filter chains, routes and endpoints. It is structured as a map, usually from
    filter name (in reverse DNS format) to metadata specific to the filter. Metadata
    key-values for a filter are merged as connection and request handling occurs,
    with later values for the same key overriding earlier values.

    An example use of metadata is providing additional values to
    http_connection_manager in the envoy.http_connection_manager.access_log
    namespace.

    Another example use of metadata is to per service config info in cluster metadata, which may get
    consumed by multiple filters.

    For load balancing, Metadata provides a means to subset cluster endpoints.
    Endpoints have a Metadata object associated and routes contain a Metadata
    object to match against. There are some well defined metadata used today for
    this purpose:

    * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
      endpoint and is also used during header processing
      (x-envoy-upstream-canary) and for stats purposes.
    [#next-major-version: move to type/metadata/v2]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class FilterMetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> google.protobuf.struct_pb2.Struct: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: google.protobuf.struct_pb2.Struct | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    @typing.final
    class TypedFilterMetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: google.protobuf.any_pb2.Any | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    FILTER_METADATA_FIELD_NUMBER: builtins.int
    TYPED_FILTER_METADATA_FIELD_NUMBER: builtins.int
    @property
    def filter_metadata(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, google.protobuf.struct_pb2.Struct]:
        """Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
        namespace is reserved for Envoy's built-in filters.
        If both ``filter_metadata`` and
        :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
        fields are present in the metadata with same keys,
        only ``typed_filter_metadata`` field will be parsed.
        """

    @property
    def typed_filter_metadata(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, google.protobuf.any_pb2.Any]:
        """Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
        namespace is reserved for Envoy's built-in filters.
        The value is encoded as google.protobuf.Any.
        If both :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
        and ``typed_filter_metadata`` fields are present in the metadata with same keys,
        only ``typed_filter_metadata`` field will be parsed.
        """

    def __init__(
        self,
        *,
        filter_metadata: collections.abc.Mapping[builtins.str, google.protobuf.struct_pb2.Struct] | None = ...,
        typed_filter_metadata: collections.abc.Mapping[builtins.str, google.protobuf.any_pb2.Any] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["filter_metadata", b"filter_metadata", "typed_filter_metadata", b"typed_filter_metadata"]) -> None: ...

global___Metadata = Metadata

@typing.final
class RuntimeUInt32(google.protobuf.message.Message):
    """Runtime derived uint32 with a default when not specified."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    RUNTIME_KEY_FIELD_NUMBER: builtins.int
    default_value: builtins.int
    """Default value if runtime value is not available."""
    runtime_key: builtins.str
    """Runtime key to get value for comparison. This value is used if defined."""
    def __init__(
        self,
        *,
        default_value: builtins.int = ...,
        runtime_key: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "runtime_key", b"runtime_key"]) -> None: ...

global___RuntimeUInt32 = RuntimeUInt32

@typing.final
class RuntimePercent(google.protobuf.message.Message):
    """Runtime derived percentage with a default when not specified."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    RUNTIME_KEY_FIELD_NUMBER: builtins.int
    runtime_key: builtins.str
    """Runtime key to get value for comparison. This value is used if defined."""
    @property
    def default_value(self) -> envoy.type.v3.percent_pb2.Percent:
        """Default value if runtime value is not available."""

    def __init__(
        self,
        *,
        default_value: envoy.type.v3.percent_pb2.Percent | None = ...,
        runtime_key: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "runtime_key", b"runtime_key"]) -> None: ...

global___RuntimePercent = RuntimePercent

@typing.final
class RuntimeDouble(google.protobuf.message.Message):
    """Runtime derived double with a default when not specified."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    RUNTIME_KEY_FIELD_NUMBER: builtins.int
    default_value: builtins.float
    """Default value if runtime value is not available."""
    runtime_key: builtins.str
    """Runtime key to get value for comparison. This value is used if defined."""
    def __init__(
        self,
        *,
        default_value: builtins.float = ...,
        runtime_key: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "runtime_key", b"runtime_key"]) -> None: ...

global___RuntimeDouble = RuntimeDouble

@typing.final
class RuntimeFeatureFlag(google.protobuf.message.Message):
    """Runtime derived bool with a default when not specified."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    RUNTIME_KEY_FIELD_NUMBER: builtins.int
    runtime_key: builtins.str
    """Runtime key to get value for comparison. This value is used if defined. The boolean value must
    be represented via its
    `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
    """
    @property
    def default_value(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Default value if runtime value is not available."""

    def __init__(
        self,
        *,
        default_value: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        runtime_key: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "runtime_key", b"runtime_key"]) -> None: ...

global___RuntimeFeatureFlag = RuntimeFeatureFlag

@typing.final
class QueryParameter(google.protobuf.message.Message):
    """Query parameter name/value pair."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    key: builtins.str
    """The key of the query parameter. Case sensitive."""
    value: builtins.str
    """The value of the query parameter."""
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        value: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

global___QueryParameter = QueryParameter

@typing.final
class HeaderValue(google.protobuf.message.Message):
    """Header name/value pair."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    key: builtins.str
    """Header name."""
    value: builtins.str
    """Header value.

    The same :ref:`format specifier <config_access_log_format>` as used for
    :ref:`HTTP access logging <config_access_log>` applies here, however
    unknown header values are replaced with the empty string instead of ``-``.
    """
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        value: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

global___HeaderValue = HeaderValue

@typing.final
class HeaderValueOption(google.protobuf.message.Message):
    """Header name/value pair plus option to control append behavior."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _HeaderAppendAction:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _HeaderAppendActionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[HeaderValueOption._HeaderAppendAction.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        APPEND_IF_EXISTS_OR_ADD: HeaderValueOption._HeaderAppendAction.ValueType  # 0
        """This action will append the specified value to the existing values if the header
        already exists. If the header doesn't exist then this will add the header with
        specified key and value.
        """
        ADD_IF_ABSENT: HeaderValueOption._HeaderAppendAction.ValueType  # 1
        """This action will add the header if it doesn't already exist. If the header
        already exists then this will be a no-op.
        """
        OVERWRITE_IF_EXISTS_OR_ADD: HeaderValueOption._HeaderAppendAction.ValueType  # 2
        """This action will overwrite the specified value by discarding any existing values if
        the header already exists. If the header doesn't exist then this will add the header
        with specified key and value.
        """

    class HeaderAppendAction(_HeaderAppendAction, metaclass=_HeaderAppendActionEnumTypeWrapper):
        """Describes the supported actions types for header append action."""

    APPEND_IF_EXISTS_OR_ADD: HeaderValueOption.HeaderAppendAction.ValueType  # 0
    """This action will append the specified value to the existing values if the header
    already exists. If the header doesn't exist then this will add the header with
    specified key and value.
    """
    ADD_IF_ABSENT: HeaderValueOption.HeaderAppendAction.ValueType  # 1
    """This action will add the header if it doesn't already exist. If the header
    already exists then this will be a no-op.
    """
    OVERWRITE_IF_EXISTS_OR_ADD: HeaderValueOption.HeaderAppendAction.ValueType  # 2
    """This action will overwrite the specified value by discarding any existing values if
    the header already exists. If the header doesn't exist then this will add the header
    with specified key and value.
    """

    HEADER_FIELD_NUMBER: builtins.int
    APPEND_FIELD_NUMBER: builtins.int
    APPEND_ACTION_FIELD_NUMBER: builtins.int
    KEEP_EMPTY_VALUE_FIELD_NUMBER: builtins.int
    append_action: global___HeaderValueOption.HeaderAppendAction.ValueType
    """Describes the action taken to append/overwrite the given value for an existing header
    or to only add this header if it's absent.
    Value defaults to :ref:`APPEND_IF_EXISTS_OR_ADD
    <envoy_v3_api_enum_value_config.core.v3.HeaderValueOption.HeaderAppendAction.APPEND_IF_EXISTS_OR_ADD>`.
    """
    keep_empty_value: builtins.bool
    """Is the header value allowed to be empty? If false (default), custom headers with empty values are dropped,
    otherwise they are added.
    """
    @property
    def header(self) -> global___HeaderValue:
        """Header name/value pair that this option applies to."""

    @property
    def append(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Should the value be appended? If true (default), the value is appended to
        existing values. Otherwise it replaces any existing values.
        This field is deprecated and please use
        :ref:`append_action <envoy_v3_api_field_config.core.v3.HeaderValueOption.append_action>` as replacement.

        .. note::
          The :ref:`external authorization service <envoy_v3_api_msg_service.auth.v3.CheckResponse>` and
          :ref:`external processor service <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>` have
          default value (``false``) for this field.
        """

    def __init__(
        self,
        *,
        header: global___HeaderValue | None = ...,
        append: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        append_action: global___HeaderValueOption.HeaderAppendAction.ValueType = ...,
        keep_empty_value: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["append", b"append", "header", b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["append", b"append", "append_action", b"append_action", "header", b"header", "keep_empty_value", b"keep_empty_value"]) -> None: ...

global___HeaderValueOption = HeaderValueOption

@typing.final
class HeaderMap(google.protobuf.message.Message):
    """Wrapper for a set of headers."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HEADERS_FIELD_NUMBER: builtins.int
    @property
    def headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HeaderValue]: ...
    def __init__(
        self,
        *,
        headers: collections.abc.Iterable[global___HeaderValue] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["headers", b"headers"]) -> None: ...

global___HeaderMap = HeaderMap

@typing.final
class WatchedDirectory(google.protobuf.message.Message):
    """A directory that is watched for changes, e.g. by inotify on Linux. Move/rename
    events inside this directory trigger the watch.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATH_FIELD_NUMBER: builtins.int
    path: builtins.str
    """Directory path to watch."""
    def __init__(
        self,
        *,
        path: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["path", b"path"]) -> None: ...

global___WatchedDirectory = WatchedDirectory

@typing.final
class DataSource(google.protobuf.message.Message):
    """Data source consisting of a file, an inline value, or an environment variable."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FILENAME_FIELD_NUMBER: builtins.int
    INLINE_BYTES_FIELD_NUMBER: builtins.int
    INLINE_STRING_FIELD_NUMBER: builtins.int
    ENVIRONMENT_VARIABLE_FIELD_NUMBER: builtins.int
    filename: builtins.str
    """Local filesystem data source."""
    inline_bytes: builtins.bytes
    """Bytes inlined in the configuration."""
    inline_string: builtins.str
    """String inlined in the configuration."""
    environment_variable: builtins.str
    """Environment variable data source."""
    def __init__(
        self,
        *,
        filename: builtins.str = ...,
        inline_bytes: builtins.bytes = ...,
        inline_string: builtins.str = ...,
        environment_variable: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["environment_variable", b"environment_variable", "filename", b"filename", "inline_bytes", b"inline_bytes", "inline_string", b"inline_string", "specifier", b"specifier"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["environment_variable", b"environment_variable", "filename", b"filename", "inline_bytes", b"inline_bytes", "inline_string", b"inline_string", "specifier", b"specifier"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["specifier", b"specifier"]) -> typing.Literal["filename", "inline_bytes", "inline_string", "environment_variable"] | None: ...

global___DataSource = DataSource

@typing.final
class RetryPolicy(google.protobuf.message.Message):
    """The message specifies the retry policy of remote data source when fetching fails."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RETRY_BACK_OFF_FIELD_NUMBER: builtins.int
    NUM_RETRIES_FIELD_NUMBER: builtins.int
    @property
    def retry_back_off(self) -> envoy.config.core.v3.backoff_pb2.BackoffStrategy:
        """Specifies parameters that control :ref:`retry backoff strategy <envoy_v3_api_msg_config.core.v3.BackoffStrategy>`.
        This parameter is optional, in which case the default base interval is 1000 milliseconds. The
        default maximum interval is 10 times the base interval.
        """

    @property
    def num_retries(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """Specifies the allowed number of retries. This parameter is optional and
        defaults to 1.
        """

    def __init__(
        self,
        *,
        retry_back_off: envoy.config.core.v3.backoff_pb2.BackoffStrategy | None = ...,
        num_retries: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["num_retries", b"num_retries", "retry_back_off", b"retry_back_off"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["num_retries", b"num_retries", "retry_back_off", b"retry_back_off"]) -> None: ...

global___RetryPolicy = RetryPolicy

@typing.final
class RemoteDataSource(google.protobuf.message.Message):
    """The message specifies how to fetch data from remote and how to verify it."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HTTP_URI_FIELD_NUMBER: builtins.int
    SHA256_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    sha256: builtins.str
    """SHA256 string for verifying data."""
    @property
    def http_uri(self) -> envoy.config.core.v3.http_uri_pb2.HttpUri:
        """The HTTP URI to fetch the remote data."""

    @property
    def retry_policy(self) -> global___RetryPolicy:
        """Retry policy for fetching remote data."""

    def __init__(
        self,
        *,
        http_uri: envoy.config.core.v3.http_uri_pb2.HttpUri | None = ...,
        sha256: builtins.str = ...,
        retry_policy: global___RetryPolicy | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["http_uri", b"http_uri", "retry_policy", b"retry_policy"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["http_uri", b"http_uri", "retry_policy", b"retry_policy", "sha256", b"sha256"]) -> None: ...

global___RemoteDataSource = RemoteDataSource

@typing.final
class AsyncDataSource(google.protobuf.message.Message):
    """Async data source which support async data fetch."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCAL_FIELD_NUMBER: builtins.int
    REMOTE_FIELD_NUMBER: builtins.int
    @property
    def local(self) -> global___DataSource:
        """Local async data source."""

    @property
    def remote(self) -> global___RemoteDataSource:
        """Remote async data source."""

    def __init__(
        self,
        *,
        local: global___DataSource | None = ...,
        remote: global___RemoteDataSource | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["local", b"local", "remote", b"remote", "specifier", b"specifier"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["local", b"local", "remote", b"remote", "specifier", b"specifier"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["specifier", b"specifier"]) -> typing.Literal["local", "remote"] | None: ...

global___AsyncDataSource = AsyncDataSource

@typing.final
class TransportSocket(google.protobuf.message.Message):
    """Configuration for transport socket in :ref:`listeners <config_listeners>` and
    :ref:`clusters <envoy_v3_api_msg_config.cluster.v3.Cluster>`. If the configuration is
    empty, a default transport socket implementation and configuration will be
    chosen based on the platform and existence of tls_context.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPED_CONFIG_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The name of the transport socket to instantiate. The name must match a supported transport
    socket implementation.
    """
    @property
    def typed_config(self) -> google.protobuf.any_pb2.Any: ...
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        typed_config: google.protobuf.any_pb2.Any | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["config_type", b"config_type", "typed_config", b"typed_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["config_type", b"config_type", "name", b"name", "typed_config", b"typed_config"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["config_type", b"config_type"]) -> typing.Literal["typed_config"] | None: ...

global___TransportSocket = TransportSocket

@typing.final
class RuntimeFractionalPercent(google.protobuf.message.Message):
    """Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
    specified via a runtime key.

    .. note::

      Parsing of the runtime key's data is implemented such that it may be represented as a
      :ref:`FractionalPercent <envoy_v3_api_msg_type.v3.FractionalPercent>` proto represented as JSON/YAML
      and may also be represented as an integer with the assumption that the value is an integral
      percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
      as a ``FractionalPercent`` whose numerator is 42 and denominator is HUNDRED.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEFAULT_VALUE_FIELD_NUMBER: builtins.int
    RUNTIME_KEY_FIELD_NUMBER: builtins.int
    runtime_key: builtins.str
    """Runtime key for a YAML representation of a FractionalPercent."""
    @property
    def default_value(self) -> envoy.type.v3.percent_pb2.FractionalPercent:
        """Default value if the runtime value's for the numerator/denominator keys are not available."""

    def __init__(
        self,
        *,
        default_value: envoy.type.v3.percent_pb2.FractionalPercent | None = ...,
        runtime_key: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["default_value", b"default_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["default_value", b"default_value", "runtime_key", b"runtime_key"]) -> None: ...

global___RuntimeFractionalPercent = RuntimeFractionalPercent

@typing.final
class ControlPlane(google.protobuf.message.Message):
    """Identifies a specific ControlPlane instance that Envoy is connected to."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IDENTIFIER_FIELD_NUMBER: builtins.int
    identifier: builtins.str
    """An opaque control plane identifier that uniquely identifies an instance
    of control plane. This can be used to identify which control plane instance,
    the Envoy is connected to.
    """
    def __init__(
        self,
        *,
        identifier: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["identifier", b"identifier"]) -> None: ...

global___ControlPlane = ControlPlane
