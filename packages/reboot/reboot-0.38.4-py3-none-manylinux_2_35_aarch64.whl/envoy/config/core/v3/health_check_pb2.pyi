"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.config.core.v3.base_pb2
import envoy.config.core.v3.event_service_config_pb2
import envoy.type.matcher.v3.string_pb2
import envoy.type.v3.http_pb2
import envoy.type.v3.range_pb2
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.wrappers_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _HealthStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _HealthStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_HealthStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN: _HealthStatus.ValueType  # 0
    """The health status is not known. This is interpreted by Envoy as ``HEALTHY``."""
    HEALTHY: _HealthStatus.ValueType  # 1
    """Healthy."""
    UNHEALTHY: _HealthStatus.ValueType  # 2
    """Unhealthy."""
    DRAINING: _HealthStatus.ValueType  # 3
    """Connection draining in progress. E.g.,
    `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
    or
    `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
    This is interpreted by Envoy as ``UNHEALTHY``.
    """
    TIMEOUT: _HealthStatus.ValueType  # 4
    """Health check timed out. This is part of HDS and is interpreted by Envoy as
    ``UNHEALTHY``.
    """
    DEGRADED: _HealthStatus.ValueType  # 5
    """Degraded."""

class HealthStatus(_HealthStatus, metaclass=_HealthStatusEnumTypeWrapper):
    """[#protodoc-title: Health check]
    * Health checking :ref:`architecture overview <arch_overview_health_checking>`.
    * If health checking is configured for a cluster, additional statistics are emitted. They are
      documented :ref:`here <config_cluster_manager_cluster_stats>`.

    Endpoint health status.
    """

UNKNOWN: HealthStatus.ValueType  # 0
"""The health status is not known. This is interpreted by Envoy as ``HEALTHY``."""
HEALTHY: HealthStatus.ValueType  # 1
"""Healthy."""
UNHEALTHY: HealthStatus.ValueType  # 2
"""Unhealthy."""
DRAINING: HealthStatus.ValueType  # 3
"""Connection draining in progress. E.g.,
`<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
or
`<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
This is interpreted by Envoy as ``UNHEALTHY``.
"""
TIMEOUT: HealthStatus.ValueType  # 4
"""Health check timed out. This is part of HDS and is interpreted by Envoy as
``UNHEALTHY``.
"""
DEGRADED: HealthStatus.ValueType  # 5
"""Degraded."""
global___HealthStatus = HealthStatus

@typing.final
class HealthStatusSet(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATUSES_FIELD_NUMBER: builtins.int
    @property
    def statuses(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___HealthStatus.ValueType]:
        """An order-independent set of health status."""

    def __init__(
        self,
        *,
        statuses: collections.abc.Iterable[global___HealthStatus.ValueType] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["statuses", b"statuses"]) -> None: ...

global___HealthStatusSet = HealthStatusSet

@typing.final
class HealthCheck(google.protobuf.message.Message):
    """[#next-free-field: 26]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Payload(google.protobuf.message.Message):
        """Describes the encoding of the payload bytes in the payload."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TEXT_FIELD_NUMBER: builtins.int
        BINARY_FIELD_NUMBER: builtins.int
        text: builtins.str
        """Hex encoded payload. E.g., "000000FF"."""
        binary: builtins.bytes
        """Binary payload."""
        def __init__(
            self,
            *,
            text: builtins.str = ...,
            binary: builtins.bytes = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["binary", b"binary", "payload", b"payload", "text", b"text"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["binary", b"binary", "payload", b"payload", "text", b"text"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["payload", b"payload"]) -> typing.Literal["text", "binary"] | None: ...

    @typing.final
    class HttpHealthCheck(google.protobuf.message.Message):
        """[#next-free-field: 15]"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        HOST_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        SEND_FIELD_NUMBER: builtins.int
        RECEIVE_FIELD_NUMBER: builtins.int
        RESPONSE_BUFFER_SIZE_FIELD_NUMBER: builtins.int
        REQUEST_HEADERS_TO_ADD_FIELD_NUMBER: builtins.int
        REQUEST_HEADERS_TO_REMOVE_FIELD_NUMBER: builtins.int
        EXPECTED_STATUSES_FIELD_NUMBER: builtins.int
        RETRIABLE_STATUSES_FIELD_NUMBER: builtins.int
        CODEC_CLIENT_TYPE_FIELD_NUMBER: builtins.int
        SERVICE_NAME_MATCHER_FIELD_NUMBER: builtins.int
        METHOD_FIELD_NUMBER: builtins.int
        host: builtins.str
        """The value of the host header in the HTTP health check request. If
        left empty (default value), the name of the cluster this health check is associated
        with will be used. The host header can be customized for a specific endpoint by setting the
        :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
        """
        path: builtins.str
        """Specifies the HTTP path that will be requested during health checking. For example
        ``/healthcheck``.
        """
        codec_client_type: envoy.type.v3.http_pb2.CodecClientType.ValueType
        """Use specified application protocol for health checks."""
        method: envoy.config.core.v3.base_pb2.RequestMethod.ValueType
        """HTTP Method that will be used for health checking, default is "GET".
        GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
        CONNECT method is disallowed because it is not appropriate for health check request.
        If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`.
        """
        @property
        def send(self) -> global___HealthCheck.Payload:
            """[#not-implemented-hide:] HTTP specific payload."""

        @property
        def receive(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HealthCheck.Payload]:
            """Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
            If it is set, both the expected response check and status code determine the health check.
            When checking the response, “fuzzy” matching is performed such that each payload block must be found,
            and in the order specified, but not necessarily contiguous.

            .. note::

              It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
              The default buffer size is 1024 bytes when it is not set.
            """

        @property
        def response_buffer_size(self) -> google.protobuf.wrappers_pb2.UInt64Value:
            """Specifies the size of response buffer in bytes that is used to Payload match.
            The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
            """

        @property
        def request_headers_to_add(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
            """Specifies a list of HTTP headers that should be added to each request that is sent to the
            health checked cluster. For more information, including details on header value syntax, see
            the documentation on :ref:`custom request headers
            <config_http_conn_man_headers_custom_request_headers>`.
            """

        @property
        def request_headers_to_remove(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Specifies a list of HTTP headers that should be removed from each request that is sent to the
            health checked cluster.
            """

        @property
        def expected_statuses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.type.v3.range_pb2.Int64Range]:
            """Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
            200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
            semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
            range are required. Only statuses in the range [100, 600) are allowed.
            """

        @property
        def retriable_statuses(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.type.v3.range_pb2.Int64Range]:
            """Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
            will count towards the configured :ref:`unhealthy_threshold <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`,
            but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
            :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range are required.
            Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
            field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
            be considered a successful health check. By default all responses not in
            :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>` will result in
            the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
            non-200 response will result in the host being marked unhealthy.
            """

        @property
        def service_name_matcher(self) -> envoy.type.matcher.v3.string_pb2.StringMatcher:
            """An optional service name parameter which is used to validate the identity of
            the health checked cluster using a :ref:`StringMatcher
            <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`. See the :ref:`architecture overview
            <arch_overview_health_checking_identity>` for more information.
            """

        def __init__(
            self,
            *,
            host: builtins.str = ...,
            path: builtins.str = ...,
            send: global___HealthCheck.Payload | None = ...,
            receive: collections.abc.Iterable[global___HealthCheck.Payload] | None = ...,
            response_buffer_size: google.protobuf.wrappers_pb2.UInt64Value | None = ...,
            request_headers_to_add: collections.abc.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption] | None = ...,
            request_headers_to_remove: collections.abc.Iterable[builtins.str] | None = ...,
            expected_statuses: collections.abc.Iterable[envoy.type.v3.range_pb2.Int64Range] | None = ...,
            retriable_statuses: collections.abc.Iterable[envoy.type.v3.range_pb2.Int64Range] | None = ...,
            codec_client_type: envoy.type.v3.http_pb2.CodecClientType.ValueType = ...,
            service_name_matcher: envoy.type.matcher.v3.string_pb2.StringMatcher | None = ...,
            method: envoy.config.core.v3.base_pb2.RequestMethod.ValueType = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["response_buffer_size", b"response_buffer_size", "send", b"send", "service_name_matcher", b"service_name_matcher"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["codec_client_type", b"codec_client_type", "expected_statuses", b"expected_statuses", "host", b"host", "method", b"method", "path", b"path", "receive", b"receive", "request_headers_to_add", b"request_headers_to_add", "request_headers_to_remove", b"request_headers_to_remove", "response_buffer_size", b"response_buffer_size", "retriable_statuses", b"retriable_statuses", "send", b"send", "service_name_matcher", b"service_name_matcher"]) -> None: ...

    @typing.final
    class TcpHealthCheck(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SEND_FIELD_NUMBER: builtins.int
        RECEIVE_FIELD_NUMBER: builtins.int
        @property
        def send(self) -> global___HealthCheck.Payload:
            """Empty payloads imply a connect-only health check."""

        @property
        def receive(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HealthCheck.Payload]:
            """When checking the response, “fuzzy” matching is performed such that each
            payload block must be found, and in the order specified, but not
            necessarily contiguous.
            """

        def __init__(
            self,
            *,
            send: global___HealthCheck.Payload | None = ...,
            receive: collections.abc.Iterable[global___HealthCheck.Payload] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["send", b"send"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["receive", b"receive", "send", b"send"]) -> None: ...

    @typing.final
    class RedisHealthCheck(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        key: builtins.str
        """If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
        from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
        than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
        by setting the specified key to any value and waiting for traffic to drain.
        """
        def __init__(
            self,
            *,
            key: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

    @typing.final
    class GrpcHealthCheck(google.protobuf.message.Message):
        """`grpc.health.v1.Health
        <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
        healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
        for details.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SERVICE_NAME_FIELD_NUMBER: builtins.int
        AUTHORITY_FIELD_NUMBER: builtins.int
        INITIAL_METADATA_FIELD_NUMBER: builtins.int
        service_name: builtins.str
        """An optional service name parameter which will be sent to gRPC service in
        `grpc.health.v1.HealthCheckRequest
        <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
        message. See `gRPC health-checking overview
        <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
        """
        authority: builtins.str
        """The value of the :authority header in the gRPC health check request. If
        left empty (default value), the name of the cluster this health check is associated
        with will be used. The authority header can be customized for a specific endpoint by setting
        the :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
        """
        @property
        def initial_metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[envoy.config.core.v3.base_pb2.HeaderValueOption]:
            """Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
            that is sent to the health checked cluster. For more information, including details on header value syntax,
            see the documentation on :ref:`custom request headers
            <config_http_conn_man_headers_custom_request_headers>`.
            """

        def __init__(
            self,
            *,
            service_name: builtins.str = ...,
            authority: builtins.str = ...,
            initial_metadata: collections.abc.Iterable[envoy.config.core.v3.base_pb2.HeaderValueOption] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["authority", b"authority", "initial_metadata", b"initial_metadata", "service_name", b"service_name"]) -> None: ...

    @typing.final
    class CustomHealthCheck(google.protobuf.message.Message):
        """Custom health check."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        TYPED_CONFIG_FIELD_NUMBER: builtins.int
        name: builtins.str
        """The registered name of the custom health checker."""
        @property
        def typed_config(self) -> google.protobuf.any_pb2.Any: ...
        def __init__(
            self,
            *,
            name: builtins.str = ...,
            typed_config: google.protobuf.any_pb2.Any | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["config_type", b"config_type", "typed_config", b"typed_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["config_type", b"config_type", "name", b"name", "typed_config", b"typed_config"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["config_type", b"config_type"]) -> typing.Literal["typed_config"] | None: ...

    @typing.final
    class TlsOptions(google.protobuf.message.Message):
        """Health checks occur over the transport socket specified for the cluster. This implies that if a
        cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.

        This allows overriding the cluster TLS settings, just for health check connections.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ALPN_PROTOCOLS_FIELD_NUMBER: builtins.int
        @property
        def alpn_protocols(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
            """Specifies the ALPN protocols for health check connections. This is useful if the
            corresponding upstream is using ALPN-based :ref:`FilterChainMatch
            <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` along with different protocols for health checks
            versus data connections. If empty, no ALPN protocols will be set on health check connections.
            """

        def __init__(
            self,
            *,
            alpn_protocols: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["alpn_protocols", b"alpn_protocols"]) -> None: ...

    TIMEOUT_FIELD_NUMBER: builtins.int
    INTERVAL_FIELD_NUMBER: builtins.int
    INITIAL_JITTER_FIELD_NUMBER: builtins.int
    INTERVAL_JITTER_FIELD_NUMBER: builtins.int
    INTERVAL_JITTER_PERCENT_FIELD_NUMBER: builtins.int
    UNHEALTHY_THRESHOLD_FIELD_NUMBER: builtins.int
    HEALTHY_THRESHOLD_FIELD_NUMBER: builtins.int
    ALT_PORT_FIELD_NUMBER: builtins.int
    REUSE_CONNECTION_FIELD_NUMBER: builtins.int
    HTTP_HEALTH_CHECK_FIELD_NUMBER: builtins.int
    TCP_HEALTH_CHECK_FIELD_NUMBER: builtins.int
    GRPC_HEALTH_CHECK_FIELD_NUMBER: builtins.int
    CUSTOM_HEALTH_CHECK_FIELD_NUMBER: builtins.int
    NO_TRAFFIC_INTERVAL_FIELD_NUMBER: builtins.int
    NO_TRAFFIC_HEALTHY_INTERVAL_FIELD_NUMBER: builtins.int
    UNHEALTHY_INTERVAL_FIELD_NUMBER: builtins.int
    UNHEALTHY_EDGE_INTERVAL_FIELD_NUMBER: builtins.int
    HEALTHY_EDGE_INTERVAL_FIELD_NUMBER: builtins.int
    EVENT_LOG_PATH_FIELD_NUMBER: builtins.int
    EVENT_SERVICE_FIELD_NUMBER: builtins.int
    ALWAYS_LOG_HEALTH_CHECK_FAILURES_FIELD_NUMBER: builtins.int
    TLS_OPTIONS_FIELD_NUMBER: builtins.int
    TRANSPORT_SOCKET_MATCH_CRITERIA_FIELD_NUMBER: builtins.int
    DISABLE_HEALTH_CHECK_IF_ACTIVE_TRAFFIC_FIELD_NUMBER: builtins.int
    interval_jitter_percent: builtins.int
    """An optional jitter amount as a percentage of interval_ms. If specified,
    during every interval Envoy will add ``interval_ms`` *
    ``interval_jitter_percent`` / 100 to the wait time.

    If interval_jitter_ms and interval_jitter_percent are both set, both of
    them will be used to increase the wait time.
    """
    event_log_path: builtins.str
    """Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
    If empty, no event log will be written.
    """
    always_log_health_check_failures: builtins.bool
    """If set to true, health check failure events will always be logged. If set to false, only the
    initial health check failure event will be logged.
    The default value is false.
    """
    disable_health_check_if_active_traffic: builtins.bool
    """When the health status of a host is healthy, if this field is enabled, when envoy wants to send an active health check packet to a target host, it will first check whether
    there was successful non-health check traffic that targeted the host during the previous interval. If there was successful non-health check traffic, Envoy will not send a health check packet.
    For HTTP, if the traffic response is 2xx, it will be considered as successful traffic.
    For TCP, if any TCP connections successfully connect, it will be considered as successful traffic.
    For gRPC, if grpc_status is not one of ( DeadlineExceeded, Unimplemented, Internal, Unavailable, Unknown, DataLoss), it will be considered as successful traffic. Refer to UpstreamEndpointStats.
    For Custom health check, this option can not be used.
    The default value is false.
    """
    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """The time to wait for a health check response. If the timeout is reached the
        health check attempt will be considered a failure.
        """

    @property
    def interval(self) -> google.protobuf.duration_pb2.Duration:
        """The interval between health checks."""

    @property
    def initial_jitter(self) -> google.protobuf.duration_pb2.Duration:
        """An optional jitter amount in milliseconds. If specified, Envoy will start health
        checking after for a random time in ms between 0 and initial_jitter. This only
        applies to the first health check.
        """

    @property
    def interval_jitter(self) -> google.protobuf.duration_pb2.Duration:
        """An optional jitter amount in milliseconds. If specified, during every
        interval Envoy will add interval_jitter to the wait time.
        """

    @property
    def unhealthy_threshold(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The number of unhealthy health checks required before a host is marked
        unhealthy. Note that for ``http`` health checking if a host responds with a code not in
        :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
        or :ref:`retriable_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
        this threshold is ignored and the host is considered immediately unhealthy.
        """

    @property
    def healthy_threshold(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The number of healthy health checks required before a host is marked
        healthy. Note that during startup, only a single successful health check is
        required to mark a host healthy.
        """

    @property
    def alt_port(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """[#not-implemented-hide:] Non-serving port for health checking."""

    @property
    def reuse_connection(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Reuse health check connection between health checks. Default is true."""

    @property
    def http_health_check(self) -> global___HealthCheck.HttpHealthCheck:
        """HTTP health check."""

    @property
    def tcp_health_check(self) -> global___HealthCheck.TcpHealthCheck:
        """TCP health check."""

    @property
    def grpc_health_check(self) -> global___HealthCheck.GrpcHealthCheck:
        """gRPC health check."""

    @property
    def custom_health_check(self) -> global___HealthCheck.CustomHealthCheck:
        """Custom health check."""

    @property
    def no_traffic_interval(self) -> google.protobuf.duration_pb2.Duration:
        """The "no traffic interval" is a special health check interval that is used when a cluster has
        never had traffic routed to it. This lower interval allows cluster information to be kept up to
        date, without sending a potentially large amount of active health checking traffic for no
        reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
        standard health check interval that is defined. Note that this interval takes precedence over
        any other.

        The default value for "no traffic interval" is 60 seconds.
        """

    @property
    def no_traffic_healthy_interval(self) -> google.protobuf.duration_pb2.Duration:
        """The "no traffic healthy interval" is a special health check interval that
        is used for hosts that are currently passing active health checking
        (including new hosts) when the cluster has received no traffic.

        This is useful for when we want to send frequent health checks with
        ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
        a host in the cluster is marked as healthy.

        Once a cluster has been used for traffic routing, Envoy will shift back to using the
        standard health check interval that is defined.

        If no_traffic_healthy_interval is not set, it will default to the
        no traffic interval and send that interval regardless of health state.
        """

    @property
    def unhealthy_interval(self) -> google.protobuf.duration_pb2.Duration:
        """The "unhealthy interval" is a health check interval that is used for hosts that are marked as
        unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
        standard health check interval that is defined.

        The default value for "unhealthy interval" is the same as "interval".
        """

    @property
    def unhealthy_edge_interval(self) -> google.protobuf.duration_pb2.Duration:
        """The "unhealthy edge interval" is a special health check interval that is used for the first
        health check right after a host is marked as unhealthy. For subsequent health checks
        Envoy will shift back to using either "unhealthy interval" if present or the standard health
        check interval that is defined.

        The default value for "unhealthy edge interval" is the same as "unhealthy interval".
        """

    @property
    def healthy_edge_interval(self) -> google.protobuf.duration_pb2.Duration:
        """The "healthy edge interval" is a special health check interval that is used for the first
        health check right after a host is marked as healthy. For subsequent health checks
        Envoy will shift back to using the standard health check interval that is defined.

        The default value for "healthy edge interval" is the same as the default interval.
        """

    @property
    def event_service(self) -> envoy.config.core.v3.event_service_config_pb2.EventServiceConfig:
        """[#not-implemented-hide:]
        The gRPC service for the health check event service.
        If empty, health check events won't be sent to a remote endpoint.
        """

    @property
    def tls_options(self) -> global___HealthCheck.TlsOptions:
        """This allows overriding the cluster TLS settings, just for health check connections."""

    @property
    def transport_socket_match_criteria(self) -> google.protobuf.struct_pb2.Struct:
        """Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
        :ref:`tranport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
        For example, the following match criteria

        .. code-block:: yaml

         transport_socket_match_criteria:
           useMTLS: true

        Will match the following :ref:`cluster socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`

        .. code-block:: yaml

         transport_socket_matches:
         - name: "useMTLS"
           match:
             useMTLS: true
           transport_socket:
             name: envoy.transport_sockets.tls
             config: { ... } # tls socket configuration

        If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
        :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
        This allows using different transport socket capabilities for health checking versus proxying to the
        endpoint.

        If the key/values pairs specified do not match any
        :ref:`transport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`,
        the cluster's :ref:`transport socket <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`
        will be used for health check socket configuration.
        """

    def __init__(
        self,
        *,
        timeout: google.protobuf.duration_pb2.Duration | None = ...,
        interval: google.protobuf.duration_pb2.Duration | None = ...,
        initial_jitter: google.protobuf.duration_pb2.Duration | None = ...,
        interval_jitter: google.protobuf.duration_pb2.Duration | None = ...,
        interval_jitter_percent: builtins.int = ...,
        unhealthy_threshold: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        healthy_threshold: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        alt_port: google.protobuf.wrappers_pb2.UInt32Value | None = ...,
        reuse_connection: google.protobuf.wrappers_pb2.BoolValue | None = ...,
        http_health_check: global___HealthCheck.HttpHealthCheck | None = ...,
        tcp_health_check: global___HealthCheck.TcpHealthCheck | None = ...,
        grpc_health_check: global___HealthCheck.GrpcHealthCheck | None = ...,
        custom_health_check: global___HealthCheck.CustomHealthCheck | None = ...,
        no_traffic_interval: google.protobuf.duration_pb2.Duration | None = ...,
        no_traffic_healthy_interval: google.protobuf.duration_pb2.Duration | None = ...,
        unhealthy_interval: google.protobuf.duration_pb2.Duration | None = ...,
        unhealthy_edge_interval: google.protobuf.duration_pb2.Duration | None = ...,
        healthy_edge_interval: google.protobuf.duration_pb2.Duration | None = ...,
        event_log_path: builtins.str = ...,
        event_service: envoy.config.core.v3.event_service_config_pb2.EventServiceConfig | None = ...,
        always_log_health_check_failures: builtins.bool = ...,
        tls_options: global___HealthCheck.TlsOptions | None = ...,
        transport_socket_match_criteria: google.protobuf.struct_pb2.Struct | None = ...,
        disable_health_check_if_active_traffic: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["alt_port", b"alt_port", "custom_health_check", b"custom_health_check", "event_service", b"event_service", "grpc_health_check", b"grpc_health_check", "health_checker", b"health_checker", "healthy_edge_interval", b"healthy_edge_interval", "healthy_threshold", b"healthy_threshold", "http_health_check", b"http_health_check", "initial_jitter", b"initial_jitter", "interval", b"interval", "interval_jitter", b"interval_jitter", "no_traffic_healthy_interval", b"no_traffic_healthy_interval", "no_traffic_interval", b"no_traffic_interval", "reuse_connection", b"reuse_connection", "tcp_health_check", b"tcp_health_check", "timeout", b"timeout", "tls_options", b"tls_options", "transport_socket_match_criteria", b"transport_socket_match_criteria", "unhealthy_edge_interval", b"unhealthy_edge_interval", "unhealthy_interval", b"unhealthy_interval", "unhealthy_threshold", b"unhealthy_threshold"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["alt_port", b"alt_port", "always_log_health_check_failures", b"always_log_health_check_failures", "custom_health_check", b"custom_health_check", "disable_health_check_if_active_traffic", b"disable_health_check_if_active_traffic", "event_log_path", b"event_log_path", "event_service", b"event_service", "grpc_health_check", b"grpc_health_check", "health_checker", b"health_checker", "healthy_edge_interval", b"healthy_edge_interval", "healthy_threshold", b"healthy_threshold", "http_health_check", b"http_health_check", "initial_jitter", b"initial_jitter", "interval", b"interval", "interval_jitter", b"interval_jitter", "interval_jitter_percent", b"interval_jitter_percent", "no_traffic_healthy_interval", b"no_traffic_healthy_interval", "no_traffic_interval", b"no_traffic_interval", "reuse_connection", b"reuse_connection", "tcp_health_check", b"tcp_health_check", "timeout", b"timeout", "tls_options", b"tls_options", "transport_socket_match_criteria", b"transport_socket_match_criteria", "unhealthy_edge_interval", b"unhealthy_edge_interval", "unhealthy_interval", b"unhealthy_interval", "unhealthy_threshold", b"unhealthy_threshold"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["health_checker", b"health_checker"]) -> typing.Literal["http_health_check", "tcp_health_check", "grpc_health_check", "custom_health_check"] | None: ...

global___HealthCheck = HealthCheck
