"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import envoy.type.matcher.v3.value_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class MetadataMatcher(google.protobuf.message.Message):
    """MetadataMatcher provides a general interface to check if a given value is matched in
    :ref:`Metadata <envoy_v3_api_msg_config.core.v3.Metadata>`. It uses `filter` and `path` to retrieve the value
    from the Metadata and then check if it's matched to the specified value.

    For example, for the following Metadata:

    .. code-block:: yaml

       filter_metadata:
         envoy.filters.http.rbac:
           fields:
             a:
               struct_value:
                 fields:
                   b:
                     struct_value:
                       fields:
                         c:
                           string_value: pro
                   t:
                     list_value:
                       values:
                         - string_value: m
                         - string_value: n

    The following MetadataMatcher is matched as the path [a, b, c] will retrieve a string value "pro"
    from the Metadata which is matched to the specified prefix match.

    .. code-block:: yaml

       filter: envoy.filters.http.rbac
       path:
       - key: a
       - key: b
       - key: c
       value:
         string_match:
           prefix: pr

    The following MetadataMatcher is matched as the code will match one of the string values in the
    list at the path [a, t].

    .. code-block:: yaml

       filter: envoy.filters.http.rbac
       path:
       - key: a
       - key: t
       value:
         list_match:
           one_of:
             string_match:
               exact: m

    An example use of MetadataMatcher is specifying additional metadata in envoy.filters.http.rbac to
    enforce access control based on dynamic metadata in a request. See :ref:`Permission
    <envoy_v3_api_msg_config.rbac.v3.Permission>` and :ref:`Principal
    <envoy_v3_api_msg_config.rbac.v3.Principal>`.

    [#next-major-version: MetadataMatcher should use StructMatcher]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class PathSegment(google.protobuf.message.Message):
        """Specifies the segment in a path to retrieve value from Metadata.
        Note: Currently it's not supported to retrieve a value from a list in Metadata. This means that
        if the segment key refers to a list, it has to be the last segment in a path.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        key: builtins.str
        """If specified, use the key to retrieve the value in a Struct."""
        def __init__(
            self,
            *,
            key: builtins.str = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["key", b"key", "segment", b"segment"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "segment", b"segment"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["segment", b"segment"]) -> typing.Literal["key"] | None: ...

    FILTER_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    INVERT_FIELD_NUMBER: builtins.int
    filter: builtins.str
    """The filter name to retrieve the Struct from the Metadata."""
    invert: builtins.bool
    """If true, the match result will be inverted."""
    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetadataMatcher.PathSegment]:
        """The path to retrieve the Value from the Struct."""

    @property
    def value(self) -> envoy.type.matcher.v3.value_pb2.ValueMatcher:
        """The MetadataMatcher is matched if the value retrieved by path is matched to this value."""

    def __init__(
        self,
        *,
        filter: builtins.str = ...,
        path: collections.abc.Iterable[global___MetadataMatcher.PathSegment] | None = ...,
        value: envoy.type.matcher.v3.value_pb2.ValueMatcher | None = ...,
        invert: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "invert", b"invert", "path", b"path", "value", b"value"]) -> None: ...

global___MetadataMatcher = MetadataMatcher
