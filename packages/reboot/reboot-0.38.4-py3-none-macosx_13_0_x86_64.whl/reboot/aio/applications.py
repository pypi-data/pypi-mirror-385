import asyncio
import colorama
import os
import rebootdev.aio.memoize
import rebootdev.aio.workflows
import sys
import traceback
from log.log import get_logger
from pathlib import Path
from reboot.aio.http import NodeWebFramework, PythonWebFramework, WebFramework
from reboot.aio.reboot import Reboot
from reboot.aio.servers import Server
from reboot.cli import terminal
from reboot.controller.consensus_managers import run_nodejs_consensus_process
from reboot.controller.settings import USER_CONTAINER_GRPC_PORT
from rebootdev.aio.auth.token_verifiers import TokenVerifier
from rebootdev.aio.exceptions import InputError
from rebootdev.aio.external import InitializeContext
from rebootdev.aio.internals.channel_manager import _ChannelManager
from rebootdev.aio.servicers import Serviceable, Servicer
from rebootdev.aio.tracing import function_span
from rebootdev.aio.types import ConsensusId
from rebootdev.consensus.service_descriptor_validator import (
    ProtoValidationError,
)
from rebootdev.nodejs.python import should_print_stacktrace
from rebootdev.run_environments import (
    InvalidRunEnvironment,
    RunEnvironment,
    detect_run_environment,
    within_nodejs_consensus,
)
from rebootdev.settings import (
    DEFAULT_SECURE_PORT,
    ENVVAR_RBT_NAME,
    ENVVAR_RBT_PARTITIONS,
    ENVVAR_RBT_STATE_DIRECTORY,
    ENVVAR_REBOOT_LOCAL_ENVOY,
    ENVVAR_REBOOT_LOCAL_ENVOY_PORT,
    RBT_APPLICATION_EXIT_CODE_BACKWARDS_INCOMPATIBILITY,
)
from typing import Awaitable, Callable, NoReturn, Optional

logger = get_logger(__name__)


def _handle_unknown_exception(
    exception: Exception,
    stack_trace: Optional[str] = None,
) -> None:
    """Pretty print stack trace and error message for an unknown exception. This
    includes informing the user how to best get in touch with us.
    """
    if should_print_stacktrace():
        if stack_trace is None:
            stack_trace = ''.join(traceback.format_exception(exception))

        # Emulate `traceback.print_exc()` by printing the
        # error to `sys.stderr`.
        print(stack_trace, file=sys.stderr)

    terminal.error(
        f'Caught unexpected `{type(exception).__name__}`: {exception}\n'
        '\n',
    )

    terminal.warn(
        'Please report this error, including any stack trace above, \n'
        'to the kind folks at Reboot - they\'ll be happy to help you out!\n'
        'You can get in touch via Discord: https://discord.gg/cRbdcS94Nr\n'
        '\n'
    )


def _handle_input_error(input_error: InputError) -> None:
    """Handle an input error."""
    # Special cases of rendering of InputError.
    if isinstance(input_error, ProtoValidationError):
        terminal.error(input_error.reason)
        for validation_error in input_error.validation_errors:
            # We indent the validation errors to make them easier to read; make
            # sure that also works when there are newlines.
            validation_error = validation_error.replace('\n', '\n  ')
            terminal.error(f'- {validation_error}')
        terminal.error('\n')
        return

    terminal.error(f'Caught `{type(input_error).__name__}`: {input_error}\n')


# Need to set `reboodev.aio.workflows.memoize` at run
# time. This unfortunately is necessary to break a circular
# dependency between generated code and functions in
# `workflows.py` which need to call `memoize` which also
# depends on generated code!
assert rebootdev.aio.workflows.memoize is None
assert rebootdev.aio.memoize.memoize is not None
rebootdev.aio.workflows.memoize = rebootdev.aio.memoize.memoize


class Application:
    """Entry point for all Reboot applications."""

    def __init__(
        self,
        *,
        servicers: Optional[list[type[Servicer]]] = None,
        # A legacy gRPC servicer type can't be more specific than `type`,
        # because legacy gRPC servicers (as generated by the gRPC `protoc`
        # plugin) do not share any common base class other than `object`.
        legacy_grpc_servicers: Optional[list[type]] = None,
        initialize: Optional[Callable[[InitializeContext],
                                      Awaitable[None]]] = None,
        initialize_bearer_token: Optional[str] = None,
        token_verifier: Optional[TokenVerifier] = None,
    ):
        """
        :param servicers: the types of Reboot-powered servicers that this
                          Application will serve.
        :param legacy_grpc_servicers: the types of legacy gRPC servicers (not
                                      using Reboot libraries) that this
                                      Application will serve.

        :param initialize: will be called after the Application's servicers have
                       started for the first time, so that it can perform
                       initialization logic (e.g., creating some well-known
                       actors, loading some data, etc. It must do so in the
                       context of the given InitializeContext.

        :param initialize_bearer_token: a Bearer token that will be used to construct
            the `InitializeContext` passed to `initialize`. If none is provided,
            the `InitializeContext` will be constructed without a Bearer token,
            and have app-internal privileges instead.

        :param token_verifier: a TokenVerifier that will be used to verify
            authorization bearer tokens passed to the application.

        TODO(benh): update the initialize function to be run in a transaction
        and ensure that the transaction has finished before serving any other
        calls on the servicers.
        """
        if servicers is not None and len(servicers) == 0:
            raise ValueError("'servicers' can't be an empty list")

        # Runtime type checks, in case the type annotation didn't get checked
        # statically.
        for servicer in servicers or []:
            if not isinstance(servicer, type):
                raise ValueError(
                    "The `servicers` parameter contains a "
                    f"'{type(servicer).__name__}' object, but was expecting "
                    f"only classes. Try passing `{type(servicer).__name__}` "
                    f"instead of `{type(servicer).__name__}(...)`"
                )
            if not issubclass(servicer, Servicer):
                raise ValueError(
                    "The `servicers` parameter contains "
                    f"'{servicer.__name__}', which is not a Reboot servicer. "
                    "If it is a legacy gRPC servicer it should be passed in "
                    "via the `legacy_grpc_servicers` parameter instead"
                )
        for servicer in legacy_grpc_servicers or []:
            if not isinstance(servicer, type):
                raise ValueError(
                    "The `legacy_grpc_servicers` parameter contains a "
                    f"'{type(servicer).__name__}' object, but was expecting "
                    f"only classes. Try passing `{type(servicer).__name__}` "
                    f"instead of `{type(servicer).__name__}(...)`"
                )
            if issubclass(servicer, Servicer):
                raise ValueError(
                    "The `legacy_grpc_servicers` parameter contains "
                    f"'{servicer.__name__}', which is a Reboot servicer, not "
                    "a legacy gRPC servicer. It should be passed in via the "
                    "`servicers` parameter instead"
                )

        # Deduplicate the servicers and legacy gRPC servicers. In the context of
        # a complex set of servicers-depending-on-servicers it's not reasonable
        # to expect the user to deduplicate the list themselves.
        self._servicers = list(
            set(servicers)
        ) if servicers is not None else None
        del servicers  # To avoid accidental use of the original list.
        self._legacy_grpc_servicers = list(
            set(legacy_grpc_servicers)
        ) if legacy_grpc_servicers is not None else None
        del legacy_grpc_servicers  # To avoid accidental use of the original list.
        self._initialize = initialize
        self._token_verifier = token_verifier
        self._initialize_bearer_token = initialize_bearer_token

        # NOTE: we override with `NodeWebFramework` in `NodeApplication`.
        self._web_framework: WebFramework = PythonWebFramework()

        self._rbt: Optional[Reboot] = None

        self._directory: Optional[Path] = None

        self._run_environment: Optional[RunEnvironment] = None

        try:
            self._run_environment = detect_run_environment()
        except InvalidRunEnvironment:
            # Bail out.
            #
            # We might be running tests, in which case the test will
            # manually call `Reboot.up` to create a cluster.
            #
            # If this is being run without `rbt dev` or `rbt serve`
            # the user will be given a helpful error message at
            # run-time and the application will exit with a non-0 exit
            # code without a distracting stack trace.
            return

        if self._run_environment not in [
            RunEnvironment.RBT_DEV,
            RunEnvironment.RBT_SERVE,
        ] or within_nodejs_consensus():
            # Only when running as part of `rbt dev` or `rbt serve` do
            # we need to bring up a Reboot cluster.
            #
            # We also don't need to bring up a Reboot cluster when
            # running a Node.js consensus because it is already being
            # created.
            return

        self._name: Optional[str] = os.environ.get(ENVVAR_RBT_NAME)

        state_directory: Optional[str] = os.environ.get(
            ENVVAR_RBT_STATE_DIRECTORY
        )
        self._state_directory = (
            None if state_directory is None else Path(state_directory)
        )

        if self._name is not None:
            assert self._state_directory is not None

        # NOTE: we construct a 'Reboot' instance here so that it can
        # perform any process wide initialization as early as possible
        # (e.g., initializing multiprocessing before any threads are
        # created)
        if self._state_directory is not None:
            os.makedirs(self._state_directory, exist_ok=True)

        self._rbt = Reboot(
            application_name=self._name,
            state_directory=self._state_directory,
            # Don't initialize tracing for the 'Reboot' instance, if
            # we're starting a consensus.
            # A separate tracing context for that process will be started in the
            # 'consensus_managers.py'.
            initialize_tracing=not within_nodejs_consensus(),
        )

    @property
    def servicers(self):
        # Always include `memoize` servicers.
        return (self._servicers or []) + rebootdev.aio.memoize.servicers()

    @property
    def legacy_grpc_servicers(self):
        return self._legacy_grpc_servicers or []

    @property
    def token_verifier(self):
        return self._token_verifier

    @property
    def initialize(
        self,
    ) -> Optional[Callable[[InitializeContext], Awaitable[None]]]:
        return self._initialize

    @property
    def web_framework(self) -> WebFramework:
        return self._web_framework

    @property
    def http(self) -> PythonWebFramework.HTTP:
        # This should only get called by Python applications, and thus
        # we should have constructed the web framework.
        assert isinstance(self._web_framework, PythonWebFramework)
        return self._web_framework.http

    def has_http_routes_or_mounts(self) -> bool:
        return len(self.http._api_routes) > 0 or len(self.http._mounts) > 0

    @function_span()
    async def _rbt_start_and_up_and_initialize(self) -> None:
        assert self._rbt is not None
        assert self._run_environment is not None

        await self._rbt.start()

        local_envoy: bool = os.environ.get(
            ENVVAR_REBOOT_LOCAL_ENVOY,
            'false',
        ).lower() == 'true'

        local_envoy_port: int = int(
            os.environ.get(
                ENVVAR_REBOOT_LOCAL_ENVOY_PORT, str(DEFAULT_SECURE_PORT)
            )
        )

        partitions = os.environ.get(ENVVAR_RBT_PARTITIONS, None)

        assert partitions is not None, (
            'Expecting partitions from `rbt dev` or `rbt serve`'
        )

        await self._rbt.up(
            servicers=self.servicers,
            legacy_grpc_servicers=self.legacy_grpc_servicers,
            web_framework=self.web_framework,
            token_verifier=self.token_verifier,
            initialize=self._initialize,
            initialize_bearer_token=self._initialize_bearer_token,
            local_envoy=local_envoy,
            local_envoy_port=local_envoy_port,
            partitions=int(partitions),
        )

    async def _run_locally(self) -> NoReturn:
        """Runs the application and returns a status code indicating success
        or failure."""
        try:
            await self._rbt_start_and_up_and_initialize()
        except InputError as e:
            _handle_input_error(e)
            if isinstance(e, ProtoValidationError):
                sys.exit(RBT_APPLICATION_EXIT_CODE_BACKWARDS_INCOMPATIBILITY)
        except Exception as e:
            _handle_unknown_exception(e)
        else:
            # Wait forever unless we get cancelled!
            #
            # TODO(benh): have 'rbt.up()' return a tuple of (revision,
            # future) so we can watch the future and if that ever
            # fails we should exit and return an error to the user.
            #
            # TODO(benh): also have 'rbt.up()' fail the future that it
            # returns to us if the local envoy that got started
            # happened to fail.
            forever = asyncio.Event()
            await forever.wait()
        finally:
            assert self._rbt is not None
            await self._rbt.stop()

        sys.exit(1)

    async def _run_kubernetes(self) -> NoReturn:
        """Runs a single consensus in a Kubernetes-appropriate way.

        Blocks until cancelled, then returns a status code indicating success
        or failure.
        """

        try:
            server = Server.create_on_k8s(
                serviceables=self._get_serviceables(),
                web_framework=self._web_framework,
                listen_address=f'0.0.0.0:{USER_CONTAINER_GRPC_PORT}',
                initialize=self._initialize,
                initialize_bearer_token=self._initialize_bearer_token,
                token_verifier=self._token_verifier,
            )
            server_run_task = asyncio.create_task(
                server.run(),
                name=f'server.run() in {__name__}',
            )
        except InputError as e:
            _handle_input_error(e)
            sys.exit(1)
        except Exception as e:
            logger.error(f"Unexpected error while starting: {e}")
            # An unexpected error, by definition, is something that we didn't
            # see coming. It may have been caused by the user's code. Help them
            # (and us, if they file a bug report) debug it by printing the stack
            # trace.
            logger.error("Stack trace:", exc_info=True)
            sys.exit(1)

        # Wait forever, or at least until the server gets shut down.
        await server_run_task

        sys.exit(0)

    def _get_serviceables(self) -> list[Serviceable]:
        """Helper for converting servicers and legacy gRPC servicers into
        serviceables.
        """
        serviceables: list[Serviceable] = []

        for servicer in self.servicers:
            serviceables.append(Serviceable.from_servicer_type(servicer))

        for legacy_grpc_servicer in self.legacy_grpc_servicers:
            serviceables.append(
                Serviceable.from_servicer_type(legacy_grpc_servicer)
            )

        if len(serviceables) == 0:
            raise ValueError("No servicers were provided to the Application")

        return serviceables

    async def run(self) -> NoReturn:
        """Runs the application, and does not return unless the application fails.

        Does 'sys.exit' in case of failure.
        """

        colorama.init()

        if self._run_environment is None:
            # We can't detect the run environment. Assume that the user is trying to
            # run the application locally, but doing it in a way we don't support.
            # Give a helpful error message pointing them to `rbt dev|serve run`.
            terminal.error(
                "Please use 'rbt dev run' or 'rbt serve run' to run your "
                "application locally",
            )
            sys.exit(1)
        elif self._run_environment in [
            RunEnvironment.RBT_DEV,
            RunEnvironment.RBT_SERVE,
        ]:
            await self._run_locally()
        else:
            await self._run_kubernetes()


class NodeApplication(Application):
    """Entry point for all Node.js based Reboot applications."""

    def __init__(
        self,
        *,
        servicers: Optional[list[type[Servicer]]] = None,
        web_framework_start: Callable[
            [ConsensusId, Optional[int], _ChannelManager],
            Awaitable[int],
        ],
        web_framework_stop: Callable[[ConsensusId], Awaitable[None]],
        initialize: Optional[Callable[[InitializeContext],
                                      Awaitable[None]]] = None,
        initialize_bearer_token: Optional[str] = None,
        token_verifier: Optional[TokenVerifier] = None,
    ):
        super().__init__(
            servicers=servicers,
            initialize=initialize,
            initialize_bearer_token=initialize_bearer_token,
            token_verifier=token_verifier,
        )

        self._web_framework = NodeWebFramework(
            start=web_framework_start,
            stop=web_framework_stop,
        )

    @property
    def http(self) -> NoReturn:
        raise RuntimeError(
            "`.http` property should not be accessed for a Node.js application"
        )

    async def run(self) -> NoReturn:
        if not within_nodejs_consensus():
            await super().run()

        colorama.init()

        try:
            await run_nodejs_consensus_process(
                serviceables=self._get_serviceables(),
                web_framework=self._web_framework,
                token_verifier=self._token_verifier,
            )
        except Exception as e:
            logger.error(f"Unexpected error while starting: {e}")
            # An unexpected error, by definition, is something that we didn't
            # see coming. It may have been caused by the user's code. Help them
            # (and us, if they file a bug report) debug it by printing the stack
            # trace.
            logger.error("Stack trace:", exc_info=True)
            sys.exit(1)

        sys.exit(0)
