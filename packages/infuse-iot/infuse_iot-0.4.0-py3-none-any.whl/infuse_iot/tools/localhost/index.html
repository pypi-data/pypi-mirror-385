<!DOCTYPE html>
<html lang="en">
<!-- Don't request favicon.ico -->
<link rel="icon" href="data:,">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDF Viewer</title>
    <link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
</head>
<style>
    .tabulator {
        font-family: monospace;
    }

    #tdf-show {
        vertical-align: top;
    }

    #app-show {
        vertical-align: top;
    }
</style>

<body>
    <h1>Infuse-IoT TDF Viewer</h1>
    <p>
    <div id="data-table"></div>
    </p>
    <p>
    <h2>Table Control</h2>
    <span id="tdf-show"></span>
    <span id="app-show"></span>
    <br>
    <input type="checkbox" id="update_pause" name="update_pause" value="pause">
    <label for="update_pause"> Pause table updating</label>
    </p>

    <script>
        let filtering_update = false;
        // Initialize the Tabulator table
        const dataTable = new Tabulator("#data-table", {
            layout: "fitDataTable",
            pagination:"local",
            paginationSize:25,
            paginationSizeSelector:[10, 25, 50, 100],
            paginationCounter:"rows",
        });
        const shownTdfTable = new Tabulator("#tdf-show", {
            layout: "fitDataTable",
            columns: [
                { title: "TDF", field: "name", width: 200 },
                {
                    title: "Show",
                    field: "checked",
                    hozAlign: "center",
                    formatter: "tickCross",
                    cellClick: function (ev, cell) {
                        filtering_update = true;
                        cell.setValue(!cell.getValue());
                    },
                },
            ]
        });
        const shownAppTable = new Tabulator("#app-show", {
            layout: "fitDataTable",
            columns: [
                { title: "Application", field: "name", width: 200 },
                {
                    title: "Show",
                    field: "checked",
                    hozAlign: "center",
                    formatter: "tickCross",
                    cellClick: function (ev, cell) {
                        filtering_update = true;
                        cell.setValue(!cell.getValue());
                    },
                },
            ]
        });

        // Connect to the WebSocket server
        const ws = new WebSocket("ws://localhost:" + location.port + "/ws");
        let shownTDFs = {};
        let currentTDFs = [];
        let current_num_columns = 0;
        let currentApps = [];

        const arraysEqual = (a, b) =>
            a.length === b.length &&
            a.every((element, index) => element === b[index]);

        ws.onmessage = function (event) {
            const { columns, rows, tdfs } = JSON.parse(event.data);

            if (!arraysEqual(currentTDFs, tdfs)) {
                // Merge new data with the existing table data
                const currentRows = shownTdfTable.getData();
                const updatedData = tdfs.map((str, index) => {
                    const existingRow = currentRows.find(row => row.name === str);
                    return existingRow
                        ? existingRow // Preserve the existing row if found
                        : { id: `row-${index}`, name: str, checked: true };
                });
                // Update table and refresh the checked state map
                shownTdfTable.replaceData(updatedData);
                shownTDFs = Object.fromEntries(
                    updatedData.map(row => [row.name, row.checked])
                );
                currentTDFs = tdfs;
            }
            const disableData = shownTdfTable.getData();
            shownTDFs = Object.fromEntries(
                disableData.map(row => [row.name, row.checked])
            );

            const uniqueApplications = [
                ...new Set(rows.map(obj => obj.ANNOUNCE?.application).filter(app => app !== undefined).sort())
            ];
            if (!arraysEqual(currentApps, uniqueApplications)) {
                versions = uniqueApplications.map((v, idx) => { return { id: `row-${idx}`, name: v, checked: true }; })
                shownAppTable.replaceData(versions);
                currentApps = uniqueApplications
                filtering_update = true;
            }

            // Update column definitions if new TDFs have appeared
            if (columns.length != current_num_columns) {
                dataTable.setColumns(columns);
                current_num_columns = columns.length;
                filtering_update = true;
            }

            // Dynamically set the table content
            if (current_num_columns > 0) {
                if (!document.getElementById('update_pause').checked) {
                    dataTable.replaceData(rows);
                }
            }

            if (filtering_update) {
                // Hide columns as requested
                dataTable.getColumns().forEach(column => {
                    // Split field name into [TDF_NAME, subfields]
                    const field = column.getField().split('.');
                    if (shownTDFs[field[0]] ?? true) {
                        column.show();
                    } else {
                        column.hide();
                    }
                });

                // Filter applications as requested
                appShow = Object.fromEntries(
                    shownAppTable.getData().map(row => [row.name, row.checked])
                );
                enabledApps = currentApps.filter(a => appShow[a]);

                dataTable.clearFilter();
                dataTable.setFilter("ANNOUNCE.application", "in", enabledApps);

                filtering_update = false;
            }
        };

        ws.onopen = function () {
            console.log("WebSocket connected");
        };

        ws.onerror = function (error) {
            console.error("WebSocket error:", error);
        };
    </script>
</body>

</html>
