"""Module for defining the VulnerabilityMapping model."""

from __future__ import annotations

from typing import Optional, List, Dict, Any

from pydantic import Field, ConfigDict

from regscale.models.regscale_models.regscale_model import RegScaleModel
from regscale.models.regscale_models.search import Search


class VulnerabilityMapping(RegScaleModel):
    """Represents a mapping between vulnerabilities and assets."""

    _module_slug = "vulnerabilityMappings"
    _unique_fields = [
        ["vulnerabilityId", "assetId", "scanId"],
    ]
    _parent_id_field = "scanId"

    uuid: Optional[str] = None
    vulnerabilityId: int
    assetId: int
    scanId: Optional[int] = None
    securityPlanId: Optional[int] = None
    status: Optional[str] = Field(max_length=450)
    firstSeen: str
    lastSeen: str
    dateClosed: Optional[str] = None
    isPublic: bool = Field(default=False)
    createdById: str = Field(default_factory=RegScaleModel.get_user_id)
    lastUpdatedById: str = Field(default_factory=RegScaleModel.get_user_id)
    dateCreated: str
    dateLastUpdated: Optional[str] = None
    tenantsId: int = Field(default=1)

    @staticmethod
    def _get_additional_endpoints() -> ConfigDict:
        """
        Get additional endpoints for the API.

        :return: A dictionary of additional endpoints
        :rtype: ConfigDict
        """
        return ConfigDict(
            find_by_vulnerability="/api/{model_slug}/findByVulnerability/{vulnerability_id}",
            find_by_asset="/api/{model_slug}/findByAsset/{asset_id}",
            find_by_issue="/api/{model_slug}/findByIssue/{issue_id}",
            find_by_scan="/api/{model_slug}/findByScan/{scan_id}",
        )

    @classmethod
    def find_by_vulnerability(cls, vulnerability_id: int, status: str = "all") -> List["VulnerabilityMapping"]:
        """
        Get vulnerability mappings by vulnerability ID.

        :param int vulnerability_id: The vulnerability ID
        :param str status: The status filter (default is "all")
        :return: A list of vulnerability mappings with the given vulnerability ID
        :rtype: List[VulnerabilityMapping]
        """
        endpoint = cls.get_endpoint("find_by_vulnerability").format(vulnerability_id=vulnerability_id)
        params = {"status": status}
        response = cls._get_api_handler().get(endpoint, params=params)
        results = cls._handle_list_response(response)
        for result in results:
            cls.cache_object(result)
        return results

    @classmethod
    def find_by_asset(cls, asset_id: int, status: str = "all") -> List["VulnerabilityMapping"]:
        """
        Get vulnerability mappings by asset ID.

        :param int asset_id: The asset ID
        :param str status: The status filter (default is "all")
        :return: A list of vulnerability mappings with the given asset ID
        :rtype: List[VulnerabilityMapping]
        """
        endpoint = cls.get_endpoint("find_by_asset").format(asset_id=asset_id)
        params = {"status": status}
        response = cls._get_api_handler().get(endpoint, params=params)
        results = cls._handle_list_response(response)
        for result in results:
            cls.cache_object(result)
        return results

    @classmethod
    def find_by_issue(cls, issue_id: int, status: str = "all") -> List["VulnerabilityMapping"]:
        """
        Get vulnerability mappings by issue ID.

        :param int issue_id: The issue ID
        :param str status: The status filter (default is "all")
        :return: A list of vulnerability mappings with the given issue ID
        :rtype: List[VulnerabilityMapping]
        """
        endpoint = cls.get_endpoint("find_by_issue").format(issue_id=issue_id)
        params = {"status": status}
        response = cls._get_api_handler().get(endpoint, params=params)
        results = cls._handle_list_response(response)
        for result in results:
            cls.cache_object(result)
        return results

    @classmethod
    def find_by_scan(cls, scan_id: int, status: str = "all") -> List["VulnerabilityMapping"]:
        """
        Get vulnerability mappings by scan ID.

        :param int scan_id: The scan ID
        :param str status: The status filter (default is "all")
        :return: A list of vulnerability mappings with the given scan ID
        :rtype: List[VulnerabilityMapping]
        """
        endpoint = cls.get_endpoint("find_by_scan").format(scan_id=scan_id)
        params = {"status": status}
        response = cls._get_api_handler().get(endpoint, params=params)
        results = cls._handle_list_response(response)
        for result in results:
            cls.cache_object(result)
        return results

    def create_unique(self) -> "VulnerabilityMapping":
        """
        Create a VulnerabilityMapping object, using cache to check for existing records.

        :return: The created or existing VulnerabilityMapping object
        :rtype: VulnerabilityMapping
        """
        # Check if the object already exists in the cache
        cache_key = self._get_cache_key(self)
        with self._get_lock(cache_key):
            cached_object = self.get_cached_object(cache_key)
            if cached_object:
                return cached_object

            # If not found, create a new object
            new_object = super().create()
            self.cache_object(new_object)
            return new_object

    @classmethod
    def get_all_by_parent(
        cls,
        parent_id: int,
        parent_module: Optional[str] = None,
        search: Optional[Search] = None,
        **kwargs: Dict[str, Any],
    ) -> List["VulnerabilityMapping"]:
        """
        Get all vulnerability mappings for a given parent.

        :param int parent_id: The ID of the parent (scan ID in this case)
        :param Optional[str] parent_module: The module of the parent (not used for VulnerabilityMapping)
        :param Optional[Search] search: Search string (not used for VulnerabilityMapping)
        :return: A list of vulnerability mappings for the given parent
        :rtype: List[VulnerabilityMapping]
        """
        status = kwargs.get("status", "all")
        return cls.find_by_scan(scan_id=parent_id, status=status)
