# coding: utf-8

"""
    Kowabunga API

    Kvm Orchestrator With A BUNch of Goods Added

    The version of the OpenAPI document: 0.53.1
    Contact: maintainers@kowabunga.cloud
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from kowabunga.models.kawaii_firewall import KawaiiFirewall
from typing import Optional, Set
from typing_extensions import Self

class KawaiiIpSec(BaseModel):
    """
    A Kawaii IPsec connection.
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="The Kawaii IPsec connection ID (auto-generated).")
    name: StrictStr = Field(description="The Kawaii IPsec connection name.")
    description: Optional[StrictStr] = Field(default=None, description="The Kawaii IPsec connection description.")
    ip: Optional[StrictStr] = Field(default=None, description="The Kawaii IPsec connection IPSec IP.")
    remote_ip: StrictStr = Field(description="The Kawaii IPsec connection remote peer VPN Gateway.")
    remote_subnet: StrictStr = Field(description="The Kawaii IPsec connection remote subnet.")
    pre_shared_key: StrictStr = Field(description="The Kawaii IPsec connection pre-shared key(PSK).")
    dpd_timeout_action: Optional[StrictStr] = Field(default='restart', description="The Kawaii IPsec connection Dead Peer Detection Action (clear,restart or trap).")
    dpd_timeout: Optional[StrictStr] = Field(default='240s', description="The Kawaii IPsec connection Dead Peer Detection Timeout.")
    start_action: Optional[StrictStr] = Field(default='start', description="The Kawaii IPsec connection start action (none, start, trap).")
    rekey_time: Optional[StrictStr] = Field(default='2h', description="The Kawaii IPsec connection rekey time. Default is 2h.")
    phase1_lifetime: Optional[StrictStr] = Field(default='1h', description="The Kawaii IPsec connection Lifetime for phase 1 negociation. Default is 1h.")
    phase1_dh_group_number: StrictInt = Field(description="The Kawaii IPsec connection phase 1 Diffie Hellman IANA algorithm.")
    phase1_integrity_algorithm: StrictStr = Field(description="The Kawaii IPsec connection phase 1 integrity algorithm..")
    phase1_encryption_algorithm: StrictStr = Field(description="The Kawaii IPsec connection phase 1 encryption algorithm..")
    phase2_lifetime: Optional[StrictStr] = Field(default='1h', description="The Kawaii IPsec connection Lifetime for phase 2 negociation. Default is 1h.")
    phase2_dh_group_number: StrictInt = Field(description="The Kawaii IPsec connection phase 2 Diffie Hellman IANA algorithm.")
    phase2_integrity_algorithm: StrictStr = Field(description="The Kawaii IPsec connection phase 2 integrity algorithm..")
    phase2_encryption_algorithm: StrictStr = Field(description="The Kawaii IPsec connection phase 2 encryption algorithm..")
    firewall: Optional[KawaiiFirewall] = None
    __properties: ClassVar[List[str]] = ["id", "name", "description", "ip", "remote_ip", "remote_subnet", "pre_shared_key", "dpd_timeout_action", "dpd_timeout", "start_action", "rekey_time", "phase1_lifetime", "phase1_dh_group_number", "phase1_integrity_algorithm", "phase1_encryption_algorithm", "phase2_lifetime", "phase2_dh_group_number", "phase2_integrity_algorithm", "phase2_encryption_algorithm", "firewall"]

    @field_validator('dpd_timeout_action')
    def dpd_timeout_action_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['clear', 'restart', 'start']):
            raise ValueError("must be one of enum values ('clear', 'restart', 'start')")
        return value

    @field_validator('start_action')
    def start_action_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'start', 'trap']):
            raise ValueError("must be one of enum values ('none', 'start', 'trap')")
        return value

    @field_validator('phase1_dh_group_number')
    def phase1_dh_group_number_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set([2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]):
            raise ValueError("must be one of enum values (2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)")
        return value

    @field_validator('phase1_integrity_algorithm')
    def phase1_integrity_algorithm_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['SHA1', 'SHA256', 'SHA384', 'SHA512']):
            raise ValueError("must be one of enum values ('SHA1', 'SHA256', 'SHA384', 'SHA512')")
        return value

    @field_validator('phase1_encryption_algorithm')
    def phase1_encryption_algorithm_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['AES128', 'AES256', 'CAMELLIA128', 'CAMELLIA256']):
            raise ValueError("must be one of enum values ('AES128', 'AES256', 'CAMELLIA128', 'CAMELLIA256')")
        return value

    @field_validator('phase2_dh_group_number')
    def phase2_dh_group_number_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set([2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]):
            raise ValueError("must be one of enum values (2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)")
        return value

    @field_validator('phase2_integrity_algorithm')
    def phase2_integrity_algorithm_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['SHA1', 'SHA256', 'SHA384', 'SHA512']):
            raise ValueError("must be one of enum values ('SHA1', 'SHA256', 'SHA384', 'SHA512')")
        return value

    @field_validator('phase2_encryption_algorithm')
    def phase2_encryption_algorithm_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['AES128', 'AES256', 'CAMELLIA128', 'CAMELLIA256']):
            raise ValueError("must be one of enum values ('AES128', 'AES256', 'CAMELLIA128', 'CAMELLIA256')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of KawaiiIpSec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of firewall
        if self.firewall:
            _dict['firewall'] = self.firewall.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of KawaiiIpSec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "description": obj.get("description"),
            "ip": obj.get("ip"),
            "remote_ip": obj.get("remote_ip"),
            "remote_subnet": obj.get("remote_subnet"),
            "pre_shared_key": obj.get("pre_shared_key"),
            "dpd_timeout_action": obj.get("dpd_timeout_action") if obj.get("dpd_timeout_action") is not None else 'restart',
            "dpd_timeout": obj.get("dpd_timeout") if obj.get("dpd_timeout") is not None else '240s',
            "start_action": obj.get("start_action") if obj.get("start_action") is not None else 'start',
            "rekey_time": obj.get("rekey_time") if obj.get("rekey_time") is not None else '2h',
            "phase1_lifetime": obj.get("phase1_lifetime") if obj.get("phase1_lifetime") is not None else '1h',
            "phase1_dh_group_number": obj.get("phase1_dh_group_number"),
            "phase1_integrity_algorithm": obj.get("phase1_integrity_algorithm"),
            "phase1_encryption_algorithm": obj.get("phase1_encryption_algorithm"),
            "phase2_lifetime": obj.get("phase2_lifetime") if obj.get("phase2_lifetime") is not None else '1h',
            "phase2_dh_group_number": obj.get("phase2_dh_group_number"),
            "phase2_integrity_algorithm": obj.get("phase2_integrity_algorithm"),
            "phase2_encryption_algorithm": obj.get("phase2_encryption_algorithm"),
            "firewall": KawaiiFirewall.from_dict(obj["firewall"]) if obj.get("firewall") is not None else None
        })
        return _obj


