{"version":3,"file":"3188.d88413141ce58d62.js","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-conversation-agent-picker.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-conversation-agent.ts","webpack://knx-frontend/./homeassistant-frontend/src/data/conversation.ts","webpack://knx-frontend/./homeassistant-frontend/src/data/integration.ts","webpack://knx-frontend/./homeassistant-frontend/src/dialogs/config-flow/show-dialog-data-entry-flow.ts","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/store.js","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/collection.js"],"sourcesContent":["import { mdiCog } from \"@mdi/js\";\nimport type { PropertyValues } from \"lit\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport { debounce } from \"../common/util/debounce\";\nimport type { ConfigEntry, SubEntry } from \"../data/config_entries\";\nimport { getConfigEntry, getSubEntries } from \"../data/config_entries\";\nimport type { Agent } from \"../data/conversation\";\nimport { listAgents } from \"../data/conversation\";\nimport { fetchIntegrationManifest } from \"../data/integration\";\nimport { showOptionsFlowDialog } from \"../dialogs/config-flow/show-dialog-options-flow\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-list-item\";\nimport \"./ha-select\";\nimport type { HaSelect } from \"./ha-select\";\nimport { getExtendedEntityRegistryEntry } from \"../data/entity_registry\";\nimport { showSubConfigFlowDialog } from \"../dialogs/config-flow/show-dialog-sub-config-flow\";\n\nconst NONE = \"__NONE_OPTION__\";\n\n@customElement(\"ha-conversation-agent-picker\")\nexport class HaConversationAgentPicker extends LitElement {\n  @property() public value?: string;\n\n  @property() public language?: string;\n\n  @property() public label?: string;\n\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean, reflect: true }) public disabled = false;\n\n  @property({ type: Boolean }) public required = false;\n\n  @state() _agents?: Agent[];\n\n  @state() private _configEntry?: ConfigEntry;\n\n  @state() private _subConfigEntry?: SubEntry;\n\n  protected render() {\n    if (!this._agents) {\n      return nothing;\n    }\n    let value = this.value;\n    if (!value && this.required) {\n      // Select Home Assistant conversation agent if it supports the language\n      for (const agent of this._agents) {\n        if (\n          agent.id === \"conversation.home_assistant\" &&\n          agent.supported_languages.includes(this.language!)\n        ) {\n          value = agent.id;\n          break;\n        }\n      }\n      if (!value) {\n        // Select the first agent that supports the language\n        for (const agent of this._agents) {\n          if (\n            agent.supported_languages === \"*\" &&\n            agent.supported_languages.includes(this.language!)\n          ) {\n            value = agent.id;\n            break;\n          }\n        }\n      }\n    }\n    if (!value) {\n      value = NONE;\n    }\n\n    return html`\n      <ha-select\n        .label=${this.label ||\n        this.hass!.localize(\n          \"ui.components.coversation-agent-picker.conversation_agent\"\n        )}\n        .value=${value}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        @selected=${this._changed}\n        @closed=${stopPropagation}\n        fixedMenuPosition\n        naturalMenuWidth\n      >\n        ${!this.required\n          ? html`<ha-list-item .value=${NONE}>\n              ${this.hass!.localize(\n                \"ui.components.coversation-agent-picker.none\"\n              )}\n            </ha-list-item>`\n          : nothing}\n        ${this._agents.map(\n          (agent) =>\n            html`<ha-list-item\n              .value=${agent.id}\n              .disabled=${agent.supported_languages !== \"*\" &&\n              agent.supported_languages.length === 0}\n            >\n              ${agent.name}\n            </ha-list-item>`\n        )}</ha-select\n      >${(this._subConfigEntry &&\n        this._configEntry?.supported_subentry_types[\n          this._subConfigEntry.subentry_type\n        ]?.supports_reconfigure) ||\n      this._configEntry?.supports_options\n        ? html`<ha-icon-button\n            .path=${mdiCog}\n            @click=${this._openOptionsFlow}\n          ></ha-icon-button>`\n        : \"\"}\n    `;\n  }\n\n  protected willUpdate(changedProperties: PropertyValues<this>): void {\n    super.willUpdate(changedProperties);\n    if (!this.hasUpdated) {\n      this._updateAgents();\n    } else if (changedProperties.has(\"language\")) {\n      this._debouncedUpdateAgents();\n    }\n\n    if (changedProperties.has(\"value\")) {\n      this._maybeFetchConfigEntry();\n    }\n  }\n\n  private async _maybeFetchConfigEntry() {\n    if (!this.value || !(this.value in this.hass.entities)) {\n      this._configEntry = undefined;\n      return;\n    }\n    try {\n      const regEntry = await getExtendedEntityRegistryEntry(\n        this.hass,\n        this.value\n      );\n\n      if (!regEntry.config_entry_id) {\n        this._configEntry = undefined;\n        return;\n      }\n\n      this._configEntry = (\n        await getConfigEntry(this.hass, regEntry.config_entry_id)\n      ).config_entry;\n\n      if (!regEntry.config_subentry_id) {\n        this._subConfigEntry = undefined;\n      } else {\n        this._subConfigEntry = (\n          await getSubEntries(this.hass, regEntry.config_entry_id)\n        ).find((entry) => entry.subentry_id === regEntry.config_subentry_id);\n      }\n    } catch (_err) {\n      this._configEntry = undefined;\n      this._subConfigEntry = undefined;\n    }\n  }\n\n  private _debouncedUpdateAgents = debounce(() => this._updateAgents(), 500);\n\n  private async _updateAgents() {\n    const { agents } = await listAgents(\n      this.hass,\n      this.language,\n      this.hass.config.country || undefined\n    );\n\n    this._agents = agents;\n\n    if (!this.value) {\n      return;\n    }\n\n    const selectedAgent = agents.find((agent) => agent.id === this.value);\n\n    fireEvent(this, \"supported-languages-changed\", {\n      value: selectedAgent?.supported_languages,\n    });\n\n    if (\n      !selectedAgent ||\n      (selectedAgent.supported_languages !== \"*\" &&\n        selectedAgent.supported_languages.length === 0)\n    ) {\n      this.value = undefined;\n      fireEvent(this, \"value-changed\", { value: this.value });\n    }\n  }\n\n  private async _openOptionsFlow() {\n    if (!this._configEntry) {\n      return;\n    }\n\n    if (\n      this._subConfigEntry &&\n      this._configEntry.supported_subentry_types[\n        this._subConfigEntry.subentry_type\n      ]?.supports_reconfigure\n    ) {\n      showSubConfigFlowDialog(\n        this,\n        this._configEntry,\n        this._subConfigEntry.subentry_type,\n        {\n          startFlowHandler: this._configEntry.entry_id,\n          subEntryId: this._subConfigEntry.subentry_id,\n        }\n      );\n      return;\n    }\n\n    showOptionsFlowDialog(this, this._configEntry, {\n      manifest: await fetchIntegrationManifest(\n        this.hass,\n        this._configEntry.domain\n      ),\n    });\n  }\n\n  static styles = css`\n    :host {\n      display: flex;\n      align-items: center;\n    }\n    ha-select {\n      width: 100%;\n    }\n    ha-icon-button {\n      color: var(--secondary-text-color);\n    }\n  `;\n\n  private _changed(ev): void {\n    const target = ev.target as HaSelect;\n    if (\n      !this.hass ||\n      target.value === \"\" ||\n      target.value === this.value ||\n      (this.value === undefined && target.value === NONE)\n    ) {\n      return;\n    }\n    this.value = target.value === NONE ? undefined : target.value;\n    fireEvent(this, \"value-changed\", { value: this.value });\n    fireEvent(this, \"supported-languages-changed\", {\n      value: this._agents!.find((agent) => agent.id === this.value)\n        ?.supported_languages,\n    });\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-conversation-agent-picker\": HaConversationAgentPicker;\n  }\n  interface HASSDomEvents {\n    \"supported-languages-changed\": { value: \"*\" | string[] | undefined };\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport type { ConversationAgentSelector } from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-conversation-agent-picker\";\n\n@customElement(\"ha-selector-conversation_agent\")\nexport class HaConversationAgentSelector extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public selector!: ConversationAgentSelector;\n\n  @property() public value?: any;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  @property({ attribute: false }) public context?: {\n    language?: string;\n  };\n\n  protected render() {\n    return html`<ha-conversation-agent-picker\n      .hass=${this.hass}\n      .value=${this.value}\n      .language=${this.selector.conversation_agent?.language ||\n      this.context?.language}\n      .label=${this.label}\n      .helper=${this.helper}\n      .disabled=${this.disabled}\n      .required=${this.required}\n    ></ha-conversation-agent-picker>`;\n  }\n\n  static styles = css`\n    ha-conversation-agent-picker {\n      width: 100%;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-conversation_agent\": HaConversationAgentSelector;\n  }\n}\n","import { ensureArray } from \"../common/array/ensure-array\";\nimport type { HomeAssistant } from \"../types\";\n\nexport const enum ConversationEntityFeature {\n  CONTROL = 1,\n}\n\ninterface IntentTarget {\n  type: \"area\" | \"device\" | \"entity\" | \"domain\" | \"device_class\" | \"custom\";\n  name: string;\n  id: string | null;\n}\n\ninterface IntentResultBase {\n  language: string;\n  speech: Record<\"plain\" | \"ssml\", { extra_data: any; speech: string }> | null;\n}\n\ninterface IntentResultActionDone extends IntentResultBase {\n  response_type: \"action_done\";\n  data: {\n    targets: IntentTarget[];\n    success: IntentTarget[];\n    failed: IntentTarget[];\n  };\n}\n\ninterface IntentResultQueryAnswer extends IntentResultBase {\n  response_type: \"query_answer\";\n  data: {\n    targets: IntentTarget[];\n    success: IntentTarget[];\n    failed: IntentTarget[];\n  };\n}\n\ninterface IntentResultError extends IntentResultBase {\n  response_type: \"error\";\n  data: {\n    code:\n      | \"no_intent_match\"\n      | \"no_valid_targets\"\n      | \"failed_to_handle\"\n      | \"unknown\";\n  };\n}\n\nexport interface ConversationResult {\n  conversation_id: string | null;\n  response:\n    | IntentResultActionDone\n    | IntentResultQueryAnswer\n    | IntentResultError;\n  continue_conversation: boolean;\n}\n\nexport interface Agent {\n  id: string;\n  name: string;\n  supported_languages: \"*\" | string[];\n}\n\nexport interface AssitDebugResult {\n  intent: {\n    name: string;\n  };\n  entities: Record<\n    string,\n    {\n      name: string;\n      value: string;\n      text: string;\n    }\n  >;\n}\n\nexport interface AssistDebugResponse {\n  results: (AssitDebugResult | null)[];\n}\n\nexport const processConversationInput = (\n  hass: HomeAssistant,\n  text: string,\n  // eslint-disable-next-line: variable-name\n  conversation_id: string | null,\n  language: string\n): Promise<ConversationResult> =>\n  hass.callWS({\n    type: \"conversation/process\",\n    text,\n    conversation_id,\n    language,\n  });\n\nexport const listAgents = (\n  hass: HomeAssistant,\n  language?: string,\n  country?: string\n): Promise<{ agents: Agent[] }> =>\n  hass.callWS({\n    type: \"conversation/agent/list\",\n    language,\n    country,\n  });\n\nexport const prepareConversation = (\n  hass: HomeAssistant,\n  language?: string\n): Promise<void> =>\n  hass.callWS({\n    type: \"conversation/prepare\",\n    language,\n  });\n\nexport const debugAgent = (\n  hass: HomeAssistant,\n  sentences: string[] | string,\n  language: string,\n  device_id?: string\n): Promise<AssistDebugResponse> =>\n  hass.callWS({\n    type: \"conversation/agent/homeassistant/debug\",\n    sentences: ensureArray(sentences),\n    language,\n    device_id,\n  });\n\nexport interface LanguageScore {\n  cloud: number;\n  focused_local: number;\n  full_local: number;\n}\n\nexport type LanguageScores = Record<string, LanguageScore>;\n\nexport const getLanguageScores = (\n  hass: HomeAssistant,\n  language?: string,\n  country?: string\n): Promise<{ languages: LanguageScores; preferred_language: string | null }> =>\n  hass.callWS({\n    type: \"conversation/agent/homeassistant/language_scores\",\n    language,\n    country,\n  });\n","import type { Connection } from \"home-assistant-js-websocket\";\nimport { createCollection } from \"home-assistant-js-websocket\";\nimport type { LocalizeFunc } from \"../common/translations/localize\";\nimport type { HomeAssistant } from \"../types\";\nimport { debounce } from \"../common/util/debounce\";\n\nexport const integrationsWithPanel = {\n  bluetooth: \"config/bluetooth\",\n  dhcp: \"config/dhcp\",\n  matter: \"config/matter\",\n  mqtt: \"config/mqtt\",\n  ssdp: \"config/ssdp\",\n  thread: \"config/thread\",\n  zeroconf: \"config/zeroconf\",\n  zha: \"config/zha/dashboard\",\n  zwave_js: \"config/zwave_js/dashboard\",\n};\n\nexport type IntegrationType =\n  | \"device\"\n  | \"helper\"\n  | \"hub\"\n  | \"service\"\n  | \"hardware\"\n  | \"entity\"\n  | \"system\";\n\nexport interface IntegrationManifest {\n  is_built_in: boolean;\n  overwrites_built_in?: boolean;\n  domain: string;\n  name: string;\n  config_flow: boolean;\n  documentation: string;\n  issue_tracker?: string;\n  dependencies?: string[];\n  after_dependencies?: string[];\n  codeowners?: string[];\n  requirements?: string[];\n  ssdp?: { manufacturer?: string; modelName?: string; st?: string }[];\n  zeroconf?: string[];\n  homekit?: { models: string[] };\n  integration_type?: IntegrationType;\n  loggers?: string[];\n  quality_scale?:\n    | \"bronze\"\n    | \"silver\"\n    | \"gold\"\n    | \"platinum\"\n    | \"no_score\"\n    | \"internal\"\n    | \"legacy\"\n    | \"custom\";\n  iot_class:\n    | \"assumed_state\"\n    | \"cloud_polling\"\n    | \"cloud_push\"\n    | \"local_polling\"\n    | \"local_push\";\n  single_config_entry?: boolean;\n  version?: string;\n}\nexport interface IntegrationSetup {\n  domain: string;\n  seconds?: number;\n}\n\nexport interface IntegrationLogInfo {\n  domain: string;\n  level?: number;\n}\n\nexport enum LogSeverity {\n  CRITICAL = 50,\n  ERROR = 40,\n  WARNING = 30,\n  INFO = 20,\n  DEBUG = 10,\n  NOTSET = 0,\n}\n\nexport type IntegrationLogPersistance = \"none\" | \"once\" | \"permanent\";\n\nexport const integrationIssuesUrl = (\n  domain: string,\n  manifest: IntegrationManifest\n) =>\n  manifest.issue_tracker ||\n  `https://github.com/home-assistant/core/issues?q=is%3Aissue+is%3Aopen+label%3A%22integration%3A+${domain}%22`;\n\nexport const domainToName = (\n  localize: LocalizeFunc,\n  domain: string,\n  manifest?: IntegrationManifest\n) => localize(`component.${domain}.title`) || manifest?.name || domain;\n\nexport const fetchIntegrationManifests = (\n  hass: HomeAssistant,\n  integrations?: string[]\n) => {\n  const params: any = {\n    type: \"manifest/list\",\n  };\n  if (integrations) {\n    params.integrations = integrations;\n  }\n  return hass.callWS<IntegrationManifest[]>(params);\n};\n\nexport const fetchIntegrationManifest = (\n  hass: HomeAssistant,\n  integration: string\n) => hass.callWS<IntegrationManifest>({ type: \"manifest/get\", integration });\n\nexport const fetchIntegrationSetups = (hass: HomeAssistant) =>\n  hass.callWS<IntegrationSetup[]>({ type: \"integration/setup_info\" });\n\nexport const fetchIntegrationLogInfo = (conn) =>\n  conn.sendMessagePromise({\n    type: \"logger/log_info\",\n  });\n\nexport const setIntegrationLogLevel = (\n  hass: HomeAssistant,\n  integration: string,\n  level: string,\n  persistence: IntegrationLogPersistance\n) =>\n  hass.callWS({\n    type: \"logger/integration_log_level\",\n    integration,\n    level,\n    persistence,\n  });\n\nconst subscribeLogInfoUpdates = (conn, store) =>\n  conn.subscribeEvents(\n    debounce(\n      () =>\n        fetchIntegrationLogInfo(conn).then((log_infos) =>\n          store.setState(log_infos, true)\n        ),\n      200,\n      true\n    ),\n    \"logging_changed\"\n  );\n\nexport const subscribeLogInfo = (\n  conn: Connection,\n  onChange: (devices: IntegrationLogInfo[]) => void\n) =>\n  createCollection<IntegrationLogInfo[]>(\n    \"_integration_log_info\",\n    fetchIntegrationLogInfo,\n    subscribeLogInfoUpdates,\n    conn,\n    onChange\n  );\n\nexport const waitForIntegrationSetup = (hass: HomeAssistant, domain: string) =>\n  hass.callWS<{ integration_loaded: boolean }>({\n    type: \"integration/wait\",\n    domain,\n  });\n","import type { TemplateResult } from \"lit\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { HaFormSchema } from \"../../components/ha-form/types\";\nimport type {\n  DataEntryFlowStep,\n  DataEntryFlowStepAbort,\n  DataEntryFlowStepCreateEntry,\n  DataEntryFlowStepExternal,\n  DataEntryFlowStepForm,\n  DataEntryFlowStepMenu,\n  DataEntryFlowStepProgress,\n  FlowType,\n} from \"../../data/data_entry_flow\";\nimport type { IntegrationManifest } from \"../../data/integration\";\nimport type { HomeAssistant } from \"../../types\";\n\nexport interface FlowConfig {\n  flowType: FlowType;\n\n  showDevices: boolean;\n\n  createFlow(hass: HomeAssistant, handler: string): Promise<DataEntryFlowStep>;\n\n  fetchFlow(hass: HomeAssistant, flowId: string): Promise<DataEntryFlowStep>;\n\n  handleFlowStep(\n    hass: HomeAssistant,\n    flowId: string,\n    data: Record<string, any>\n  ): Promise<DataEntryFlowStep>;\n\n  deleteFlow(hass: HomeAssistant, flowId: string): Promise<unknown>;\n\n  renderAbortHeader?(hass: HomeAssistant, step: DataEntryFlowStepAbort): string;\n\n  renderAbortSubheader?(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepAbort\n  ): string | TemplateResult;\n\n  renderAbortDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepAbort\n  ): TemplateResult | string;\n\n  renderShowFormStepHeader(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm\n  ): string;\n\n  renderShowFormStepSubheader?(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm\n  ): string | TemplateResult;\n\n  renderShowFormStepDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm\n  ): TemplateResult | \"\";\n\n  renderShowFormStepFieldLabel(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm,\n    field: HaFormSchema,\n    options: { path?: string[]; [key: string]: any }\n  ): string;\n\n  renderShowFormStepFieldHelper(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm,\n    field: HaFormSchema,\n    options: { path?: string[]; [key: string]: any }\n  ): TemplateResult | string;\n\n  renderShowFormStepFieldError(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm,\n    error: string\n  ): string;\n\n  renderShowFormStepFieldLocalizeValue(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm,\n    key: string\n  ): string;\n\n  renderShowFormStepSubmitButton(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepForm\n  ): string;\n\n  renderExternalStepHeader(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepExternal\n  ): string;\n\n  renderExternalStepDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepExternal\n  ): TemplateResult | \"\";\n\n  renderCreateEntryDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepCreateEntry\n  ): TemplateResult | \"\";\n\n  renderShowFormProgressHeader(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepProgress\n  ): string;\n\n  renderShowFormProgressSubheader?(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepProgress\n  ): string | TemplateResult;\n\n  renderShowFormProgressDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepProgress\n  ): TemplateResult | \"\";\n\n  renderMenuHeader(hass: HomeAssistant, step: DataEntryFlowStepMenu): string;\n\n  renderMenuSubheader?(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepMenu\n  ): string | TemplateResult;\n\n  renderMenuDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepMenu\n  ): TemplateResult | \"\";\n\n  renderMenuOption(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepMenu,\n    option: string\n  ): string;\n\n  renderMenuOptionDescription(\n    hass: HomeAssistant,\n    step: DataEntryFlowStepMenu,\n    option: string\n  ): string;\n\n  renderLoadingDescription(\n    hass: HomeAssistant,\n    loadingReason: LoadingReason,\n    handler?: string,\n    step?: DataEntryFlowStep | null\n  ): string;\n}\n\nexport type LoadingReason =\n  | \"loading_handlers\"\n  | \"loading_flow\"\n  | \"loading_step\";\n\nexport interface DataEntryFlowDialogParams {\n  startFlowHandler?: string;\n  searchQuery?: string;\n  continueFlowId?: string;\n  manifest?: IntegrationManifest | null;\n  domain?: string;\n  dialogClosedCallback?: (params: {\n    flowFinished: boolean;\n    entryId?: string;\n  }) => void;\n  flowConfig: FlowConfig;\n  showAdvanced?: boolean;\n  dialogParentElement?: HTMLElement;\n  navigateToResult?: boolean;\n  carryOverDevices?: string[];\n}\n\nexport const loadDataEntryFlowDialog = () => import(\"./dialog-data-entry-flow\");\n\nexport const showFlowDialog = (\n  element: HTMLElement,\n  dialogParams: Omit<DataEntryFlowDialogParams, \"flowConfig\">,\n  flowConfig: FlowConfig\n): void => {\n  fireEvent(element, \"show-dialog\", {\n    dialogTag: \"dialog-data-entry-flow\",\n    dialogImport: loadDataEntryFlowDialog,\n    dialogParams: {\n      ...dialogParams,\n      flowConfig,\n      dialogParentElement: element,\n    },\n  });\n};\n","export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n","import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    // @ts-ignore\n    if (conn[key]) {\n        // @ts-ignore\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    // @ts-ignore\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    // @ts-ignore\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n"],"names":["NONE","HaConversationAgentPicker","LitElement","render","_this$_configEntry","_this$_configEntry2","this","_agents","nothing","value","required","agent","id","supported_languages","includes","language","html","_t","_","label","hass","localize","disabled","_changed","stopPropagation","_t2","map","_t3","length","name","_subConfigEntry","_configEntry","supported_subentry_types","subentry_type","supports_reconfigure","supports_options","_t4","_openOptionsFlow","willUpdate","changedProperties","super","hasUpdated","has","_debouncedUpdateAgents","_updateAgents","_maybeFetchConfigEntry","entities","regEntry","getExtendedEntityRegistryEntry","config_entry_id","undefined","getConfigEntry","config_entry","config_subentry_id","getSubEntries","find","entry","subentry_id","_err","agents","listAgents","config","country","selectedAgent","fireEvent","_this$_configEntry$su","showSubConfigFlowDialog","startFlowHandler","entry_id","subEntryId","showOptionsFlowDialog","manifest","fetchIntegrationManifest","domain","ev","_this$_agents$find","target","args","debounce","styles","css","_t5","attribute","type","Boolean","reflect","HaConversationAgentSelector","_this$selector$conver","_this$context","selector","conversation_agent","context","helper","ConversationEntityFeature","callWS","getLanguageScores","domainToName","fetchIntegrationManifests","integrations","params","integration","loadDataEntryFlowDialog","e","showFlowDialog","element","dialogParams","flowConfig","dialogTag","dialogImport","Object","assign","dialogParentElement","createStore","state","listeners","setState","update","overwrite","currentListeners","i","action","apply","result","arguments","push","ret","Promise","then","clearState","subscribe","listener","out","unsubscribe","getCollection","conn","key","fetchCollection","subscribeUpdates","options","unsubGrace","unsubProm","unsubTimer","active","store","refresh","Error","refreshSwallow","catch","err","connected","teardownUpdateSubscription","unsub","removeEventListener","handleDisconnect","clearTimeout","subscriber","setupUpdateSubscription","addEventListener","setTimeout","createCollection","onChange"],"mappings":"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"}