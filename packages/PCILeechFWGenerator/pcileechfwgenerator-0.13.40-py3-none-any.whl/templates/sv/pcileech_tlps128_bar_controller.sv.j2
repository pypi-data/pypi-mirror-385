{#- Unified PCILeech BAR Controller Template -#}
{{ header | safe }}

{% set _bar_config = bar_config if bar_config is defined and bar_config is not none else {} %}
{% set _controller_variant = _bar_config.controller_variant | default(None) %}
{% if _bar_config.use_enhanced_controller | default(false) %}
    {% set _controller_variant = "enhanced" %}
{% elif _controller_variant is none %}
    {% set _controller_variant = "legacy" %}
{% endif %}
{% if device_signature %}
    {% set _device_signature_literal = device_signature | sv_hex(32) %}
{% else %}
    {% set _device_signature_literal = "32'hDEAD_BEEF" %}
{% endif %}
{% from "_helpers.j2" import safe_int, get_vendor_id, get_device_id %}

`default_nettype none

{% if _controller_variant == "basic" %}
module pcileech_tlps128_bar_controller #(
    parameter BAR_APERTURE_SIZE = 131072,  // 128KB
    parameter DEVICE_ID = 16'h{{ get_device_id(device_config, device, config_space, device_id_int) }},
    parameter VENDOR_ID = 16'h{{ get_vendor_id(device_config, device, config_space, vendor_id_int) }}
) (
    input  wire         clk,
    input  wire         reset_n,
    
    // BAR interface
    input  wire  [31:0] bar_addr,
    input  wire  [31:0] bar_wr_data,
    input  wire  [3:0]  bar_wr_be,
    input  wire         bar_wr_en,
    input  wire         bar_rd_en,
    output logic [31:0] bar_rd_data,
    
    // Custom PIO regions
    output logic        custom_pio_sel,
    output logic [15:0] custom_pio_addr,
    output logic [31:0] custom_pio_wdata,
    output logic        custom_pio_we,
    input  wire  [31:0] custom_pio_rdata
);

    // Address decode for custom PIO regions
    logic device_control_sel = (bar_addr[15:8] == 8'h00);  // 0x0000-0x00FF
    logic status_regs_sel    = (bar_addr[15:8] == 8'h01);  // 0x0100-0x01FF
    logic data_buffer_sel    = (bar_addr[15:9] == 7'h01);  // 0x0200-0x03FF
    
    assign custom_pio_sel = device_control_sel || status_regs_sel || data_buffer_sel;
    assign custom_pio_addr = bar_addr[15:0];
    assign custom_pio_wdata = bar_wr_data;
    assign custom_pio_we = bar_wr_en && custom_pio_sel;
    
    // Read data multiplexing
    always_comb begin
        if (custom_pio_sel) begin
            bar_rd_data = custom_pio_rdata;
        end else begin
            bar_rd_data = 32'h00000000;  // Default for unmapped regions
        end
    end

endmodule
{% elif _controller_variant == "legacy" %}
module pcileech_tlps128_bar_controller #(
    parameter BAR_APERTURE_SIZE   = {{ BAR_APERTURE_SIZE }},  // {{ BAR_APERTURE_SIZE }} bytes by default
    parameter NUM_MSIX           = {{ NUM_MSIX }},
    parameter MSIX_TABLE_BIR     = {{ MSIX_TABLE_BIR }},
    parameter MSIX_TABLE_OFFSET  = {{ MSIX_TABLE_OFFSET }},
    parameter MSIX_PBA_BIR       = {{ MSIX_PBA_BIR }},
    parameter MSIX_PBA_OFFSET    = {{ MSIX_PBA_OFFSET }},
    // Address map (all offsets within *this* BAR)
    parameter CONFIG_SHDW_HI     = {{ CONFIG_SHDW_HI }}, // top 4 KB reserved for cfg space shadow
    parameter CUSTOM_WIN_BASE    = {{ CUSTOM_WIN_BASE }}  // next-to-top 4 KB reserved for custom regs
) (
    // Clock and reset
    input  wire         clk,
    input  wire         reset_n,

    // BAR selector (which BAR of the endpoint this controller is mapped to)
    input  wire  [2:0]  bar_index,

    // PCIe BAR interface
    input  wire  [31:0] bar_addr,
    input  wire  [31:0] bar_wr_data,
    input  wire  [3:0]  bar_wr_be,
    input  wire         bar_wr_en,
    input  wire         bar_rd_en,
    // Procedural assignment below requires a variable type, not a net.
    // Use 'logic' to allow assignment in always_comb.
    output logic [31:0] bar_rd_data,

    // PCIe configuration space interface
    input  wire         cfg_ext_read_received,
    input  wire         cfg_ext_write_received,
    input  wire  [9:0]  cfg_ext_register_number,
    input  wire  [3:0]  cfg_ext_function_number,
    input  wire  [31:0] cfg_ext_write_data,
    input  wire  [3:0]  cfg_ext_write_byte_enable,
    output wire [31:0]  cfg_ext_read_data,
    output wire         cfg_ext_read_data_valid,

    // MSI-X interrupt interface
    output logic        msix_interrupt,
    output logic [10:0] msix_vector,
    input  wire         msix_interrupt_ack,

    // --- Custom window hook --------------------------------------------------
    output wire         custom_win_sel,
    output wire [11:0]  custom_win_addr,
    output wire [31:0]  custom_win_wdata,
    output wire [3:0]   custom_win_be,
    output wire         custom_win_we,
    output wire         custom_win_re,
    input  wire [31:0]  custom_win_rdata
);

    // ----------------------------------------------------------------
    // Device signature constant (for debug/identification in builds)
    // ----------------------------------------------------------------
    localparam [31:0] DEVICE_SIGNATURE = {{ _device_signature_literal }};

    // ------------------------------------------------------------
    // Internal signal declarations (declare before use)
    // ------------------------------------------------------------
    logic [31:0] cfg_shdw_rdata;
    logic [31:0] msix_tbl_rdata;
{% if device_config is defined and (device_config.enable_perf_counters | default(false, true)) %}
    logic [31:0] perf_rd_count;
    logic [31:0] perf_wr_count;
{% endif %}
    
    // ------------------------------------------------------------
    // Address decode helpers (declared early so downstream modules can use)
    // ------------------------------------------------------------
    logic bar_access_cfg;
    logic bar_access_msix;
    logic bar_access_cust;
    logic bar_access_mem;

    assign bar_access_cfg  = (bar_addr[31:12] == {{ CONFIG_SHDW_HI }});
    assign bar_access_cust = (bar_addr[31:12] == {{ CUSTOM_WIN_BASE }});
    assign bar_access_mem  = !bar_access_cfg && !bar_access_msix && !bar_access_cust;

    // ------------------------------------------------------------
    // Configuration-space shadow BRAM
    // ------------------------------------------------------------
    pcileech_tlps128_cfgspace_shadow cfg_shdw (
        .clk                       (clk),
        .reset_n                   (reset_n),
        .cfg_ext_read_received     (cfg_ext_read_received),
        .cfg_ext_write_received    (cfg_ext_write_received),
        .cfg_ext_register_number   (cfg_ext_register_number),
        .cfg_ext_function_number   (cfg_ext_function_number),
        .cfg_ext_write_data        (cfg_ext_write_data),
        .cfg_ext_write_byte_enable (cfg_ext_write_byte_enable),
        .cfg_ext_read_data         (cfg_ext_read_data),
        .cfg_ext_read_data_valid   (cfg_ext_read_data_valid),
        .host_access_en            (bar_access_cfg),
        .host_write_en             (bar_wr_en && bar_access_cfg),
        .host_addr                 (bar_addr[11:0]),
        .host_write_data           (bar_wr_data),
        .host_read_data            (cfg_shdw_rdata)
    );

    // ------------------------------------------------------------
    // MSI-X capability runtime registers
    // Replaces static decode from shadow BRAM so driver writes to the
    // MSI-X Message Control register update enable/mask semantics.
    // ------------------------------------------------------------
    localparam [9:0] MSIX_CAP_REG = 10'h1C; // Base dword index for MSI-X cap (0x70 >> 2)

    // Write detection for MSI-X capability dword window (0x70 - 0x7C)
    logic        msix_cap_wr;
    logic [31:0] msix_cap_addr;
    logic [31:0] msix_cap_wdata;
    logic [3:0]  msix_cap_be;
    logic        msix_enabled;
    logic        msix_fn_masked;
    wire  [10:0] msix_table_size_ro;

    assign msix_cap_wr   = cfg_ext_write_received &&
                           (cfg_ext_register_number >= MSIX_CAP_REG) &&
                           (cfg_ext_register_number <= (MSIX_CAP_REG + 4));
    // Capability-internal byte address (low 4 bits used inside module)
    assign msix_cap_addr = {28'h0, (cfg_ext_register_number - MSIX_CAP_REG), 2'b00};
    assign msix_cap_wdata = cfg_ext_write_data;
    assign msix_cap_be    = cfg_ext_write_byte_enable;

    msix_capability_registers #(
        .TABLE_SIZE_MINUS_ONE (NUM_MSIX-1),
        .TABLE_OFFSET_BIR     (MSIX_TABLE_OFFSET + MSIX_TABLE_BIR),
        .PBA_OFFSET_BIR       (MSIX_PBA_OFFSET + MSIX_PBA_BIR)
    ) msix_caps (
        .clk               (clk),
        .reset_n           (reset_n),
        .msix_cap_wr       (msix_cap_wr),
        .msix_cap_addr     (msix_cap_addr),
        .msix_cap_wdata    (msix_cap_wdata),
        .msix_cap_be       (msix_cap_be),
        .msix_cap_rdata    (/* unused */),
        .msix_enable       (msix_enabled),
        .msix_function_mask(msix_fn_masked),
        .msix_table_size   (msix_table_size_ro)
    );

    // ------------------------------------------------------------
    // MSI-X table sub-module
    // ------------------------------------------------------------
    msix_table #(
        .NUM_MSIX          (NUM_MSIX),
        .MSIX_TABLE_BIR    (MSIX_TABLE_BIR),
        .MSIX_TABLE_OFFSET (MSIX_TABLE_OFFSET),
        .MSIX_PBA_BIR      (MSIX_PBA_BIR),
        .MSIX_PBA_OFFSET   (MSIX_PBA_OFFSET)
    ) msix_tbl (
        .clk               (clk),
        .reset_n           (reset_n),
        .bar_addr          (bar_addr),
        .bar_index         (bar_index),
        .bar_wr_data       (bar_wr_data),
        .bar_wr_en         (bar_wr_en),
        .bar_wr_be         (bar_wr_be),
        .bar_rd_en         (bar_rd_en),
        .bar_rd_data       (msix_tbl_rdata),
        .bar_access_match  (bar_access_msix),
        .msix_enable       (msix_enabled),
        .msix_function_mask(msix_fn_masked),
        .msix_interrupt    (msix_interrupt),
        .msix_vector       (msix_vector),
        .msix_interrupt_ack(msix_interrupt_ack),
        .trigger_valid     (1'b0),
        .trigger_vector    (11'h0)
    );

    // ------------------------------------------------------------
    // BAR memory (block-RAM-friendly, synchronous read)
    // ------------------------------------------------------------
    (* ram_style = "block" *) logic [31:0] bar_mem [({{ BAR_APERTURE_SIZE }}/4)-1:0];
    logic [31:0] bar_mem_q;

    always_ff @(posedge clk) begin
        if (bar_wr_en && bar_access_mem && (bar_addr[31:2] < ({{ BAR_APERTURE_SIZE }}/4))) begin
{% if USE_BYTE_ENABLES %}
            for (int b=0; b<4; b++) begin
                if (bar_wr_be[b])
                    bar_mem[bar_addr[31:2]][8*b +: 8] <= bar_wr_data[8*b +: 8];
            end
{% else %}
            bar_mem[bar_addr[31:2]] <= bar_wr_data;
{% endif %}
        end
        if (bar_rd_en && bar_access_mem && (bar_addr[31:2] < ({{ BAR_APERTURE_SIZE }}/4))) begin
            bar_mem_q <= bar_mem[bar_addr[31:2]];
        end
    end

    // ------------------------------------------------------------
    // Custom window bus out
    // ------------------------------------------------------------
    assign custom_win_sel   = bar_access_cust;
    assign custom_win_addr  = bar_addr[11:0];
    assign custom_win_wdata = bar_wr_data;
    assign custom_win_be    = bar_wr_be;
    assign custom_win_we    = bar_wr_en  && bar_access_cust;
    assign custom_win_re    = bar_rd_en  && bar_access_cust;

    // ------------------------------------------------------------
    // Read data mux
    // ------------------------------------------------------------
    always_comb begin
        unique case (1'b1)
            bar_access_cfg  : bar_rd_data = cfg_shdw_rdata;
            bar_access_msix : bar_rd_data = msix_tbl_rdata;
            bar_access_cust : bar_rd_data = custom_win_rdata;
            bar_access_mem  : bar_rd_data = bar_mem_q;
            default         : bar_rd_data = 32'h00000000;
        endcase
    end

{% if device_config is defined and (device_config.enable_perf_counters | default(false, true)) %}
    // ------------------------------------------------------------
    // Lightweight performance counters for BAR transactions
    // ------------------------------------------------------------
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            perf_rd_count <= 32'h0;
            perf_wr_count <= 32'h0;
        end else begin
            if (bar_rd_en && bar_access_mem) begin
                perf_rd_count <= perf_rd_count + 32'd1;
            end
            if (bar_wr_en && bar_access_mem) begin
                perf_wr_count <= perf_wr_count + 32'd1;
            end
        end
    end
{% else %}
    // Performance counters disabled in configuration
{% endif %}

    // ------------------------------------------------------------
    // Initial BAR memory clear (simulation only)
    // ------------------------------------------------------------
`ifdef XILINX_SIMULATOR
    initial begin
        for (int i=0; i<({{ BAR_APERTURE_SIZE }}/4); i++) bar_mem[i] = 32'h0;
    end
`endif

    // ------------------------------------------------------------
    // Helper task for SW models
    // ------------------------------------------------------------
    task automatic trigger_msix_interrupt(input logic [10:0] vec);
        if (vec < NUM_MSIX) msix_tbl.trigger_interrupt(vec);
    endtask

endmodule
{% else %}
module pcileech_tlps128_bar_controller #(
    // BAR Configuration Parameters
    parameter BAR_APERTURE_SIZE = {{ bar_config.aperture_size | default(65536) }},
    parameter BAR_INDEX = {{ bar_config.bar_index | default(0) }},
    parameter BAR_TYPE = {{ bar_config.bar_type | default(0) }}, // 0=32-bit, 1=64-bit
    parameter BAR_PREFETCHABLE = {{ '1\'b1' if bar_config.prefetchable | default(false) else '1\'b0' }},
    
    // MSI-X Configuration
    parameter NUM_MSIX = {{ msix_config.num_vectors | default(4) }},
    parameter MSIX_TABLE_BIR = {{ msix_config.table_bir | default(0) }},
    parameter MSIX_TABLE_OFFSET = {{ (msix_config.table_offset | default(4096)) | sv_hex(32) }},
    parameter MSIX_PBA_BIR = {{ msix_config.pba_bir | default(0) }},
    parameter MSIX_PBA_OFFSET = {{ (msix_config.pba_offset | default(8192)) | sv_hex(32) }},
    // Precompute PBA dword span once to avoid recomputation in logic
    parameter integer MSIX_PBA_DWORDS = ((NUM_MSIX + 31) / 32),
    
    // Address map compatibility (top-level wrapper expectations)
    // top 4 KB reserved for cfg space shadow, next-to-top 4 KB for custom regs
    // Provide safe defaults when not explicitly set in context
    // Derive defaults from the BAR aperture so we never hardcode device-unique values
    // Default CONFIG_SHDW_HI = index of the top 4KB page within BAR
    parameter CONFIG_SHDW_HI  = {% if CONFIG_SHDW_HI is defined %}{{ CONFIG_SHDW_HI }}{% else %}((BAR_APERTURE_SIZE >> 12) - 1){% endif %},
    // Default CUSTOM_WIN_BASE = next-to-top 4KB page within BAR
    parameter CUSTOM_WIN_BASE = {% if CUSTOM_WIN_BASE is defined %}{{ CUSTOM_WIN_BASE }}{% else %}(CONFIG_SHDW_HI - 1){% endif %},
    
    // Unmapped region default read value (configurable)
    parameter DEFAULT_UNMAPPED_VALUE = 32'h00000000,
    
    // PCILeech Memory Layout
    parameter DEVICE_CTRL_BASE = 32'h00000000,  // Device Control Region
    parameter DEVICE_CTRL_SIZE = 32'h00000100,  // 256 bytes
    parameter STATUS_REG_BASE = 32'h00000100,   // Status Registers
    parameter STATUS_REG_SIZE = 32'h00000100,   // 256 bytes
    parameter DATA_BUFFER_BASE = 32'h00000200,  // Data Buffer
    parameter DATA_BUFFER_SIZE = 32'h00000200,  // 512 bytes
    parameter CUSTOM_REGION_BASE = 32'h00000400, // Custom PIO Region
    parameter CUSTOM_REGION_SIZE = 32'h00000C00, // 3KB
    
    // Device-Specific Timing Parameters
    parameter READ_LATENCY = {{ timing_config.read_latency | default(4) }},
    parameter WRITE_LATENCY = {{ timing_config.write_latency | default(2) }},
    parameter BURST_LENGTH = {{ timing_config.burst_length | default(16) }},
    parameter INTER_BURST_GAP = {{ timing_config.inter_burst_gap | default(8) }},
    
    // Performance and Error Handling
    parameter ENABLE_PERFORMANCE_COUNTERS = {{ '1\'b1' if device_config.enable_perf_counters else '1\'b0' }},
    parameter TIMEOUT_CYCLES = {{ timing_config.timeout_cycles | default(1024) }}
) (
    // Clock and Reset
    input  wire                 clk,
    input  wire                 reset_n,
    
    // PCIe TLP 128-bit Interface
    input  wire                 tlp_rx_valid,
    input  wire  [127:0]        tlp_rx_data,
    input  wire                 tlp_rx_sop,
    input  wire                 tlp_rx_eop,
    input  wire  [3:0]          tlp_rx_empty,
    input  wire                 tlp_rx_err,
    output logic                tlp_rx_ready,
    
    output logic                tlp_tx_valid,
    output logic [127:0]        tlp_tx_data,
    output logic                tlp_tx_sop,
    output logic                tlp_tx_eop,
    output logic [3:0]          tlp_tx_empty,
    input  wire                 tlp_tx_ready,
    output logic                tlp_tx_err,
    
    // BAR Access Interface
    input  wire  [31:0]         bar_addr,
    input  wire  [31:0]         bar_wr_data,
    input  wire  [3:0]          bar_wr_be,
    input  wire                 bar_wr_en,
    input  wire                 bar_rd_en,
    output logic [31:0]         bar_rd_data,
    output logic                bar_rd_valid,
    
    // Configuration Space Interface
    input  wire                 cfg_ext_read_received,
    input  wire                 cfg_ext_write_received,
    input  wire  [9:0]          cfg_ext_register_number,
    input  wire  [3:0]          cfg_ext_function_number,
    input  wire  [31:0]         cfg_ext_write_data,
    input  wire  [3:0]          cfg_ext_write_byte_enable,
    output logic [31:0]         cfg_ext_read_data,
    output logic                cfg_ext_read_data_valid,
    
    // MSI-X Interrupt Interface
    output logic                msix_interrupt,
    output logic [10:0]         msix_vector,
    input  wire                 msix_interrupt_ack,
    
    // --- Custom window hook (compatibility with basic controller) ---------
    output logic                custom_win_sel,
    output logic [11:0]         custom_win_addr,
    output logic [31:0]         custom_win_wdata,
    output logic [3:0]          custom_win_be,
    output logic                custom_win_we,
    output logic                custom_win_re,
    input  wire  [31:0]         custom_win_rdata,
    
    // PCILeech Control Interface
    input  wire                 pcileech_enable,
    input  wire  [31:0]         pcileech_command,
    input  wire  [63:0]         pcileech_address,
    input  wire  [31:0]         pcileech_length,
    output logic [31:0]         pcileech_status,
    output logic                pcileech_ready,
    
    // DMA Interface
    output logic                dma_read_req,
    output logic [63:0]         dma_read_addr,
    output logic [31:0]         dma_read_len,
    input  wire                 dma_read_ack,
    input  wire  [127:0]        dma_read_data,
    input  wire                 dma_read_valid,
    
    output logic                dma_write_req,
    output logic [63:0]         dma_write_addr,
    output logic [31:0]         dma_write_len,
    output logic [127:0]        dma_write_data,
    input  wire                 dma_write_ack,
    
    // Status and Debug
    output logic [31:0]         error_status,
    output logic [31:0]         performance_counter_0,
    output logic [31:0]         performance_counter_1,
    output logic [7:0]          debug_state
);

    // ========================================================================
    // Local Parameters and Type Definitions
    // ========================================================================
    // Device signature constant, used in status/debug registers
    // Force into a sized SV hex literal to avoid malformed tokens
    localparam [31:0] DEVICE_SIGNATURE = {{ _device_signature_literal }};
    
    // TLP Types
    localparam [4:0] TLP_MEM_READ_32    = 5'b00000;
    localparam [4:0] TLP_MEM_READ_64    = 5'b00001;
    localparam [4:0] TLP_MEM_WRITE_32   = 5'b01000;
    localparam [4:0] TLP_MEM_WRITE_64   = 5'b01001;
    localparam [4:0] TLP_COMPLETION     = 5'b01010;
    localparam [4:0] TLP_COMPLETION_DATA = 5'b01011;
    
    // PCILeech Command Opcodes
    localparam [7:0] PCILEECH_CMD_READ      = 8'h01;
    localparam [7:0] PCILEECH_CMD_WRITE     = 8'h02;
    localparam [7:0] PCILEECH_CMD_PROBE     = 8'h03;
    localparam [7:0] PCILEECH_CMD_WRITE_SCATTER = 8'h04;
    localparam [7:0] PCILEECH_CMD_READ_SCATTER  = 8'h05;
    localparam [7:0] PCILEECH_CMD_EXEC      = 8'h06;
    localparam [7:0] PCILEECH_CMD_STATUS    = 8'h07;
    
    // PCI Command Register Bit Fields
    localparam int CMD_REG_IO_SPACE_ENABLE     = 0;
    localparam int CMD_REG_MEMORY_SPACE_ENABLE = 1;
    localparam int CMD_REG_BUS_MASTER_ENABLE   = 2;
    localparam int CMD_REG_SPECIAL_CYCLE_EN    = 3;
    localparam int CMD_REG_MEM_WRITE_INV_EN    = 4;
    localparam int CMD_REG_VGA_PALETTE_SNOOP   = 5;
    localparam int CMD_REG_PARITY_ERR_RESP     = 6;
    localparam int CMD_REG_IDSEL_STEPPING      = 7;
    localparam int CMD_REG_SERR_ENABLE         = 8;
    localparam int CMD_REG_FAST_BACK2BACK_EN   = 9;
    localparam int CMD_REG_INTERRUPT_DISABLE   = 10;
    
    // PCI Command Register Reserved Fields
    localparam [4:0] CMD_REG_RESERVED_15_11    = 5'h00;  // Bits 15:11
    localparam [3:0] CMD_REG_RESERVED_9_6      = 4'h0;   // Bits 9:6
    localparam       CMD_REG_RESERVED_0        = 1'h0;   // Bit 0 (I/O Space Enable)
    
    // Memory Region Selectors
    typedef enum logic [3:0] {
        REGION_DEVICE_CTRL,
        REGION_STATUS_REG,
        REGION_DATA_BUFFER,
        REGION_CUSTOM_PIO,
        REGION_MSIX_TABLE,
        REGION_MSIX_PBA,
        REGION_CONFIG_SHADOW,
        REGION_GENERAL_MEM,
        REGION_INVALID
    } region_select_t;
    
    // State Machine States
    typedef enum logic [3:0] {
        STATE_IDLE,
        STATE_TLP_DECODE,
        STATE_ADDRESS_DECODE,
        STATE_READ_PROCESS,
        STATE_WRITE_PROCESS,
        STATE_COMPLETION_GEN,
        STATE_DMA_READ,
        STATE_DMA_WRITE,
        STATE_ERROR_HANDLE,
        STATE_PCILEECH_EXEC
    } controller_state_t;
    
    // ========================================================================
    // Internal Signal Declarations
    // ========================================================================
    
    // State Machine
    controller_state_t current_state, next_state;
    
    // TLP Parsing
    logic [127:0]       tlp_header;
    logic [4:0]         tlp_type;
    logic [2:0]         tlp_tc;
    logic               tlp_td, tlp_ep, tlp_attr, tlp_th;
    logic [9:0]         tlp_length;
    logic [15:0]        tlp_requester_id;
    logic [7:0]         tlp_tag;
    logic [3:0]         tlp_first_be, tlp_last_be;
    logic [63:0]        tlp_address;
    logic [127:0]       tlp_data;
    
    // Address Decoding
    region_select_t     target_region;
    logic [31:0]        region_offset;
    logic               address_valid;
    
    // Memory Regions
    (* ram_style = "block" *) logic [31:0] device_ctrl_mem [0:(DEVICE_CTRL_SIZE/4)-1];
    (* ram_style = "block" *) logic [31:0] status_reg_mem [0:(STATUS_REG_SIZE/4)-1];
    (* ram_style = "block" *) logic [31:0] data_buffer_mem [0:(DATA_BUFFER_SIZE/4)-1];
    (* ram_style = "block" *) logic [31:0] custom_region_mem [0:(CUSTOM_REGION_SIZE/4)-1];
    
    // PCILeech Control Registers
    logic [31:0]        pcileech_ctrl_reg;
    logic [31:0]        pcileech_stat_reg;
    logic [63:0]        pcileech_addr_reg;
    logic [31:0]        pcileech_len_reg;
    logic [31:0]        pcileech_data_reg;
    
    // Performance Counters
    logic [31:0]        perf_counter_0;
    logic [31:0]        perf_counter_1;
    logic [31:0]        read_count;
    logic [31:0]        write_count;
    logic [31:0]        error_count;
    
    // Timing Control
    logic [15:0]        timing_counter;
    logic [7:0]         burst_counter;
    logic               timing_active;
    logic               burst_in_progress;
    
    // Error Handling
    logic [31:0]        error_status_reg;
    logic               timeout_error;
    logic               address_error;
    logic               tlp_error;
    logic [15:0]        timeout_counter;
    
    // MSI-X Integration
    logic               msix_table_access;
    logic               msix_pba_access;
    logic [31:0]        msix_table_data;
    logic [31:0]        msix_pba_data;
    
    // Configuration Space Shadow
    logic               cfg_shadow_access;
    logic [31:0]        cfg_shadow_data;
    
    // Debug monitoring
    logic [31:0]        prev_pcileech_command;

    // --------------------------------------------------------------------
    // Default tie-offs for custom window interface (not used internally)
    // --------------------------------------------------------------------
    assign custom_win_sel   = 1'b0;
    assign custom_win_addr  = 12'h000;
    assign custom_win_wdata = 32'h0000_0000;
    assign custom_win_be    = 4'h0;
    assign custom_win_we    = 1'b0;
    assign custom_win_re    = 1'b0;
    
    // ========================================================================
    // Command Register Bit Extraction
    // ========================================================================
    
    // Extract command register bits from pcileech_command input
    logic cfg_bus_master_enable_dynamic;
    logic cfg_memory_space_enable_dynamic;
    logic cfg_interrupt_disable_dynamic;
    
    always_comb begin
        // Extract individual bits from pcileech_command (PCI command register format)
        cfg_bus_master_enable_dynamic = pcileech_command[2];     // Bit 2: Bus Master Enable
        cfg_memory_space_enable_dynamic = pcileech_command[1];   // Bit 1: Memory Space Enable
        cfg_interrupt_disable_dynamic = pcileech_command[10];    // Bit 10: Interrupt Disable
    end
    
    // ========================================================================
    // TLP Parsing and Decoding
    // ========================================================================
    
    // TLP Header Parsing
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            tlp_header <= '0;
            tlp_type <= '0;
            tlp_tc <= '0;
            tlp_td <= '0;
            tlp_ep <= '0;
            tlp_attr <= '0;
            tlp_th <= '0;
            tlp_length <= '0;
            tlp_requester_id <= '0;
            tlp_tag <= '0;
            tlp_first_be <= '0;
            tlp_last_be <= '0;
            tlp_address <= '0;
            tlp_data <= '0;
        end else if (tlp_rx_valid && tlp_rx_ready && tlp_rx_sop) begin
            tlp_header <= tlp_rx_data;
            
            // Parse TLP header fields
            tlp_type <= tlp_rx_data[127:123];
            tlp_tc <= tlp_rx_data[122:120];
            tlp_td <= tlp_rx_data[119];
            tlp_ep <= tlp_rx_data[118];
            tlp_attr <= tlp_rx_data[117];
            tlp_th <= tlp_rx_data[116];
            tlp_length <= tlp_rx_data[105:96];
            tlp_requester_id <= tlp_rx_data[95:80];
            tlp_tag <= tlp_rx_data[79:72];
            tlp_first_be <= tlp_rx_data[71:68];
            tlp_last_be <= tlp_rx_data[67:64];
            
            // Extract address based on TLP type
            if (tlp_rx_data[127:123] == TLP_MEM_READ_64 || tlp_rx_data[127:123] == TLP_MEM_WRITE_64) begin
                tlp_address <= {tlp_rx_data[63:32], tlp_rx_data[31:2], 2'b00};
            end else begin
                tlp_address <= {32'h00000000, tlp_rx_data[63:34], 2'b00};
            end
        end else if (tlp_rx_valid && tlp_rx_ready && !tlp_rx_sop) begin
            tlp_data <= tlp_rx_data;
        end
    end
    
    // ========================================================================
    // Address Decoding and Region Selection
    // ========================================================================
    // Registered decode to avoid races on tlp_address and to shorten comb paths
    region_select_t     target_region_r;
    logic [31:0]        region_offset_r;
    logic               address_valid_r;

    always_comb begin
        target_region = REGION_INVALID;
        region_offset = '0;
        address_valid = 1'b0;
        
        if (tlp_address >= DEVICE_CTRL_BASE && 
            tlp_address < (DEVICE_CTRL_BASE + DEVICE_CTRL_SIZE)) begin
            target_region = REGION_DEVICE_CTRL;
            region_offset = tlp_address - DEVICE_CTRL_BASE;
            address_valid = 1'b1;
        end else if (tlp_address >= STATUS_REG_BASE && 
                     tlp_address < (STATUS_REG_BASE + STATUS_REG_SIZE)) begin
            target_region = REGION_STATUS_REG;
            region_offset = tlp_address - STATUS_REG_BASE;
            address_valid = 1'b1;
        end else if (tlp_address >= DATA_BUFFER_BASE && 
                     tlp_address < (DATA_BUFFER_BASE + DATA_BUFFER_SIZE)) begin
            target_region = REGION_DATA_BUFFER;
            region_offset = tlp_address - DATA_BUFFER_BASE;
            address_valid = 1'b1;
        end else if (tlp_address >= CUSTOM_REGION_BASE && 
                     tlp_address < (CUSTOM_REGION_BASE + CUSTOM_REGION_SIZE)) begin
            target_region = REGION_CUSTOM_PIO;
            region_offset = tlp_address - CUSTOM_REGION_BASE;
            address_valid = 1'b1;
        end else if (tlp_address >= MSIX_TABLE_OFFSET && 
                     tlp_address < (MSIX_TABLE_OFFSET + NUM_MSIX * 16)) begin
            target_region = REGION_MSIX_TABLE;
            region_offset = tlp_address - MSIX_TABLE_OFFSET;
            address_valid = 1'b1;
        end else if (tlp_address >= MSIX_PBA_OFFSET && 
                     tlp_address < (MSIX_PBA_OFFSET + (MSIX_PBA_DWORDS * 4))) begin
            target_region = REGION_MSIX_PBA;
            region_offset = tlp_address - MSIX_PBA_OFFSET;
            address_valid = 1'b1;
        end else if (tlp_address < BAR_APERTURE_SIZE) begin
            target_region = REGION_GENERAL_MEM;
            region_offset = tlp_address;
            address_valid = 1'b1;
        end
    end

    // Register the decode results to remove long comb paths to multiple consumers
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            target_region_r <= REGION_INVALID;
            region_offset_r <= '0;
            address_valid_r <= 1'b0;
        end else begin
            target_region_r <= target_region;
            region_offset_r <= region_offset;
            address_valid_r <= address_valid;
        end
    end
    
    // ========================================================================
    // Main Controller State Machine
    // ========================================================================
    // Register all external interface outputs via next-value staging
    logic                tlp_rx_ready_n;
    logic                tlp_tx_valid_n;
    logic [127:0]        tlp_tx_data_n;
    logic                tlp_tx_sop_n;
    logic                tlp_tx_eop_n;
    logic [3:0]          tlp_tx_empty_n;
    logic                tlp_tx_err_n;

    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            current_state <= STATE_IDLE;
            // Initialize registered outputs
            tlp_rx_ready <= 1'b0;
            tlp_tx_valid <= 1'b0;
            tlp_tx_data  <= '0;
            tlp_tx_sop   <= 1'b0;
            tlp_tx_eop   <= 1'b0;
            tlp_tx_empty <= '0;
            tlp_tx_err   <= 1'b0;
        end else begin
            current_state <= next_state;
            // Update registered outputs
            tlp_rx_ready <= tlp_rx_ready_n;
            tlp_tx_valid <= tlp_tx_valid_n;
            tlp_tx_data  <= tlp_tx_data_n;
            tlp_tx_sop   <= tlp_tx_sop_n;
            tlp_tx_eop   <= tlp_tx_eop_n;
            tlp_tx_empty <= tlp_tx_empty_n;
            tlp_tx_err   <= tlp_tx_err_n;
        end
    end
    
    always_comb begin
        // Local scratch signals (declare before any statements for tool compatibility)
        logic [7:0] cmd_opcode;
        logic       is_read_tlp;

        next_state = current_state;
        tlp_rx_ready_n = 1'b0;
        tlp_tx_valid_n = 1'b0;
        tlp_tx_data_n = '0;
        tlp_tx_sop_n = 1'b0;
        tlp_tx_eop_n = 1'b0;
        tlp_tx_empty_n = '0;
        tlp_tx_err_n = 1'b0;
        // Decode command opcode once for clarity
        cmd_opcode = pcileech_command[7:0];
        // Is current parsed TLP a Memory Read request?
        is_read_tlp = (tlp_type == TLP_MEM_READ_32) || (tlp_type == TLP_MEM_READ_64);
        
        case (current_state)
            STATE_IDLE: begin
                tlp_rx_ready_n = 1'b1;
                if (tlp_rx_valid && tlp_rx_sop) begin
                    next_state = STATE_TLP_DECODE;
                end else if (pcileech_enable) begin
                    unique case (cmd_opcode)
                        PCILEECH_CMD_READ,
                        PCILEECH_CMD_WRITE,
                        PCILEECH_CMD_PROBE,
                        PCILEECH_CMD_STATUS,
                        PCILEECH_CMD_EXEC: begin
                            next_state = STATE_PCILEECH_EXEC;
                        end
                        default: /* no-op */ ;
                    endcase
                end
            end
            
            STATE_TLP_DECODE: begin
                tlp_rx_ready_n = 1'b1;
                next_state = STATE_ADDRESS_DECODE;
            end
            
            STATE_ADDRESS_DECODE: begin
                if (address_valid_r) begin
                    if (tlp_type == TLP_MEM_READ_32 || tlp_type == TLP_MEM_READ_64) begin
                        next_state = STATE_READ_PROCESS;
                    end else if (tlp_type == TLP_MEM_WRITE_32 || tlp_type == TLP_MEM_WRITE_64) begin
                        next_state = STATE_WRITE_PROCESS;
                    end else begin
                        next_state = STATE_ERROR_HANDLE;
                    end
                end else begin
                    next_state = STATE_ERROR_HANDLE;
                end
            end
            
            STATE_READ_PROCESS: begin
                // Process read based on target region
                next_state = STATE_COMPLETION_GEN;
            end
            
            STATE_WRITE_PROCESS: begin
                tlp_rx_ready_n = 1'b1;
                if (tlp_rx_valid && tlp_rx_eop) begin
                    // Memory Writes are posted; no Completion on PCIe
                    next_state = STATE_IDLE;
                end
            end
            
            STATE_COMPLETION_GEN: begin
                // Only emit a Completion when servicing a TLP Read
                if (is_read_tlp) begin
                    tlp_tx_valid_n = 1'b1;
                    tlp_tx_sop_n = 1'b1;
                    tlp_tx_eop_n = 1'b1;
                    // Minimal CplD: return 1DW from selected region
                    // Header fields follow the simplified mapping used in parsing
                    tlp_tx_data_n[127:123] = TLP_COMPLETION_DATA; // CplD
                    tlp_tx_data_n[122:120] = tlp_tc;              // propagate TC
                    tlp_tx_data_n[119]     = 1'b0;                // TD
                    tlp_tx_data_n[118]     = 1'b0;                // EP
                    tlp_tx_data_n[117]     = 1'b0;                // Attr (simplified)
                    tlp_tx_data_n[116]     = 1'b0;                // TH
                    // Length in DW (1 DW payload)
                    tlp_tx_data_n[105:96]  = 10'd1;
                    tlp_tx_data_n[95:80]   = tlp_requester_id;    // echo requester
                    tlp_tx_data_n[79:72]   = tlp_tag;             // echo tag
                    // Place 1DW payload in [31:0]
                    // Data selection computed below in read_data_word
                    tlp_tx_data_n[31:0]    = read_data_word;
                    if (tlp_tx_ready) begin
                        next_state = STATE_IDLE;
                    end
                end else begin
                    // For non-read paths (e.g., DMA/exec), no PCIe completion is emitted
                    next_state = STATE_IDLE;
                end
            end
            
            STATE_DMA_READ: begin
                // Handle DMA read operations
                if (dma_read_ack) begin
                    // Internal DMA ack; no PCIe completion needed
                    next_state = STATE_IDLE;
                end
            end
            
            STATE_DMA_WRITE: begin
                // Handle DMA write operations
                if (dma_write_ack) begin
                    // Internal DMA ack; no PCIe completion needed
                    next_state = STATE_IDLE;
                end
            end
            
            STATE_ERROR_HANDLE: begin
                // Generate error completion
                tlp_tx_valid_n = 1'b1;
                tlp_tx_sop_n = 1'b1;
                tlp_tx_eop_n = 1'b1;
                tlp_tx_err_n = 1'b1;
                if (tlp_tx_ready) begin
                    next_state = STATE_IDLE;
                end
            end
            
            STATE_PCILEECH_EXEC: begin
                // Execute PCILeech commands
                // Branch based on current opcode; register updates happen in the separate always_ff block
                unique case (pcileech_command[7:0])
                    PCILEECH_CMD_READ:  next_state = STATE_DMA_READ;
                    PCILEECH_CMD_WRITE: next_state = STATE_DMA_WRITE;
                    PCILEECH_CMD_PROBE,
                    PCILEECH_CMD_STATUS,
                    PCILEECH_CMD_EXEC:  next_state = STATE_IDLE;
                    default:            next_state = STATE_ERROR_HANDLE;
                endcase
            end
        endcase
    end

    // Selected 1DW read data used for minimal CplD payload
    logic [31:0] read_data_word;
    always_comb begin
        unique case (target_region_r)
            REGION_DEVICE_CTRL: read_data_word = device_ctrl_rdata;
            REGION_STATUS_REG:  read_data_word = status_reg_rdata;
            REGION_DATA_BUFFER: read_data_word = data_buffer_rdata;
            REGION_MSIX_TABLE:  read_data_word = msix_table_data;
            REGION_MSIX_PBA:    read_data_word = msix_pba_data;
            default:            read_data_word = DEFAULT_UNMAPPED_VALUE;
        endcase
    end
    
    // ========================================================================
    // Memory Region Access Logic
    // ========================================================================
    
    // Device Control Region Access
    logic [31:0] device_ctrl_rdata;
    always_ff @(posedge clk) begin
        if (current_state == STATE_WRITE_PROCESS && target_region_r == REGION_DEVICE_CTRL) begin
            if (region_offset_r[31:2] < (DEVICE_CTRL_SIZE/4)) begin
                // Apply byte enables for 32-bit data
                logic [31:0] w = device_ctrl_mem[region_offset_r[31:2]];
                if (tlp_first_be[0]) w[7:0]   = tlp_data[7:0];
                if (tlp_first_be[1]) w[15:8]  = tlp_data[15:8];
                if (tlp_first_be[2]) w[23:16] = tlp_data[23:16];
                if (tlp_first_be[3]) w[31:24] = tlp_data[31:24];
                device_ctrl_mem[region_offset_r[31:2]] <= w;
            end
        end
    end
    
    always_comb begin
        device_ctrl_rdata = '0;
        if (target_region_r == REGION_DEVICE_CTRL && region_offset_r[31:2] < (DEVICE_CTRL_SIZE/4)) begin
            device_ctrl_rdata = device_ctrl_mem[region_offset_r[31:2]];
        end
    end
    
    // Status Register Region Access
    logic [31:0] status_reg_rdata;
    always_ff @(posedge clk) begin
        if (current_state == STATE_WRITE_PROCESS && target_region_r == REGION_STATUS_REG) begin
            if (region_offset_r[31:2] < (STATUS_REG_SIZE/4)) begin
                logic [31:0] w = status_reg_mem[region_offset_r[31:2]];
                if (tlp_first_be[0]) w[7:0]   = tlp_data[7:0];
                if (tlp_first_be[1]) w[15:8]  = tlp_data[15:8];
                if (tlp_first_be[2]) w[23:16] = tlp_data[23:16];
                if (tlp_first_be[3]) w[31:24] = tlp_data[31:24];
                status_reg_mem[region_offset_r[31:2]] <= w;
            end
        end
    end
    
    always_comb begin
        status_reg_rdata = '0;
        if (target_region_r == REGION_STATUS_REG) begin
            case (region_offset_r[7:2])
                6'h00: status_reg_rdata = pcileech_stat_reg;
                6'h01: status_reg_rdata = error_status_reg;
                6'h02: status_reg_rdata = perf_counter_0;
                6'h03: status_reg_rdata = perf_counter_1;
                6'h04: status_reg_rdata = read_count;
                6'h05: status_reg_rdata = write_count;
                6'h06: status_reg_rdata = error_count;
                6'h07: status_reg_rdata = DEVICE_SIGNATURE;
                default: begin
                    if (region_offset_r[31:2] < (STATUS_REG_SIZE/4)) begin
                        status_reg_rdata = status_reg_mem[region_offset_r[31:2]];
                    end
                end
            endcase
        end
    end
    
    // Data Buffer Region Access
    logic [31:0] data_buffer_rdata;
    always_ff @(posedge clk) begin
        if (current_state == STATE_WRITE_PROCESS && target_region_r == REGION_DATA_BUFFER) begin
            if (region_offset_r[31:2] < (DATA_BUFFER_SIZE/4)) begin
                logic [31:0] w = data_buffer_mem[region_offset_r[31:2]];
                if (tlp_first_be[0]) w[7:0]   = tlp_data[7:0];
                if (tlp_first_be[1]) w[15:8]  = tlp_data[15:8];
                if (tlp_first_be[2]) w[23:16] = tlp_data[23:16];
                if (tlp_first_be[3]) w[31:24] = tlp_data[31:24];
                data_buffer_mem[region_offset_r[31:2]] <= w;
            end
        end
    end
    
    always_comb begin
        data_buffer_rdata = '0;
        if (target_region_r == REGION_DATA_BUFFER && region_offset_r[31:2] < (DATA_BUFFER_SIZE/4)) begin
            data_buffer_rdata = data_buffer_mem[region_offset_r[31:2]];
        end
    end
    
    // ========================================================================
    // Device-Specific Timing Pattern Implementation
    // ========================================================================
    
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            timing_counter <= '0;
            burst_counter <= '0;
            timing_active <= 1'b1;
            burst_in_progress <= 1'b0;
        end else begin
            // Implement device-specific timing patterns from behavior profiler
            if (timing_active) begin
                if (burst_in_progress) begin
                    if (burst_counter < BURST_LENGTH-1) begin
                        burst_counter <= burst_counter + 1;
                    end else begin
                        burst_in_progress <= 1'b0;
                        burst_counter <= '0;
                        timing_counter <= '0;
                    end
                end else begin
                    if (timing_counter < INTER_BURST_GAP-1) begin
                        timing_counter <= timing_counter + 1;
                    end else begin
                        burst_in_progress <= 1'b1;
                        timing_counter <= '0;
                    end
                end
            end
        end
    end
    
    // ========================================================================
    // PCILeech Command Processing
    // ========================================================================
    
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            pcileech_ctrl_reg <= '0;
            pcileech_stat_reg <= '0;
            pcileech_addr_reg <= '0;
            pcileech_len_reg <= '0;
            pcileech_data_reg <= '0;
        end else begin
            // Update PCILeech control registers based on commands
            if (pcileech_enable && current_state == STATE_PCILEECH_EXEC) begin
                case (pcileech_command[7:0])
                    PCILEECH_CMD_READ: begin
                        pcileech_addr_reg <= pcileech_address;
                        pcileech_len_reg <= pcileech_length;
                        pcileech_stat_reg[0] <= 1'b1; // Busy
                    end
                    PCILEECH_CMD_WRITE: begin
                        pcileech_addr_reg <= pcileech_address;
                        pcileech_len_reg <= pcileech_length;
                        pcileech_stat_reg[0] <= 1'b1; // Busy
                    end
                    PCILEECH_CMD_PROBE: begin
                        pcileech_data_reg <= DEVICE_SIGNATURE;
                        pcileech_stat_reg[1] <= 1'b1; // Ready
                    end
                    PCILEECH_CMD_STATUS: begin
                        pcileech_stat_reg[2] <= 1'b1; // Status available
                    end
                endcase
            end
        end
    end
    
    assign pcileech_status = pcileech_stat_reg;
    assign pcileech_ready = pcileech_stat_reg[1];
    
    // ========================================================================
    // MSI-X Integration
    // ========================================================================
    
    // MSI-X capability runtime registers
    // Capture writes to MSI-X Message Control and expose enable/mask outputs.
    localparam [9:0] MSIX_CAP_REG = 10'h1C; // 0x70 >> 2

    logic        msix_cap_wr;
    logic [31:0] msix_cap_addr;
    logic [31:0] msix_cap_wdata;
    logic [3:0]  msix_cap_be;
    logic        msix_enabled;
    logic        msix_function_mask;
    wire  [10:0] msix_table_size_ro;

    assign msix_cap_wr    = cfg_ext_write_received &&
                             (cfg_ext_register_number >= MSIX_CAP_REG) &&
                             (cfg_ext_register_number <= (MSIX_CAP_REG + 4));
    assign msix_cap_addr  = {28'h0, (cfg_ext_register_number - MSIX_CAP_REG), 2'b00};
    assign msix_cap_wdata = cfg_ext_write_data;
    assign msix_cap_be    = cfg_ext_write_byte_enable;

    msix_capability_registers #(
        .TABLE_SIZE_MINUS_ONE (NUM_MSIX-1),
        .TABLE_OFFSET_BIR     (MSIX_TABLE_OFFSET + MSIX_TABLE_BIR),
        .PBA_OFFSET_BIR       (MSIX_PBA_OFFSET + MSIX_PBA_BIR)
    ) msix_caps (
        .clk                (clk),
        .reset_n            (reset_n),
        .msix_cap_wr        (msix_cap_wr),
        .msix_cap_addr      (msix_cap_addr),
        .msix_cap_wdata     (msix_cap_wdata),
        .msix_cap_be        (msix_cap_be),
        .msix_cap_rdata     (/* unused for now */),
        .msix_enable        (msix_enabled),
        .msix_function_mask (msix_function_mask),
        .msix_table_size    (msix_table_size_ro)
    );

    // MSI-X Table Access
    // Register write/read enables to avoid comb control paths into submodule
    logic msix_table_wr_en_r, msix_table_rd_en_r;
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            msix_table_wr_en_r <= 1'b0;
            msix_table_rd_en_r <= 1'b0;
        end else begin
            msix_table_wr_en_r <= (current_state == STATE_WRITE_PROCESS && target_region_r == REGION_MSIX_TABLE);
            msix_table_rd_en_r <= (current_state == STATE_READ_PROCESS  && target_region_r == REGION_MSIX_TABLE);
        end
    end
    msix_table #(
        .NUM_MSIX(NUM_MSIX),
        .MSIX_TABLE_BIR(MSIX_TABLE_BIR),
        .MSIX_TABLE_OFFSET(MSIX_TABLE_OFFSET),
        .MSIX_PBA_BIR(MSIX_PBA_BIR),
        .MSIX_PBA_OFFSET(MSIX_PBA_OFFSET)
    ) msix_table_inst (
        .clk(clk),
        .reset_n(reset_n),
        .bar_addr(tlp_address[31:0]),
        .bar_index(BAR_INDEX[2:0]),
        .bar_wr_data(tlp_data[31:0]),
        .bar_wr_en(msix_table_wr_en_r),
        .bar_wr_be(tlp_first_be),
        .bar_rd_en(msix_table_rd_en_r),
        .bar_rd_data(msix_table_data),
        .bar_access_match(msix_table_access),
        .msix_enable(msix_enabled),
        .msix_function_mask(msix_function_mask),
        .msix_interrupt(msix_interrupt),
        .msix_vector(msix_vector),
        .msix_interrupt_ack(msix_interrupt_ack),
        // No external trigger source wired in this controller; tie off.
        .trigger_valid(1'b0),
        .trigger_vector(11'h0)
    );
    
    // ========================================================================
    // Performance Counters and Error Handling
    // ========================================================================
    
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            perf_counter_0 <= '0;
            perf_counter_1 <= '0;
            read_count <= '0;
            write_count <= '0;
            error_count <= '0;
            error_status_reg <= '0;
            timeout_counter <= '0;
        end else begin
            // Performance counters
            if (ENABLE_PERFORMANCE_COUNTERS) begin
                if (current_state == STATE_READ_PROCESS) begin
                    read_count <= read_count + 1;
                    perf_counter_0 <= perf_counter_0 + 1;
                end
                if (current_state == STATE_WRITE_PROCESS) begin
                    write_count <= write_count + 1;
                    perf_counter_1 <= perf_counter_1 + 1;
                end
            end
            
            // Error detection
            if (current_state == STATE_ERROR_HANDLE) begin
                error_count <= error_count + 1;
                error_status_reg[0] <= 1'b1; // Address error
            end
            
            if (tlp_rx_err) begin
                error_status_reg[1] <= 1'b1; // TLP error
                error_count <= error_count + 1;
            end
            
            // Timeout detection
            if (current_state != STATE_IDLE) begin
                if (timeout_counter < TIMEOUT_CYCLES-1) begin
                    timeout_counter <= timeout_counter + 1;
                end else begin
                    error_status_reg[2] <= 1'b1; // Timeout error
                    error_count <= error_count + 1;
                    timeout_counter <= '0;
                end
            end else begin
                timeout_counter <= '0;
            end
            
            // Clear errors on write to error status register
            if (current_state == STATE_WRITE_PROCESS && target_region == REGION_STATUS_REG && 
                region_offset[7:2] == 6'h01 && tlp_data[31]) begin
                error_status_reg <= '0;
            end
        end
    end
    
    assign error_status = error_status_reg;
    assign performance_counter_0 = perf_counter_0;
    assign performance_counter_1 = perf_counter_1;
    
    // ========================================================================
    // BAR Interface Logic
    // ========================================================================
    logic [31:0] bar_rd_data_n;
    logic        bar_rd_valid_n;
    always_comb begin
        bar_rd_data_n = '0;
        bar_rd_valid_n = 1'b0;
        if (bar_rd_en) begin
            bar_rd_valid_n = 1'b1;
            case (target_region_r)
                REGION_DEVICE_CTRL: bar_rd_data_n = device_ctrl_rdata;
                REGION_STATUS_REG:  bar_rd_data_n = status_reg_rdata;
                REGION_DATA_BUFFER: bar_rd_data_n = data_buffer_rdata;
                REGION_MSIX_TABLE:  bar_rd_data_n = msix_table_data;
                REGION_MSIX_PBA:    bar_rd_data_n = msix_pba_data;
                default:            bar_rd_data_n = DEFAULT_UNMAPPED_VALUE;
            endcase
        end
    end
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            bar_rd_data  <= '0;
            bar_rd_valid <= 1'b0;
        end else begin
            bar_rd_data  <= bar_rd_data_n;
            bar_rd_valid <= bar_rd_valid_n;
        end
    end
    
    // ========================================================================
    // Configuration Space Interface
    // ========================================================================
    
    logic [31:0] cfg_ext_read_data_n;
    logic        cfg_ext_read_data_valid_n;
    always_comb begin
        cfg_ext_read_data_n = '0;
        cfg_ext_read_data_valid_n = 1'b0;
        if (cfg_ext_read_received) begin
            cfg_ext_read_data_valid_n = 1'b1;
            case (cfg_ext_register_number)
                10'h000: cfg_ext_read_data_n = 32'h{{ get_device_id(device_config, device, config_space, device_id_int) }}{{ get_vendor_id(device_config, device, config_space, vendor_id_int) }};
                10'h001: cfg_ext_read_data_n = {16'h{{ "%04X" % (config_space.status | default(0x0010) | int) }}, 
                                             CMD_REG_RESERVED_15_11, 
                                             cfg_interrupt_disable_dynamic, 
                                             CMD_REG_RESERVED_9_6, 
                                             cfg_bus_master_enable_dynamic, 
                                             cfg_memory_space_enable_dynamic, 
                                             CMD_REG_RESERVED_0};  // Dynamic command register
                10'h002: cfg_ext_read_data_n = 32'h{{ "%06X%02X" % ((config_space.class_code | int), (config_space.revision_id | int)) }};
                10'h040: cfg_ext_read_data_n = pcileech_ctrl_reg; // PCILeech control register
                10'h041: cfg_ext_read_data_n = pcileech_stat_reg; // PCILeech status register
                10'h042: cfg_ext_read_data_n = error_status_reg;  // Error status register
                default: cfg_ext_read_data_n = 32'h00000000;
            endcase
        end
    end
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            cfg_ext_read_data <= '0;
            cfg_ext_read_data_valid <= 1'b0;
        end else begin
            cfg_ext_read_data <= cfg_ext_read_data_n;
            cfg_ext_read_data_valid <= cfg_ext_read_data_valid_n;
        end
    end
    
    // Configuration space write handling
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            // Initialize configuration space registers
        end else if (cfg_ext_write_received) begin
            case (cfg_ext_register_number)
                10'h040: begin // PCILeech control register
                    if (cfg_ext_write_byte_enable[0]) pcileech_ctrl_reg[7:0] <= cfg_ext_write_data[7:0];
                    if (cfg_ext_write_byte_enable[1]) pcileech_ctrl_reg[15:8] <= cfg_ext_write_data[15:8];
                    if (cfg_ext_write_byte_enable[2]) pcileech_ctrl_reg[23:16] <= cfg_ext_write_data[23:16];
                    if (cfg_ext_write_byte_enable[3]) pcileech_ctrl_reg[31:24] <= cfg_ext_write_data[31:24];
                end
                10'h042: begin // Error status register (write-1-to-clear)
                    if (cfg_ext_write_byte_enable[0]) error_status_reg[7:0] <= error_status_reg[7:0] & ~cfg_ext_write_data[7:0];
                    if (cfg_ext_write_byte_enable[1]) error_status_reg[15:8] <= error_status_reg[15:8] & ~cfg_ext_write_data[15:8];
                    if (cfg_ext_write_byte_enable[2]) error_status_reg[23:16] <= error_status_reg[23:16] & ~cfg_ext_write_data[23:16];
                    if (cfg_ext_write_byte_enable[3]) error_status_reg[31:24] <= error_status_reg[31:24] & ~cfg_ext_write_data[31:24];
                end
            endcase
        end
    end
    
    // ========================================================================
    // DMA Interface Logic
    // ========================================================================
    
    logic        dma_read_req_n, dma_write_req_n;
    logic [63:0] dma_read_addr_n, dma_write_addr_n;
    logic [31:0] dma_read_len_n, dma_write_len_n;
    logic [127:0] dma_write_data_n;
    always_comb begin
        dma_read_req_n = 1'b0;
        dma_read_addr_n = '0;
        dma_read_len_n = '0;
        dma_write_req_n = 1'b0;
        dma_write_addr_n = '0;
        dma_write_len_n = '0;
        dma_write_data_n = '0;
        if (current_state == STATE_DMA_READ) begin
            dma_read_req_n = 1'b1;
            dma_read_addr_n = pcileech_addr_reg;
            dma_read_len_n = pcileech_len_reg;
        end else if (current_state == STATE_DMA_WRITE) begin
            dma_write_req_n = 1'b1;
            dma_write_addr_n = pcileech_addr_reg;
            dma_write_len_n = pcileech_len_reg;
            dma_write_data_n = {96'h0, pcileech_data_reg}; // Extend to 128-bit
        end
    end
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            dma_read_req <= 1'b0;
            dma_read_addr <= '0;
            dma_read_len <= '0;
            dma_write_req <= 1'b0;
            dma_write_addr <= '0;
            dma_write_len <= '0;
            dma_write_data <= '0;
        end else begin
            dma_read_req <= dma_read_req_n;
            dma_read_addr <= dma_read_addr_n;
            dma_read_len <= dma_read_len_n;
            dma_write_req <= dma_write_req_n;
            dma_write_addr <= dma_write_addr_n;
            dma_write_len <= dma_write_len_n;
            dma_write_data <= dma_write_data_n;
        end
    end

    // Update PCILeech status on DMA completion: clear busy, set ready
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            // Maintain existing reset defaults (implicitly zeroed)
        end else begin
            if ((current_state == STATE_DMA_READ  && dma_read_ack) ||
                (current_state == STATE_DMA_WRITE && dma_write_ack)) begin
                pcileech_stat_reg[0] <= 1'b0; // clear busy
                pcileech_stat_reg[1] <= 1'b1; // set ready
            end
        end
    end
    
    // ========================================================================
    // Debug and Status Output
    // ========================================================================
    
    assign debug_state = {4'h0, current_state};
    
    // ========================================================================
    // Simulation and Debug Support
    // ========================================================================
    
    {% if device_config.enable_simulation_support | default(true) %}
`ifdef XILINX_SIMULATOR
    // Initialize memory regions for simulation
    initial begin
        for (int i = 0; i < (DEVICE_CTRL_SIZE/4); i++) device_ctrl_mem[i] = 32'h0;
        for (int i = 0; i < (STATUS_REG_SIZE/4); i++) status_reg_mem[i] = 32'h0;
        for (int i = 0; i < (DATA_BUFFER_SIZE/4); i++) data_buffer_mem[i] = 32'h0;
        for (int i = 0; i < (CUSTOM_REGION_SIZE/4); i++) custom_region_mem[i] = 32'h0;
        
        // Initialize PCILeech control registers
        device_ctrl_mem[0] = 32'h00000001; // Enable PCILeech by default
    device_ctrl_mem[1] = DEVICE_SIGNATURE;
        device_ctrl_mem[2] = {{ device_config.firmware_version | default('32\'h00010000') }};
        
        // Initialize debug monitoring
        prev_pcileech_command = 32'h0;
    end
    
    // Note: simulation helper tasks that drive module inputs from within the module
    // are intentionally omitted to avoid illegal hierarchical drive. Use a separate
    // testbench to stimulate inputs.
    
    // Debug function to read memory region
    function automatic logic [31:0] read_memory_region(input region_select_t region, input logic [31:0] offset);
        case (region)
            REGION_DEVICE_CTRL: return device_ctrl_mem[offset[31:2]];
            REGION_STATUS_REG:  return status_reg_mem[offset[31:2]];
            REGION_DATA_BUFFER: return data_buffer_mem[offset[31:2]];
            REGION_CUSTOM_PIO:  return custom_region_mem[offset[31:2]];
            default:            return DEFAULT_UNMAPPED_VALUE;
        endcase
    endfunction
    
    // Debug function to get controller status
    function automatic logic [31:0] get_controller_status();
        return {24'h0, current_state, 4'h0};
    endfunction
    
    // Performance monitoring
    always @(posedge clk) begin
        if (current_state == STATE_READ_PROCESS) begin
            $display("[PCILeech BAR Controller] Read access to region %0d, offset 0x%08X at time %0t", 
                     target_region, region_offset, $time);
        end
        if (current_state == STATE_WRITE_PROCESS) begin
            $display("[PCILeech BAR Controller] Write access to region %0d, offset 0x%08X, data 0x%08X at time %0t", 
                     target_region, region_offset, tlp_data[31:0], $time);
        end
        if (current_state == STATE_ERROR_HANDLE) begin
            $display("[PCILeech BAR Controller] Error condition detected at time %0t", $time);
        end
        
        // Monitor command register bit changes
        if (pcileech_command != prev_pcileech_command) begin
            $display("[PCILeech BAR Controller] Command register changed: 0x%08X -> 0x%08X at time %0t",
                     prev_pcileech_command, pcileech_command, $time);
            $display("[PCILeech BAR Controller]   Bus Master: %b, Memory Space: %b, Interrupt Disable: %b",
                     cfg_bus_master_enable_dynamic, cfg_memory_space_enable_dynamic, cfg_interrupt_disable_dynamic);
            prev_pcileech_command = pcileech_command;
        end
    end
`endif
    {% endif %}

endmodule

`default_nettype wire
{% endif %}