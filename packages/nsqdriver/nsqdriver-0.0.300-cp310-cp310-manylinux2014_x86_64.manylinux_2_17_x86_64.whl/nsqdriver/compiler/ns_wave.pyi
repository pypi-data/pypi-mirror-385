import numpy as np
import waveforms as wf

from enum import IntEnum
from typing import Union, List, Dict
from nsqdriver.compiler.py_wave_asm import *


class QInsPlaceholder(NSQCommand):
    ...


class Wave(GenTagMixin):
    class Tag(IntEnum): ...

    def __init__(self, ins_obj: "InstructionQ", ins_id: dict): ...

class Frame(Wave):
    def __init__(self, ins_obj: "InstructionQ", ins_id: int, freq: float): ...

    @property
    def freq(self) -> float: ...

    @freq.setter
    def freq(self, value: float): ...

    def __mul__(self, other: Wave) -> Signal: ...

    def format(self) -> "NSQCommand": ...


class Envelope(Wave):
    def __init__(self, ins_obj: "InstructionQ", ins_id: int, content: "Union[wf.Waveform, np.ndarray]"): ...

    @property
    def content(self) -> "Union[wf.Waveform, np.ndarray]": ...

    @content.setter
    def content(self, value: "Union[wf.Waveform, np.ndarray]"): ...

    def __mul__(self, other: Wave) -> Signal: ...

    def format(self) -> "NSQCommand": ...


class Signal(Wave):
    def __init__(self, ins_obj: "InstructionQ", ins_id: dict): ...


class InstructionQ(GenTagMixin):
    """!
    包含各种具体的指令
    """

    def __init__(self, freqs=None, envelopes=None):
        self.i_set: "List[Union[NSQCommand, InstructionQ]]" = []
        self.f_set: "Dict[int, Frame]" = {}
        self.e_set: "Dict[int, Envelope]" = {}
        self.symbol_set: Dict[str, int] = {}
        self.symbol_idx: int = -1
        self.is_first_trig: bool = True
        self.last_ins: NSQCommand

    def clear(self) -> None: ...

    @property
    def length(self) -> int: ...

    def ins_frame(self, freq, idx=None) -> Frame: ...

    def ins_envelope(self, envelope: "Union[np.ndarray, wf.Waveform, str]", idx=None) -> Envelope: ...

    def evlp_gaussian(self, width: float) -> Envelope: ...

    def evlp_cospulse(self, width: float) -> Envelope: ...

    def evlp_square(self, width: float) -> Envelope: ...

    def _append_ins(self, cmd: "Union[NSQCommand, InstructionQ]"): ...

    def _map_var(self, var: str) -> int: ...

    def wait_for_trigger(self): ...

    def ins_variable(self, reg: str, value: int): ...

    def ins_add(self, reg: str, value: int): ...

    def ins_reset_frame(self, flag: str, frame: "Frame"): ...

    def inc_phase(self, frame: "Frame", phase: float): ...

    def play_wave(self, wave: Signal, amp=1, freq=0, phase=0): ...

    def play_zero(self, width: float): ...

    def wait(self): ...

    def end(self): ...

    def capture(self, width: float, delay=0.): ...


class InsChannel(InstructionQ):
    def __init__(self, freqs=None, envelopes=None):
        self.if_stack: "List[InsIF]" = []
        self.looping = False

    def ins_if(self, formula: str) -> "InsIF": ...

    def ins_else(self) -> "InsElse": ...

    def ins_loop(self, times: int) -> "InsLoop": ...


class InsIF(InsChannel):
    ch_judge_name = {f'FREQ_{i}': 1<<i for i in range(6)}

    def __init__(self, freqs=None, envelopes=None):
        self.channel: "InsChannel" = None
        self.key_ins: "NSQCommand" = None
        self.ins_else = None

    @classmethod
    def from_channel(cls, channel :InsChannel) -> InsIF: ...

    @property
    def formula(self): ...

    @formula.setter
    def formula(self, formula: str): ...


class InsElse(InsChannel):
    def __init__(self, freqs=None, envelopes=None): ...

    @classmethod
    def from_channel(cls, channel: InsChannel) -> InsElse: ...

    def capture(self, width: float, delay=0): ...


class InsLoop(InsChannel):
    def __init__(self, freqs: float=None, envelopes: "Union[wf.Waveform, np.ndarray]"=None): ...

    @classmethod
    def from_channel(cls, channel: InsChannel) -> InsLoop: ...

    def capture(self, width: float, delay=0): ...

    def _compile(self) -> "List[NSQCommand]": ...
