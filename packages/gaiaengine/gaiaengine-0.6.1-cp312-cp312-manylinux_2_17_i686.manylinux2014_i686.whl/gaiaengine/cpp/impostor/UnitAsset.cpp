#include "UnitAsset.h"

#include <SDL.h>

#include "utils.h"

#include <algorithm>
#include <fstream>
#include <sstream>

#define READ_BYTE(source, buffer) source.read(reinterpret_cast<char*>(&buffer), sizeof(uint8_t));

#define LOAD_PALETTE(name) Palettes.push_back(ut::loadPalette(GAIA_SOURCE_PATH + std::string("/res/palettes/" #name ".pal")));

std::vector<std::shared_ptr<SDL_Palette>> UnitAsset::Palettes;

std::shared_ptr<SDL_Surface> UnitAsset::loadSpriteSheet(const std::string& texturePath, const std::string& infoFilePath, std::vector<SpriteInfo>& currentSprites) {
  std::ifstream spriteInfoFile(infoFilePath);

  // We expect a text file of the format generated by Openage when converting AoE files to png and text files.
  // The sprite info file is a text file that has the structure of a csv file with comments
  std::string line;
  while (std::getline(spriteInfoFile, line)) {
    // Ignore comments
    if (line[0] == '#')
      continue;

    // Change the comma separator into the space one to be able to use C++ streams
    std::replace(line.begin(), line.end(), ',', ' ');

    std::istringstream iss(line);
    SpriteInfo sprite;
    iss >> sprite.x >> sprite.y >> sprite.w >> sprite.h >> sprite.anchor_x >> sprite.anchor_y;
    currentSprites.push_back(sprite);
  }

  return ut::loadImage(texturePath);
}

struct SLPHeader {
  char version[4];
  int32_t  nbFrames;
  char comment[24];
};

struct SLPFrameInfo {
  uint32_t commandTableOffset; // Position of an array of positions where you can find the first drawing command for each row
  uint32_t outlineTableOffset; // Position of an array where you define the beginning and end of each row
  uint32_t paletteOffset; // Unused
  uint32_t properties; // Palette ID
  int32_t width;
  int32_t height;
  int32_t anchorX;
  int32_t anchorY;
};

std::shared_ptr<SDL_Surface> UnitAsset::loadSLP(const std::string& filePath, std::vector<SpriteInfo>& currentSprites) {
  // This whole code is inspired from openage (their documentation and slp.pyx file)
  // https://github.com/SFTtech/openage/blob/master/doc/media/slp-files.md

  if (Palettes.empty()) {
    LOAD_PALETTE(Standard_Graphics)
    LOAD_PALETTE(AoE2-HD_Cliff)
    LOAD_PALETTE(AoE2-HD_2_OakTree)
    LOAD_PALETTE(AoE2-HD_3_PalmTree)
    LOAD_PALETTE(AoE2-HD_4_PineTree)
    LOAD_PALETTE(AoE2-HD_5_SnowPineTree)
    LOAD_PALETTE(AoE2-HD_6_FireEffects)
  }


  std::ifstream input(filePath, std::ios::binary);
  if (input.is_open()) {
    SLPHeader slpHeader;
    input.read(reinterpret_cast<char*>(&slpHeader), sizeof(SLPHeader));

    std::unique_ptr<SLPFrameInfo[]> slpFrameInfo = std::make_unique<SLPFrameInfo[]>(slpHeader.nbFrames);
    input.read(reinterpret_cast<char*>(&slpFrameInfo[0]), sizeof(SLPFrameInfo) * slpHeader.nbFrames);

    int offsetX = 0;
    int offsetY = 0;
    int maxRowSize = 0;
    int maxYRow = 0;
    int currentRow = 0;

    // Fill the sprite info
    // This is where we lay out how sprites are organized in the sprite sheet.
    // Right now this is done sequentially from left to right, over 10 rows
    for (int i = 0; i < slpHeader.nbFrames; i++) {
      // We've reached the end of the line, need to reset the variables and start a new one
      if (i >= (currentRow + 1) * slpHeader.nbFrames / 10) {
        currentRow++;
        maxRowSize = std::max(maxRowSize, offsetX);
        offsetX = 0;
        offsetY += maxYRow;
        maxYRow = 0;
      }

      SpriteInfo sprite;
      sprite.x = offsetX;
      sprite.y = offsetY;
      sprite.w = slpFrameInfo[i].width;
      sprite.h = slpFrameInfo[i].height;
      sprite.anchor_x = slpFrameInfo[i].anchorX;
      sprite.anchor_y = slpFrameInfo[i].anchorY;

      // Go the next sprite on the same line
      maxYRow = std::max(maxYRow, sprite.h);
      offsetX += sprite.w;

      currentSprites.push_back(sprite);
    }

    maxRowSize = std::max(maxRowSize, offsetX);

    std::shared_ptr<SDL_Surface> spriteSheet = ut::createSurface(glm::ivec2(maxRowSize, offsetY + maxYRow));

    // Fill pixel data
    for (int i = 0; i < currentSprites.size(); i++) {
      const SpriteInfo& sprite = currentSprites[i];
      std::unique_ptr<uint16_t[]> leftRightSpacing = std::make_unique<uint16_t[]>(sprite.h * 2);
      std::unique_ptr<uint32_t[]> commandsOffset = std::make_unique<uint32_t[]>(sprite.h);

      input.seekg(slpFrameInfo[i].outlineTableOffset);
      input.read(reinterpret_cast<char*>(&leftRightSpacing[0]), sizeof(uint16_t) * sprite.h * 2);
      input.seekg(slpFrameInfo[i].commandTableOffset);
      input.read(reinterpret_cast<char*>(&commandsOffset[0]), sizeof(uint32_t) * sprite.h);

      std::shared_ptr<SDL_Palette> palette = selectPalette(slpFrameInfo[i].properties);

      if (!palette)
        throw std::runtime_error(("Error when processing SLP: " + filePath + " \nCouldn't read palette " + std::to_string(slpFrameInfo[i].properties)).c_str());

      for (int spriteLine = 0; spriteLine < sprite.h; spriteLine++) {
        // Those are special values that indicate that the whole line should be skipped
        if (leftRightSpacing[2 * spriteLine] == 0x8000 || leftRightSpacing[2 * spriteLine + 1] == 0x8000)
          continue;
        
        // The actual commands start after the table of command offsets
        input.seekg(commandsOffset[spriteLine]);
        processSLPDrawingCommands(spriteSheet, palette, input, sprite.x + leftRightSpacing[2 * spriteLine], sprite.y + spriteLine);
      }
    }

    input.close();

    //SDL_SaveBMP(spriteSheet.get(), (filePath + std::string(".bmp")).c_str());

    return spriteSheet;
  }

  throw std::runtime_error((std::string("Error loading SLP file ") + filePath).c_str());
}

std::shared_ptr<SDL_Palette> UnitAsset::selectPalette(uint32_t paletteID) {
  switch (paletteID) {
  case 0x00:
  case 0x10:
  case 0x18:
    return Palettes[0];
  case 0x07:
    throw std::runtime_error("Error when processing SLP palette: raw 32-bits values not supported yet");
  case 0x010000:
    return Palettes[1];
  case 0x020000:
    return Palettes[2];
  case 0x030000:
    return Palettes[3];
  case 0x040000:
    return Palettes[4];
  case 0x050000:
    return Palettes[5];
  case 0x060000:
    return Palettes[6];
  default:
    return nullptr;
  }
}

void UnitAsset::processSLPDrawingCommands(std::shared_ptr<SDL_Surface> surface, std::shared_ptr<SDL_Palette> palette, std::ifstream& input, int currentPixelX, int currentPixelY) {

  bool reachedEndOfLine = false;

  uint8_t command;
  uint8_t color;
  uint8_t nextByte;
  uint8_t firstByteHalf;
  uint8_t secondByteHalf;
  uint8_t lastTwoBits;
  int pixelCount;

  while (!reachedEndOfLine) {
    READ_BYTE(input, command)

    firstByteHalf = 0xF0 & command;
    secondByteHalf = 0x0F & command;
    lastTwoBits = 0b00000011 & command;

    // End of line
    if (secondByteHalf == 0x0F) {
      reachedEndOfLine = true;
      continue;
    }

    // Lesser draw - draw up to 64 following bytes as palette colors
    else if (lastTwoBits == 0) {
      pixelCount = command >> 2;

      for (int i = 0; i < pixelCount; i++) {
        READ_BYTE(input, color)
        ut::setPixelInSurface(surface, currentPixelX, currentPixelY, palette->colors[color]);
        currentPixelX++;
      }
    }

    // Lesser skip - draw up to 255 transparent pixels (if less than 64 store in the same byte, otherwise read the next one)
    else if (lastTwoBits == 1) {
      pixelCount = command >> 2;
  
      if (pixelCount == 0) {
        READ_BYTE(input, nextByte)
        pixelCount = nextByte;
      }

      currentPixelX += pixelCount;
    }

    // Greater draw - draw up to 4095 following bytes as palette colors
    else if (secondByteHalf == 0x02) {
      READ_BYTE(input, nextByte)
      pixelCount = (firstByteHalf << 4) + nextByte;

      for (int i = 0; i < pixelCount; i++) {
        READ_BYTE(input, color)
        ut::setPixelInSurface(surface, currentPixelX, currentPixelY, palette->colors[color]);
        currentPixelX++;
      }
    }

    // Greater skip - draw up to 4095 transparent pixels
    else if (secondByteHalf == 0x03) {
      READ_BYTE(input, nextByte)
      pixelCount = (firstByteHalf << 4) + nextByte;
      currentPixelX += pixelCount;
    }

    // Player color list command - draw the current player color up to 255 times
    // (if less than 64 store in the same byte, otherwise read the next one)
    else if (secondByteHalf == 0x06) {
      pixelCount = command >> 4;

      if (pixelCount == 0) {
        READ_BYTE(input, nextByte)
        pixelCount = nextByte;
      }

      for (int i = 0; i < pixelCount; i++) {
        READ_BYTE(input, color)
        ut::setPixelInSurface(surface, currentPixelX, currentPixelY, color + 0xFFFFFFFF);
        currentPixelX++;
      }
    }

    // Fill command - draw up to 255 pixels with the color of the next byte (if less than 64 store in the same byte, otherwise read the next one)
    else if (secondByteHalf == 0x07) {
      pixelCount = command >> 4;

      if (pixelCount == 0) {
        READ_BYTE(input, nextByte)
          pixelCount = nextByte;
      }

      READ_BYTE(input, color)

      for (int i = 0; i < pixelCount; i++) {
        ut::setPixelInSurface(surface, currentPixelX, currentPixelY, palette->colors[color]);
        currentPixelX++;
      }
    }

    // Fill player color command - draw up to 255 pixels with the player color
    else if (secondByteHalf == 0x0A) {
      pixelCount = command >> 4;

      if (pixelCount == 0) {
        READ_BYTE(input, nextByte)
        pixelCount = nextByte;
      }

      READ_BYTE(input, color)

      for (int i = 0; i < pixelCount; i++) {
        ut::setPixelInSurface(surface, currentPixelX, currentPixelY, color + 0xFFFFFFFF);
        currentPixelX++;
      }
    }

    // Shadow command - draw a transparent shadow pixel up to 255 times
    else if (secondByteHalf == 0x0B) {
      pixelCount = command >> 4;

      if (pixelCount == 0) {
        READ_BYTE(input, nextByte)
        pixelCount = nextByte;
      }

      for (int i = 0; i < pixelCount; i++) {
        ut::setPixelInSurface(surface, currentPixelX, currentPixelY, 0x64000000);
        currentPixelX++;
      }
    }

    else if (secondByteHalf == 0x0E) {
      switch (firstByteHalf) {
      case 0x00:
        // Only draw the following command if the sprite is not flipped
      case 0x10:
        // Only draw the following command if the sprite IS flipped
      case 0x20:
        // Set the transform color table to normal for all the standard drawing commands
      case 0x30:
        // Set the transform color table to alternate, affects all following standards commands
        break;
      case 0x40:
        // outline_1 command - The following pixel should be drawn as special color 1 if it is obstructed later in rendering
        currentPixelX++; break;
      case 0x60:
        // outline_2 command - Same as above but for special color 2
        currentPixelX++; break;
      case 0x50:
        // outline_span_1 command - Same as above, but span special color 1 nextbyte times
        READ_BYTE(input, nextByte)
        currentPixelX += nextByte;
        break;
      case 0x70:
        // outline_span_2 command - Same as above, using special color 2
        READ_BYTE(input, nextByte)
        currentPixelX += nextByte;
        break;
      case 0x80:
        // Dither command
      case 0x90:
        // Pre-multiplied alpha command
      case 0xA0:
        // Original alpha command
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Error - unimplemented SLP command");
        break;
      }
    }
  }
}

UnitAsset::UnitAsset(const std::string& assetPath):
  UnitAsset(std::vector<std::string>{ assetPath })
{}

UnitAsset::UnitAsset(const std::vector<std::string>& assetPaths):
  _assetPaths(assetPaths)
{}

UnitAsset::UnitAsset(const Color& color, const glm::ivec2& size) :
  _fallbackColor(color),
  _fallbackSize(size)
{}

void UnitAsset::load() {
  std::vector<std::shared_ptr<SDL_Surface>> imageData;

  // If no path was provided, use the fallback color and size
  if (_assetPaths.size() == 0)
    _assetPaths.push_back("");

  for (int i = 0; i < _assetPaths.size(); i++) {
    _spriteInfo.push_back(std::vector<SpriteInfo>());

    // Check which asset type to load
    size_t separatorPos = _assetPaths[i].find(ut::os_pathsep);
    std::string filePath = _assetPaths[i].substr(0, separatorPos);

    // No data for this animation
    if (filePath.empty()) {
      imageData.push_back(ut::createColoredSurface(glm::ivec2(1), _fallbackColor));
      _spriteInfo[i].push_back(SpriteInfo(_fallbackSize.x, _fallbackSize.y));
    }

    // Two paths were provided, it means it was an image with some sprite info
    else if (separatorPos != std::string::npos) {
      imageData.push_back(loadSpriteSheet(filePath, _assetPaths[i].substr(separatorPos + 1), _spriteInfo[i]));
    }

    else if (ut::endsWith(filePath, ".slp")) {
      imageData.push_back(loadSLP(filePath, _spriteInfo[i]));
    }

    else {
      imageData.push_back(ut::loadImage(filePath));
      _spriteInfo[i].push_back(SpriteInfo(imageData.back()->w, imageData.back()->h));
    }
  }

  _textureArray = std::make_unique<TextureArray>(imageData);

  // Find the max sprite anchor height
  for (int i = 0; i < _spriteInfo.size(); i++) {
    for (int j = 0; j < _spriteInfo[i].size(); j++) {
      _maxAnchorHeight = std::max(_maxAnchorHeight, _spriteInfo[i][j].anchor_y);
    }
  }
}

glm::vec4 UnitAsset::getTexRectangle(int textureID, int spriteID) const {
  // No sprites were specified, the texture is supposed to be used fully
  if (_spriteInfo[textureID].size() == 0)
    return getTextureArray()->getTexRectangle(textureID);

  float maxX = (float) getTextureArray()->getMaxTexSize().x;
  float maxY = (float) getTextureArray()->getMaxTexSize().y;

  glm::vec4 textureRectangle;
  textureRectangle.x = _spriteInfo[textureID][spriteID].x / maxX;
  textureRectangle.y = _spriteInfo[textureID][spriteID].y / maxY;
  textureRectangle.z = _spriteInfo[textureID][spriteID].w / maxX;
  textureRectangle.w = _spriteInfo[textureID][spriteID].h / maxY;

  return textureRectangle;
}

#include <pybind11/stl.h>

void UnitAsset::pythonBindings(py::module& m) {
  py::class_<UnitAsset, std::shared_ptr<UnitAsset>>(m, "UnitAsset")
    .def(py::init<>())
    .def(py::init<Color, glm::ivec2>())
    .def(py::init<const std::string&>())
    .def(py::init<const std::vector<std::string>&>())
    .def("isLoaded", &UnitAsset::isLoaded)
    .def("load", &UnitAsset::load)
    .def("textureExists", &UnitAsset::textureExists)
    .def_readwrite("assetPaths", &UnitAsset::_assetPaths)
    .def_readwrite("unitID", &UnitAsset::_unitID);
}