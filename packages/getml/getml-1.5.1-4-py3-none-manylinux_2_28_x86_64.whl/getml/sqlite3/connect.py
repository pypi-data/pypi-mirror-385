# Copyright 2025 Code17 GmbH
#
# This file is licensed under the Elastic License 2.0 (ELv2).
# Refer to the LICENSE.txt file in the root of the repository
# for details.
#


"""
Contains a wrapper around connect.
"""

from __future__ import annotations

import sqlite3

from .contains import _contains
from .count_above_mean import _CountAboveMean
from .count_below_mean import _CountBelowMean
from .count_distinct_over_count import _CountDistinctOverCount
from .email_domain import _email_domain
from .ewma import (
    _EWMA1D,
    _EWMA1H,
    _EWMA1M,
    _EWMA1S,
    _EWMA7D,
    _EWMA30D,
    _EWMA90D,
    _EWMA365D,
)
from .ewma_trend import (
    _EWMATrend1D,
    _EWMATrend1H,
    _EWMATrend1M,
    _EWMATrend1S,
    _EWMATrend7D,
    _EWMATrend30D,
    _EWMATrend90D,
    _EWMATrend365D,
)
from .first import _First
from .get_word import _get_word
from .helpers import _try_import_scipy
from .kurtosis import _Kurtosis
from .last import _Last
from .median import _Median
from .mode import _Mode
from .num_max import _NumMax
from .num_min import _NumMin
from .num_words import _num_words
from .quantiles import (
    _Q1,
    _Q5,
    _Q10,
    _Q25,
    _Q75,
    _Q90,
    _Q95,
    _Q99,
)
from .skew import _Skew
from .stddev import _Stddev
from .time_since_first_maximum import _TimeSinceFirstMaximum
from .time_since_first_minimum import _TimeSinceFirstMinimum
from .time_since_last_maximum import _TimeSinceLastMaximum
from .time_since_last_minimum import _TimeSinceLastMinimum
from .trend import _Trend
from .var import _Var
from .variation_coefficient import _VariationCoefficient


def connect(database: str) -> sqlite3.Connection:
    """
    Generates a new sqlite3 connection.

    This connection contains all customized aggregations
    and transformation functions needed to execute the
    SQL pipeline generated by getML. Other than that
    it behaves just like a normal sqlite3 connection from
    the Python standard library.

    Args:
        database:
            Filename of the database. Use ':memory:' to
            create an in-memory database.

    Returns:
        A new sqlite3 connection with all custom
            functions and aggregations registered.
    """

    if not isinstance(database, str):
        raise TypeError("'database' must be of type str")

    if sqlite3.sqlite_version < "3.33.0":
        raise ValueError(
            "getML requires SQLite version 3.33.0 or above. Found version "
            + sqlite3.sqlite_version
            + ". Please upgrade Python and/or the Python sqlite3 package."
        )

    # Lazily check if scipy is installed
    _try_import_scipy()

    conn = sqlite3.connect(database)

    conn.create_function("contains", 2, _contains)
    conn.create_function("email_domain", 1, _email_domain)
    conn.create_function("get_word", 2, _get_word)
    conn.create_function("num_words", 1, _num_words)

    conn.create_aggregate("COUNT_ABOVE_MEAN", 1, _CountAboveMean)  # type: ignore
    conn.create_aggregate("COUNT_BELOW_MEAN", 1, _CountBelowMean)  # type: ignore
    conn.create_aggregate("COUNT_DISTINCT_OVER_COUNT", 1, _CountDistinctOverCount)  # type: ignore
    conn.create_aggregate("EWMA_1S", 2, _EWMA1S)  # type: ignore
    conn.create_aggregate("EWMA_1M", 2, _EWMA1M)  # type: ignore
    conn.create_aggregate("EWMA_1H", 2, _EWMA1H)  # type: ignore
    conn.create_aggregate("EWMA_1D", 2, _EWMA1D)  # type: ignore
    conn.create_aggregate("EWMA_7D", 2, _EWMA7D)  # type: ignore
    conn.create_aggregate("EWMA_30D", 2, _EWMA30D)  # type: ignore
    conn.create_aggregate("EWMA_90D", 2, _EWMA90D)  # type: ignore
    conn.create_aggregate("EWMA_365D", 2, _EWMA365D)  # type: ignore
    conn.create_aggregate("EWMA_TREND_1S", 2, _EWMATrend1S)  # type: ignore
    conn.create_aggregate("EWMA_TREND_1M", 2, _EWMATrend1M)  # type: ignore
    conn.create_aggregate("EWMA_TREND_1H", 2, _EWMATrend1H)  # type: ignore
    conn.create_aggregate("EWMA_TREND_1D", 2, _EWMATrend1D)  # type: ignore
    conn.create_aggregate("EWMA_TREND_7D", 2, _EWMATrend7D)  # type: ignore
    conn.create_aggregate("EWMA_TREND_30D", 2, _EWMATrend30D)  # type: ignore
    conn.create_aggregate("EWMA_TREND_90D", 2, _EWMATrend90D)  # type: ignore
    conn.create_aggregate("EWMA_TREND_365D", 2, _EWMATrend365D)  # type: ignore
    conn.create_aggregate("FIRST", 2, _First)  # type: ignore
    conn.create_aggregate("KURTOSIS", 1, _Kurtosis)
    conn.create_aggregate("LAST", 2, _Last)  # type: ignore
    conn.create_aggregate("MEDIAN", 1, _Median)
    conn.create_aggregate("MODE", 1, _Mode)
    conn.create_aggregate("NUM_MAX", 1, _NumMax)  # type: ignore
    conn.create_aggregate("NUM_MIN", 1, _NumMin)  # type: ignore
    conn.create_aggregate("Q1", 1, _Q1)  # type: ignore
    conn.create_aggregate("Q5", 1, _Q5)  # type: ignore
    conn.create_aggregate("Q10", 1, _Q10)  # type: ignore
    conn.create_aggregate("Q25", 1, _Q25)  # type: ignore
    conn.create_aggregate("Q75", 1, _Q75)  # type: ignore
    conn.create_aggregate("Q90", 1, _Q90)  # type: ignore
    conn.create_aggregate("Q95", 1, _Q95)  # type: ignore
    conn.create_aggregate("Q99", 1, _Q99)  # type: ignore
    conn.create_aggregate("SKEW", 1, _Skew)
    conn.create_aggregate("STDDEV", 1, _Stddev)
    conn.create_aggregate("TIME_SINCE_FIRST_MAXIMUM", 2, _TimeSinceFirstMaximum)  # type: ignore
    conn.create_aggregate("TIME_SINCE_FIRST_MINIMUM", 2, _TimeSinceFirstMinimum)  # type: ignore
    conn.create_aggregate("TIME_SINCE_LAST_MAXIMUM", 2, _TimeSinceLastMaximum)  # type: ignore
    conn.create_aggregate("TIME_SINCE_LAST_MINIMUM", 2, _TimeSinceLastMinimum)  # type: ignore
    conn.create_aggregate("TREND", 2, _Trend)  # type: ignore
    conn.create_aggregate("VAR", 1, _Var)
    conn.create_aggregate("VARIATION_COEFFICIENT", 1, _VariationCoefficient)

    return conn
