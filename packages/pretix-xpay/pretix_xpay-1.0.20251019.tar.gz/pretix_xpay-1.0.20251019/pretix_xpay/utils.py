import hashlib
import logging
from datetime import datetime
from django.utils.translation import gettext_lazy as _
from i18nfield.strings import LazyI18nString
from pretix.base.models import Event, Order, OrderPayment, OrderPosition
from pretix.base.payment import BasePaymentProvider
from pretix.base.services.mail import mail
from pretix.base.settings import SettingsSandbox

from pretix_xpay.constants import (
    LANGUAGE_DEFAULT,
    LANGUAGES_TRANSLATION,
    PROD_URL,
    TEST_URL,
    XPAY_RESULT_AUTHORIZED,
    XPAY_RESULT_CANCELED,
    XPAY_RESULT_CAPTURED,
    XPAY_RESULT_PENDING,
    XPAY_RESULT_REFUNDED,
)

logger = logging.getLogger(__name__)


def get_xpay_api_url(provider: BasePaymentProvider):
    return TEST_URL if provider.event.testmode else PROD_URL


def get_alias_key(provider: BasePaymentProvider) -> str:
    if provider.event.testmode:
        key = provider.settings.test_alias_key
        if not key:
            key = provider.settings.alias_key
        return key
    else:
        return provider.settings.alias_key


def get_mac_secret_pass(provider: BasePaymentProvider) -> str:
    if provider.event.testmode:
        key = provider.settings.test_mac_secret_pass
        if not key:
            key = provider.settings.mac_secret_pass
        return key
    else:
        return provider.settings.mac_secret_pass


def encode_order_id(
    orderPayment: OrderPayment, event: Event, provider: BasePaymentProvider
) -> str:
    secret: str = (
        provider.settings.order_id_salt
        if provider.settings.order_id_salt
        else "gabibbo"
    )
    data: str = f"{event.organizer.slug}{event.slug}{orderPayment.full_id}{secret}"
    return hashlib.sha256(data.encode("utf-8")).hexdigest()[:18]


def generate_mac(data: list, provider: BasePaymentProvider) -> str:
    hash_algo = hashlib.new(provider.settings.hash)
    for el in data:
        hash_algo.update(f"{el[0]}={str(el[1])}".encode("UTF-8"))
    hash_algo.update(get_mac_secret_pass(provider).encode("UTF-8"))
    return hash_algo.hexdigest()


def get_settings_object(event: Event) -> SettingsSandbox:
    return SettingsSandbox("payment", "xpay", event)


def send_refund_needed_email(orderPayment: OrderPayment, origin: str = "-") -> None:
    settings = get_settings_object(orderPayment.order.event)
    email = settings.payment_error_email
    if email and len(email.strip()) > 0:
        to = [k.strip() for k in settings.payment_error_email.split(",")]
        subject = _("Severe error in XPay's payment process")
        body = LazyI18nString.from_gettext(
            _(
                "A severe error occurred while processing the OrderPayment {op_full_id} with transactionId {transaction_id}.\n"
                "The user has probably paid more than expected (due to a double payment or to a Quota Exceeded problem) and a manual refund is needed.\n\n"
                "Please verify the payment and order status and, in case, proceed with a manual refund.\n\n\n"
                'This email is autogenerated by the XPay plugin by the "{origin}" origin. '
                "For more information, contact us on https://github.com/APSfurizon/pretix-xpay/"
            )
        )
        ctx = {
            "op_full_id": orderPayment.full_id,
            "transaction_id": encode_order_id(
                orderPayment, orderPayment.order.event, orderPayment.payment_provider
            ),
            "origin": origin,
        }
        logger.info(
            f"XPAY_send_refund_needed_email [{orderPayment.full_id}]: Sending email with origin {origin}"
        )
        mail(to, subject, body, ctx)


def translate_language(order: Order) -> str:
    return (
        LANGUAGES_TRANSLATION[order.locale]
        if order.locale in LANGUAGES_TRANSLATION
        else LANGUAGE_DEFAULT
    )


def build_order_desc(order: Order) -> str:
    itemNames = []
    p: OrderPosition
    for p in order.positions.all():
        itemNames.append(get_translated_text(p.item.name, order))
    return f"[{order.event.organizer.name} / {order.event.name}] Order {order.code}: {', '.join(itemNames)}"


def get_translated_text(value, order: Order) -> str:
    if isinstance(value, LazyI18nString):
        lazy: LazyI18nString = value
        return lazy.localize(order.locale)
    elif isinstance(value, str):
        return value
    else:
        raise ValueError("Unexpected item type")


class OrderOperation:
    def __init__(self, data: dict):
        if (
            "tipoOperazione" not in data
            or "stato" not in data
            or "dataOperazione" not in data
        ):
            raise ValueError(_("Could not parse operation."))
        self.type = data["tipoOperazione"]
        self.status = data["stato"]
        # 2024-07-25 12:41:47.0
        # By docs this should only contains the date, but in prod it contains everything
        if "-" in data["dataOperazione"]:
            self.timestamp = datetime.strptime(
                data["dataOperazione"], "%Y-%m-%d %H:%M:%S.%f"
            )
        else:
            self.timestamp = datetime.strptime(data["dataOperazione"], "%Y-%m-%d")
        self.full_data = data


class OrderReport:
    def __init__(self, report: dict, transaction_id: str):
        self.operations = []
        # If order is not created
        if report["stato"] in XPAY_RESULT_CANCELED:
            self.fallback_status = report["stato"]
            logger.error(
                f"XPAY_OrderStatus_init [{transaction_id}]: Order was not created"
            )
            return

        # Throw if report data is unparseable
        is_valid = (
            "codiceTransazione" in report
            and report["codiceTransazione"] == transaction_id
        )
        is_valid = (
            is_valid
            and "dettaglio" in report
            and isinstance(report["dettaglio"], list)
            and len(report["dettaglio"]) > 0
        )
        if not is_valid:
            logger.debug(
                f"XPAY_OrderStatus_init [{transaction_id}]: second is_valid check was false. REPORT = {report}"
            )
            raise ValueError(_("Could not parse order %s") % transaction_id)
        self.transaction_id = report["codiceTransazione"]

        # Throw if detail is unparseable
        details = report["dettaglio"][
            0
        ]  # From the docs it looks like that there is only one detail
        self.details = details
        is_valid = is_valid and isinstance(details, dict) and "stato" in details
        if not is_valid:
            logger.debug(
                f"XPAY_OrderStatus_init [{transaction_id}]: third is_valid check was false. REPORT = {report}"
            )
            raise ValueError(_("Could not parse order %s") % transaction_id)

        self.fallback_status = details["stato"]
        if "operazioni" in details and isinstance(details["operazioni"], list):
            for op in details["operazioni"]:
                op_to_add = OrderOperation(op)
                self.operations.append(op_to_add)
        self.full_data = report

    def operation_status(self):
        return (
            None
            if len(self.operations) == 0
            else sorted(self.operations, key=lambda os: os.timestamp)[0].status
        )

    @property
    def status(self):
        return (
            self.fallback_status
            if len(self.operations) == 0
            else self.operation_status()
        )


class OrderStatus:
    def __init__(self, transaction_id: str, data: dict):
        logger.info(f"XPAY_OrderStatus_init [{transaction_id}]: Parsing order status")
        logger.debug(data)
        # Throw if outside data is unparseable
        is_valid = (
            data
            and isinstance(data, dict)
            and "esito" in data
            and data["esito"] == "OK"
        )
        is_valid = is_valid and "report" in data and isinstance(data["report"], list)
        is_valid = (
            is_valid and len(data["report"]) > 0 and isinstance(data["report"][0], dict)
        )
        if not is_valid:
            logger.debug(
                f"XPAY_OrderStatus_init [{transaction_id}]: first is_valid check was false. DATA = {data}"
            )
            raise ValueError(_("Could not parse order %s") % transaction_id)

        self.report = []
        for report in data["report"]:
            self.report.append(OrderReport(report, transaction_id))

        self.full_data = data

    # We declare an order on which priority each set of status have
    # We will only pick the best for the final one
    def translateStatusToVal(self, status: str):
        if status in XPAY_RESULT_CANCELED:
            return 0
        elif status in XPAY_RESULT_REFUNDED:
            return 1
        elif status in XPAY_RESULT_AUTHORIZED:
            return 2
        elif status in XPAY_RESULT_PENDING:
            return 3
        elif status in XPAY_RESULT_CAPTURED:
            return 4

    def findBestReport(self) -> OrderReport:
        val = -1
        retReport = None
        for report in self.report:
            statusVal = self.translateStatusToVal(report.status)
            if statusVal > val:
                val = statusVal
                retReport = report
        return retReport

    @property
    def status(self) -> str:
        report = self.findBestReport()
        return "-" if report is None else report.status

    def updatePaymentInformation(
        self, payment: OrderPayment, provider: BasePaymentProvider
    ):
        info = {"alias": get_alias_key(provider)}
        report: OrderReport = self.findBestReport()
        if report is not None:
            date = datetime.strptime(
                report.full_data["dataTransazione"], "%Y-%m-%d %H:%M:%S.%f"
            )
            # Shitty-ass code, but the api is as bad
            descrizione: str = report.full_data["parametri"]
            descrizione = (
                [] if descrizione is None else descrizione.split("descrizione=")
            )

            info = {
                **info,
                "brand": report.full_data["brand"],
                "codAut": report.full_data["codiceAutorizzazione"],
                "codTrans": report.full_data["codiceTransazione"],
                "data": date.strftime("%Y%m%d"),
                "orario": date.strftime("%H%M%S"),
                "descrizione": (
                    descrizione[1].split("&")[0] if len(descrizione) > 1 else "-"
                ),
                "divisa": report.full_data["divisa"],
                "importo": report.full_data["importo"],
                "languageId": report.full_data["nazione"],
                "nazionalita": report.full_data["nazione"],
                "mail": report.full_data["mail"],
                "merchantnumber": report.full_data["numeroMerchant"],
                "pan": report.full_data["pan"],
                "scadenza_pan": report.full_data["scadenza"],
                "tipoProdotto": report.full_data["tipoProdotto"],
                "tipoTransazione": report.full_data["tipoTransazione"],
            }

            if report.details is not None:
                details = report.details
                info = {
                    **info,
                    "cognome": details["cognome"],
                    "nome": details["nome"],
                }

        payment.info_data = {**payment.info_data, **info}
        payment.save(update_fields=["info"])
