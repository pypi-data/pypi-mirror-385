import amsdal_glue as glue
from _typeshed import Incomplete
from amsdal_data.aliases.using import LAKEHOUSE_DB_ALIAS as LAKEHOUSE_DB_ALIAS
from amsdal_data.connections.constants import PRIMARY_PARTITION_KEY as PRIMARY_PARTITION_KEY, SCHEMA_TABLE_NAME_FIELD as SCHEMA_TABLE_NAME_FIELD, SECONDARY_PARTITION_KEY as SECONDARY_PARTITION_KEY
from amsdal_data.connections.historical.command_builder import TABLE_NAME_VERSION_SEPARATOR as TABLE_NAME_VERSION_SEPARATOR
from amsdal_data.connections.historical.data_query_transform import METADATA_TABLE_ALIAS as METADATA_TABLE_ALIAS, META_CLASS_NAME as META_CLASS_NAME, META_NEW_CLASS_VERSION as META_NEW_CLASS_VERSION, META_PRIMARY_KEY as META_PRIMARY_KEY, META_PRIMARY_KEY_FIELDS as META_PRIMARY_KEY_FIELDS, NEXT_VERSION_FIELD as NEXT_VERSION_FIELD, build_simple_query_statement_with_metadata as build_simple_query_statement_with_metadata
from amsdal_data.errors import CommandError as CommandError, QueryError as QueryError, RegisterTableError as RegisterTableError
from amsdal_data.transactions.manager import AmsdalAsyncTransactionManager as AmsdalAsyncTransactionManager, AmsdalTransactionManager as AmsdalTransactionManager
from amsdal_data.utils import FOREIGN_KEYS_PROPERTY as FOREIGN_KEYS_PROPERTY
from amsdal_utils.utils.decorators import async_mode_only, sync_mode_only
from amsdal_utils.utils.singleton import Singleton
from collections.abc import AsyncGenerator, Generator
from typing import Any

MIGRATION_BATCH_SIZE: Incomplete
logger: Incomplete

class BaseTableSchemasManager:
    @classmethod
    def enrich_schema_metadata(cls, schema: glue.Schema) -> glue.Schema: ...
    @staticmethod
    def process_fk_field(field: str, schema: glue.Schema) -> str: ...

class TableSchemasManager(BaseTableSchemasManager, metaclass=Singleton):
    _operation_manager: Incomplete
    schema_version_manager: Incomplete
    @sync_mode_only
    def __init__(self) -> None: ...
    def register_table(self, schema: glue.Schema, *, using: str | None = None) -> tuple[bool, bool]:
        """
        Creates a new table in the database through connection.
        """
    def unregister_table(self, schema_reference: glue.SchemaReference, *, using: str | None = None) -> None: ...
    def get_existing_schema(self, schema: glue.Schema, *, using: str | None = None) -> glue.Schema | None: ...
    def _create_table(self, schema: glue.Schema, *, using: str | None = None) -> None: ...
    def _update_table(self, schema: glue.Schema, existing_schema: glue.Schema, *, using: str | None = None) -> bool: ...
    def fetch_historical_data(self, schema_reference: glue.SchemaReference, batch_size: int = ..., offset: int = 0, extra_conditions: glue.Conditions | None = None) -> Generator[dict[str, Any], None, None]: ...
    def search_latest_class_object(self, schema_reference: glue.SchemaReference, class_object_name: str) -> dict[str, Any] | None: ...
    def insert_class_object_schema(self, schema_reference: glue.SchemaReference, class_object_data: glue.Data) -> dict[str, Any]: ...
    def update_class_object_schema(self, schema_reference: glue.SchemaReference, class_object_data: glue.Data) -> dict[str, Any]: ...
    def delete_class_object_schema(self, schema_reference: glue.SchemaReference, class_object_id: str) -> dict[str, Any]: ...
    def _mutate_class_object_schema(self, mutation: glue.InsertData | glue.UpdateData | glue.DeleteData) -> dict[str, Any]: ...

class AsyncTableSchemasManager(BaseTableSchemasManager, metaclass=Singleton):
    _operation_manager: Incomplete
    schema_version_manager: Incomplete
    @async_mode_only
    def __init__(self) -> None: ...
    async def register_table(self, schema: glue.Schema, *, using: str | None = None) -> tuple[bool, bool]:
        """
        Creates a new table in the database through connection.
        """
    async def unregister_table(self, schema_reference: glue.SchemaReference, *, using: str | None = None) -> None: ...
    async def get_existing_schema(self, schema: glue.Schema, *, using: str | None = None) -> glue.Schema | None: ...
    async def _create_table(self, schema: glue.Schema, *, using: str | None = None) -> None: ...
    async def _update_table(self, schema: glue.Schema, existing_schema: glue.Schema, *, using: str | None = None) -> bool: ...
    async def fetch_historical_data(self, schema_reference: glue.SchemaReference, batch_size: int = ..., offset: int = 0, extra_conditions: glue.Conditions | None = None) -> AsyncGenerator[dict[str, Any]]: ...
    async def search_latest_class_object(self, schema_reference: glue.SchemaReference, class_object_name: str) -> dict[str, Any] | None: ...
    async def insert_class_object_schema(self, schema_reference: glue.SchemaReference, class_object_data: glue.Data) -> dict[str, Any]: ...
    async def update_class_object_schema(self, schema_reference: glue.SchemaReference, class_object_data: glue.Data) -> dict[str, Any]: ...
    async def delete_class_object_schema(self, schema_reference: glue.SchemaReference, class_object_id: str) -> dict[str, Any]: ...
    async def _mutate_class_object_schema(self, mutation: glue.InsertData | glue.UpdateData | glue.DeleteData) -> dict[str, Any]: ...
