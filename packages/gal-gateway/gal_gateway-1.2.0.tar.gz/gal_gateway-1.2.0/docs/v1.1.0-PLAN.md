# GAL v1.1.0 - Implementierungsplan

**Target Release:** Q4 2025
**Focus:** Traffic Management & Security Basics
**Estimated Effort:** 6-8 Wochen

---

## üìã Feature Overview

| # | Feature | Priority | Status | Effort | Dependencies |
|---|---------|----------|--------|--------|--------------|
| 1 | Rate Limiting | üî¥ High | ‚úÖ **Done** | 2 Wochen | - |
| 2 | Authentication (Basic/API Key/JWT) | üî¥ High | ‚úÖ **Done** | 2 Wochen | - |
| 3 | Request/Response Headers | üî¥ High | ‚úÖ **Done** | 1.5 Wochen | - |
| 4 | CORS Policies | üî¥ High | ‚úÖ **Done** | 1 Woche | - |
| 5 | PyPI Publication | üî¥ High | ‚úÖ **Done** | 1 Woche | - |
| 6 | Circuit Breaker | üü° Medium | ‚úÖ **Done** | 1.5 Wochen | Optional |
| 7 | Health Checks & Load Balancing | üü° Medium | ‚úÖ **Done** | 2 Wochen | Optional |

**Total Estimated Effort:** 10.5 Wochen (mit optionalen Features)
**Progress:** 7/7 Features completed (100% - 10.5 von 10.5 Wochen) üéâ

---

## üéØ Feature 1: Rate Limiting ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT** (Commit: `6a67803`)
**Branch:** `feature/v1.1.0-rate-limiting`
**Completed:** 2025-10-17

### Implementation Summary

‚úÖ **Config Model** - RateLimitConfig mit allen Optionen
‚úÖ **Kong Provider** - rate-limiting Plugin
‚úÖ **APISIX Provider** - limit-count Plugin
‚úÖ **Traefik Provider** - rateLimit Middleware
‚úÖ **Envoy Provider** - local_ratelimit Filter
‚úÖ **Tests** - 15 neue Tests, 117 total (alle bestehen)
‚úÖ **Documentation** - Umfassender RATE_LIMITING.md Guide
‚úÖ **Coverage** - 90% (erh√∂ht von 89%)

### Motivation
- Schutz vor API-√úberlastung
- DDoS-Mitigation
- Fairness zwischen Clients
- SLA-Enforcement

### Configuration Schema

```yaml
routes:
  - path: /api/users
    method: GET
    upstream: user_service
    rate_limit:
      enabled: true
      requests_per_second: 100
      burst: 200
      key_type: ip_address  # ip_address, header, jwt_claim
      key_header: X-API-Key  # Optional: wenn key_type=header
      response:
        status_code: 429
        message: "Rate limit exceeded"
```

### Implementation Tasks

#### Config Model (`gal/config.py`)
```python
class RateLimitConfig:
    enabled: bool = True
    requests_per_second: int
    burst: int = 0
    key_type: str = "ip_address"  # ip_address, header, jwt_claim
    key_header: Optional[str] = None
    key_claim: Optional[str] = None
    response_status: int = 429
    response_message: str = "Rate limit exceeded"
```

#### Provider Implementations

**Envoy (`gal/providers/envoy.py`)**
```python
def _generate_rate_limit(self, route_config):
    """
    Uses Envoy's rate limit filter
    Requires external rate limit service (Redis-based)
    """
    return {
        "typed_config": {
            "@type": "type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit",
            "domain": "api_gateway",
            "rate_limit_service": {
                "grpc_service": {
                    "envoy_grpc": {
                        "cluster_name": "rate_limit_cluster"
                    }
                }
            }
        }
    }
```

**Kong (`gal/providers/kong.py`)**
```python
def _generate_rate_limit(self, route_config):
    """
    Uses Kong's rate-limiting plugin
    """
    return {
        "name": "rate-limiting",
        "config": {
            "second": route_config.rate_limit.requests_per_second,
            "policy": "local",  # or 'cluster', 'redis'
            "fault_tolerant": True,
            "hide_client_headers": False
        }
    }
```

**APISIX (`gal/providers/apisix.py`)**
```python
def _generate_rate_limit(self, route_config):
    """
    Uses APISIX's limit-count plugin
    """
    return {
        "limit-count": {
            "count": route_config.rate_limit.requests_per_second,
            "time_window": 1,
            "rejected_code": 429,
            "key": "remote_addr"  # or 'consumer_name', 'server_addr'
        }
    }
```

**Traefik (`gal/providers/traefik.py`)**
```python
def _generate_rate_limit(self, route_config):
    """
    Uses Traefik's RateLimit middleware
    """
    return {
        "rateLimit": {
            "average": route_config.rate_limit.requests_per_second,
            "burst": route_config.rate_limit.burst,
            "sourceCriterion": {
                "requestHost": True  # or ipStrategy
            }
        }
    }
```

#### Testing
- Unit Tests f√ºr Config-Parsing
- Provider-spezifische Tests
- Integration Tests mit Mock-Gateways
- Load Tests (optional)

#### Documentation
- Configuration Guide
- Provider-specific Notes
- Best Practices
- Migration Guide from custom configs

---

## üîê Feature 2: Authentication & Authorization ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT**
**Branch:** `feature/v1.1.0-authentication`
**Completed:** 2025-10-17

### Implementation Summary

‚úÖ **Config Models** - BasicAuthConfig, ApiKeyConfig, JwtConfig, AuthenticationConfig
‚úÖ **Kong Provider** - basic-auth, key-auth, jwt plugins
‚úÖ **APISIX Provider** - basic-auth, key-auth, jwt-auth plugins
‚úÖ **Traefik Provider** - basicAuth, forwardAuth middleware
‚úÖ **Envoy Provider** - jwt_authn filter, Lua filter f√ºr Basic Auth/API Key
‚úÖ **Tests** - 33 neue Tests (21 authentication + 12 config), 145 total (alle bestehen)
‚úÖ **Documentation** - Umfassender AUTHENTICATION.md Guide (600+ Zeilen)
‚úÖ **Example Config** - examples/authentication-test.yaml mit 9 Szenarien
‚úÖ **Coverage** - 91% (erh√∂ht von 90%)

### Motivation
- API-Zugriffskontrolle
- User Identity Management
- Token-basierte Auth
- Standards-Konformit√§t (JWT, OAuth2)

### Configuration Schema

```yaml
routes:
  - path: /api/protected
    method: GET
    upstream: protected_service
    authentication:
      type: jwt  # basic, api_key, jwt, oauth2

      # Basic Auth Config
      basic:
        users:
          - username: admin
            password_hash: "$2b$12$..."

      # API Key Config
      api_key:
        header_name: X-API-Key
        query_param: api_key
        keys:
          - key: "abc123..."
            name: "client_1"

      # JWT Config
      jwt:
        issuer: https://auth.example.com
        audiences: ["api"]
        jwks_uri: https://auth.example.com/.well-known/jwks.json
        header_name: Authorization
        header_prefix: "Bearer "
        claims_to_headers:
          - claim: sub
            header: X-User-ID
          - claim: email
            header: X-User-Email
```

### Implementation Tasks

#### Config Model
```python
class AuthenticationConfig:
    type: str  # basic, api_key, jwt, oauth2
    basic: Optional[BasicAuthConfig] = None
    api_key: Optional[ApiKeyConfig] = None
    jwt: Optional[JwtConfig] = None
    oauth2: Optional[OAuth2Config] = None

class JwtConfig:
    issuer: str
    audiences: List[str]
    jwks_uri: str
    algorithms: List[str] = ["RS256"]
    header_name: str = "Authorization"
    header_prefix: str = "Bearer "
    claims_to_headers: List[ClaimMapping] = []
```

#### Provider Implementations

**Envoy - JWT Auth**
```python
def _generate_jwt_auth(self, auth_config):
    return {
        "name": "envoy.filters.http.jwt_authn",
        "typed_config": {
            "@type": "type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication",
            "providers": {
                "auth_provider": {
                    "issuer": auth_config.jwt.issuer,
                    "audiences": auth_config.jwt.audiences,
                    "remote_jwks": {
                        "http_uri": {
                            "uri": auth_config.jwt.jwks_uri,
                            "cluster": "jwks_cluster"
                        }
                    }
                }
            }
        }
    }
```

**Kong - Multiple Auth Plugins**
```python
def _generate_authentication(self, auth_config):
    if auth_config.type == "jwt":
        return {
            "name": "jwt",
            "config": {
                "uri_param_names": ["jwt"],
                "claims_to_verify": ["exp"],
                "key_claim_name": "iss"
            }
        }
    elif auth_config.type == "api_key":
        return {
            "name": "key-auth",
            "config": {
                "key_names": [auth_config.api_key.header_name],
                "hide_credentials": True
            }
        }
```

#### Testing
- JWT Token Generation f√ºr Tests
- Mock JWKS Endpoint
- Auth Success/Failure Scenarios
- Token Expiration Tests
- Multiple Auth Methods Tests

---

## üîÑ Feature 3: Request/Response Headers ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT**
**Branch:** `feature/v1.1.0-headers`
**Completed:** 2025-10-17

### Implementation Summary

‚úÖ **Config Model** - HeaderManipulation mit allen Operationen (add/set/remove)
‚úÖ **Kong Provider** - request-transformer, response-transformer plugins
‚úÖ **APISIX Provider** - proxy-rewrite, response-rewrite plugins
‚úÖ **Traefik Provider** - headers middleware
‚úÖ **Envoy Provider** - Native route-level header manipulation
‚úÖ **Route-Level Config** - Per-Route Header-Konfiguration
‚úÖ **Service-Level Config** - Service-weite Header-Konfiguration in Transformation
‚úÖ **Tests** - 30 neue Tests (16 headers + 14 config), 175 total (alle bestehen)
‚úÖ **Documentation** - Umfassender HEADERS.md Guide (700+ Zeilen)
‚úÖ **Example Config** - examples/headers-test.yaml mit 10 Szenarien
‚úÖ **Coverage** - 85% (reduziert durch zus√§tzlichen Code, aber alle neuen Features getestet)

### Configuration Schema

```yaml
routes:
  - path: /api/service
    headers:
      # Request headers
      request_add:
        X-Request-ID: "req-{{uuid}}"
        X-Gateway: "GAL"
      request_set:
        User-Agent: "GAL-Gateway/1.0"
      request_remove:
        - X-Internal-Token
        - X-Debug-Info

      # Response headers
      response_add:
        X-Frame-Options: "DENY"
        X-Content-Type-Options: "nosniff"
      response_set:
        Server: "GAL-Gateway"
      response_remove:
        - X-Powered-By

# Alternative: Service-Level Configuration
services:
  - name: backend_service
    transformation:
      enabled: true
      headers:
        request_add:
          X-Service-Name: "backend_service"
        response_add:
          X-API-Version: "1.0"
```

### Implementation Details

#### Config Model (`gal/config.py`)
```python
@dataclass
class HeaderManipulation:
    """HTTP header manipulation configuration."""
    request_add: Dict[str, str] = field(default_factory=dict)
    request_set: Dict[str, str] = field(default_factory=dict)
    request_remove: List[str] = field(default_factory=list)
    response_add: Dict[str, str] = field(default_factory=dict)
    response_set: Dict[str, str] = field(default_factory=dict)
    response_remove: List[str] = field(default_factory=list)

@dataclass
class Route:
    path_prefix: str
    methods: Optional[List[str]] = None
    rate_limit: Optional[RateLimitConfig] = None
    authentication: Optional[AuthenticationConfig] = None
    headers: Optional[HeaderManipulation] = None  # NEW!

@dataclass
class Transformation:
    enabled: bool = True
    defaults: Dict[str, Any] = field(default_factory=dict)
    computed_fields: List[ComputedField] = field(default_factory=list)
    metadata: Dict[str, str] = field(default_factory=dict)
    validation: Optional[Validation] = None
    headers: Optional[HeaderManipulation] = None  # NEW!
```

### Use Cases
- **Security Headers**: X-Frame-Options, X-Content-Type-Options, CSP
- **CORS**: Access-Control-* headers
- **Request Identification**: X-Request-ID, X-Correlation-ID
- **Backend Communication**: X-Forwarded-*, X-Real-IP
- **Information Hiding**: Remove Server, X-Powered-By

---

## üåê Feature 4: CORS Policies ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT**
**Branch:** `feature/v1.1.0-cors`
**Completed:** 2025-10-18

### Implementation Summary

‚úÖ **Config Model** - CORSPolicy mit vollst√§ndiger CORS-Unterst√ºtzung
‚úÖ **Kong Provider** - Native cors plugin
‚úÖ **APISIX Provider** - Native cors plugin (komma-separiert)
‚úÖ **Traefik Provider** - headers middleware mit accessControl* Feldern
‚úÖ **Envoy Provider** - Native route-level CORS policy
‚úÖ **Route-Level Config** - Per-Route CORS-Konfiguration
‚úÖ **Tests** - 28 CORS Tests + 8 Config Tests, 211 total (alle bestehen)
‚úÖ **Documentation** - Umfassender CORS.md Guide (1000+ Zeilen auf Deutsch)
‚úÖ **Example Config** - examples/cors-example.yaml mit 15 Szenarien

### Motivation
- Cross-Origin API-Zugriff f√ºr SPAs
- Browser-Sicherheit (Same-Origin-Policy)
- Mobile App-Integration
- Preflight-Request-Optimierung

### Configuration Schema

```yaml
routes:
  - path_prefix: /api/public
    methods: [GET, POST, OPTIONS]  # OPTIONS wichtig!
    cors:
      enabled: true
      # Allowed origins (spezifisch oder Wildcard)
      allowed_origins:
        - "https://app.example.com"
        - "https://www.example.com"
      # Allowed HTTP methods
      allowed_methods:
        - GET
        - POST
        - PUT
        - DELETE
        - OPTIONS
      # Allowed request headers
      allowed_headers:
        - Content-Type
        - Authorization
        - X-API-Key
      # Headers exposed to browser
      expose_headers:
        - X-Request-ID
        - X-RateLimit-Remaining
      # Allow credentials (cookies, auth)
      allow_credentials: true
      # Preflight cache duration (seconds)
      max_age: 86400  # 24 hours
```

### Implementation Details

#### Config Model (`gal/config.py`)
```python
@dataclass
class CORSPolicy:
    """CORS (Cross-Origin Resource Sharing) policy configuration."""
    enabled: bool = True
    allowed_origins: List[str] = field(default_factory=lambda: ["*"])
    allowed_methods: List[str] = field(default_factory=lambda: ["GET", "POST", "PUT", "DELETE", "OPTIONS"])
    allowed_headers: List[str] = field(default_factory=lambda: ["Content-Type", "Authorization"])
    expose_headers: List[str] = field(default_factory=list)
    allow_credentials: bool = False
    max_age: int = 86400  # 24 hours

@dataclass
class Route:
    path_prefix: str
    methods: Optional[List[str]] = None
    rate_limit: Optional[RateLimitConfig] = None
    authentication: Optional[AuthenticationConfig] = None
    headers: Optional[HeaderManipulation] = None
    cors: Optional[CORSPolicy] = None  # NEW!
```

#### Provider Implementations

**Kong (`gal/providers/kong.py`)**
```python
# Native cors plugin
if route.cors and route.cors.enabled:
    cors = route.cors
    cors_config = {
        "origins": cors.allowed_origins,
        "methods": cors.allowed_methods,
        "headers": cors.allowed_headers,
        "credentials": cors.allow_credentials,
        "max_age": cors.max_age
    }
    if cors.expose_headers:
        cors_config["exposed_headers"] = cors.expose_headers
    route_plugins.append({
        "name": "cors",
        "config": cors_config
    })
```

**APISIX (`gal/providers/apisix.py`)**
```python
# Native cors plugin (comma-separated format)
if route.cors and route.cors.enabled:
    cors = route.cors
    cors_config = {
        "allow_origins": ",".join(cors.allowed_origins),
        "allow_methods": ",".join(cors.allowed_methods),
        "allow_headers": ",".join(cors.allowed_headers),
        "allow_credential": cors.allow_credentials,  # Note: singular!
        "max_age": cors.max_age
    }
    if cors.expose_headers:
        cors_config["expose_headers"] = ",".join(cors.expose_headers)
    route_config["plugins"]["cors"] = cors_config
```

**Traefik (`gal/providers/traefik.py`)**
```python
# CORS via headers middleware
if route.cors and route.cors.enabled:
    cors = route.cors
    output.append(f"    {router_name}_cors:")
    output.append("      headers:")
    output.append("        accessControlAllowMethods:")
    for method in cors.allowed_methods:
        output.append(f"          - {method}")
    output.append("        accessControlAllowOriginList:")
    for origin in cors.allowed_origins:
        output.append(f"          - '{origin}'")
    if cors.allowed_headers:
        output.append("        accessControlAllowHeaders:")
        for header in cors.allowed_headers:
            output.append(f"          - {header}")
    output.append(f"        accessControlAllowCredentials: {str(cors.allow_credentials).lower()}")
    output.append(f"        accessControlMaxAge: {cors.max_age}")
```

**Envoy (`gal/providers/envoy.py`)**
```python
# Native CORS policy on route level
if route.cors and route.cors.enabled:
    cors = route.cors
    output.append("                cors:")
    output.append("                  allow_origin_string_match:")
    for origin in cors.allowed_origins:
        if origin == "*":
            output.append("                  - safe_regex:")
            output.append("                      regex: '.*'")
        else:
            output.append(f"                  - exact: '{origin}'")
    output.append(f"                  allow_methods: '{', '.join(cors.allowed_methods)}'")
    output.append(f"                  allow_headers: '{', '.join(cors.allowed_headers)}'")
    if cors.expose_headers:
        output.append(f"                  expose_headers: '{', '.join(cors.expose_headers)}'")
    output.append(f"                  allow_credentials: {str(cors.allow_credentials).lower()}")
    output.append(f"                  max_age: '{cors.max_age}'")
```

### Use Cases
- **Single-Page Applications (SPA)**: Frontend auf anderem Domain als Backend
- **Mobile Apps**: Capacitor/Cordova/React Native Origins
- **Multi-Domain**: Mehrere Frontend-Domains erlauben
- **Public APIs**: Wildcard-Origins f√ºr √∂ffentliche APIs
- **GraphQL**: CORS f√ºr GraphQL-Endpoints
- **WebSocket**: CORS f√ºr WebSocket-Verbindungen

---

## ‚ö° Feature 6: Circuit Breaker ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT**
**Branch:** `feature/v1.1.0-circuit-breaker`
**Completed:** 2025-10-18

### Implementation Summary

‚úÖ **Config Model** - CircuitBreakerConfig mit allen Optionen
‚úÖ **Kong Provider** - Third-party Plugin (warning in docs)
‚úÖ **APISIX Provider** - Native api-breaker plugin
‚úÖ **Traefik Provider** - Native CircuitBreaker middleware
‚úÖ **Envoy Provider** - Native Outlier Detection
‚úÖ **Tests** - 30+ Circuit Breaker Tests (357 total tests)
‚úÖ **Documentation** - Umfassender CIRCUIT_BREAKER.md Guide (1000+ Zeilen)
‚úÖ **Example Config** - examples/circuit-breaker-example.yaml mit 10+ Szenarien

### Motivation
- Fehler-Isolation (Cascading Failures verhindern)
- Schnelle Fehlerbehandlung (sofortige R√ºckmeldung)
- Automatische Erholung (Service-Health Testing)
- Resource-Schonung (keine verschwendeten Requests)

### Configuration Schema

```yaml
routes:
  - path_prefix: /api/payments
    methods: [GET, POST]
    circuit_breaker:
      enabled: true
      # Schwellwert: Nach wie vielen Fehlern √∂ffnet Circuit Breaker?
      max_failures: 5
      # Timeout: Wie lange wartet CB bis HALF_OPEN Test?
      timeout: "30s"
      # Half-Open Requests: Wie viele Test-Requests in HALF_OPEN?
      half_open_requests: 3
      # Welche HTTP Status Codes gelten als Fehler?
      unhealthy_status_codes: [500, 502, 503, 504]
      # Custom Response wenn Circuit OPEN
      response:
        status_code: 503
        message: "Service temporarily unavailable"
```

### Implementation Details

#### Circuit Breaker States
```
CLOSED (Normal) ‚Üí OPEN (Broken) ‚Üí HALF_OPEN (Testing) ‚Üí CLOSED
```

1. **CLOSED**: Normal operation, alle Requests durchgelassen
2. **OPEN**: Circuit "gebrochen", Requests sofort abgelehnt
3. **HALF_OPEN**: Testet mit wenigen Requests ob Service wieder OK

#### Config Model (`gal/config.py`)
```python
@dataclass
class CircuitBreakerConfig:
    """Circuit Breaker configuration for resilience."""
    enabled: bool = True
    max_failures: int = 5
    timeout: str = "30s"
    half_open_requests: int = 3
    unhealthy_status_codes: List[int] = field(
        default_factory=lambda: [500, 502, 503, 504]
    )
    response_status_code: int = 503
    response_message: str = "Service temporarily unavailable"

@dataclass
class Route:
    path_prefix: str
    methods: Optional[List[str]] = None
    rate_limit: Optional[RateLimitConfig] = None
    authentication: Optional[AuthenticationConfig] = None
    headers: Optional[HeaderManipulation] = None
    cors: Optional[CORSPolicy] = None
    circuit_breaker: Optional[CircuitBreakerConfig] = None  # NEW!
```

#### Provider Implementations

**APISIX (`gal/providers/apisix.py`)**
```python
# Native api-breaker plugin
if route.circuit_breaker and route.circuit_breaker.enabled:
    cb = route.circuit_breaker
    route_config["plugins"]["api-breaker"] = {
        "break_response_code": cb.response_status_code,
        "max_breaker_sec": int(cb.timeout.rstrip('s')),
        "unhealthy_status_codes": cb.unhealthy_status_codes,
        "healthy_status_codes": [200, 201, 204]
    }
```

**Traefik (`gal/providers/traefik.py`)**
```python
# Native CircuitBreaker middleware
if route.circuit_breaker and route.circuit_breaker.enabled:
    cb = route.circuit_breaker
    output.append(f"    {router_name}_circuit_breaker:")
    output.append("      circuitBreaker:")
    output.append(f"        expression: 'ResponseCodeRatio(500, 600, 0, 600) > 0.30'")
```

**Envoy (`gal/providers/envoy.py`)**
```python
# Native Outlier Detection
if route.circuit_breaker and route.circuit_breaker.enabled:
    cb = route.circuit_breaker
    output.append("            outlier_detection:")
    output.append(f"              consecutive_5xx: {cb.max_failures}")
    output.append(f"              interval: {cb.timeout}")
    output.append(f"              base_ejection_time: {cb.timeout}")
    output.append("              max_ejection_percent: 100")
```

**Kong (`gal/providers/kong.py`)**
```python
# Kong hat kein natives Circuit Breaker Plugin
# Warnung wird in Dokumentation ausgegeben
if route.circuit_breaker and route.circuit_breaker.enabled:
    # Warning: Kong requires third-party plugin
    pass
```

### Use Cases
- **Payment Services**: Schutz vor fehlerhaften Payment-Providern
- **Third-Party APIs**: Externe APIs die tempor√§r down sein k√∂nnen
- **Microservices**: Service-to-Service Resilience
- **Database Services**: Schutz vor DB-√úberlastung
- **Legacy Systems**: Isolation alter, instabiler Services

### Provider Coverage
- ‚úÖ **75% Native Support** (3 von 4 Providern)
- ‚ö†Ô∏è Kong ben√∂tigt Third-Party Plugin

---

## üè• Feature 7: Health Checks & Load Balancing ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT**
**Branch:** `feature/v1.1.0-health-checks`
**Completed:** 2025-10-18

### Implementation Summary

‚úÖ **Config Models** - UpstreamTarget, ActiveHealthCheck, PassiveHealthCheck, HealthCheckConfig, LoadBalancerConfig
‚úÖ **APISIX Provider** - Native checks with active/passive support, all LB algorithms
‚úÖ **Kong Provider** - Upstream healthchecks, targets with weights, all LB algorithms
‚úÖ **Traefik Provider** - LoadBalancer healthCheck, multiple servers, weighted LB, sticky sessions
‚úÖ **Envoy Provider** - health_checks, outlier_detection, all LB policies
‚úÖ **Tests** - 50+ Health Check & Load Balancing Tests
‚úÖ **Documentation** - Umfassender HEALTH_CHECKS.md Guide (1000+ Zeilen)
‚úÖ **Example Config** - examples/health-checks-example.yaml mit 15 Szenarien

### Motivation
- Hochverf√ºgbarkeit (automatisches Failover)
- Performance-Optimierung (Lastverteilung)
- Horizontale Skalierbarkeit (mehrere Backend-Server)
- Service Health Monitoring (Active & Passive)

### Configuration Schema

```yaml
upstream:
  # Multiple Backend Servers (Load Balancing)
  targets:
    - host: api-1.internal
      port: 8080
      weight: 2              # Gewichtung f√ºr Load Balancing
    - host: api-2.internal
      port: 8080
      weight: 1

  # Health Checks
  health_check:
    # Active Health Checks (Periodic Probing)
    active:
      enabled: true
      http_path: /health
      interval: "10s"
      timeout: "5s"
      healthy_threshold: 2
      unhealthy_threshold: 3
      healthy_status_codes: [200, 201, 204]

    # Passive Health Checks (Traffic Monitoring)
    passive:
      enabled: true
      max_failures: 5
      unhealthy_status_codes: [500, 502, 503, 504]

  # Load Balancing
  load_balancer:
    algorithm: round_robin   # round_robin, least_conn, ip_hash, weighted
    sticky_sessions: false
    cookie_name: galSession
```

### Implementation Details

#### Config Models (`gal/config.py`)
```python
@dataclass
class UpstreamTarget:
    """Individual backend server with host, port, weight."""
    host: str
    port: int
    weight: int = 1

@dataclass
class ActiveHealthCheck:
    """Periodic HTTP/HTTPS/TCP probing configuration."""
    enabled: bool = True
    http_path: str = "/health"
    interval: str = "10s"
    timeout: str = "5s"
    healthy_threshold: int = 2
    unhealthy_threshold: int = 3
    healthy_status_codes: List[int] = field(default_factory=lambda: [200, 201, 204])

@dataclass
class PassiveHealthCheck:
    """Traffic monitoring / circuit breaker configuration."""
    enabled: bool = True
    max_failures: int = 5
    unhealthy_status_codes: List[int] = field(default_factory=lambda: [500, 502, 503, 504])

@dataclass
class HealthCheckConfig:
    """Combined active + passive health checks."""
    active: Optional[ActiveHealthCheck] = None
    passive: Optional[PassiveHealthCheck] = None

@dataclass
class LoadBalancerConfig:
    """Load balancing algorithm and sticky session config."""
    algorithm: str = "round_robin"
    sticky_sessions: bool = False
    cookie_name: str = "galSession"

@dataclass
class Upstream:
    """Extended to support multiple targets with health checks and load balancing."""
    host: str = ""
    port: int = 0
    targets: List[UpstreamTarget] = field(default_factory=list)
    health_check: Optional[HealthCheckConfig] = None
    load_balancer: Optional[LoadBalancerConfig] = None
```

#### Provider Implementations

**APISIX (`gal/providers/apisix.py`)**
```python
# Upstream with health checks and load balancing
upstream = {
    "id": f"{service.name}_upstream",
    "type": "roundrobin",  # oder: least_conn, chash
    "nodes": {
        "api-1.internal:8080": 2,  # weight
        "api-2.internal:8080": 1
    },
    "checks": {
        "active": {
            "type": "http",
            "http_path": "/health",
            "timeout": 5,
            "healthy": {"interval": 10, "successes": 2},
            "unhealthy": {"interval": 10, "http_failures": 3}
        },
        "passive": {
            "unhealthy": {"http_failures": 5, "http_statuses": [500, 502, 503, 504]}
        }
    }
}
```

**Kong (`gal/providers/kong.py`)**
```python
# Separate upstream with targets and healthchecks
upstreams:
- name: api_service_upstream
  algorithm: round-robin  # oder: least-connections, consistent-hashing
  healthchecks:
    active:
      http_path: /health
      interval: 10
      healthy:
        successes: 2
    passive:
      unhealthy:
        http_failures: 5
  targets:
  - target: api-1.internal:8080
    weight: 200  # Kong: 0-1000 scale
```

**Traefik (`gal/providers/traefik.py`)**
```python
# LoadBalancer service with health check
services:
  api_service_service:
    loadBalancer:
      servers:
      - url: 'http://api-1.internal:8080'
        weight: 2
      - url: 'http://api-2.internal:8080'
        weight: 1
      healthCheck:
        path: /health
        interval: 10s
        timeout: 5s
      sticky:
        cookie:
          name: galSession
```

**Envoy (`gal/providers/envoy.py`)**
```python
# Cluster with health_checks and outlier_detection
clusters:
- name: api_service_cluster
  lb_policy: ROUND_ROBIN  # oder: LEAST_REQUEST, RING_HASH
  health_checks:
  - timeout: 5s
    interval: 10s
    unhealthy_threshold: 3
    healthy_threshold: 2
    http_health_check:
      path: /health
  outlier_detection:
    consecutive_5xx: 5
  load_assignment:
    endpoints:
    - lb_endpoints:
      - endpoint:
          socket_address:
            address: api-1.internal
            port_value: 8080
        load_balancing_weight:
          value: 2
```

### Load Balancing Algorithms

**Round Robin**:
- Gleichm√§√üige zirkul√§re Verteilung
- Use Case: Homogene Backend-Server

**Least Connections**:
- Server mit wenigsten aktiven Verbindungen
- Use Case: WebSockets, lange Verbindungen

**IP Hash**:
- Basierend auf Client-IP (Consistent Hashing)
- Use Case: Session Persistence, Stateful Apps

**Weighted**:
- Verteilung basierend auf Server-Gewichtung
- Use Case: Heterogene Server, Canary Deployments

### Use Cases
- **Hochverf√ºgbare REST APIs**: Round-Robin + Active Health Checks
- **WebSocket Services**: IP Hash oder Sticky Sessions
- **Canary Deployments**: Weighted (90% old, 10% new)
- **Heterogene Server**: Weighted (nach CPU-Kapazit√§t)
- **Graceful Degradation**: Active + Passive Health Checks

### Provider Coverage
- ‚úÖ **100% Active Health Check Support** (4 von 4 Providern)
- ‚úÖ **75% Passive Health Check Support** (3 von 4 Providern, Traefik nutzt K8s Probes)
- ‚úÖ **100% Load Balancing Support** (4 von 4 Providern)
- ‚úÖ **50+ Tests** (alle Provider, alle Algorithmen)

---

## üì¶ Feature 5: PyPI Publication ‚úÖ

**Status:** ‚úÖ **IMPLEMENTIERT**
**Branch:** `develop`
**Completed:** 2025-10-18

### Implementation Summary

‚úÖ **Package Configuration** - pyproject.toml, setup.py mit v1.1.0 Keywords/Classifiers
‚úÖ **Release Workflow** - Automatisches Publishing zu PyPI & TestPyPI
‚úÖ **TestPyPI Integration** - Pre-Release Tags (alpha/beta/rc) ‚Üí TestPyPI
‚úÖ **PyPI Integration** - Stable Tags (v1.x.x) ‚Üí PyPI
‚úÖ **Documentation** - Umfassender PyPI Publishing Guide (docs/PYPI_PUBLISHING.md)
‚úÖ **README Updates** - PyPI Badges, Installation Instructions, Links
‚úÖ **Security** - API Tokens als GitHub Secrets konfiguriert

### Package Details

**PyPI Package Name:** `gal-gateway`
**Import Name:** `gal`
**CLI Command:** `gal`
**Python Versions:** 3.10, 3.11, 3.12

### Tasks Completed

1. **Package Preparation**
   - ‚úÖ pyproject.toml updated with v1.1.0 keywords & classifiers
   - ‚úÖ setup.py updated with v1.1.0 keywords & classifiers
   - ‚úÖ MANIFEST.in configured (includes VERSION, docs, examples)
   - ‚úÖ Keywords: rate-limiting, authentication, cors, circuit-breaker, health-checks, jwt, security
   - ‚úÖ Classifiers: HTTP Servers, Security, AsyncIO

2. **Release Workflow Implementation**
   - ‚úÖ `.github/workflows/release.yml` updated
   - ‚úÖ `publish-testpypi` Job: Pre-Release Tags (alpha/beta/rc) ‚Üí TestPyPI
   - ‚úÖ `publish-pypi` Job: Stable Tags (vX.Y.Z) ‚Üí PyPI
   - ‚úÖ `twine check` Integration f√ºr Package-Validierung
   - ‚úÖ Conditional Publishing basierend auf Tag-Format

3. **GitHub Secrets Setup** (Maintainer)
   - ‚ö†Ô∏è `PYPI_API_TOKEN` - Muss von PyPI Account generiert werden
   - ‚ö†Ô∏è `TEST_PYPI_API_TOKEN` - Muss von TestPyPI Account generiert werden
   - üìù Siehe [docs/PYPI_PUBLISHING.md](../PYPI_PUBLISHING.md) f√ºr Setup-Anleitung

4. **Testing Workflow**
   ```bash
   # Pre-Release Testing (TestPyPI)
   git tag -a v1.1.0-rc1 -m "Release Candidate 1"
   git push origin v1.1.0-rc1
   # ‚Üí Publishes to TestPyPI

   # Stable Release (PyPI)
   git tag -a v1.1.0 -m "Release v1.1.0"
   git push origin v1.1.0
   # ‚Üí Publishes to PyPI
   ```

5. **Documentation**
   - ‚úÖ `docs/PYPI_PUBLISHING.md` - Vollst√§ndiger Publishing Guide
     - PyPI/TestPyPI Account Setup
     - 2FA Konfiguration
     - API Token Generation
     - Release Prozess (Pre-Release & Stable)
     - Manuelle Publishing-Anweisungen
     - Troubleshooting Guide
     - Best Practices
   - ‚úÖ `README.md` Updates:
     - PyPI Badges (version, python versions, downloads)
     - Installation Instructions
     - PyPI Links (PyPI, TestPyPI, Docs)

### Installation

```bash
# Von PyPI (Stable)
pip install gal-gateway

# Von TestPyPI (Pre-Release)
pip install --index-url https://test.pypi.org/simple/ \
            --extra-index-url https://pypi.org/simple/ \
            gal-gateway

# CLI verwenden
gal --version
gal generate examples/rate-limiting-example.yaml
```

### Release Workflow Details

**Trigger:** Git Tags (vX.Y.Z format)

**Jobs:**
1. `create-release` - GitHub Release erstellen
2. `build-artifacts` - Python Wheel & Source Distribution bauen
3. `publish-testpypi` - Pre-Release auf TestPyPI (if tag contains -alpha/-beta/-rc)
4. `publish-pypi` - Stable Release auf PyPI (if tag does NOT contain pre-release suffixes)

**Pre-Release Tags:**
- `v1.1.0-alpha1` ‚Üí TestPyPI
- `v1.1.0-beta1` ‚Üí TestPyPI
- `v1.1.0-rc1` ‚Üí TestPyPI

**Stable Tags:**
- `v1.1.0` ‚Üí PyPI

### Next Steps (F√ºr Maintainer)

1. **PyPI Account Setup:**
   - Erstelle PyPI Account auf https://pypi.org/account/register/
   - Aktiviere 2FA (verpflichtend!)
   - Generiere API Token
   - F√ºge Token als `PYPI_API_TOKEN` in GitHub Secrets hinzu

2. **TestPyPI Account Setup:**
   - Erstelle TestPyPI Account auf https://test.pypi.org/account/register/
   - Aktiviere 2FA
   - Generiere API Token
   - F√ºge Token als `TEST_PYPI_API_TOKEN` in GitHub Secrets hinzu

3. **First Release Test:**
   ```bash
   # Test mit Pre-Release Tag
   git tag -a v1.1.0-rc1 -m "Release Candidate 1 for v1.1.0"
   git push origin v1.1.0-rc1

   # Verifiziere auf TestPyPI
   # https://test.pypi.org/project/gal-gateway/

   # Install & Test
   pip install --index-url https://test.pypi.org/simple/ \
               --extra-index-url https://pypi.org/simple/ \
               gal-gateway==1.1.0rc1
   gal --version
   ```

4. **Official v1.1.0 Release:**
   ```bash
   # Wenn alles funktioniert, stable Release
   git tag -a v1.1.0 -m "Release v1.1.0 - Traffic Management & Security"
   git push origin v1.1.0

   # Verifiziere auf PyPI
   # https://pypi.org/project/gal-gateway/
   ```

### Links

- **PyPI Package:** https://pypi.org/project/gal-gateway/
- **TestPyPI Package:** https://test.pypi.org/project/gal-gateway/
- **Publishing Guide:** [docs/PYPI_PUBLISHING.md](../PYPI_PUBLISHING.md)
- **Release Workflow:** [.github/workflows/release.yml](../../.github/workflows/release.yml)

---

## üìä Testing Strategy

### Test Coverage Goals
- **Unit Tests:** 95%+ coverage
- **Integration Tests:** All provider combinations
- **E2E Tests:** Real gateway deployments (optional)

### Test Structure
```
tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ test_rate_limiting.py
‚îÇ   ‚îú‚îÄ‚îÄ test_authentication.py
‚îÇ   ‚îú‚îÄ‚îÄ test_headers.py
‚îÇ   ‚îî‚îÄ‚îÄ test_cors.py
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ test_envoy_rate_limit.py
‚îÇ   ‚îú‚îÄ‚îÄ test_kong_jwt_auth.py
‚îÇ   ‚îî‚îÄ‚îÄ test_apisix_cors.py
‚îî‚îÄ‚îÄ e2e/
    ‚îî‚îÄ‚îÄ test_complete_workflow.py
```

### Test Fixtures
```python
@pytest.fixture
def rate_limit_config():
    return RateLimitConfig(
        requests_per_second=100,
        burst=200,
        key_type="ip_address"
    )

@pytest.fixture
def jwt_auth_config():
    return JwtConfig(
        issuer="https://auth.test",
        audiences=["api"],
        jwks_uri="https://auth.test/.well-known/jwks.json"
    )
```

---

## üìö Documentation Plan

### New Documentation Files

1. **`docs/guides/RATE_LIMITING.md`**
   - Configuration examples
   - Provider-specific notes
   - Best practices
   - Troubleshooting

2. **`docs/guides/AUTHENTICATION.md`**
   - All auth types explained
   - JWT setup guide
   - API key management
   - Security considerations

3. **`docs/guides/HEADERS.md`**
   - Header manipulation patterns
   - Template syntax
   - Use cases

4. **`docs/guides/CORS.md`**
   - CORS explained
   - Configuration examples
   - Browser compatibility

5. **`docs/guides/MIGRATION.md`**
   - v1.0 ‚Üí v1.1 migration guide
   - Breaking changes
   - New features adoption

### README Updates
- Add v1.1.0 features to feature list
- Update Quick Start with new examples
- Add PyPI installation section

---

## üöÄ Release Plan

### Pre-Release Checklist

- [ ] All features implemented
- [ ] Tests passing (95%+ coverage)
- [ ] Documentation complete
- [ ] CHANGELOG.md updated
- [ ] RELEASE_NOTES updated
- [ ] Migration guide written
- [ ] PyPI package tested on TestPyPI
- [ ] Docker images built and tested
- [ ] GitHub release notes prepared

### Release Steps

1. **Create Release Branch**
   ```bash
   git checkout -b release/v1.1.0
   ```

2. **Update Version**
   - Update `VERSION` file to `1.1.0`
   - Update all version references

3. **Final Testing**
   - Run full test suite
   - Manual testing on all providers
   - Performance benchmarks

4. **Merge to Main**
   ```bash
   git checkout main
   git merge release/v1.1.0
   ```

5. **Create Tag**
   ```bash
   git tag -a v1.1.0 -m "Release v1.1.0"
   git push origin v1.1.0
   ```

6. **Verify Automated Workflows**
   - GitHub Release created
   - Docker images pushed
   - PyPI package published

7. **Announce Release**
   - GitHub Discussions
   - Update documentation site
   - Social media (if applicable)

---

## üéØ Success Metrics

### Feature Adoption
- PyPI download count
- Docker image pulls
- GitHub Stars/Forks
- Issue/Discussion activity

### Code Quality
- Test coverage ‚â• 95%
- No critical bugs in first week
- Documentation completeness
- Performance benchmarks

### Community
- Contributor count
- Feature requests addressed
- Response time to issues
- Documentation quality feedback

---

## üìû Next Steps

1. **Review this plan** - Team/Community feedback
2. **Break down into Issues** - Create GitHub issues for each feature
3. **Assign milestones** - Set target dates
4. **Start Implementation** - Begin with highest priority features
5. **Weekly Status Updates** - Track progress

---

**Document Status:** Draft v1
**Last Updated:** 2025-10-18
**Author:** GAL Development Team
