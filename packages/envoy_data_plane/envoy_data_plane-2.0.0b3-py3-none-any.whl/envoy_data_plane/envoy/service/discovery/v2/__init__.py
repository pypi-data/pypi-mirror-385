# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/discovery/v2/ads.proto, envoy/service/discovery/v2/hds.proto, envoy/service/discovery/v2/rtds.proto, envoy/service/discovery/v2/sds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AdsDummy",
    "AggregatedDiscoveryServiceStub",
    "Capability",
    "CapabilityProtocol",
    "ClusterHealthCheck",
    "EndpointHealth",
    "EndpointHealthResponse",
    "HealthCheckRequest",
    "HealthCheckRequestOrEndpointHealthResponse",
    "HealthCheckSpecifier",
    "HealthDiscoveryServiceStub",
    "LocalityEndpoints",
    "RtdsDummy",
    "Runtime",
    "RuntimeDiscoveryServiceStub",
    "SdsDummy",
    "SecretDiscoveryServiceStub",
)

import datetime
from collections.abc import Iterable, Iterator
from dataclasses import dataclass

import betterproto2
import grpc

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class CapabilityProtocol(betterproto2.Enum):
    """
    Different Envoy instances may have different capabilities (e.g. Redis)
    and/or have ports enabled for different protocols.
    """

    HTTP = 0

    TCP = 1

    REDIS = 2


@dataclass(eq=False, repr=False)
class AdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221
    """

    pass


default_message_pool.register_message(
    "envoy.service.discovery.v2", "AdsDummy", AdsDummy
)


@dataclass(eq=False, repr=False)
class Capability(betterproto2.Message):
    """
    Defines supported protocols etc, so the management server can assign proper
    endpoints to healthcheck.
    """

    health_check_protocols: "list[CapabilityProtocol]" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "Capability", Capability
)


@dataclass(eq=False, repr=False)
class ClusterHealthCheck(betterproto2.Message):
    """
    The cluster name and locality is provided to Envoy for the endpoints that it
    health checks to support statistics reporting, logging and debugging by the
    Envoy instance (outside of HDS). For maximum usefulness, it should match the
    same cluster structure as that provided by EDS.
    """

    cluster_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    health_checks: "list[___api__v2__core__.HealthCheck]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    locality_endpoints: "list[LocalityEndpoints]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "ClusterHealthCheck", ClusterHealthCheck
)


@dataclass(eq=False, repr=False)
class EndpointHealth(betterproto2.Message):
    endpoint: "___api__v2__endpoint__.Endpoint | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    health_status: "___api__v2__core__.HealthStatus" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: ___api__v2__core__.HealthStatus(0),
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "EndpointHealth", EndpointHealth
)


@dataclass(eq=False, repr=False)
class EndpointHealthResponse(betterproto2.Message):
    endpoints_health: "list[EndpointHealth]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "EndpointHealthResponse", EndpointHealthResponse
)


@dataclass(eq=False, repr=False)
class HealthCheckRequest(betterproto2.Message):
    node: "___api__v2__core__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    capability: "Capability | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "HealthCheckRequest", HealthCheckRequest
)


@dataclass(eq=False, repr=False)
class HealthCheckRequestOrEndpointHealthResponse(betterproto2.Message):
    """


    Oneofs:
        - request_type:
    """

    health_check_request: "HealthCheckRequest | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="request_type"
    )

    endpoint_health_response: "EndpointHealthResponse | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="request_type"
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2",
    "HealthCheckRequestOrEndpointHealthResponse",
    HealthCheckRequestOrEndpointHealthResponse,
)


@dataclass(eq=False, repr=False)
class HealthCheckSpecifier(betterproto2.Message):
    cluster_health_checks: "list[ClusterHealthCheck]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    interval: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ____google__protobuf__.Duration,
        optional=True,
    )
    """
    The default is 1 second.
    """


default_message_pool.register_message(
    "envoy.service.discovery.v2", "HealthCheckSpecifier", HealthCheckSpecifier
)


@dataclass(eq=False, repr=False)
class LocalityEndpoints(betterproto2.Message):
    locality: "___api__v2__core__.Locality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    endpoints: "list[___api__v2__endpoint__.Endpoint]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.discovery.v2", "LocalityEndpoints", LocalityEndpoints
)


@dataclass(eq=False, repr=False)
class RtdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221
    """

    pass


default_message_pool.register_message(
    "envoy.service.discovery.v2", "RtdsDummy", RtdsDummy
)


@dataclass(eq=False, repr=False)
class Runtime(betterproto2.Message):
    """
    RTDS resource type. This describes a layer in the runtime virtual filesystem.
    """

    name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    Runtime resource name. This makes the Runtime a self-describing xDS
    resource.
    """

    layer: "____google__protobuf__.Struct | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("envoy.service.discovery.v2", "Runtime", Runtime)


@dataclass(eq=False, repr=False)
class SdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221
    """

    pass


default_message_pool.register_message(
    "envoy.service.discovery.v2", "SdsDummy", SdsDummy
)


class AggregatedDiscoveryServiceStub:
    """
    [#protodoc-title: Aggregated Discovery Service (ADS)]

    Discovery services for endpoints, clusters, routes,
    and listeners are retained in the package `envoy.api.v2` for backwards
    compatibility with existing management servers. New development in discovery
    services should proceed in the package `envoy.service.discovery.v2`.

    See https://github.com/envoyproxy/envoy-api#apis for a description of the role of
    ADS and how it is intended to be used by a management server. ADS requests
    have the same structure as their singleton xDS counterparts, but can
    multiplex many resource types on a single stream. The type_url in the
    DiscoveryRequest/DiscoveryResponse provides sufficient information to recover
    the multiplexed singleton APIs at the Envoy instance and management server.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_aggregated_resources(
        self, messages: "Iterable[___api__v2__.DiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DiscoveryResponse]":
        """
        This is a gRPC-only API.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/StreamAggregatedResources",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_aggregated_resources(
        self, messages: "Iterable[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.AggregatedDiscoveryService/DeltaAggregatedResources",
            ___api__v2__.DeltaDiscoveryRequest.SerializeToString,
            ___api__v2__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))


class HealthDiscoveryServiceStub:
    """
    [#protodoc-title: Health Discovery Service (HDS)]

    HDS is Health Discovery Service. It compliments Envoyâ€™s health checking
    service by designating this Envoy to be a healthchecker for a subset of hosts
    in the cluster. The status of these health checks will be reported to the
    management server, where it can be aggregated etc and redistributed back to
    Envoy through EDS.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_health_check(
        self, messages: "Iterable[HealthCheckRequestOrEndpointHealthResponse]"
    ) -> "Iterator[HealthCheckSpecifier]":
        """
        1. Envoy starts up and if its can_healthcheck option in the static
           bootstrap config is enabled, sends HealthCheckRequest to the management
           server. It supplies its capabilities (which protocol it can health check
           with, what zone it resides in, etc.).
        2. In response to (1), the management server designates this Envoy as a
           healthchecker to health check a subset of all upstream hosts for a given
           cluster (for example upstream Host 1 and Host 2). It streams
           HealthCheckSpecifier messages with cluster related configuration for all
           clusters this Envoy is designated to health check. Subsequent
           HealthCheckSpecifier message will be sent on changes to:
           a. Endpoints to health checks
           b. Per cluster configuration change
        3. Envoy creates a health probe based on the HealthCheck config and sends
           it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
           configuration Envoy waits upon the arrival of the probe response and
           looks at the content of the response to decide whether the endpoint is
           healthy or not. If a response hasn't been received within the timeout
           interval, the endpoint health status is considered TIMEOUT.
        4. Envoy reports results back in an EndpointHealthResponse message.
           Envoy streams responses as often as the interval configured by the
           management server in HealthCheckSpecifier.
        5. The management Server collects health statuses for all endpoints in the
           cluster (for all clusters) and uses this information to construct
           EndpointDiscoveryResponse messages.
        6. Once Envoy has a list of upstream endpoints to send traffic to, it load
           balances traffic to them without additional health checking. It may
           use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
           failed to a particular endpoint to account for health status propagation
           delay between HDS and EDS).
        By default, can_healthcheck is true. If can_healthcheck is false, Cluster
        configuration may not contain HealthCheck message.
        TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
        invariant?
        TODO(htuch): Add @amb67's diagram.
        """

        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.HealthDiscoveryService/StreamHealthCheck",
            HealthCheckRequestOrEndpointHealthResponse.SerializeToString,
            HealthCheckSpecifier.FromString,
        )(iter(messages))

    def fetch_health_check(
        self, message: "HealthCheckRequestOrEndpointHealthResponse"
    ) -> "HealthCheckSpecifier":
        """
        TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
        request/response. Should we add an identifier to the HealthCheckSpecifier
        to bind with the response?
        """

        return self._channel.unary_unary(
            "/envoy.service.discovery.v2.HealthDiscoveryService/FetchHealthCheck",
            HealthCheckRequestOrEndpointHealthResponse.SerializeToString,
            HealthCheckSpecifier.FromString,
        )(message)


class RuntimeDiscoveryServiceStub:
    """
    [#protodoc-title: Runtime Discovery Service (RTDS)]
    RTDS :ref:`configuration overview <config_runtime_rtds>`

    Discovery service for Runtime resources.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_runtime(
        self, messages: "Iterable[___api__v2__.DiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/StreamRuntime",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_runtime(
        self, messages: "Iterable[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/DeltaRuntime",
            ___api__v2__.DeltaDiscoveryRequest.SerializeToString,
            ___api__v2__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_runtime(
        self, message: "___api__v2__.DiscoveryRequest"
    ) -> "___api__v2__.DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.service.discovery.v2.RuntimeDiscoveryService/FetchRuntime",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(message)


class SecretDiscoveryServiceStub:
    """
    [#protodoc-title: Secret Discovery Service (SDS)]
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def delta_secrets(
        self, messages: "Iterable[___api__v2__.DeltaDiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.SecretDiscoveryService/DeltaSecrets",
            ___api__v2__.DeltaDiscoveryRequest.SerializeToString,
            ___api__v2__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def stream_secrets(
        self, messages: "Iterable[___api__v2__.DiscoveryRequest]"
    ) -> "Iterator[___api__v2__.DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.discovery.v2.SecretDiscoveryService/StreamSecrets",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_secrets(
        self, message: "___api__v2__.DiscoveryRequest"
    ) -> "___api__v2__.DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.service.discovery.v2.SecretDiscoveryService/FetchSecrets",
            ___api__v2__.DiscoveryRequest.SerializeToString,
            ___api__v2__.DiscoveryResponse.FromString,
        )(message)


from .....google import protobuf as ____google__protobuf__
from ....api import v2 as ___api__v2__
from ....api.v2 import core as ___api__v2__core__
from ....api.v2 import endpoint as ___api__v2__endpoint__
