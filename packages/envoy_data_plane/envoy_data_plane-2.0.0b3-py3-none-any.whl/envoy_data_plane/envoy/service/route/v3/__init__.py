# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/route/v3/rds.proto, envoy/service/route/v3/srds.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "RdsDummy",
    "RouteDiscoveryServiceStub",
    "ScopedRoutesDiscoveryServiceStub",
    "SrdsDummy",
    "VirtualHostDiscoveryServiceStub",
)

from collections.abc import Iterable, Iterator
from dataclasses import dataclass

import betterproto2
import grpc

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class RdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.service.route.v3", "RdsDummy", RdsDummy)


@dataclass(eq=False, repr=False)
class SrdsDummy(betterproto2.Message):
    """
    [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
    services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
    """

    pass


default_message_pool.register_message("envoy.service.route.v3", "SrdsDummy", SrdsDummy)


class RouteDiscoveryServiceStub:
    """
    [#protodoc-title: RDS]

    The resource_names field in DiscoveryRequest specifies a route configuration.
    This allows an Envoy configuration with multiple HTTP listeners (and
    associated HTTP connection manager filters) to use different route
    configurations. Each listener will bind its HTTP connection manager filter to
    a route table via this identifier.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_routes(
        self, messages: "Iterable[__discovery__v3__.DiscoveryRequest]"
    ) -> "Iterator[__discovery__v3__.DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.route.v3.RouteDiscoveryService/StreamRoutes",
            __discovery__v3__.DiscoveryRequest.SerializeToString,
            __discovery__v3__.DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_routes(
        self, messages: "Iterable[__discovery__v3__.DeltaDiscoveryRequest]"
    ) -> "Iterator[__discovery__v3__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.route.v3.RouteDiscoveryService/DeltaRoutes",
            __discovery__v3__.DeltaDiscoveryRequest.SerializeToString,
            __discovery__v3__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_routes(
        self, message: "__discovery__v3__.DiscoveryRequest"
    ) -> "__discovery__v3__.DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.service.route.v3.RouteDiscoveryService/FetchRoutes",
            __discovery__v3__.DiscoveryRequest.SerializeToString,
            __discovery__v3__.DiscoveryResponse.FromString,
        )(message)


class ScopedRoutesDiscoveryServiceStub:
    """
    [#protodoc-title: SRDS]
    * Routing :ref:`architecture overview <arch_overview_http_routing>`

    The Scoped Routes Discovery Service (SRDS) API distributes
    :ref:`ScopedRouteConfiguration<envoy_v3_api_msg.ScopedRouteConfiguration>`
    resources. Each ScopedRouteConfiguration resource represents a "routing
    scope" containing a mapping that allows the HTTP connection manager to
    dynamically assign a routing table (specified via a
    :ref:`RouteConfiguration<envoy_v3_api_msg_config.route.v3.RouteConfiguration>` message) to each
    HTTP request.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_scoped_routes(
        self, messages: "Iterable[__discovery__v3__.DiscoveryRequest]"
    ) -> "Iterator[__discovery__v3__.DiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.route.v3.ScopedRoutesDiscoveryService/StreamScopedRoutes",
            __discovery__v3__.DiscoveryRequest.SerializeToString,
            __discovery__v3__.DiscoveryResponse.FromString,
        )(iter(messages))

    def delta_scoped_routes(
        self, messages: "Iterable[__discovery__v3__.DeltaDiscoveryRequest]"
    ) -> "Iterator[__discovery__v3__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.route.v3.ScopedRoutesDiscoveryService/DeltaScopedRoutes",
            __discovery__v3__.DeltaDiscoveryRequest.SerializeToString,
            __discovery__v3__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))

    def fetch_scoped_routes(
        self, message: "__discovery__v3__.DiscoveryRequest"
    ) -> "__discovery__v3__.DiscoveryResponse":
        return self._channel.unary_unary(
            "/envoy.service.route.v3.ScopedRoutesDiscoveryService/FetchScopedRoutes",
            __discovery__v3__.DiscoveryRequest.SerializeToString,
            __discovery__v3__.DiscoveryResponse.FromString,
        )(message)


class VirtualHostDiscoveryServiceStub:
    """
    Virtual Host Discovery Service (VHDS) is used to dynamically update the list of virtual hosts for
    a given RouteConfiguration. If VHDS is configured a virtual host list update will be triggered
    during the processing of an HTTP request if a route for the request cannot be resolved. The
    :ref:`resource_names_subscribe <envoy_v3_api_field_service.discovery.v3.DeltaDiscoveryRequest.resource_names_subscribe>`
    field contains a list of virtual host names or aliases to track. The contents of an alias would
    be the contents of a ``host`` or ``authority`` header used to make an http request. An xDS server
    will match an alias to a virtual host based on the content of :ref:`domains'
    <envoy_v3_api_field_config.route.v3.VirtualHost.domains>` field. The ``resource_names_unsubscribe`` field
    contains a list of virtual host names that have been :ref:`unsubscribed
    <xds_protocol_unsubscribe>` from the routing table associated with the RouteConfiguration.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def delta_virtual_hosts(
        self, messages: "Iterable[__discovery__v3__.DeltaDiscoveryRequest]"
    ) -> "Iterator[__discovery__v3__.DeltaDiscoveryResponse]":
        yield from self._channel.stream_stream(
            "/envoy.service.route.v3.VirtualHostDiscoveryService/DeltaVirtualHosts",
            __discovery__v3__.DeltaDiscoveryRequest.SerializeToString,
            __discovery__v3__.DeltaDiscoveryResponse.FromString,
        )(iter(messages))


from ...discovery import v3 as __discovery__v3__
