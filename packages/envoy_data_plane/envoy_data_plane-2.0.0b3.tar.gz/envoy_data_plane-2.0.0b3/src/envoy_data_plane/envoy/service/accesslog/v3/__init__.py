# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/accesslog/v3/als.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AccessLogServiceStub",
    "StreamAccessLogsMessage",
    "StreamAccessLogsMessageHttpAccessLogEntries",
    "StreamAccessLogsMessageIdentifier",
    "StreamAccessLogsMessageTcpAccessLogEntries",
    "StreamAccessLogsResponse",
)

from collections.abc import Iterable
from dataclasses import dataclass

import betterproto2
import grpc

from .....message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class StreamAccessLogsMessage(betterproto2.Message):
    """
    Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
    access logs without ever expecting a response.

    Oneofs:
        - log_entries: Batches of log entries of a single type. Generally speaking, a given stream should only
            ever include one type of log entry.
    """

    identifier: "StreamAccessLogsMessageIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifier data that will only be sent in the first message on the stream. This is effectively
    structured metadata and is a performance optimization.
    """

    http_logs: "StreamAccessLogsMessageHttpAccessLogEntries | None" = (
        betterproto2.field(
            2, betterproto2.TYPE_MESSAGE, optional=True, group="log_entries"
        )
    )

    tcp_logs: "StreamAccessLogsMessageTcpAccessLogEntries | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="log_entries"
    )


default_message_pool.register_message(
    "envoy.service.accesslog.v3", "StreamAccessLogsMessage", StreamAccessLogsMessage
)


@dataclass(eq=False, repr=False)
class StreamAccessLogsMessageHttpAccessLogEntries(betterproto2.Message):
    """
    Wrapper for batches of HTTP access log entries.
    """

    log_entry: "list[___data__accesslog__v3__.HttpAccessLogEntry]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.accesslog.v3",
    "StreamAccessLogsMessage.HTTPAccessLogEntries",
    StreamAccessLogsMessageHttpAccessLogEntries,
)


@dataclass(eq=False, repr=False)
class StreamAccessLogsMessageIdentifier(betterproto2.Message):
    node: "___config__core__v3__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node sending the access log messages over the stream.
    """

    log_name: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    The friendly name of the log configured in :ref:`CommonGrpcAccessLogConfig
    <envoy_v3_api_msg_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig>`.
    """


default_message_pool.register_message(
    "envoy.service.accesslog.v3",
    "StreamAccessLogsMessage.Identifier",
    StreamAccessLogsMessageIdentifier,
)


@dataclass(eq=False, repr=False)
class StreamAccessLogsMessageTcpAccessLogEntries(betterproto2.Message):
    """
    Wrapper for batches of TCP access log entries.
    """

    log_entry: "list[___data__accesslog__v3__.TcpAccessLogEntry]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "envoy.service.accesslog.v3",
    "StreamAccessLogsMessage.TCPAccessLogEntries",
    StreamAccessLogsMessageTcpAccessLogEntries,
)


@dataclass(eq=False, repr=False)
class StreamAccessLogsResponse(betterproto2.Message):
    """
    Empty response for the StreamAccessLogs API. Will never be sent. See below.
    """

    pass


default_message_pool.register_message(
    "envoy.service.accesslog.v3", "StreamAccessLogsResponse", StreamAccessLogsResponse
)


class AccessLogServiceStub:
    """
    [#protodoc-title: gRPC access log service (ALS)]

    Service for streaming access logs from Envoy to an access log server.
    """

    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def stream_access_logs(
        self, messages: "Iterable[StreamAccessLogsMessage]"
    ) -> "StreamAccessLogsResponse":
        """
        Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
        response to be sent as nothing would be done in the case of failure. The server should
        disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
        API for "critical" access logs in which Envoy will buffer access logs for some period of time
        until it gets an ACK so it could then retry. This API is designed for high throughput with the
        expectation that it might be lossy.
        """

        return self._channel.stream_unary(
            "/envoy.service.accesslog.v3.AccessLogService/StreamAccessLogs",
            StreamAccessLogsMessage.SerializeToString,
            StreamAccessLogsResponse.FromString,
        )(iter(messages))


from ....config.core import v3 as ___config__core__v3__
from ....data.accesslog import v3 as ___data__accesslog__v3__
