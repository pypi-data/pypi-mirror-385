
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "dbg"

@_ods_cext.register_operation(_Dialect)
class ArrayOp(_ods_ir.OpView):
  r"""
  Creates an array aggregate from a list of values. The first operand is
  placed at array index 0. The last operand is placed at the highest array
  index. The `dbg.array` operation allows for array-like source language
  values to be captured in the debug info. This includes arrays, or in the
  case of SystemVerilog, packed and unpacked arrays, lists, sequences, queues,
  FIFOs, channels, and vectors.
  
  See the rationale for examples and details.
  """

  OPERATION_NAME = "dbg.array"

  _ODS_REGIONS = (0, True)

  def __init__(self, elements, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(elements))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def elements(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array(elements, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayOp(elements=elements, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ScopeOp(_ods_ir.OpView):
  r"""
  Creates an additional level of hierarchy in the DI, a "scope", which can be
  used to group variables and other scopes.
  
  Operations such as `hw.module` introduce an implicit scope. All debug
  operations within a module are added to that implicit scope, unless they
  have an explicit `scope` operand. Providing an explicit scope can be used to
  represent inlined modules.
  
  Scopes in DI do not necessarily have to correspond to levels of a module
  hierarchy. They can also be used to model things like control flow scopes,
  call stacks, and other source-language concepts.
  
  The `scope` operand of any debug dialect operation must be defined locally
  by a `dbg.scope` operation. It cannot be a block argument. (This is intended
  as a temporary restriction, to be lifted in the future.)
  """

  OPERATION_NAME = "dbg.scope"

  _ODS_REGIONS = (0, True)

  def __init__(self, instanceName, moduleName, *, scope=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if scope is not None: operands.append(scope)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instanceName"] = (instanceName if (
    isinstance(instanceName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(instanceName, context=_ods_context))
    attributes["moduleName"] = (moduleName if (
    isinstance(moduleName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(moduleName, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def scope(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def instanceName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["instanceName"]

  @instanceName.setter
  def instanceName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceName"] = value

  @builtins.property
  def moduleName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["moduleName"]

  @moduleName.setter
  def moduleName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["moduleName"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def scope(instance_name, module_name, *, scope=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ScopeOp(instanceName=instance_name, moduleName=module_name, scope=scope, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StructOp(_ods_ir.OpView):
  r"""
  Creates a struct aggregate from a list of names and values. The `dbg.struct`
  operation allows for struct-like source language values to be captured in
  the debug info. This includes structs, unions, bidirectional bundles,
  interfaces, classes, and other similar structures.
  
  See the rationale for examples and details.
  """

  OPERATION_NAME = "dbg.struct"

  _ODS_REGIONS = (0, True)

  def __init__(self, fields, names, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(fields))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["names"] = (names if (
    isinstance(names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(names, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fields(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["names"]

  @names.setter
  def names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["names"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def struct(fields, names, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StructOp(fields=fields, names=names, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VariableOp(_ods_ir.OpView):
  r"""
  Marks a value to be tracked in DI under the given name. The `dbg.variable`
  operation is useful to represent named values in a source language. For
  example, ports, constants, parameters, variables, nodes, or name aliases can
  all be represented as a variable. In combination with `dbg.array` and
  `dbg.struct`, complex aggregate source language values can be described and
  reconstituted from individual IR values. The `dbg.variable` operation acts
  as a tracker that follows the evolution of its assigned value throughout the
  compiler's pass pipelines. The debug info analysis uses this op to populate
  a module's scope with named source language values, and to establish how
  these source language values can be reconstituted from the actual IR values
  present at the end of compilation.
  
  See the rationale for examples and details. See the `dbg.scope` operation
  for additional details on how to use the `scope` operand.
  """

  OPERATION_NAME = "dbg.variable"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, scope=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if scope is not None: operands.append(scope)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scope(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def variable(name, value, *, scope=None, loc=None, ip=None) -> VariableOp:
  return VariableOp(name=name, value=value, scope=scope, loc=loc, ip=ip)
