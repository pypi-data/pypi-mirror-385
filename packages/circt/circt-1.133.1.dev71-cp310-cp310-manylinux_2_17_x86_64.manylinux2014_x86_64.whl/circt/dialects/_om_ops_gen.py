
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "om"

@_ods_cext.register_operation(_Dialect)
class AnyCastOp(_ods_ir.OpView):
  r"""
  Casts any value to AnyType. This is useful for situations where a value of
  AnyType is needed, but a value of some concrete type is known.
  
  In the evaluator, this is a noop, and the value of concrete type is used.
  """

  OPERATION_NAME = "om.any_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def any_cast(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AnyCastOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BasePathCreateOp(_ods_ir.OpView):
  r"""
  Produces a value which represents a fragment of a hierarchical path to a
  target. Given a base path, extend it with the name of a module instance, to
  produce a new base path. The instance is identified via an NLA. Once the
  final verilog name of the instance is known, this op can be converted into
  a FrozenBasePathOp.
  
  Example:
  ```mlir
  hw.module @Foo() -> () {
    hw.inst "bar" sym @bar @Bar() -> ()
  }
  hw.hierpath @Path [@Foo::@bar]
  om.class @OM(%basepath: !om.basepath) {
    %0 = om.basepath_create %base @Path
  }
  ```
  """

  OPERATION_NAME = "om.basepath_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, basePath, target, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(basePath)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def basePath(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def target(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def basepath_create(base_path, target, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BasePathCreateOp(basePath=base_path, target=target, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClassExternOp(_ods_ir.OpView):
  OPERATION_NAME = "om.class.extern"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, formalParamNames, fieldNames, fieldTypes, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["formalParamNames"] = (formalParamNames if (
    isinstance(formalParamNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(formalParamNames, context=_ods_context))
    attributes["fieldNames"] = (fieldNames if (
    isinstance(fieldNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(fieldNames, context=_ods_context))
    attributes["fieldTypes"] = (fieldTypes if (
    isinstance(fieldTypes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(fieldTypes, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def formalParamNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["formalParamNames"]

  @formalParamNames.setter
  def formalParamNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formalParamNames"] = value

  @builtins.property
  def fieldNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["fieldNames"]

  @fieldNames.setter
  def fieldNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldNames"] = value

  @builtins.property
  def fieldTypes(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["fieldTypes"]

  @fieldTypes.setter
  def fieldTypes(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldTypes"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def class_extern(sym_name, formal_param_names, field_names, field_types, *, loc=None, ip=None) -> ClassExternOp:
  return ClassExternOp(sym_name=sym_name, formalParamNames=formal_param_names, fieldNames=field_names, fieldTypes=field_types, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClassFieldsOp(_ods_ir.OpView):
  OPERATION_NAME = "om.class.fields"

  _ODS_REGIONS = (0, True)

  def __init__(self, fields, *, field_locs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(fields))
    _ods_context = _ods_get_default_loc_context(loc)
    if field_locs is not None: attributes["field_locs"] = (field_locs if (
        isinstance(field_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(field_locs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fields(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def field_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "field_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["field_locs"]

  @field_locs.setter
  def field_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["field_locs"] = value
    elif "field_locs" in self.operation.attributes:
      del self.operation.attributes["field_locs"]

  @field_locs.deleter
  def field_locs(self):
    del self.operation.attributes["field_locs"]

def class_fields(fields, *, field_locs=None, loc=None, ip=None) -> ClassFieldsOp:
  return ClassFieldsOp(fields=fields, field_locs=field_locs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ClassOp(_ods_ir.OpView):
  OPERATION_NAME = "om.class"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, formalParamNames, fieldNames, fieldTypes, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["formalParamNames"] = (formalParamNames if (
    isinstance(formalParamNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(formalParamNames, context=_ods_context))
    attributes["fieldNames"] = (fieldNames if (
    isinstance(fieldNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(fieldNames, context=_ods_context))
    attributes["fieldTypes"] = (fieldTypes if (
    isinstance(fieldTypes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(fieldTypes, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def formalParamNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["formalParamNames"]

  @formalParamNames.setter
  def formalParamNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formalParamNames"] = value

  @builtins.property
  def fieldNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["fieldNames"]

  @fieldNames.setter
  def fieldNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldNames"] = value

  @builtins.property
  def fieldTypes(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["fieldTypes"]

  @fieldTypes.setter
  def fieldTypes(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldTypes"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def class_(sym_name, formal_param_names, field_names, field_types, *, loc=None, ip=None) -> ClassOp:
  return ClassOp(sym_name=sym_name, formalParamNames=formal_param_names, fieldNames=field_names, fieldTypes=field_types, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "om.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EmptyPathOp(_ods_ir.OpView):
  r"""
  Produces a value which represents a hierarchical path to nothing.
  
  Example:
  ```mlir
  om.class @OM()
    %0 = om.path_empty
  }
  ```
  """

  OPERATION_NAME = "om.path_empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def path_empty(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EmptyPathOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FrozenBasePathCreateOp(_ods_ir.OpView):
  r"""
  Produces a value which represents a fragment of a hierarchical path to a
  target.
  
  Example:
  ```mlir
  om.class @OM(%basepath: !om.basepath)
    %0 = om.frozenbasepath_create %basepath "Foo/bar:Bar/baz"
  }
  ```
  """

  OPERATION_NAME = "om.frozenbasepath_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, basePath, path, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(basePath)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["path"] = (path if (
    isinstance(path, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('OMPathAttr')) else
      _ods_ir.AttrBuilder.get('OMPathAttr')(path, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def basePath(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def path(self) -> _ods_ir.Attribute:
    return self.operation.attributes["path"]

  @path.setter
  def path(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["path"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def frozenbasepath_create(base_path, path, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FrozenBasePathCreateOp(basePath=base_path, path=path, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FrozenEmptyPathOp(_ods_ir.OpView):
  r"""
  Produces a value which represents a hierarchical path to nothing.
  
  Example:
  ```mlir
  om.class @OM()
    %0 = om.frozenpath_empty
  }
  ```
  """

  OPERATION_NAME = "om.frozenpath_empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def frozenpath_empty(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FrozenEmptyPathOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FrozenPathCreateOp(_ods_ir.OpView):
  r"""
  Produces a value which represents a hierarchical path to a hardware
  component from a base path to a target.
  
  Example:
  ```mlir
  om.class @OM(%basepath: !om.basepath)
    %0 = om.frozenpath_create reference %base "Foo/bar:Bar>w.a"
  }
  ```
  """

  OPERATION_NAME = "om.frozenpath_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, targetKind, basePath, path, module, ref, field, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(basePath)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["targetKind"] = (targetKind if (
    isinstance(targetKind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TargetKind')) else
      _ods_ir.AttrBuilder.get('TargetKind')(targetKind, context=_ods_context))
    attributes["path"] = (path if (
    isinstance(path, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('OMPathAttr')) else
      _ods_ir.AttrBuilder.get('OMPathAttr')(path, context=_ods_context))
    attributes["module"] = (module if (
    isinstance(module, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(module, context=_ods_context))
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(ref, context=_ods_context))
    attributes["field"] = (field if (
    isinstance(field, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(field, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def basePath(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def targetKind(self) -> _ods_ir.Attribute:
    return self.operation.attributes["targetKind"]

  @targetKind.setter
  def targetKind(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["targetKind"] = value

  @builtins.property
  def path(self) -> _ods_ir.Attribute:
    return self.operation.attributes["path"]

  @path.setter
  def path(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["path"] = value

  @builtins.property
  def module(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["module"]

  @module.setter
  def module(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module"] = value

  @builtins.property
  def ref(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def field(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["field"]

  @field.setter
  def field(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["field"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def frozenpath_create(target_kind, base_path, path, module, ref, field, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FrozenPathCreateOp(targetKind=target_kind, basePath=base_path, path=path, module=module, ref=ref, field=field, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntegerAddOp(_ods_ir.OpView):
  r"""
  Perform arbitrary precision signed integer addition of two OMIntegerType
  values.
  
  Example:
  ```mlir
  %2 = om.integer.add %0, %1 : !om.integer
  ```
  """

  OPERATION_NAME = "om.integer.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def integer_add(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntegerAddOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntegerMulOp(_ods_ir.OpView):
  r"""
  Perform arbitrary prevision signed integer multiplication of two
  OMIntegerType values.
  
  Example:
  ```mlir
  %2 = om.integer.mul %0, %1 : !om.integer
  ```
  """

  OPERATION_NAME = "om.integer.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def integer_mul(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntegerMulOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntegerShlOp(_ods_ir.OpView):
  r"""
  Perform arbitrary precision signed integer arithmetic shift left of the lhs
  OMIntegerType value by the rhs OMIntegerType value. The rhs value must be
  non-negative.
  
  Example:
  ```mlir
  %2 = om.integer.shl %0, %1 : !om.integer
  ```
  """

  OPERATION_NAME = "om.integer.shl"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def integer_shl(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntegerShlOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntegerShrOp(_ods_ir.OpView):
  r"""
  Perform arbitrary precision signed integer arithmetic shift right of the lhs
  OMIntegerType value by the rhs OMIntegerType value. The rhs value must be
  non-negative.
  
  Example:
  ```mlir
  %2 = om.integer.shr %0, %1 : !om.integer
  ```
  """

  OPERATION_NAME = "om.integer.shr"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def integer_shr(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntegerShrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListConcatOp(_ods_ir.OpView):
  r"""
  Produces a value of list type by concatenating the provided lists.
  
  Example:
  ```
  %3 = om.list_concat %0, %1, %2 : !om.list<string>
  ```
  """

  OPERATION_NAME = "om.list_concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, subLists, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(subLists))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def subLists(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_concat(sub_lists, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListConcatOp(subLists=sub_lists, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListCreateOp(_ods_ir.OpView):
  r"""
  Creates a list from a sequence of inputs.
  
  ```
  %list = om.list_create %a, %b, %c : !om.ref
  ```
  """

  OPERATION_NAME = "om.list_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def list_create(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ListCreateOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ObjectFieldOp(_ods_ir.OpView):
  OPERATION_NAME = "om.object.field"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, object, fieldPath, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(object)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fieldPath"] = (fieldPath if (
    isinstance(fieldPath, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefArrayAttr')(fieldPath, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def object(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fieldPath(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["fieldPath"]

  @fieldPath.setter
  def fieldPath(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldPath"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def object_field(result, object, field_path, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ObjectFieldOp(result=result, object=object, fieldPath=field_path, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ObjectOp(_ods_ir.OpView):
  OPERATION_NAME = "om.object"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, className, actualParams, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(actualParams))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["className"] = (className if (
    isinstance(className, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(className, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def actualParams(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def className(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["className"]

  @className.setter
  def className(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["className"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def object(result, class_name, actual_params, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ObjectOp(result=result, className=class_name, actualParams=actual_params, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PathCreateOp(_ods_ir.OpView):
  r"""
  Produces a value which represents a hierarchical path to a hardware
  target.
   from a base path to a target.
  
  Example:
  ```mlir
  hw.module @Foo() -> () {
    %wire = hw.wire sym @w: !i1
  }
  hw.hierpath @Path [@Foo::@w]
  om.class @OM(%basepath: !om.basepath)
    %0 = om.path_create reference %basepath @Path
  }
  ```
  """

  OPERATION_NAME = "om.path_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, targetKind, basePath, target, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(basePath)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["targetKind"] = (targetKind if (
    isinstance(targetKind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TargetKind')) else
      _ods_ir.AttrBuilder.get('TargetKind')(targetKind, context=_ods_context))
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def basePath(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def targetKind(self) -> _ods_ir.Attribute:
    return self.operation.attributes["targetKind"]

  @targetKind.setter
  def targetKind(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["targetKind"] = value

  @builtins.property
  def target(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def path_create(target_kind, base_path, target, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PathCreateOp(targetKind=target_kind, basePath=base_path, target=target, results=results, loc=loc, ip=ip).result
