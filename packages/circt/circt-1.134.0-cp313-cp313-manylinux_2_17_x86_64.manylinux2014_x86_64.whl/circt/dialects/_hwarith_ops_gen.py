
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "hwarith"

@_ods_cext.register_operation(_Dialect)
class AddOp(_ods_ir.OpView):
  r"""
  The `add` operation takes two operands and returns one result. The result
  type is inferred from the operand types, which may be signed or unsigned
  scalar integer types of arbitrary bitwidth.
  
  | LHS type | RHS type | Result type                              |
  | :------- | :------- | :--------------------------------------- |
  | `ui<a>`  | `ui<b>`  | `ui<r>`, *r* = max(*a*, *b*) + 1         |
  | `si<a>`  | `si<b>`  | `si<r>`, *r* = max(*a*, *b*) + 1         |
  | `ui<a>`  | `si<b>`  | `si<r>`, *r* = *a* + 2 **if** *a* ≥ *b*  |
  |          |          | `si<r>`, *r* = *b* + 1 **if** *a* < *b*  |
  | `si<a>`  | `ui<b>`  | Same as `ui<b> + si<a>`                  |
  
  Examples:
  ```mlir
  %0 = hwarith.add %10, %11 : (ui3, ui4) -> ui5
  %1 = hwarith.add %12, %13 : (si3, si3) -> si4
  %2 = hwarith.add %14, %15 : (ui3, si4) -> si5
  %3 = hwarith.add %16, %17 : (si4, ui6) -> si8
  ```
  """

  OPERATION_NAME = "hwarith.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  The constant operation produces a sign-aware constant value.
  ```
    %result = hwarith.constant 42 : t1
  ```
  """

  OPERATION_NAME = "hwarith.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, rawValue, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["rawValue"] = (rawValue if (
    isinstance(rawValue, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(rawValue, context=_ods_context))
    if results is None:
      _ods_result_type_source_attr = attributes["rawValue"]
      _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
      results = [_ods_derived_result_type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rawValue(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["rawValue"]

  @rawValue.setter
  def rawValue(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rawValue"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(raw_value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(rawValue=raw_value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DivOp(_ods_ir.OpView):
  r"""
  The `div` operation takes two operands and returns one result. The result
  type is inferred from the operand types, which may be signed or unsigned
  scalar integer types of arbitrary bitwidth.
  
  | LHS type | RHS type | Result type                              |
  | :------- | :------- | :--------------------------------------- |
  | `ui<a>`  | `ui<b>`  | `ui<r>`, *r* = *a*                       |
  | `si<a>`  | `si<b>`  | `si<r>`, *r* = *a* + 1                   |
  | `ui<a>`  | `si<b>`  | `si<r>`, *r* = *a* + 1                   |
  | `si<a>`  | `ui<b>`  | `si<r>`, *r* = *a*                       |
  
  Examples:
  ```mlir
  %0 = hwarith.div %10, %11 : (ui3, ui4) -> ui3
  %1 = hwarith.div %12, %13 : (si3, si3) -> si4
  %2 = hwarith.div %14, %15 : (ui3, si4) -> si4
  %3 = hwarith.div %16, %17 : (si4, ui6) -> si4
  ```
  """

  OPERATION_NAME = "hwarith.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def div(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DivOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  r"""
  The `cast` operation takes one operand and returns one result. Both, the
  result type and the operand type can be of any scalar integer type with
  arbitrary bitwidth. However, at least one of them needs to be a
  HWArithIntegerType.
  
  | Input type | Result type            | Behavior                                |
  | :--------- | :--------------------- | :-------------------------------------- |
  | `ui<a>`    | `ui<b>`/`si<b>`/`i<b>` | zero-extension **if** *b* ≥ *a*         |
  |            |                        | truncation **if** *b* < *a*             |
  | `si<a>`    | `ui<b>`/`si<b>`/`i<b>` | sign-extension **if** *b* ≥ *a*         |
  |            |                        | truncation **if** *b* < *a*             |
  | `i<a>`     | `ui<b>`/`si<b>`        | truncation **if** *b* **≤** *a*         |
  | `i<a>`     | `ui<b>`/`si<b>`        | prohibited<sup>†</sup> **if** *b* > *a* |
  
  †\) prohibited because of the ambiguity whether a sign or a zero extension
  is required.
  
  Examples:
  ```mlir
  %0 = hwarith.cast %10 : (ui3) -> si5
  %1 = hwarith.cast %11 : (si3) -> si4
  %2 = hwarith.cast %12 : (si7) -> ui4
  %3 = hwarith.cast %13 : (i7) -> si5
  %3 = hwarith.cast %13 : (si14) -> i4
  ```
  """

  OPERATION_NAME = "hwarith.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, in_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(in_)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(out)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def in_(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def out(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cast(out, in_, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CastOp(out=out, in_=in_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ICmpOp(_ods_ir.OpView):
  r"""
  The `icmp` operation compares two integers using a predicate. If the
  predicate is true, returns 1, otherwise returns 0. This operation always
  returns a one bit wide result of type `i1`. Both operand types may be
  signed or unsigned scalar integer types of arbitrary bitwidth.
  
  | LHS type | RHS type | Comparison type                          | Result type |
  | :------- | :------- | :--------------------------------------- | :---------- |
  | `ui<a>`  | `ui<b>`  | `ui<r>`, *r* = max(*a*, *b*)             | `i1`        |
  | `si<a>`  | `si<b>`  | `si<r>`, *r* = max(*a*, *b*)             | `i1`        |
  | `ui<a>`  | `si<b>`  | `si<r>`, *r* = *a* + 1 **if** *a* ≥ *b*  | `i1`        |
  |          |          | `si<r>`, *r* = *b* **if** *a* < *b*      | `i1`        |
  | `si<a>`  | `ui<b>`  | Same as `ui<b> si<a>`                    | `i1`        |
  
  Examples:
  ```mlir
  %0 = hwarith.icmp lt %10, %11 : ui5, ui6
  %1 = hwarith.icmp lt %12, %13 : si3, si4
  %2 = hwarith.icmp lt %12, %11 : si3, ui6
  ```
  """

  OPERATION_NAME = "hwarith.icmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, predicate, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["predicate"] = (predicate if (
    isinstance(predicate, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ICmpPredicate')) else
      _ods_ir.AttrBuilder.get('ICmpPredicate')(predicate, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def predicate(self) -> _ods_ir.Attribute:
    return self.operation.attributes["predicate"]

  @predicate.setter
  def predicate(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["predicate"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def icmp(predicate, lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ICmpOp(predicate=predicate, lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MulOp(_ods_ir.OpView):
  r"""
  The `mul` operation takes two operands and returns one result. The result
  type is inferred from the operand types, which may be signed or unsigned
  scalar integer types of arbitrary bitwidth.
  
  | LHS type | RHS type | Result type                              |
  | :------- | :------- | :--------------------------------------- |
  | `ui<a>`  | `ui<b>`  | `ui<r>`, *r* = *a* + *b*                 |
  | `si<a>`  | `si<b>`  | `si<r>`, *r* = *a* + *b*                 |
  | `ui<a>`  | `si<b>`  | `si<r>`, *r* = *a* + *b*                 |
  | `si<a>`  | `ui<b>`  | `si<r>`, *r* = *a* + *b*                 |
  
  Examples:
  ```mlir
  %0 = hwarith.mul %10, %11 : (ui3, ui4) -> ui7
  %1 = hwarith.mul %12, %13 : (si3, si3) -> si6
  %2 = hwarith.mul %14, %15 : (si3, ui5) -> si8
  ```
  """

  OPERATION_NAME = "hwarith.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mul(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MulOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SubOp(_ods_ir.OpView):
  r"""
  The `sub` operation takes two operands and returns one result. The result
  type is inferred from the operand types, which may be signed or unsigned
  scalar integer types of arbitrary bitwidth.
  
  | LHS type | RHS type | Result type                              |
  | :------- | :------- | :--------------------------------------- |
  | `ui<a>`  | `ui<b>`  | `si<r>`, *r* = max(*a*, *b*) + 1         |
  | `si<a>`  | `si<b>`  | `si<r>`, *r* = max(*a*, *b*) + 1         |
  | `ui<a>`  | `si<b>`  | `si<r>`, *r* = *a* + 2 **if** *a* ≥ *b*  |
  |          |          | `si<r>`, *r* = *b* + 1 **if** *a* < *b*  |
  | `si<a>`  | `ui<b>`  | Same as `ui<b> - si<a>`                  |
  
  Examples:
  ```mlir
  %0 = hwarith.sub %10, %11 : (ui3, ui4) -> si5
  %1 = hwarith.sub %12, %13 : (si3, si3) -> si4
  %2 = hwarith.sub %14, %15 : (ui3, si4) -> si5
  %3 = hwarith.sub %16, %17 : (si4, ui6) -> si8
  ```
  """

  OPERATION_NAME = "hwarith.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sub(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SubOp(inputs=inputs, results=results, loc=loc, ip=ip).result
