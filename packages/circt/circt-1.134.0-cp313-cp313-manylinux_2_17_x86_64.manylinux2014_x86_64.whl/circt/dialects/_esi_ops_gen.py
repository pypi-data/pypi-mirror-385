
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "esi"

@_ods_cext.register_operation(_Dialect)
class AppIDHierNodeOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.manifest.hier_node"

  _ODS_REGIONS = (1, True)

  def __init__(self, appID, moduleRef, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["appID"] = (appID if (
    isinstance(appID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDAttr')) else
      _ods_ir.AttrBuilder.get('AppIDAttr')(appID, context=_ods_context))
    attributes["moduleRef"] = (moduleRef if (
    isinstance(moduleRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(moduleRef, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def appID(self) -> _ods_ir.Attribute:
    return self.operation.attributes["appID"]

  @appID.setter
  def appID(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["appID"] = value

  @builtins.property
  def moduleRef(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["moduleRef"]

  @moduleRef.setter
  def moduleRef(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["moduleRef"] = value

  @builtins.property
  def children(self) -> _ods_ir.Region:
    return self.regions[0]

def manifest_hier_node(app_id, module_ref, *, loc=None, ip=None) -> AppIDHierNodeOp:
  return AppIDHierNodeOp(appID=app_id, moduleRef=module_ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AppIDHierRootOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.manifest.hier_root"

  _ODS_REGIONS = (1, True)

  def __init__(self, topModuleRef, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["topModuleRef"] = (topModuleRef if (
    isinstance(topModuleRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(topModuleRef, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def topModuleRef(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["topModuleRef"]

  @topModuleRef.setter
  def topModuleRef(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["topModuleRef"] = value

  @builtins.property
  def children(self) -> _ods_ir.Region:
    return self.regions[0]

def manifest_hier_root(top_module_ref, *, loc=None, ip=None) -> AppIDHierRootOp:
  return AppIDHierRootOp(topModuleRef=top_module_ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CallServiceDeclOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.service.std.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

def service_std_call(sym_name, *, loc=None, ip=None) -> CallServiceDeclOp:
  return CallServiceDeclOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ChannelBufferOp(_ods_ir.OpView):
  r"""
  A channel buffer (`buffer`) is essentially a set of options on a channel.
  It always adds at least one cycle of latency (pipeline stage) to the
  channel, but this is configurable.
  
  This operation is inserted on an ESI dataflow edge. It must exist
  previous to SystemVerilog emission but can be added in a lowering pass.
  
  A `stages` attribute may be provided to specify a specific number of cycles
  (pipeline stages) to use on this channel. Must be greater than 0.
  
  A `name` attribute may be provided to assigned a name to a buffered
  connection.
  
  Example:
  
  ```mlir
  %esiChan = hw.instance "sender" @Sender () : () -> (!esi.channel<i1>)
  // Allow automatic selection of options.
  %bufferedChan = esi.buffer %esiChan : i1
  hw.instance "recv" @Reciever (%bufferedChan) : (!esi.channel<i1>) -> ()
  
  // Alternatively, specify the number of stages.
  %fourStageBufferedChan = esi.buffer %esiChan { stages = 4 } : i1
  ```
  """

  OPERATION_NAME = "esi.buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, clk, rst, input, *, stages=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if stages is not None: attributes["stages"] = (stages if (
        isinstance(stages, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(stages, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def stages(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "stages" not in self.operation.attributes:
      return None
    return self.operation.attributes["stages"]

  @stages.setter
  def stages(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["stages"] = value
    elif "stages" in self.operation.attributes:
      del self.operation.attributes["stages"]

  @stages.deleter
  def stages(self):
    del self.operation.attributes["stages"]

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def buffer(output, clk, rst, input, *, stages=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ChannelBufferOp(output=output, clk=clk, rst=rst, input=input, stages=stages, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompressedManifestOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.manifest.compressed"

  _ODS_REGIONS = (0, True)

  def __init__(self, compressedManifest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["compressedManifest"] = (compressedManifest if (
    isinstance(compressedManifest, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BlobAttr')) else
      _ods_ir.AttrBuilder.get('BlobAttr')(compressedManifest, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def compressedManifest(self) -> _ods_ir.Attribute:
    return self.operation.attributes["compressedManifest"]

  @compressedManifest.setter
  def compressedManifest(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["compressedManifest"] = value

def manifest_compressed(compressed_manifest, *, loc=None, ip=None) -> CompressedManifestOp:
  return CompressedManifestOp(compressedManifest=compressed_manifest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CosimFromHostEndpointOp(_ods_ir.OpView):
  r"""
  A co-simulation endpoint is a connection from the simulation to some
  outside process, usually a software application responsible for driving
  the simulation (driver).
  
  It is uni-directional, in this case receiving data from the host for the
  simulation.
  
  NOTE: $id MUST be unique across all endpoints at simulation runtime.
  """

  OPERATION_NAME = "esi.cosim.from_host"

  _ODS_REGIONS = (0, True)

  def __init__(self, fromHost, clk, rst, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(id, context=_ods_context))
    results = []
    results.append(fromHost)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def id(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

  @builtins.property
  def fromHost(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cosim_from_host(from_host, clk, rst, id, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CosimFromHostEndpointOp(fromHost=from_host, clk=clk, rst=rst, id=id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CosimToHostEndpointOp(_ods_ir.OpView):
  r"""
  A co-simulation endpoint is a connection from the simulation to some
  outside process, usually a software application responsible for driving
  the simulation (driver).
  
  It is uni-directional, in this case sending data from the simulation to the
  host.
  
  NOTE: $id MUST be unique across all endpoints at simulation runtime.
  """

  OPERATION_NAME = "esi.cosim.to_host"

  _ODS_REGIONS = (0, True)

  def __init__(self, clk, rst, toHost, id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    operands.append(toHost)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    isinstance(id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(id, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def toHost(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def id(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

def cosim_to_host(clk, rst, to_host, id, *, loc=None, ip=None) -> CosimToHostEndpointOp:
  return CosimToHostEndpointOp(clk=clk, rst=rst, toHost=to_host, id=id, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CustomServiceDeclOp(_ods_ir.OpView):
  r"""
  A declaration of an ESI service interface. Defines a contract between a
  service provider and its clients.
  
  Example:
  
  ```mlir
  esi.service.decl @HostComms {
    esi.service.port send : !esi.bundle<[!esi.any from "send"]>
    esi.service.port recieve : !esi.channel<[i8 to "recv"]>
  }
  ```
  """

  OPERATION_NAME = "esi.service.decl"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def ports(self) -> _ods_ir.Region:
    return self.regions[0]

def service_decl(sym_name, *, loc=None, ip=None) -> CustomServiceDeclOp:
  return CustomServiceDeclOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ESIPureModuleInputOp(_ods_ir.OpView):
  r"""
  To create input ports when lowering a pure module op into an HWModuleOp, use
  this op. This op is typically created by a service implementation generator.
  
  If two 'input' ops exist in the same block, the names match, and the type
  matches they'll become one port during lowering. Two or more may not exist
  with the same name and different types. Useful for 'clk' and 'rst'.
  """

  OPERATION_NAME = "esi.pure_module.input"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def pure_module_input(value, name, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ESIPureModuleInputOp(value=value, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ESIPureModuleOp(_ods_ir.OpView):
  r"""
  A module containing only ESI channels and modules with only ESI ports. All
  non-local connectivity is done through ESI services. If this module is the
  top level in the design, then the design's actual top level ports are
  defined by a BSP.
  
  Useful on its own for simulation and BSPs which don't define a top-level.
  """

  OPERATION_NAME = "esi.pure_module"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def pure_module(sym_name, *, loc=None, ip=None) -> ESIPureModuleOp:
  return ESIPureModuleOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ESIPureModuleOutputOp(_ods_ir.OpView):
  r"""
  To create output ports when lowering a pure module op into an HWModuleOp, use
  this op. This op is typically created by a service implementation generator.
  
  Two 'output' ops with the same name cannot exist in the same block.
  """

  OPERATION_NAME = "esi.pure_module.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

def pure_module_output(name, value, *, loc=None, ip=None) -> ESIPureModuleOutputOp:
  return ESIPureModuleOutputOp(name=name, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ESIPureModuleParamOp(_ods_ir.OpView):
  r"""
  Allows attaching parameters to modules which become HW module parameters
  when lowering. Currently, they are ignored. Some low-level BSPs instantiate
  modules with parameters. This allows the modules produced to accept
  parameters so those BSPs can instantiate them.
  """

  OPERATION_NAME = "esi.pure_module.param"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, type_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

def pure_module_param(name, type_, *, loc=None, ip=None) -> ESIPureModuleParamOp:
  return ESIPureModuleParamOp(name=name, type_=type_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FIFOOp(_ods_ir.OpView):
  r"""
  A FIFO is a first-in-first-out buffer. This operation is a simple FIFO
  which can be used to connect two ESI channels. The ESI channels MUST have
  FIFO signaling semantics.
  """

  OPERATION_NAME = "esi.fifo"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, clk, rst, input, depth, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["depth"] = (depth if (
    isinstance(depth, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(depth, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def depth(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["depth"]

  @depth.setter
  def depth(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["depth"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def fifo(output, clk, rst, input, depth, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FIFOOp(output=output, clk=clk, rst=rst, input=input, depth=depth, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncServiceDeclOp(_ods_ir.OpView):
  r"""
  Declares a service which provides a function call interface to a client.
  
  Ports:
    to_client call(args: any) -> result: any
      Client exposes a function call interface to the user and does not allow
      out-of-order returns.
  
    TODO: ports for out-of-order returns
  """

  OPERATION_NAME = "esi.service.std.func"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

def service_std_func(sym_name, *, loc=None, ip=None) -> FuncServiceDeclOp:
  return FuncServiceDeclOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class HostMemServiceDeclOp(_ods_ir.OpView):
  r"""
  Declares a service to read/write host memory. Used for DMA services. Must be
  implemented by a BSP.
  """

  OPERATION_NAME = "esi.service.std.hostmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

def service_std_hostmem(sym_name, *, loc=None, ip=None) -> HostMemServiceDeclOp:
  return HostMemServiceDeclOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MMIOServiceDeclOp(_ods_ir.OpView):
  r"""
  Declares a service to be backed by a MMIO interface, which is platform
  dependent. Must be implemented by a BSP.
  """

  OPERATION_NAME = "esi.service.std.mmio"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

def service_std_mmio(sym_name, *, loc=None, ip=None) -> MMIOServiceDeclOp:
  return MMIOServiceDeclOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NullSourceOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.null"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(out)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def out(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def null(out, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return NullSourceOp(out=out, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PackBundleOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.bundle.pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, bundle, fromChannels, toChannels, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(toChannels))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(bundle)
    results.extend(fromChannels)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def toChannels(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def bundle(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def fromChannels(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def bundle_pack(bundle, from_channels, to_channels, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, PackBundleOp]:
  op = PackBundleOp(bundle=bundle, fromChannels=from_channels, toChannels=to_channels, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class PipelineStageOp(_ods_ir.OpView):
  r"""
  An individual elastic pipeline register. Generally lowered to from a
  ChannelBuffer ('buffer'), though can be inserted anywhere to add an
  additional pipeline stage. Adding individually could be useful for
  late-pass latency balancing.
  """

  OPERATION_NAME = "esi.stage"

  _ODS_REGIONS = (0, True)

  def __init__(self, clk, rst, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clk)
    operands.append(rst)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clk(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rst(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def stage(clk, rst, input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PipelineStageOp(clk=clk, rst=rst, input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RandomAccessMemoryDeclOp(_ods_ir.OpView):
  r"""
  Declares a service which is backed by a memory of some sort. Allows random
  access of the inner elements.
  
  Ports:
    read(address: clog2(depth)) -> data: innerType
    write({address: clog2(depth), data: innerType}) -> done: i0
  
  Users can ensure R/W ordering by waiting for the write "done" message before
  issuing a potentially dependant read. Ordering of R/W messages in flight is
  undefined.
  """

  OPERATION_NAME = "esi.mem.ram"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, innerType, depth, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["innerType"] = (innerType if (
    isinstance(innerType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(innerType, context=_ods_context))
    attributes["depth"] = (depth if (
    isinstance(depth, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(depth, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def innerType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["innerType"]

  @innerType.setter
  def innerType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["innerType"] = value

  @builtins.property
  def depth(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["depth"]

  @depth.setter
  def depth(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["depth"] = value

def mem_ram(sym_name, inner_type, depth, *, loc=None, ip=None) -> RandomAccessMemoryDeclOp:
  return RandomAccessMemoryDeclOp(sym_name=sym_name, innerType=inner_type, depth=depth, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RequestConnectionOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.service.req"

  _ODS_REGIONS = (0, True)

  def __init__(self, toClient, servicePort, appID, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["servicePort"] = (servicePort if (
    isinstance(servicePort, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(servicePort, context=_ods_context))
    attributes["appID"] = (appID if (
    isinstance(appID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDAttr')) else
      _ods_ir.AttrBuilder.get('AppIDAttr')(appID, context=_ods_context))
    results = []
    results.append(toClient)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def servicePort(self) -> _ods_ir.Attribute:
    return self.operation.attributes["servicePort"]

  @servicePort.setter
  def servicePort(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["servicePort"] = value

  @builtins.property
  def appID(self) -> _ods_ir.Attribute:
    return self.operation.attributes["appID"]

  @appID.setter
  def appID(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["appID"] = value

  @builtins.property
  def toClient(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def service_req(to_client, service_port, app_id, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RequestConnectionOp(toClient=to_client, servicePort=service_port, appID=app_id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ServiceDeclPortOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.service.port"

  _ODS_REGIONS = (0, True)

  def __init__(self, inner_sym, toClientType, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inner_sym"] = (inner_sym if (
    isinstance(inner_sym, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(inner_sym, context=_ods_context))
    attributes["toClientType"] = (toClientType if (
    isinstance(toClientType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_477')) else
      _ods_ir.AttrBuilder.get('anonymous_477')(toClientType, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inner_sym(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inner_sym"] = value

  @builtins.property
  def toClientType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["toClientType"]

  @toClientType.setter
  def toClientType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["toClientType"] = value

def service_port(inner_sym, to_client_type, *, loc=None, ip=None) -> ServiceDeclPortOp:
  return ServiceDeclPortOp(inner_sym=inner_sym, toClientType=to_client_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ServiceImplClientRecordOp(_ods_ir.OpView):
  r"""
  A record containing all the necessary details of how to connect to a client
  which the parent service record is servicing. Emitted on a per-client bundle
  basis. There shall be at most on of these records in the entire manifest for
  a particular client.
  """

  OPERATION_NAME = "esi.manifest.impl_conn"

  _ODS_REGIONS = (0, True)

  def __init__(self, relAppIDPath, servicePort, typeID, *, channelAssignments=None, implDetails=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["relAppIDPath"] = (relAppIDPath if (
    isinstance(relAppIDPath, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDArrayAttr')) else
      _ods_ir.AttrBuilder.get('AppIDArrayAttr')(relAppIDPath, context=_ods_context))
    attributes["servicePort"] = (servicePort if (
    isinstance(servicePort, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(servicePort, context=_ods_context))
    attributes["typeID"] = (typeID if (
    isinstance(typeID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_477')) else
      _ods_ir.AttrBuilder.get('anonymous_477')(typeID, context=_ods_context))
    if channelAssignments is not None: attributes["channelAssignments"] = (channelAssignments if (
        isinstance(channelAssignments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(channelAssignments, context=_ods_context))
    if implDetails is not None: attributes["implDetails"] = (implDetails if (
        isinstance(implDetails, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(implDetails, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def relAppIDPath(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["relAppIDPath"]

  @relAppIDPath.setter
  def relAppIDPath(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relAppIDPath"] = value

  @builtins.property
  def servicePort(self) -> _ods_ir.Attribute:
    return self.operation.attributes["servicePort"]

  @servicePort.setter
  def servicePort(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["servicePort"] = value

  @builtins.property
  def typeID(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["typeID"]

  @typeID.setter
  def typeID(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["typeID"] = value

  @builtins.property
  def channelAssignments(self) -> _Optional[_ods_ir.DictAttr]:
    if "channelAssignments" not in self.operation.attributes:
      return None
    return self.operation.attributes["channelAssignments"]

  @channelAssignments.setter
  def channelAssignments(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["channelAssignments"] = value
    elif "channelAssignments" in self.operation.attributes:
      del self.operation.attributes["channelAssignments"]

  @channelAssignments.deleter
  def channelAssignments(self):
    del self.operation.attributes["channelAssignments"]

  @builtins.property
  def implDetails(self) -> _Optional[_ods_ir.DictAttr]:
    if "implDetails" not in self.operation.attributes:
      return None
    return self.operation.attributes["implDetails"]

  @implDetails.setter
  def implDetails(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["implDetails"] = value
    elif "implDetails" in self.operation.attributes:
      del self.operation.attributes["implDetails"]

  @implDetails.deleter
  def implDetails(self):
    del self.operation.attributes["implDetails"]

def manifest_impl_conn(rel_app_id_path, service_port, type_id, *, channel_assignments=None, impl_details=None, loc=None, ip=None) -> ServiceImplClientRecordOp:
  return ServiceImplClientRecordOp(relAppIDPath=rel_app_id_path, servicePort=service_port, typeID=type_id, channelAssignments=channel_assignments, implDetails=impl_details, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ServiceImplRecordOp(_ods_ir.OpView):
  r"""
  A record of a service implementation. Optionally emitted by the service
  implementation. Contains information necessary to connect to the service and
  service clients.
  """

  OPERATION_NAME = "esi.manifest.service_impl"

  _ODS_REGIONS = (1, True)

  def __init__(self, appID, serviceImplName, implDetails, *, isEngine=None, service=None, stdService=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["appID"] = (appID if (
    isinstance(appID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDAttr')) else
      _ods_ir.AttrBuilder.get('AppIDAttr')(appID, context=_ods_context))
    if bool(isEngine): attributes["isEngine"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if service is not None: attributes["service"] = (service if (
        isinstance(service, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(service, context=_ods_context))
    if stdService is not None: attributes["stdService"] = (stdService if (
        isinstance(stdService, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(stdService, context=_ods_context))
    attributes["serviceImplName"] = (serviceImplName if (
    isinstance(serviceImplName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(serviceImplName, context=_ods_context))
    attributes["implDetails"] = (implDetails if (
    isinstance(implDetails, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(implDetails, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def appID(self) -> _ods_ir.Attribute:
    return self.operation.attributes["appID"]

  @appID.setter
  def appID(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["appID"] = value

  @builtins.property
  def isEngine(self) -> bool:
    return "isEngine" in self.operation.attributes

  @isEngine.setter
  def isEngine(self, value):
    if bool(value):
      self.operation.attributes["isEngine"] = _ods_ir.UnitAttr.get()
    elif "isEngine" in self.operation.attributes:
      del self.operation.attributes["isEngine"]

  @isEngine.deleter
  def isEngine(self):
    del self.operation.attributes["isEngine"]

  @builtins.property
  def service(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "service" not in self.operation.attributes:
      return None
    return self.operation.attributes["service"]

  @service.setter
  def service(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["service"] = value
    elif "service" in self.operation.attributes:
      del self.operation.attributes["service"]

  @service.deleter
  def service(self):
    del self.operation.attributes["service"]

  @builtins.property
  def stdService(self) -> _Optional[_ods_ir.StringAttr]:
    if "stdService" not in self.operation.attributes:
      return None
    return self.operation.attributes["stdService"]

  @stdService.setter
  def stdService(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["stdService"] = value
    elif "stdService" in self.operation.attributes:
      del self.operation.attributes["stdService"]

  @stdService.deleter
  def stdService(self):
    del self.operation.attributes["stdService"]

  @builtins.property
  def serviceImplName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["serviceImplName"]

  @serviceImplName.setter
  def serviceImplName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["serviceImplName"] = value

  @builtins.property
  def implDetails(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["implDetails"]

  @implDetails.setter
  def implDetails(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implDetails"] = value

  @builtins.property
  def reqDetails(self) -> _ods_ir.Region:
    return self.regions[0]

def manifest_service_impl(app_id, service_impl_name, impl_details, *, is_engine=None, service=None, std_service=None, loc=None, ip=None) -> ServiceImplRecordOp:
  return ServiceImplRecordOp(appID=app_id, serviceImplName=service_impl_name, implDetails=impl_details, isEngine=is_engine, service=service, stdService=std_service, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ServiceImplementConnReqOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.service.impl_req.req"

  _ODS_REGIONS = (0, True)

  def __init__(self, toClient, servicePort, relativeAppIDPath, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["servicePort"] = (servicePort if (
    isinstance(servicePort, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(servicePort, context=_ods_context))
    attributes["relativeAppIDPath"] = (relativeAppIDPath if (
    isinstance(relativeAppIDPath, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDArrayAttr')) else
      _ods_ir.AttrBuilder.get('AppIDArrayAttr')(relativeAppIDPath, context=_ods_context))
    results = []
    results.append(toClient)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def servicePort(self) -> _ods_ir.Attribute:
    return self.operation.attributes["servicePort"]

  @servicePort.setter
  def servicePort(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["servicePort"] = value

  @builtins.property
  def relativeAppIDPath(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["relativeAppIDPath"]

  @relativeAppIDPath.setter
  def relativeAppIDPath(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relativeAppIDPath"] = value

  @builtins.property
  def toClient(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def service_impl_req_req(to_client, service_port, relative_app_id_path, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ServiceImplementConnReqOp(toClient=to_client, servicePort=service_port, relativeAppIDPath=relative_app_id_path, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ServiceImplementReqOp(_ods_ir.OpView):
  r"""
  The connect services pass replaces `service.instance`s with this op. The
  `portReqs` region is the set of connection requests which need to be
  implemented for this service instance. Channels to/from the requests have
  been added to the operands/results of this op and consumers/producers have
  been redirected.
  
  Some other pass or frontend is expected to replace this op with an actual
  implementation.
  """

  OPERATION_NAME = "esi.service.impl_req"

  _ODS_REGIONS = (1, True)

  def __init__(self, outputs, appID, impl_type, inputs, *, service_symbol=None, stdService=None, impl_opts=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["appID"] = (appID if (
    isinstance(appID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDAttr')) else
      _ods_ir.AttrBuilder.get('AppIDAttr')(appID, context=_ods_context))
    if service_symbol is not None: attributes["service_symbol"] = (service_symbol if (
        isinstance(service_symbol, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(service_symbol, context=_ods_context))
    attributes["impl_type"] = (impl_type if (
    isinstance(impl_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(impl_type, context=_ods_context))
    if stdService is not None: attributes["stdService"] = (stdService if (
        isinstance(stdService, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(stdService, context=_ods_context))
    if impl_opts is not None: attributes["impl_opts"] = (impl_opts if (
        isinstance(impl_opts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(impl_opts, context=_ods_context))
    results = []
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def appID(self) -> _ods_ir.Attribute:
    return self.operation.attributes["appID"]

  @appID.setter
  def appID(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["appID"] = value

  @builtins.property
  def service_symbol(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "service_symbol" not in self.operation.attributes:
      return None
    return self.operation.attributes["service_symbol"]

  @service_symbol.setter
  def service_symbol(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["service_symbol"] = value
    elif "service_symbol" in self.operation.attributes:
      del self.operation.attributes["service_symbol"]

  @service_symbol.deleter
  def service_symbol(self):
    del self.operation.attributes["service_symbol"]

  @builtins.property
  def impl_type(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["impl_type"]

  @impl_type.setter
  def impl_type(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["impl_type"] = value

  @builtins.property
  def stdService(self) -> _Optional[_ods_ir.StringAttr]:
    if "stdService" not in self.operation.attributes:
      return None
    return self.operation.attributes["stdService"]

  @stdService.setter
  def stdService(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["stdService"] = value
    elif "stdService" in self.operation.attributes:
      del self.operation.attributes["stdService"]

  @stdService.deleter
  def stdService(self):
    del self.operation.attributes["stdService"]

  @builtins.property
  def impl_opts(self) -> _Optional[_ods_ir.DictAttr]:
    if "impl_opts" not in self.operation.attributes:
      return None
    return self.operation.attributes["impl_opts"]

  @impl_opts.setter
  def impl_opts(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["impl_opts"] = value
    elif "impl_opts" in self.operation.attributes:
      del self.operation.attributes["impl_opts"]

  @impl_opts.deleter
  def impl_opts(self):
    del self.operation.attributes["impl_opts"]

  @builtins.property
  def outputs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def portReqs(self) -> _ods_ir.Region:
    return self.regions[0]

def service_impl_req(outputs, app_id, impl_type, inputs, *, service_symbol=None, std_service=None, impl_opts=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ServiceImplementReqOp]:
  op = ServiceImplementReqOp(outputs=outputs, appID=app_id, impl_type=impl_type, inputs=inputs, service_symbol=service_symbol, stdService=std_service, impl_opts=impl_opts, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ServiceInstanceOp(_ods_ir.OpView):
  r"""
  Instantiate a service adhering to a service declaration interface.
  
  A pass collects all of the connection requests to the service this op
  implements from the containing modules' descendants (in the instance
  hierarchy). It bubbles them all up to the module containing this op,
  creating the necessary ESI channel ports, groups them appropriately, then
  replaces this op with a `service.impl_req`.
  
  If 'service_symbol' isn't specified, this instance will be used to implement
  all of the service requests which get surfaced to here. This option is
  generally used at the top level to specify host connectivity.
  
  Since implementing the server will usually need "normal" I/O, `inputs` and
  `results` act like normal `hw.instance` ports.
  
  $identifier is used by frontends to specify or remember the type of
  implementation to use for this service.
  """

  OPERATION_NAME = "esi.service.instance"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, appID, impl_type, inputs, *, service_symbol=None, impl_opts=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["appID"] = (appID if (
    isinstance(appID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDAttr')) else
      _ods_ir.AttrBuilder.get('AppIDAttr')(appID, context=_ods_context))
    if service_symbol is not None: attributes["service_symbol"] = (service_symbol if (
        isinstance(service_symbol, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(service_symbol, context=_ods_context))
    attributes["impl_type"] = (impl_type if (
    isinstance(impl_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(impl_type, context=_ods_context))
    if impl_opts is not None: attributes["impl_opts"] = (impl_opts if (
        isinstance(impl_opts, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(impl_opts, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def appID(self) -> _ods_ir.Attribute:
    return self.operation.attributes["appID"]

  @appID.setter
  def appID(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["appID"] = value

  @builtins.property
  def service_symbol(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "service_symbol" not in self.operation.attributes:
      return None
    return self.operation.attributes["service_symbol"]

  @service_symbol.setter
  def service_symbol(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["service_symbol"] = value
    elif "service_symbol" in self.operation.attributes:
      del self.operation.attributes["service_symbol"]

  @service_symbol.deleter
  def service_symbol(self):
    del self.operation.attributes["service_symbol"]

  @builtins.property
  def impl_type(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["impl_type"]

  @impl_type.setter
  def impl_type(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["impl_type"] = value

  @builtins.property
  def impl_opts(self) -> _Optional[_ods_ir.DictAttr]:
    if "impl_opts" not in self.operation.attributes:
      return None
    return self.operation.attributes["impl_opts"]

  @impl_opts.setter
  def impl_opts(self, value: _Optional[_ods_ir.DictAttr]):
    if value is not None:
      self.operation.attributes["impl_opts"] = value
    elif "impl_opts" in self.operation.attributes:
      del self.operation.attributes["impl_opts"]

  @impl_opts.deleter
  def impl_opts(self):
    del self.operation.attributes["impl_opts"]

def service_instance(result, app_id, impl_type, inputs, *, service_symbol=None, impl_opts=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ServiceInstanceOp]:
  op = ServiceInstanceOp(result=result, appID=app_id, impl_type=impl_type, inputs=inputs, service_symbol=service_symbol, impl_opts=impl_opts, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ServiceRequestRecordOp(_ods_ir.OpView):
  r"""
  A record of a service request, including the requestor, the service
  requested, and the parameters of the request. Emitted before connecting the
  service to preserve metadata about the original request.
  """

  OPERATION_NAME = "esi.manifest.req"

  _ODS_REGIONS = (0, True)

  def __init__(self, requestor, servicePort, typeID, *, stdService=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["requestor"] = (requestor if (
    isinstance(requestor, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AppIDAttr')) else
      _ods_ir.AttrBuilder.get('AppIDAttr')(requestor, context=_ods_context))
    attributes["servicePort"] = (servicePort if (
    isinstance(servicePort, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(servicePort, context=_ods_context))
    if stdService is not None: attributes["stdService"] = (stdService if (
        isinstance(stdService, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(stdService, context=_ods_context))
    attributes["typeID"] = (typeID if (
    isinstance(typeID, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_477')) else
      _ods_ir.AttrBuilder.get('anonymous_477')(typeID, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def requestor(self) -> _ods_ir.Attribute:
    return self.operation.attributes["requestor"]

  @requestor.setter
  def requestor(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["requestor"] = value

  @builtins.property
  def servicePort(self) -> _ods_ir.Attribute:
    return self.operation.attributes["servicePort"]

  @servicePort.setter
  def servicePort(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["servicePort"] = value

  @builtins.property
  def stdService(self) -> _Optional[_ods_ir.StringAttr]:
    if "stdService" not in self.operation.attributes:
      return None
    return self.operation.attributes["stdService"]

  @stdService.setter
  def stdService(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["stdService"] = value
    elif "stdService" in self.operation.attributes:
      del self.operation.attributes["stdService"]

  @stdService.deleter
  def stdService(self):
    del self.operation.attributes["stdService"]

  @builtins.property
  def typeID(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["typeID"]

  @typeID.setter
  def typeID(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["typeID"] = value

def manifest_req(requestor, service_port, type_id, *, std_service=None, loc=None, ip=None) -> ServiceRequestRecordOp:
  return ServiceRequestRecordOp(requestor=requestor, servicePort=service_port, typeID=type_id, stdService=std_service, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SnoopTransactionOp(_ods_ir.OpView):
  r"""
  A snoop that observes when a transaction occurs on a channel and provides
  the data being transmitted. The transaction signal indicates when data is
  actually being transferred on the channel, regardless of the underlying
  signaling protocol (ValidReady or FIFO). Like other snoop operations, this
  does not count as another user of the channel. Useful for monitoring data
  flow and debugging.
  """

  OPERATION_NAME = "esi.snoop.xact"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def transaction(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def snoop_xact(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return SnoopTransactionOp(input=input, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class SnoopValidReadyOp(_ods_ir.OpView):
  r"""
  A snoop allows one to combinationally observe a channel's internal signals.
  It does not count as another user of the channel. Useful for constructing
  control logic which can be combinationally driven. Also potentially useful
  for debugging.
  """

  OPERATION_NAME = "esi.snoop.vr"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def valid(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def ready(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[2]

def snoop_vr(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return SnoopValidReadyOp(input=input, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class SymbolConstantsOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.manifest.constants"

  _ODS_REGIONS = (0, True)

  def __init__(self, symbolRef, constants, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["symbolRef"] = (symbolRef if (
    isinstance(symbolRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(symbolRef, context=_ods_context))
    attributes["constants"] = (constants if (
    isinstance(constants, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
      _ods_ir.AttrBuilder.get('DictionaryAttr')(constants, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def symbolRef(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["symbolRef"]

  @symbolRef.setter
  def symbolRef(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbolRef"] = value

  @builtins.property
  def constants(self) -> _ods_ir.DictAttr:
    return self.operation.attributes["constants"]

  @constants.setter
  def constants(self, value: _ods_ir.DictAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["constants"] = value

def manifest_constants(symbol_ref, constants, *, loc=None, ip=None) -> SymbolConstantsOp:
  return SymbolConstantsOp(symbolRef=symbol_ref, constants=constants, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SymbolMetadataOp(_ods_ir.OpView):
  r"""
  Metadata about a symbol, including its name, repository, commit hash,
  version, and summary. All are optional, but strongly encouraged. Any
  additional metadata which users wish to attach should go as discardable
  attributes.
  """

  OPERATION_NAME = "esi.manifest.sym"

  _ODS_REGIONS = (0, True)

  def __init__(self, symbolRef, *, name=None, repo=None, commitHash=None, version=None, summary=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["symbolRef"] = (symbolRef if (
    isinstance(symbolRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(symbolRef, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if repo is not None: attributes["repo"] = (repo if (
        isinstance(repo, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(repo, context=_ods_context))
    if commitHash is not None: attributes["commitHash"] = (commitHash if (
        isinstance(commitHash, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(commitHash, context=_ods_context))
    if version is not None: attributes["version"] = (version if (
        isinstance(version, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(version, context=_ods_context))
    if summary is not None: attributes["summary"] = (summary if (
        isinstance(summary, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(summary, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def symbolRef(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["symbolRef"]

  @symbolRef.setter
  def symbolRef(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbolRef"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def repo(self) -> _Optional[_ods_ir.StringAttr]:
    if "repo" not in self.operation.attributes:
      return None
    return self.operation.attributes["repo"]

  @repo.setter
  def repo(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["repo"] = value
    elif "repo" in self.operation.attributes:
      del self.operation.attributes["repo"]

  @repo.deleter
  def repo(self):
    del self.operation.attributes["repo"]

  @builtins.property
  def commitHash(self) -> _Optional[_ods_ir.StringAttr]:
    if "commitHash" not in self.operation.attributes:
      return None
    return self.operation.attributes["commitHash"]

  @commitHash.setter
  def commitHash(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["commitHash"] = value
    elif "commitHash" in self.operation.attributes:
      del self.operation.attributes["commitHash"]

  @commitHash.deleter
  def commitHash(self):
    del self.operation.attributes["commitHash"]

  @builtins.property
  def version(self) -> _Optional[_ods_ir.StringAttr]:
    if "version" not in self.operation.attributes:
      return None
    return self.operation.attributes["version"]

  @version.setter
  def version(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["version"] = value
    elif "version" in self.operation.attributes:
      del self.operation.attributes["version"]

  @version.deleter
  def version(self):
    del self.operation.attributes["version"]

  @builtins.property
  def summary(self) -> _Optional[_ods_ir.StringAttr]:
    if "summary" not in self.operation.attributes:
      return None
    return self.operation.attributes["summary"]

  @summary.setter
  def summary(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["summary"] = value
    elif "summary" in self.operation.attributes:
      del self.operation.attributes["summary"]

  @summary.deleter
  def summary(self):
    del self.operation.attributes["summary"]

def manifest_sym(symbol_ref, *, name=None, repo=None, commit_hash=None, version=None, summary=None, loc=None, ip=None) -> SymbolMetadataOp:
  return SymbolMetadataOp(symbolRef=symbol_ref, name=name, repo=repo, commitHash=commit_hash, version=version, summary=summary, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TelemetryServiceDeclOp(_ods_ir.OpView):
  r"""
  Declares a service to send telemetry data. Has one port 'report' for
  something to request telemetry data (via a 'get' channel to the client and a
  'data' channel for the return value).
  """

  OPERATION_NAME = "esi.service.std.telemetry"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

def service_std_telemetry(sym_name, *, loc=None, ip=None) -> TelemetryServiceDeclOp:
  return TelemetryServiceDeclOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UnpackBundleOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.bundle.unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, toChannels, bundle, fromChannels, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bundle)
    operands.extend(_get_op_results_or_values(fromChannels))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(toChannels)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bundle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fromChannels(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def toChannels(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def bundle_unpack(to_channels, bundle, from_channels, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, UnpackBundleOp]:
  op = UnpackBundleOp(toChannels=to_channels, bundle=bundle, fromChannels=from_channels, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class UnwrapFIFOOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.unwrap.fifo"

  _ODS_REGIONS = (0, True)

  def __init__(self, chanInput, rden, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(chanInput)
    operands.append(rden)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def chanInput(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rden(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def data(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def empty(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def unwrap_fifo(chan_input, rden, *, results=None, loc=None, ip=None) -> _ods_ir.OpResultList:
  return UnwrapFIFOOp(chanInput=chan_input, rden=rden, results=results, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class UnwrapSVInterfaceOp(_ods_ir.OpView):
  r"""
  Unwrap an ESI channel into a SystemVerilog interface containing valid,
  ready, and data signals.
  """

  OPERATION_NAME = "esi.unwrap.iface"

  _ODS_REGIONS = (0, True)

  def __init__(self, chanInput, interfaceSource, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(chanInput)
    operands.append(interfaceSource)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def chanInput(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def interfaceSource(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def unwrap_iface(chan_input, interface_source, *, loc=None, ip=None) -> UnwrapSVInterfaceOp:
  return UnwrapSVInterfaceOp(chanInput=chan_input, interfaceSource=interface_source, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UnwrapValidReadyOp(_ods_ir.OpView):
  r"""
  Unwrapping a value allows operations on the contained value. Unwrap the
  channel along with a ready signal that you generate. Result is the data
  along with a valid signal.
  """

  OPERATION_NAME = "esi.unwrap.vr"

  _ODS_REGIONS = (0, True)

  def __init__(self, rawOutput, valid, chanInput, ready, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(chanInput)
    operands.append(ready)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(rawOutput)
    results.append(valid)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def chanInput(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ready(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rawOutput(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def valid(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def unwrap_vr(raw_output, valid, chan_input, ready, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return UnwrapValidReadyOp(rawOutput=raw_output, valid=valid, chanInput=chan_input, ready=ready, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class UnwrapWindow(_ods_ir.OpView):
  OPERATION_NAME = "esi.window.unwrap"

  _ODS_REGIONS = (0, True)

  def __init__(self, window, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(window)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def window(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def frame(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def window_unwrap(window, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnwrapWindow(window=window, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WrapFIFOOp(_ods_ir.OpView):
  OPERATION_NAME = "esi.wrap.fifo"

  _ODS_REGIONS = (0, True)

  def __init__(self, chanOutput, rden, data, empty, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(data)
    operands.append(empty)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(chanOutput)
    results.append(rden)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def data(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def empty(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def chanOutput(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def rden(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def wrap_fifo(chan_output, rden, data, empty, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return WrapFIFOOp(chanOutput=chan_output, rden=rden, data=data, empty=empty, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class WrapSVInterfaceOp(_ods_ir.OpView):
  r"""
  Wrap a SystemVerilog interface into an ESI channel. Interface MUST look
  like an interface produced by ESI meaning it MUST contain valid, ready,
  and data signals. Any other signals will be discarded.
  """

  OPERATION_NAME = "esi.wrap.iface"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, interfaceSink, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(interfaceSink)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def interfaceSink(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wrap_iface(output, interface_sink, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return WrapSVInterfaceOp(output=output, interfaceSink=interface_sink, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WrapValidReadyOp(_ods_ir.OpView):
  r"""
  Wrapping a value into an ESI port type allows modules to send values down
  an ESI port. Wrap data with valid bit, result is the ESI channel and the
  ready signal from the other end of the channel.
  """

  OPERATION_NAME = "esi.wrap.vr"

  _ODS_REGIONS = (0, True)

  def __init__(self, chanOutput, ready, rawInput, valid, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rawInput)
    operands.append(valid)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(chanOutput)
    results.append(ready)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rawInput(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def valid(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def chanOutput(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def ready(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def wrap_vr(chan_output, ready, raw_input, valid, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return WrapValidReadyOp(chanOutput=chan_output, ready=ready, rawInput=raw_input, valid=valid, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class WrapWindow(_ods_ir.OpView):
  OPERATION_NAME = "esi.window.wrap"

  _ODS_REGIONS = (0, True)

  def __init__(self, window, frame, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(frame)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(window)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def frame(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def window(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def window_wrap(window, frame, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return WrapWindow(window=window, frame=frame, loc=loc, ip=ip).result
