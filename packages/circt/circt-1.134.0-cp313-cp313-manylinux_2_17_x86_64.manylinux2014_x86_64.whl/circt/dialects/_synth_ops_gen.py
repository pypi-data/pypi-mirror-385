
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "synth"

@_ods_cext.register_operation(_Dialect)
class AndInverterOp(_ods_ir.OpView):
  r"""
  The `synth.aig.and_inv` operation represents an And-Inverter in the AIG dialect.
  Unlike `comb.and`, operands can be inverted respectively.
  
  Example:
  ```mlir
    %r1 = synth.aig.and_inv %a, %b: i3
    %r2 = synth.aig.and_inv not %a, %b, not %c : i3
    %r3 = synth.aig.and_inv not %a : i3
  ```
  
  Traditionally, an And-Node in AIG has two operands. However, `synth.aig.and_inv`
  extends this concept by allowing variadic operands and non-i1 integer types.
  Although the final stage of the synthesis pipeline requires lowering
  everything to i1-binary operands, it's more efficient to progressively lower
  the variadic multibit operations.
  
  Variadic operands have demonstrated their utility in low-level optimizations
  within the `comb` dialect. Furthermore, in synthesis, it's common practice
  to re-balance the logic path. Variadic operands enable the compiler to
  select more efficient solutions without the need to traverse binary trees
  multiple times.
  
  The ability to represent multibit operations during synthesis is crucial for
  scalability. This approach enables a form of vectorization, allowing for
  batch processing of logic synthesis when multibit operations are constructed
  in a similar manner.
  """

  OPERATION_NAME = "synth.aig.and_inv"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, inverted, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inverted"] = (inverted if (
    isinstance(inverted, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(inverted, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def inverted(self) -> _ods_ir.DenseBoolArrayAttr:
    return self.operation.attributes["inverted"]

  @inverted.setter
  def inverted(self, value: _ods_ir.DenseBoolArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inverted"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def aig_and_inv(inputs, inverted, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndInverterOp(inputs=inputs, inverted=inverted, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MajorityInverterOp(_ods_ir.OpView):
  r"""
  The `synth.mig.maj_inv` operation represents a Majority-Inverter in the
  Synth dialect. This is used to represent majority inverter graph in
  synthesis. This operation computes the majority function of its inputs,
  where operands can be inverted respectively.
  
  The majority function returns 1 when more than half of the inputs are 1,
  and 0 otherwise. For three inputs, it's equivalent to:
  (a & b) | (a & c) | (b & c).
  
  Example:
  ```mlir
    %r1 = synth.mig.maj_inv %a, %b, %c : i1
    %r2 = synth.mig.maj_inv not %a, %b, not %c : i1
    %r3 = synth.mig.maj_inv %a, %b, %c, %d, %e : i3
  ```
  
  The number of inputs must be odd to avoid ties.
  """

  OPERATION_NAME = "synth.mig.maj_inv"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, inverted, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inverted"] = (inverted if (
    isinstance(inverted, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(inverted, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def inverted(self) -> _ods_ir.DenseBoolArrayAttr:
    return self.operation.attributes["inverted"]

  @inverted.setter
  def inverted(self, value: _ods_ir.DenseBoolArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inverted"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mig_maj_inv(inputs, inverted, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MajorityInverterOp(inputs=inputs, inverted=inverted, results=results, loc=loc, ip=ip).result
