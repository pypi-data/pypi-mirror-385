
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "smt"

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  r"""
  This operation performs a boolean conjunction.
      The semantics are equivalent to the 'and' operator in the
      [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2).
      of the SMT-LIB Standard 2.7.
  
      It supports a variadic number of operands, but requires at least two.
      This is because the operator is annotated with the `:left-assoc` attribute
      which means that `op a b c` is equivalent to `(op (op a b) c)`.
  """

  OPERATION_NAME = "smt.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def and_(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ApplyFuncOp(_ods_ir.OpView):
  r"""
  This operation performs a function application as described in the
  [SMT-LIB 2.7 standard](https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf).
  It is part of the language itself rather than a theory or logic.
  """

  OPERATION_NAME = "smt.apply_func"

  _ODS_REGIONS = (0, True)

  def __init__(self, func, args, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(func)
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def func(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def apply_func(func, args, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ApplyFuncOp(func=func, args=args, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayBroadcastOp(_ods_ir.OpView):
  r"""
  This operation represents a broadcast of the 'value' operand to all indices
  of the array. It is equivalent to
  ```
  %0 = smt.declare_fun "array" : !smt.array<[!smt.int -> !smt.bool]>
  %1 = smt.forall ["idx"] {
  ^bb0(%idx: !smt.int):
    %2 = smt.array.select %0[%idx] : !smt.array<[!smt.int -> !smt.bool]>
    %3 = smt.eq %value, %2 : !smt.bool
    smt.yield %3 : !smt.bool
  }
  smt.assert %1
  // return %0
  ```
  
  In SMT-LIB, this is frequently written as
  `((as const (Array Int Bool)) value)`.
  """

  OPERATION_NAME = "smt.array.broadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_broadcast(result, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayBroadcastOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArraySelectOp(_ods_ir.OpView):
  r"""
  This operation is retuns the value stored in the given array at the given
  index. The semantics are equivalent to the `select` operator defined in the
  [SMT ArrayEx theory](https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2) of
  the SMT-LIB standard 2.7.
  """

  OPERATION_NAME = "smt.array.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, array, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(array)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def array(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_select(array, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArraySelectOp(array=array, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayStoreOp(_ods_ir.OpView):
  r"""
  This operation returns a new array which is the same as the 'array' operand
  except that the value at the given 'index' is changed to the given 'value'.
  The semantics are equivalent to the 'store' operator described in the
  [SMT ArrayEx theory](https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2) of
  the SMT-LIB standard 2.7.
  """

  OPERATION_NAME = "smt.array.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, array, index, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(array)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def array(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_store(array, index, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayStoreOp(array=array, index=index, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssertOp(_ods_ir.OpView):
  OPERATION_NAME = "smt.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def assert_(input, *, loc=None, ip=None) -> AssertOp:
  return AssertOp(input=input, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BV2IntOp(_ods_ir.OpView):
  r"""
  Create an integer from the bit-vector argument `input`. If `is_signed` is
  present, the bit-vector is treated as two's complement signed.  Otherwise,
  it is treated as an unsigned integer in the range [0..2^N-1], where N is
  the number of bits in `input`.
  """

  OPERATION_NAME = "smt.bv2int"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, is_signed=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_signed): attributes["is_signed"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_signed(self) -> bool:
    return "is_signed" in self.operation.attributes

  @is_signed.setter
  def is_signed(self, value):
    if bool(value):
      self.operation.attributes["is_signed"] = _ods_ir.UnitAttr.get()
    elif "is_signed" in self.operation.attributes:
      del self.operation.attributes["is_signed"]

  @is_signed.deleter
  def is_signed(self):
    del self.operation.attributes["is_signed"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv2int(input, *, is_signed=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BV2IntOp(input=input, is_signed=is_signed, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVAShrOp(_ods_ir.OpView):
  r"""
  This operation performs arithmetic shift right. The semantics are
      equivalent to the `bvashr` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.ashr"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_ashr(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVAShrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVAddOp(_ods_ir.OpView):
  r"""
  This operation performs addition. The semantics are
      equivalent to the `bvadd` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_add(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVAddOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVAndOp(_ods_ir.OpView):
  r"""
  This operation performs bitwise AND. The semantics are
      equivalent to the `bvand` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_and(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVAndOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVCmpOp(_ods_ir.OpView):
  r"""
  This operation compares bit-vector values, interpreting them as signed or
  unsigned values depending on the predicate. The semantics are equivalent to
  the `bvslt`, `bvsle`, `bvsgt`, `bvsge`, `bvult`, `bvule`, `bvugt`, or
  `bvuge` operator defined in the SMT-LIB 2.7 standard depending on the
  specified predicate. More precisely in the
  [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
  and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
  describing closed quantifier-free formulas over the theory of fixed-size
  bit-vectors.
  """

  OPERATION_NAME = "smt.bv.cmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, pred, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pred"] = (pred if (
    isinstance(pred, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BVCmpPredicate')) else
      _ods_ir.AttrBuilder.get('BVCmpPredicate')(pred, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def pred(self) -> _ods_ir.Attribute:
    return self.operation.attributes["pred"]

  @pred.setter
  def pred(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pred"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_cmp(pred, lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVCmpOp(pred=pred, lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVConstantOp(_ods_ir.OpView):
  r"""
  This operation produces an SSA value equal to the bit-vector constant
  specified by the 'value' attribute.
  Refer to the `BitVectorAttr` documentation for more information about
  the semantics of bit-vector constants, their format, and associated sort.
  The result type always matches the attribute's type.
  
  Examples:
  ```mlir
  %c92_bv8 = smt.bv.constant #smt.bv<92> : !smt.bv<8>
  %c5_bv4 = smt.bv.constant #smt.bv<5> : !smt.bv<4>
  ```
  """

  OPERATION_NAME = "smt.bv.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BitVectorAttr')) else
      _ods_ir.AttrBuilder.get('BitVectorAttr')(value, context=_ods_context))
    if results is None:
      _ods_result_type_source_attr = attributes["value"]
      _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
      results = [_ods_derived_result_type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVLShrOp(_ods_ir.OpView):
  r"""
  This operation performs logical shift right. The semantics are
      equivalent to the `bvlshr` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.lshr"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_lshr(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVLShrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVMulOp(_ods_ir.OpView):
  r"""
  This operation performs multiplication. The semantics are
      equivalent to the `bvmul` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_mul(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVMulOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVNegOp(_ods_ir.OpView):
  r"""
  This operation performs two's complement unary minus. The semantics are
      equivalent to the `bvneg` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.neg"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_neg(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVNegOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVNotOp(_ods_ir.OpView):
  r"""
  This operation performs bitwise negation. The semantics are
      equivalent to the `bvnot` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_not(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVNotOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVOrOp(_ods_ir.OpView):
  r"""
  This operation performs bitwise OR. The semantics are
      equivalent to the `bvor` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_or(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVOrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVSDivOp(_ods_ir.OpView):
  r"""
  This operation performs two's complement signed division. The semantics are
      equivalent to the `bvsdiv` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.sdiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_sdiv(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVSDivOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVSModOp(_ods_ir.OpView):
  r"""
  This operation performs two's complement signed remainder (sign follows divisor). The semantics are
      equivalent to the `bvsmod` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.smod"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_smod(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVSModOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVSRemOp(_ods_ir.OpView):
  r"""
  This operation performs two's complement signed remainder (sign follows dividend). The semantics are
      equivalent to the `bvsrem` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.srem"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_srem(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVSRemOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVShlOp(_ods_ir.OpView):
  r"""
  This operation performs shift left. The semantics are
      equivalent to the `bvshl` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.shl"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_shl(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVShlOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVUDivOp(_ods_ir.OpView):
  r"""
  This operation performs unsigned division (rounded towards zero). The semantics are
      equivalent to the `bvudiv` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.udiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_udiv(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVUDivOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVURemOp(_ods_ir.OpView):
  r"""
  This operation performs unsigned remainder. The semantics are
      equivalent to the `bvurem` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.urem"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_urem(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVURemOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BVXOrOp(_ods_ir.OpView):
  r"""
  This operation performs bitwise exclusive OR. The semantics are
      equivalent to the `bvxor` operator defined in the SMT-LIB 2.7
      standard. More precisely in the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
      and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
      describing closed quantifier-free formulas over the theory of fixed-size
      bit-vectors.
  """

  OPERATION_NAME = "smt.bv.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_xor(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BVXOrOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BoolConstantOp(_ods_ir.OpView):
  r"""
  Produces the constant expressions 'true' and 'false' as described in the
  [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2) of the SMT-LIB
  Standard 2.7.
  """

  OPERATION_NAME = "smt.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BoolConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CheckOp(_ods_ir.OpView):
  r"""
  This operation checks if all the assertions in the solver defined by the
  nearest ancestor operation of type `smt.solver` are consistent. The outcome
  an be 'satisfiable', 'unknown', or 'unsatisfiable' and the corresponding
  region will be executed. It is the corresponding construct to the
  `check-sat` in SMT-LIB.
  
  Example:
  ```mlir
  %0 = smt.check sat {
    %c1_i32 = arith.constant 1 : i32
    smt.yield %c1_i32 : i32
  } unknown {
    %c0_i32 = arith.constant 0 : i32
    smt.yield %c0_i32 : i32
  } unsat {
    %c-1_i32 = arith.constant -1 : i32
    smt.yield %c-1_i32 : i32
  } -> i32
  ```
  """

  OPERATION_NAME = "smt.check"

  _ODS_REGIONS = (3, True)

  def __init__(self, results_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def satRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def unknownRegion(self) -> _ods_ir.Region:
    return self.regions[1]

  @builtins.property
  def unsatRegion(self) -> _ods_ir.Region:
    return self.regions[2]

def check(results_, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CheckOp]:
  op = CheckOp(results_=results_, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  This operation concatenates bit-vector values with semantics equivalent to
  the `concat` operator defined in the SMT-LIB 2.7 standard. More precisely in
  the [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
  and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
  describing closed quantifier-free formulas over the theory of fixed-size
  bit-vectors.
  
  Note that the following equivalences hold:
  * `smt.bv.concat %a, %b : !smt.bv<4>, !smt.bv<4>` is equivalent to
    `(concat a b)` in SMT-LIB
  * `(= (concat #xf #x0) #xf0)`
  """

  OPERATION_NAME = "smt.bv.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_concat(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeclareFunOp(_ods_ir.OpView):
  r"""
  This operation declares a symbolic value just as the `declare-const` and
  `declare-fun` statements in SMT-LIB 2.7. The result type determines the SMT
  sort of the symbolic value. The returned value can then be used to refer to
  the symbolic value instead of using the identifier like in SMT-LIB.
  
  The optionally provided string will be used as a prefix for the newly
  generated identifier (useful for easier readability when exporting to
  SMT-LIB). Each `declare` will always provide a unique new symbolic value
  even if the identifier strings are the same.
  
  Note that there does not exist a separate operation equivalent to
  SMT-LIBs `define-fun` since
  ```
  (define-fun f (a Int) Int (-a))
  ```
  is only syntactic sugar for
  ```
  %f = smt.declare_fun : !smt.func<(!smt.int) !smt.int>
  %0 = smt.forall {
  ^bb0(%arg0: !smt.int):
    %1 = smt.apply_func %f(%arg0) : !smt.func<(!smt.int) !smt.int>
    %2 = smt.int.neg %arg0
    %3 = smt.eq %1, %2 : !smt.int
    smt.yield %3 : !smt.bool
  }
  smt.assert %0
  ```
  
  Note that this operation cannot be marked as Pure since two operations (even
  with the same identifier string) could then be CSEd, leading to incorrect
  behavior.
  """

  OPERATION_NAME = "smt.declare_fun"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, namePrefix=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if namePrefix is not None: attributes["namePrefix"] = (namePrefix if (
        isinstance(namePrefix, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(namePrefix, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def namePrefix(self) -> _Optional[_ods_ir.StringAttr]:
    if "namePrefix" not in self.operation.attributes:
      return None
    return self.operation.attributes["namePrefix"]

  @namePrefix.setter
  def namePrefix(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["namePrefix"] = value
    elif "namePrefix" in self.operation.attributes:
      del self.operation.attributes["namePrefix"]

  @namePrefix.deleter
  def namePrefix(self):
    del self.operation.attributes["namePrefix"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def declare_fun(result, *, name_prefix=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DeclareFunOp(result=result, namePrefix=name_prefix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DistinctOp(_ods_ir.OpView):
  r"""
  This operation compares the operands and returns true iff all operands are
  not identical to any of the other operands. The semantics are equivalent to
  the `distinct` operator defined in the SMT-LIB Standard 2.7 in the
  [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2).
  
  Any SMT sort/type is allowed for the operands and it supports a variadic
  number of operands, but requires at least two. This is because the
  `distinct` operator is annotated with `:pairwise` which means that
  `distinct a b c d` is equivalent to
  ```
  and (distinct a b) (distinct a c) (distinct a d)
      (distinct b c) (distinct b d)
      (distinct c d)
  ```
  where `and` is annotated `:left-assoc`, i.e., it can be further rewritten to
  ```
  (and (and (and (and (and (distinct a b)
                           (distinct a c))
                      (distinct a d))
                 (distinct b c))
            (distinct b d))
       (distinct c d)
  ```
  """

  OPERATION_NAME = "smt.distinct"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def distinct(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DistinctOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EqOp(_ods_ir.OpView):
  r"""
  This operation compares the operands and returns true iff all operands are
  identical. The semantics are equivalent to the `=` operator defined in the
  SMT-LIB Standard 2.7 in the
  [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2).
  
  Any SMT sort/type is allowed for the operands and it supports a variadic
  number of operands, but requires at least two. This is because the `=`
  operator is annotated with `:chainable` which means that `= a b c d` is
  equivalent to `and (= a b) (= b c) (= c d)` where `and` is annotated
  `:left-assoc`, i.e., it can be further rewritten to
  `and (and (= a b) (= b c)) (= c d)`.
  """

  OPERATION_NAME = "smt.eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def eq(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EqOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExistsOp(_ods_ir.OpView):
  r"""
  This operation represents the exists quantifier as described in the
  [SMT-LIB 2.7 standard](https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf).
  It is part of the language itself rather than a theory or logic.
  
  The operation specifies the name prefixes (as an optional attribute) and
  types (as the types of the block arguments of the regions) of bound
  variables that may be used in the 'body' of the operation. If a 'patterns'
  region is specified, the block arguments must match the ones of the 'body'
  region and (other than there) must be used at least once in the 'patterns'
  region. It may also not contain any operations that bind variables, such as
  quantifiers. While the 'body' region must always yield exactly one
  `!smt.bool`-typed value, the 'patterns' region can yield an arbitrary number
  (but at least one) of SMT values.
  
  The bound variables can be any SMT type except of functions, since SMT only
  supports first-order logic.
  
  The 'no_patterns' attribute is only allowed when no 'patterns' region is
  specified and forbids the solver to generate and use patterns for this
  quantifier.
  
  The 'weight' attribute indicates the importance of this quantifier being
  instantiated compared to other quantifiers that may be present. The default
  value is zero.
  
  Both the 'no_patterns' and 'weight' attributes are annotations to the
  quantifiers body term. Annotations and attributes are described in the
  standard in sections 3.4, and 3.6 (specifically 3.6.5). SMT-LIB allows
  adding custom attributes to provide solvers with additional metadata, e.g.,
  hints such as above mentioned attributes. They are not part of the standard
  themselves, but supported by common SMT solvers (e.g., Z3). 
  """

  OPERATION_NAME = "smt.exists"

  _ODS_REGIONS = (1, False)

  def __init__(self, result, num_patterns, *, weight=None, noPattern=None, boundVarNames=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if weight is not None: attributes["weight"] = (weight if (
        isinstance(weight, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(weight, context=_ods_context))
    if bool(noPattern): attributes["noPattern"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if boundVarNames is not None: attributes["boundVarNames"] = (boundVarNames if (
        isinstance(boundVarNames, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(boundVarNames, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    regions = 1 + num_patterns
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def weight(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["weight"]

  @weight.setter
  def weight(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight"] = value

  @builtins.property
  def noPattern(self) -> bool:
    return "noPattern" in self.operation.attributes

  @noPattern.setter
  def noPattern(self, value):
    if bool(value):
      self.operation.attributes["noPattern"] = _ods_ir.UnitAttr.get()
    elif "noPattern" in self.operation.attributes:
      del self.operation.attributes["noPattern"]

  @noPattern.deleter
  def noPattern(self):
    del self.operation.attributes["noPattern"]

  @builtins.property
  def boundVarNames(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "boundVarNames" not in self.operation.attributes:
      return None
    return self.operation.attributes["boundVarNames"]

  @boundVarNames.setter
  def boundVarNames(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["boundVarNames"] = value
    elif "boundVarNames" in self.operation.attributes:
      del self.operation.attributes["boundVarNames"]

  @boundVarNames.deleter
  def boundVarNames(self):
    del self.operation.attributes["boundVarNames"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def patterns(self) -> _ods_ir.RegionSequence:
    return self.regions[1:]

def exists(result, num_patterns, *, weight=None, no_pattern=None, bound_var_names=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExistsOp(result=result, num_patterns=num_patterns, weight=weight, noPattern=no_pattern, boundVarNames=bound_var_names, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExtractOp(_ods_ir.OpView):
  r"""
  This operation extracts the range of bits starting at the 'lowBit' index
  (inclusive) up to the 'lowBit' + result-width index (exclusive). The
  semantics are equivalent to the `extract` operator defined in the SMT-LIB
  2.7 standard. More precisely in the
  [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
  and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
  describing closed quantifier-free formulas over the theory of fixed-size
  bit-vectors.
  
  Note that `smt.bv.extract %bv from 2 : (!smt.bv<32>) -> !smt.bv<16>` is
  equivalent to `((_ extract 17 2) bv)`, i.e., the SMT-LIB operator takes the
  low and high indices where both are inclusive. The following equivalence
  holds: `(= ((_ extract 3 0) #x0f) #xf)`
  """

  OPERATION_NAME = "smt.bv.extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lowBit, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lowBit"] = (lowBit if (
    isinstance(lowBit, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(lowBit, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lowBit(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["lowBit"]

  @lowBit.setter
  def lowBit(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lowBit"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_extract(result, low_bit, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ExtractOp(result=result, lowBit=low_bit, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ForallOp(_ods_ir.OpView):
  r"""
  This operation represents the forall quantifier as described in the
  [SMT-LIB 2.7 standard](https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf).
  It is part of the language itself rather than a theory or logic.
  
  The operation specifies the name prefixes (as an optional attribute) and
  types (as the types of the block arguments of the regions) of bound
  variables that may be used in the 'body' of the operation. If a 'patterns'
  region is specified, the block arguments must match the ones of the 'body'
  region and (other than there) must be used at least once in the 'patterns'
  region. It may also not contain any operations that bind variables, such as
  quantifiers. While the 'body' region must always yield exactly one
  `!smt.bool`-typed value, the 'patterns' region can yield an arbitrary number
  (but at least one) of SMT values.
  
  The bound variables can be any SMT type except of functions, since SMT only
  supports first-order logic.
  
  The 'no_patterns' attribute is only allowed when no 'patterns' region is
  specified and forbids the solver to generate and use patterns for this
  quantifier.
  
  The 'weight' attribute indicates the importance of this quantifier being
  instantiated compared to other quantifiers that may be present. The default
  value is zero.
  
  Both the 'no_patterns' and 'weight' attributes are annotations to the
  quantifiers body term. Annotations and attributes are described in the
  standard in sections 3.4, and 3.6 (specifically 3.6.5). SMT-LIB allows
  adding custom attributes to provide solvers with additional metadata, e.g.,
  hints such as above mentioned attributes. They are not part of the standard
  themselves, but supported by common SMT solvers (e.g., Z3). 
  """

  OPERATION_NAME = "smt.forall"

  _ODS_REGIONS = (1, False)

  def __init__(self, result, num_patterns, *, weight=None, noPattern=None, boundVarNames=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if weight is not None: attributes["weight"] = (weight if (
        isinstance(weight, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(weight, context=_ods_context))
    if bool(noPattern): attributes["noPattern"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if boundVarNames is not None: attributes["boundVarNames"] = (boundVarNames if (
        isinstance(boundVarNames, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(boundVarNames, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    regions = 1 + num_patterns
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def weight(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["weight"]

  @weight.setter
  def weight(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight"] = value

  @builtins.property
  def noPattern(self) -> bool:
    return "noPattern" in self.operation.attributes

  @noPattern.setter
  def noPattern(self, value):
    if bool(value):
      self.operation.attributes["noPattern"] = _ods_ir.UnitAttr.get()
    elif "noPattern" in self.operation.attributes:
      del self.operation.attributes["noPattern"]

  @noPattern.deleter
  def noPattern(self):
    del self.operation.attributes["noPattern"]

  @builtins.property
  def boundVarNames(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "boundVarNames" not in self.operation.attributes:
      return None
    return self.operation.attributes["boundVarNames"]

  @boundVarNames.setter
  def boundVarNames(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["boundVarNames"] = value
    elif "boundVarNames" in self.operation.attributes:
      del self.operation.attributes["boundVarNames"]

  @boundVarNames.deleter
  def boundVarNames(self):
    del self.operation.attributes["boundVarNames"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def patterns(self) -> _ods_ir.RegionSequence:
    return self.regions[1:]

def forall(result, num_patterns, *, weight=None, no_pattern=None, bound_var_names=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ForallOp(result=result, num_patterns=num_patterns, weight=weight, noPattern=no_pattern, boundVarNames=bound_var_names, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImpliesOp(_ods_ir.OpView):
  r"""
  This operation performs a boolean implication. The semantics are equivalent
  to the '=>' operator in the
  [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2) of the SMT-LIB
  Standard 2.7.
  """

  OPERATION_NAME = "smt.implies"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def implies(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImpliesOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class Int2BVOp(_ods_ir.OpView):
  r"""
  Designed to lower directly to an operation of the same name in Z3. The Z3
  C API describes the semantics as follows:
  Create an n bit bit-vector from the integer argument t1.
  The resulting bit-vector has n bits, where the i'th bit (counting from 0
  to n-1) is 1 if (t1 div 2^i) mod 2 is 1.
  The node t1 must have integer sort.
  """

  OPERATION_NAME = "smt.int2bv"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int2bv(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return Int2BVOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntAbsOp(_ods_ir.OpView):
  r"""
  This operation represents the absolute value function for the `Int` sort.
  The semantics are equivalent to the `abs` operator as described in the
  [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_abs(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntAbsOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntAddOp(_ods_ir.OpView):
  r"""
  This operation represents (infinite-precision) integer addition.
  The semantics are equivalent to the corresponding operator described in
  the [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.add"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_add(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntAddOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntCmpOp(_ods_ir.OpView):
  r"""
  This operation represents the comparison of (infinite-precision) integers.
  The semantics are equivalent to the `<= (le)`, `< (lt)`, `>= (ge)`, or
  `> (gt)` operator depending on the predicate (indicated in parentheses) as
  described in the
  [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.cmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, pred, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pred"] = (pred if (
    isinstance(pred, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IntPredicate')) else
      _ods_ir.AttrBuilder.get('IntPredicate')(pred, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def pred(self) -> _ods_ir.Attribute:
    return self.operation.attributes["pred"]

  @pred.setter
  def pred(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pred"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_cmp(pred, lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntCmpOp(pred=pred, lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntConstantOp(_ods_ir.OpView):
  r"""
  This operation represents (infinite-precision) integer literals of the `Int`
  sort. The set of values for the sort `Int` consists of all numerals and
  all terms of the form `-n`where n is a numeral other than 0. For more
  information refer to the 
  [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntDivOp(_ods_ir.OpView):
  r"""
  This operation represents (infinite-precision) integer division.
  The semantics are equivalent to the corresponding operator described in
  the [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.div"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_div(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntDivOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntModOp(_ods_ir.OpView):
  r"""
  This operation represents (infinite-precision) integer remainder.
  The semantics are equivalent to the corresponding operator described in
  the [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_mod(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntModOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntMulOp(_ods_ir.OpView):
  r"""
  This operation represents (infinite-precision) integer multiplication.
  The semantics are equivalent to the corresponding operator described in
  the [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_mul(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntMulOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntSubOp(_ods_ir.OpView):
  r"""
  This operation represents (infinite-precision) integer subtraction.
  The semantics are equivalent to the corresponding operator described in
  the [SMT Ints theory](https://smtlib.cs.uiowa.edu/Theories/Ints.smt2) of the
  SMT-LIB 2.7 standard.
  """

  OPERATION_NAME = "smt.int.sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def int_sub(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntSubOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IteOp(_ods_ir.OpView):
  r"""
  This operation returns its second operand or its third operand depending on
  whether its first operand is true or not. The semantics are equivalent to
  the `ite` operator defined in the
  [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2) of the SMT-LIB
  2.7 standard.
  """

  OPERATION_NAME = "smt.ite"

  _ODS_REGIONS = (0, True)

  def __init__(self, cond, thenValue, elseValue, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.append(thenValue)
    operands.append(elseValue)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def thenValue(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def elseValue(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ite(cond, then_value, else_value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IteOp(cond=cond, thenValue=then_value, elseValue=else_value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  r"""
  This operation performs a boolean negation. The semantics are equivalent to
  the 'not' operator in the
  [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2) of the SMT-LIB
  Standard 2.7.
  """

  OPERATION_NAME = "smt.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def not_(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  r"""
  This operation performs a boolean disjunction.
      The semantics are equivalent to the 'or' operator in the
      [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2).
      of the SMT-LIB Standard 2.7.
  
      It supports a variadic number of operands, but requires at least two.
      This is because the operator is annotated with the `:left-assoc` attribute
      which means that `op a b c` is equivalent to `(op (op a b) c)`.
  """

  OPERATION_NAME = "smt.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def or_(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PopOp(_ods_ir.OpView):
  OPERATION_NAME = "smt.pop"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def pop(count, *, loc=None, ip=None) -> PopOp:
  return PopOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PushOp(_ods_ir.OpView):
  OPERATION_NAME = "smt.push"

  _ODS_REGIONS = (0, True)

  def __init__(self, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def push(count, *, loc=None, ip=None) -> PushOp:
  return PushOp(count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RepeatOp(_ods_ir.OpView):
  r"""
  This operation is a shorthand for repeated concatenation of the same
  bit-vector value, i.e.,
  ```mlir
  smt.bv.repeat 5 times %a : !smt.bv<4>
  // is the same as
  %0 = smt.bv.repeat 4 times %a : !smt.bv<4>
  smt.bv.concat %a, %0 : !smt.bv<4>, !smt.bv<16>
  // or also 
  %0 = smt.bv.repeat 4 times %a : !smt.bv<4>
  smt.bv.concat %0, %a : !smt.bv<16>, !smt.bv<4>
  ```
  
  The semantics are equivalent to the `repeat` operator defined in the SMT-LIB
  2.7 standard. More precisely in the
  [theory of FixedSizeBitVectors](https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2)
  and the [QF_BV logic](https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2)
  describing closed quantifier-free formulas over the theory of fixed-size
  bit-vectors.
  """

  OPERATION_NAME = "smt.bv.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bv_repeat(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RepeatOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResetOp(_ods_ir.OpView):
  OPERATION_NAME = "smt.reset"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def reset(*, loc=None, ip=None) -> ResetOp:
  return ResetOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetLogicOp(_ods_ir.OpView):
  OPERATION_NAME = "smt.set_logic"

  _ODS_REGIONS = (0, True)

  def __init__(self, logic, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["logic"] = (logic if (
    isinstance(logic, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(logic, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def logic(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["logic"]

  @logic.setter
  def logic(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["logic"] = value

def set_logic(logic, *, loc=None, ip=None) -> SetLogicOp:
  return SetLogicOp(logic=logic, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SolverOp(_ods_ir.OpView):
  r"""
  This operation defines an SMT context with a solver instance. SMT operations
  are only valid when being executed between the start and end of the region
  of this operation. Any invocation outside is undefined. However, they do not
  have to be direct children of this operation. For example, it is allowed to
  have SMT operations in a `func.func` which is only called from within this
  region. No SMT value may enter or exit the lifespan of this region (such
  that no value created from another SMT context can be used in this scope and
  the solver can deallocate all state required to keep track of SMT values at
  the end).
  
  As a result, the region is comparable to an entire SMT-LIB script, but
  allows for concrete operations and control-flow. Concrete values may be
  passed in and returned to influence the computations after the `smt.solver`
  operation.
  
  Example:
  ```mlir
  %0:2 = smt.solver (%in) {smt.some_attr} : (i8) -> (i8, i32) {
  ^bb0(%arg0: i8):
    %c = smt.declare_fun "c" : !smt.bool
    smt.assert %c
    %1 = smt.check sat {
      %c1_i32 = arith.constant 1 : i32
      smt.yield %c1_i32 : i32
    } unknown {
      %c0_i32 = arith.constant 0 : i32
      smt.yield %c0_i32 : i32
    } unsat {
      %c-1_i32 = arith.constant -1 : i32
      smt.yield %c-1_i32 : i32
    } -> i32
    smt.yield %arg0, %1 : i8, i32
  }
  ```
  """

  OPERATION_NAME = "smt.solver"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def bodyRegion(self) -> _ods_ir.Region:
    return self.regions[0]

def solver(results_, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SolverOp]:
  op = SolverOp(results_=results_, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class XOrOp(_ods_ir.OpView):
  r"""
  This operation performs a boolean exclusive OR.
      The semantics are equivalent to the 'xor' operator in the
      [Core theory](https://smtlib.cs.uiowa.edu/Theories/Core.smt2).
      of the SMT-LIB Standard 2.7.
  
      It supports a variadic number of operands, but requires at least two.
      This is because the operator is annotated with the `:left-assoc` attribute
      which means that `op a b c` is equivalent to `(op (op a b) c)`.
  """

  OPERATION_NAME = "smt.xor"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def xor(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XOrOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "smt.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(values, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(values=values, loc=loc, ip=ip)
