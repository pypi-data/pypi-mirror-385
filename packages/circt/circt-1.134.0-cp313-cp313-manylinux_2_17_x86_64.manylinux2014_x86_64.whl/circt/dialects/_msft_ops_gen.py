
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "msft"

@_ods_cext.register_operation(_Dialect)
class DeclPhysicalRegionOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.physical_region"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, bounds, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["bounds"] = (bounds if (
    isinstance(bounds, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PhysicalBoundsArray')) else
      _ods_ir.AttrBuilder.get('PhysicalBoundsArray')(bounds, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def bounds(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["bounds"]

  @bounds.setter
  def bounds(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bounds"] = value

def physical_region(sym_name, bounds, *, loc=None, ip=None) -> DeclPhysicalRegionOp:
  return DeclPhysicalRegionOp(sym_name=sym_name, bounds=bounds, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DynamicInstanceOp(_ods_ir.OpView):
  r"""
  Represents an instance (as in instance in the instance hierarchy) referred
  to henceforth as a dynamic instance. Specified with a path through the
  instance hierarchy (which in the future will be replaced with an AppID).
  Lowers to a `hw.hierpath` but unlike a global ref, does not require all of
  the ops participating in the hierpath to contain a back pointer attribute.
  Allows users to efficiently add placements to a large number of dynamic
  instances which happen to map to a small number of static instances by
  bulk-adding the necessary `hw.hierpath` attributes.
  
  During the lowering, moves the operations in the body to the top level and
  gives them the symbol of the hierpath which was created to replace the
  dynamic instance.
  """

  OPERATION_NAME = "msft.instance.dynamic"

  _ODS_REGIONS = (1, True)

  def __init__(self, instanceRef, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instanceRef"] = (instanceRef if (
    isinstance(instanceRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(instanceRef, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instanceRef(self) -> _ods_ir.Attribute:
    return self.operation.attributes["instanceRef"]

  @instanceRef.setter
  def instanceRef(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceRef"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def instance_dynamic(instance_ref, *, loc=None, ip=None) -> DynamicInstanceOp:
  return DynamicInstanceOp(instanceRef=instance_ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DynamicInstanceVerbatimAttrOp(_ods_ir.OpView):
  r"""
  Allows a user to specify a custom attribute name and value which is attached
  to a dynamic instance.
  
  For Quartus tcl, translates to:
    set_instance_assignment -name $name $value -to $parent|<instance_path>
  """

  OPERATION_NAME = "msft.instance.verb_attr"

  _ODS_REGIONS = (0, True)

  def __init__(self, name, value, *, subPath=None, ref=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(value, context=_ods_context))
    if subPath is not None: attributes["subPath"] = (subPath if (
        isinstance(subPath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(subPath, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def value(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def subPath(self) -> _Optional[_ods_ir.StringAttr]:
    if "subPath" not in self.operation.attributes:
      return None
    return self.operation.attributes["subPath"]

  @subPath.setter
  def subPath(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["subPath"] = value
    elif "subPath" in self.operation.attributes:
      del self.operation.attributes["subPath"]

  @subPath.deleter
  def subPath(self):
    del self.operation.attributes["subPath"]

  @builtins.property
  def ref(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def instance_verb_attr(name, value, *, sub_path=None, ref=None, loc=None, ip=None) -> DynamicInstanceVerbatimAttrOp:
  return DynamicInstanceVerbatimAttrOp(name=name, value=value, subPath=sub_path, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstanceHierarchyOp(_ods_ir.OpView):
  r"""
  Models the "root" / "top" of an instance hierarchy. `DynamicInstanceOp`s
  must be contained by this op. Specifies the top module and (optionally) an
  "instance" name in the case where there are multiple instances of a
  particular module in a design. (As is often the case where one isn't
  producing the design's "top" module but a subdesign.)
  """

  OPERATION_NAME = "msft.instance.hierarchy"

  _ODS_REGIONS = (1, True)

  def __init__(self, topModuleRef, *, instName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["topModuleRef"] = (topModuleRef if (
    isinstance(topModuleRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(topModuleRef, context=_ods_context))
    if instName is not None: attributes["instName"] = (instName if (
        isinstance(instName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(instName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def topModuleRef(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["topModuleRef"]

  @topModuleRef.setter
  def topModuleRef(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["topModuleRef"] = value

  @builtins.property
  def instName(self) -> _Optional[_ods_ir.StringAttr]:
    if "instName" not in self.operation.attributes:
      return None
    return self.operation.attributes["instName"]

  @instName.setter
  def instName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["instName"] = value
    elif "instName" in self.operation.attributes:
      del self.operation.attributes["instName"]

  @instName.deleter
  def instName(self):
    del self.operation.attributes["instName"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def instance_hierarchy(top_module_ref, *, inst_name=None, loc=None, ip=None) -> InstanceHierarchyOp:
  return InstanceHierarchyOp(topModuleRef=top_module_ref, instName=inst_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LinearOp(_ods_ir.OpView):
  r"""
  Defines a feed-forward datapath which can be scheduled into a pipeline.
  Due to the feed-forwardness, the inner region is NOT a graph region.
  Internally, only combinational operations (`comb`, `msft`, `hw`) are allowed.
  
  Example:
  ```mlir
  msft.module @foo(%in0 : i32, %in1 : i32, %in2 : i32, %clk : i1) -> (out: i32) -> {
    %0 = msft.hlc.linear(%a = %in0, %b = %in1, %c = %in2) clock %clk (i32, i32, i32) -> (i32) {
      %0 = comb.mul %a, %b : i32
      %1 = comb.add %0, %c : i32
      msft.output %1 : i32
    }
  }
  ```
  """

  OPERATION_NAME = "msft.hlc.linear"

  _ODS_REGIONS = (1, True)

  def __init__(self, outs, clock, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(outs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def outs(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def datapath(self) -> _ods_ir.Region:
    return self.regions[0]

def hlc_linear(outs, clock, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LinearOp]:
  op = LinearOp(outs=outs, clock=clock, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def output(operands_, *, loc=None, ip=None) -> OutputOp:
  return OutputOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDMulticycleOp(_ods_ir.OpView):
  r"""
  Specifies a multicycle constraint in between two registers.
  `source` and `dest` symbols reference `HierPathOp` symbols denoting the
  exact registers in the instance hierarchy to which the constraint applies.
  """

  OPERATION_NAME = "msft.pd.multicycle"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, dest, cycles, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source"] = (source if (
    isinstance(source, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(source, context=_ods_context))
    attributes["dest"] = (dest if (
    isinstance(dest, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(dest, context=_ods_context))
    attributes["cycles"] = (cycles if (
    isinstance(cycles, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(cycles, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["source"]

  @source.setter
  def source(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source"] = value

  @builtins.property
  def dest(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["dest"]

  @dest.setter
  def dest(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dest"] = value

  @builtins.property
  def cycles(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["cycles"]

  @cycles.setter
  def cycles(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cycles"] = value

def pd_multicycle(source, dest, cycles, *, loc=None, ip=None) -> PDMulticycleOp:
  return PDMulticycleOp(source=source, dest=dest, cycles=cycles, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDPhysLocationOp(_ods_ir.OpView):
  r"""
  Used to specify a specific location on an FPGA to place a dynamic instance.
  Supports specifying the location of a subpath for extern modules and device
  primitives. Intended to live as a child of `instance.dynamic` initially
  without the `ref` field. The dynamic instance lowering will fill in `ref`
  with the symol of the `hw.hierpath` op corresponding to the lowered dynamic
  instance.
  """

  OPERATION_NAME = "msft.pd.location"

  _ODS_REGIONS = (0, True)

  def __init__(self, loc_, *, subPath=None, ref=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["loc"] = (loc_ if (
    isinstance(loc_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PhysLocation')) else
      _ods_ir.AttrBuilder.get('PhysLocation')(loc_, context=_ods_context))
    if subPath is not None: attributes["subPath"] = (subPath if (
        isinstance(subPath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(subPath, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def loc_(self) -> _ods_ir.Attribute:
    return self.operation.attributes["loc"]

  @loc_.setter
  def loc_(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["loc"] = value

  @builtins.property
  def subPath(self) -> _Optional[_ods_ir.StringAttr]:
    if "subPath" not in self.operation.attributes:
      return None
    return self.operation.attributes["subPath"]

  @subPath.setter
  def subPath(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["subPath"] = value
    elif "subPath" in self.operation.attributes:
      del self.operation.attributes["subPath"]

  @subPath.deleter
  def subPath(self):
    del self.operation.attributes["subPath"]

  @builtins.property
  def ref(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def pd_location(loc_, *, sub_path=None, ref=None, loc=None, ip=None) -> PDPhysLocationOp:
  return PDPhysLocationOp(loc_=loc_, subPath=sub_path, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDPhysRegionOp(_ods_ir.OpView):
  r"""
  Annotate a particular entity within an op with the region of the devices
  on an FPGA to which it should mapped. The physRegionRef must refer to a
  DeclPhysicalRegion operation.
  """

  OPERATION_NAME = "msft.pd.physregion"

  _ODS_REGIONS = (0, True)

  def __init__(self, physRegionRef, *, subPath=None, ref=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["physRegionRef"] = (physRegionRef if (
    isinstance(physRegionRef, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(physRegionRef, context=_ods_context))
    if subPath is not None: attributes["subPath"] = (subPath if (
        isinstance(subPath, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(subPath, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def physRegionRef(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["physRegionRef"]

  @physRegionRef.setter
  def physRegionRef(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["physRegionRef"] = value

  @builtins.property
  def subPath(self) -> _Optional[_ods_ir.StringAttr]:
    if "subPath" not in self.operation.attributes:
      return None
    return self.operation.attributes["subPath"]

  @subPath.setter
  def subPath(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["subPath"] = value
    elif "subPath" in self.operation.attributes:
      del self.operation.attributes["subPath"]

  @subPath.deleter
  def subPath(self):
    del self.operation.attributes["subPath"]

  @builtins.property
  def ref(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def pd_physregion(phys_region_ref, *, sub_path=None, ref=None, loc=None, ip=None) -> PDPhysRegionOp:
  return PDPhysRegionOp(physRegionRef=phys_region_ref, subPath=sub_path, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PDRegPhysLocationOp(_ods_ir.OpView):
  r"""
  A version of "PDPhysLocationOp" specialized for registers, which have one
  location per bit.
  """

  OPERATION_NAME = "msft.pd.reg_location"

  _ODS_REGIONS = (0, True)

  def __init__(self, locs, *, ref=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["locs"] = (locs if (
    isinstance(locs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('LocationVector')) else
      _ods_ir.AttrBuilder.get('LocationVector')(locs, context=_ods_context))
    if ref is not None: attributes["ref"] = (ref if (
        isinstance(ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def locs(self) -> _ods_ir.Attribute:
    return self.operation.attributes["locs"]

  @locs.setter
  def locs(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["locs"] = value

  @builtins.property
  def ref(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["ref"] = value
    elif "ref" in self.operation.attributes:
      del self.operation.attributes["ref"]

  @ref.deleter
  def ref(self):
    del self.operation.attributes["ref"]

def pd_reg_location(locs, *, ref=None, loc=None, ip=None) -> PDRegPhysLocationOp:
  return PDRegPhysLocationOp(locs=locs, ref=ref, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PEOutputOp(_ods_ir.OpView):
  OPERATION_NAME = "msft.pe.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(output)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def output(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def pe_output(output, *, loc=None, ip=None) -> PEOutputOp:
  return PEOutputOp(output=output, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SystolicArrayOp(_ods_ir.OpView):
  r"""
  Note: the PE region is NOT a graph region. This was intentional since
  systolic arrays are entirely feed-forward.
  """

  OPERATION_NAME = "msft.systolic.array"

  _ODS_REGIONS = (1, True)

  def __init__(self, peOutputs, rowInputs, colInputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(rowInputs)
    operands.append(colInputs)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(peOutputs)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def rowInputs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def colInputs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def peOutputs(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def pe(self) -> _ods_ir.Region:
    return self.regions[0]

def systolic_array(pe_outputs, row_inputs, col_inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SystolicArrayOp(peOutputs=pe_outputs, rowInputs=row_inputs, colInputs=col_inputs, loc=loc, ip=ip).result
