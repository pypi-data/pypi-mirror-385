
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "sv"

@_ods_cext.register_operation(_Dialect)
class AliasOp(_ods_ir.OpView):
  r"""
  An alias statement declares multiple names for the same physical net, or
  bits within a net.  Aliases always have at least two operands.
  """

  OPERATION_NAME = "sv.alias"

  _ODS_REGIONS = (0, True)

  def __init__(self, aliases, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(aliases))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def aliases(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def alias(aliases, *, loc=None, ip=None) -> AliasOp:
  return AliasOp(aliases=aliases, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AlwaysCombOp(_ods_ir.OpView):
  r"""
  See SV Spec 9.2, and 9.2.2.2.
  """

  OPERATION_NAME = "sv.alwayscomb"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def alwayscomb(*, loc=None, ip=None) -> AlwaysCombOp:
  return AlwaysCombOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AlwaysFFOp(_ods_ir.OpView):
  r"""
  alwaysff blocks represent always_ff verilog nodes, which enforce inference
  of registers.  This block takes a clock signal and edge sensitivity and
  reset type.  If the reset type is anything but 'noreset', the block takes a
  reset signal, reset sensitivity, and reset block.  Appropriate if conditions
  are generated in the output code based on the reset type.  A negative-edge,
  asynchronous reset will check the inverse of the reset condition
  (if (!reset) begin resetblock end) to match the sensitivity.
  """

  OPERATION_NAME = "sv.alwaysff"

  _ODS_REGIONS = (2, True)

  def __init__(self, clockEdge, clock, *, resetStyle=None, resetEdge=None, reset=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    if reset is not None: operands.append(reset)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["clockEdge"] = (clockEdge if (
    isinstance(clockEdge, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
      _ods_ir.AttrBuilder.get('EventControlAttr')(clockEdge, context=_ods_context))
    if resetStyle is not None: attributes["resetStyle"] = (resetStyle if (
        isinstance(resetStyle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ResetTypeAttr')) else
          _ods_ir.AttrBuilder.get('ResetTypeAttr')(resetStyle, context=_ods_context))
    if resetEdge is not None: attributes["resetEdge"] = (resetEdge if (
        isinstance(resetEdge, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
          _ods_ir.AttrBuilder.get('EventControlAttr')(resetEdge, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def reset(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def clockEdge(self) -> _ods_ir.Attribute:
    return self.operation.attributes["clockEdge"]

  @clockEdge.setter
  def clockEdge(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clockEdge"] = value

  @builtins.property
  def resetStyle(self) -> _ods_ir.Attribute:
    return self.operation.attributes["resetStyle"]

  @resetStyle.setter
  def resetStyle(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resetStyle"] = value

  @builtins.property
  def resetEdge(self) -> _Optional[_ods_ir.Attribute]:
    if "resetEdge" not in self.operation.attributes:
      return None
    return self.operation.attributes["resetEdge"]

  @resetEdge.setter
  def resetEdge(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["resetEdge"] = value
    elif "resetEdge" in self.operation.attributes:
      del self.operation.attributes["resetEdge"]

  @resetEdge.deleter
  def resetEdge(self):
    del self.operation.attributes["resetEdge"]

  @builtins.property
  def bodyBlk(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def resetBlk(self) -> _ods_ir.Region:
    return self.regions[1]

def alwaysff(clock_edge, clock, *, reset_style=None, reset_edge=None, reset=None, loc=None, ip=None) -> AlwaysFFOp:
  return AlwaysFFOp(clockEdge=clock_edge, clock=clock, resetStyle=reset_style, resetEdge=reset_edge, reset=reset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AlwaysOp(_ods_ir.OpView):
  r"""
  See SV Spec 9.2, and 9.4.2.2.
  """

  OPERATION_NAME = "sv.always"

  _ODS_REGIONS = (1, True)

  def __init__(self, events, clocks, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(clocks))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["events"] = (events if (
    isinstance(events, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_578')) else
      _ods_ir.AttrBuilder.get('anonymous_578')(events, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clocks(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def events(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["events"]

  @events.setter
  def events(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["events"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def always(events, clocks, *, loc=None, ip=None) -> AlwaysOp:
  return AlwaysOp(events=events, clocks=clocks, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ArrayIndexInOutOp(_ods_ir.OpView):
  r"""
  See SV Spec 11.5.2.
  """

  OPERATION_NAME = "sv.array_index_inout"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_index_inout(input, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayIndexInOutOp(input=input, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssertConcurrentOp(_ods_ir.OpView):
  r"""
  Specify that a property of the hardware design is true whenever the property
  is evaluated.  This can be used to both document the behavior of the design
  and to test that the design behaves as expected.  See section 16.5 of the
  SystemVerilog 2017 specification.
  """

  OPERATION_NAME = "sv.assert.concurrent"

  _ODS_REGIONS = (0, True)

  def __init__(self, event, clock, property, substitutions, *, label=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(property)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["event"] = (event if (
    isinstance(event, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
      _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def event(self) -> _ods_ir.Attribute:
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["event"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def assert_concurrent(event, clock, property, substitutions, *, label=None, message=None, loc=None, ip=None) -> AssertConcurrentOp:
  return AssertConcurrentOp(event=event, clock=clock, property=property, substitutions=substitutions, label=label, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssertOp(_ods_ir.OpView):
  r"""
  Specify that a Boolean expression is always true.  This can be used to both
  document the behavior of the design and to test that the design behaves as
  expected.  See Section 16.3 of the SystemVerilog 2017 specification.
  """

  OPERATION_NAME = "sv.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, expression, defer, substitutions, *, label=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(expression)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["defer"] = (defer if (
    isinstance(defer, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DeferAssertAttr')) else
      _ods_ir.AttrBuilder.get('DeferAssertAttr')(defer, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def expression(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def defer(self) -> _ods_ir.Attribute:
    return self.operation.attributes["defer"]

  @defer.setter
  def defer(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["defer"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def assert_(expression, defer, substitutions, *, label=None, message=None, loc=None, ip=None) -> AssertOp:
  return AssertOp(expression=expression, defer=defer, substitutions=substitutions, label=label, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssertPropertyOp(_ods_ir.OpView):
  r"""
  Assert that a given SVA-style property holds. This is only checked when 
  the disable signal is low and a clock event occurs. This is analogous to 
  the verif.assert operation, but with a flipped enable polarity.
  """

  OPERATION_NAME = "sv.assert_property"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, event=None, clock=None, disable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    operands.append(clock)
    operands.append(disable)
    _ods_context = _ods_get_default_loc_context(loc)
    if event is not None: attributes["event"] = (event if (
        isinstance(event, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
          _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def clock(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def disable(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def event(self) -> _Optional[_ods_ir.Attribute]:
    if "event" not in self.operation.attributes:
      return None
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["event"] = value
    elif "event" in self.operation.attributes:
      del self.operation.attributes["event"]

  @event.deleter
  def event(self):
    del self.operation.attributes["event"]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def assert_property(property, *, event=None, clock=None, disable=None, label=None, loc=None, ip=None) -> AssertPropertyOp:
  return AssertPropertyOp(property=property, event=event, clock=clock, disable=disable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssignInterfaceSignalOp(_ods_ir.OpView):
  r"""
  Use this to continuously assign a signal inside an interface to a
  value or other signal.
  
  ```
    sv.interface.signal.assign %iface(@handshake_example::@data)
      = %zero32 : i32
  ```
  
  Would result in the following SystemVerilog:
  ```
    assign iface.data = zero32;
  ```
  """

  OPERATION_NAME = "sv.interface.signal.assign"

  _ODS_REGIONS = (0, True)

  def __init__(self, iface, signalName, rhs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(iface)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["signalName"] = (signalName if (
    isinstance(signalName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(signalName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def iface(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def signalName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["signalName"]

  @signalName.setter
  def signalName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signalName"] = value

def interface_signal_assign(iface, signal_name, rhs, *, loc=None, ip=None) -> AssignInterfaceSignalOp:
  return AssignInterfaceSignalOp(iface=iface, signalName=signal_name, rhs=rhs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssignOp(_ods_ir.OpView):
  r"""
  A SystemVerilog assignment statement 'x = y;'.
  These occur in module scope.  See SV Spec 10.3.2.
  """

  OPERATION_NAME = "sv.assign"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def assign(dest, src, *, loc=None, ip=None) -> AssignOp:
  return AssignOp(dest=dest, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssumeConcurrentOp(_ods_ir.OpView):
  r"""
  Specify that a property is assumed to be true whenever the property is
  evaluated.  This can be used to both document the behavior of the design and
  to test that the design behaves as expected.  See section 16.5 of the
  SystemVerilog 2017 specification.
  """

  OPERATION_NAME = "sv.assume.concurrent"

  _ODS_REGIONS = (0, True)

  def __init__(self, event, clock, property, substitutions, *, label=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(property)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["event"] = (event if (
    isinstance(event, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
      _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def event(self) -> _ods_ir.Attribute:
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["event"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def assume_concurrent(event, clock, property, substitutions, *, label=None, message=None, loc=None, ip=None) -> AssumeConcurrentOp:
  return AssumeConcurrentOp(event=event, clock=clock, property=property, substitutions=substitutions, label=label, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssumeOp(_ods_ir.OpView):
  r"""
  Specify that a Boolean expression is assumed to always be true.  This can
  either be used as an assertion-like check that the expression is, in fact,
  always true or to bound legal input values during testing.  See Section 16.3
  of the SystemVerilog 2017 specification.
  """

  OPERATION_NAME = "sv.assume"

  _ODS_REGIONS = (0, True)

  def __init__(self, expression, defer, substitutions, *, label=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(expression)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["defer"] = (defer if (
    isinstance(defer, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DeferAssertAttr')) else
      _ods_ir.AttrBuilder.get('DeferAssertAttr')(defer, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def expression(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def defer(self) -> _ods_ir.Attribute:
    return self.operation.attributes["defer"]

  @defer.setter
  def defer(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["defer"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def assume(expression, defer, substitutions, *, label=None, message=None, loc=None, ip=None) -> AssumeOp:
  return AssumeOp(expression=expression, defer=defer, substitutions=substitutions, label=label, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AssumePropertyOp(_ods_ir.OpView):
  r"""
  Assume that a given SVA-style property holds. This is only considered when 
  the disable signal is low and a clock event occurs. This is analogous to 
  the verif.assume operation, but with a flipped enable polarity.
  """

  OPERATION_NAME = "sv.assume_property"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, event=None, clock=None, disable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    operands.append(clock)
    operands.append(disable)
    _ods_context = _ods_get_default_loc_context(loc)
    if event is not None: attributes["event"] = (event if (
        isinstance(event, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
          _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def clock(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def disable(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def event(self) -> _Optional[_ods_ir.Attribute]:
    if "event" not in self.operation.attributes:
      return None
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["event"] = value
    elif "event" in self.operation.attributes:
      del self.operation.attributes["event"]

  @event.deleter
  def event(self):
    del self.operation.attributes["event"]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def assume_property(property, *, event=None, clock=None, disable=None, label=None, loc=None, ip=None) -> AssumePropertyOp:
  return AssumePropertyOp(property=property, event=event, clock=clock, disable=disable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BPAssignOp(_ods_ir.OpView):
  r"""
  A SystemVerilog blocking procedural assignment statement 'x = y;'.  These
  occur in initial, always, task, and function blocks.  The statement is
  executed before any following statements are. See SV Spec 10.4.1.
  """

  OPERATION_NAME = "sv.bpassign"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def bpassign(dest, src, *, loc=None, ip=None) -> BPAssignOp:
  return BPAssignOp(dest=dest, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BindInterfaceOp(_ods_ir.OpView):
  r"""
  Indirectly instantiate an interface in the context of another module. This
  operation must pair with a `sv.interface.instance`.
  """

  OPERATION_NAME = "sv.bind.interface"

  _ODS_REGIONS = (0, True)

  def __init__(self, instance, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instance"] = (instance if (
    isinstance(instance, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(instance, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instance(self) -> _ods_ir.Attribute:
    return self.operation.attributes["instance"]

  @instance.setter
  def instance(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instance"] = value

def bind_interface(instance, *, loc=None, ip=None) -> BindInterfaceOp:
  return BindInterfaceOp(instance=instance, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BindOp(_ods_ir.OpView):
  r"""
  Indirectly instantiate a module from the context of another module. BindOp
  pairs with a `hw.instance` (identified by a `boundInstance` symbol) which
  tracks all information except the emission point for the bind.  BindOp also
  tracks the `instanceModule` symbol for the `hw.module` that contains the
  `hw.instance` to accelerate symbol lookup.
  
  See 23.11 of SV 2017 spec for more information about bind.
  """

  OPERATION_NAME = "sv.bind"

  _ODS_REGIONS = (0, True)

  def __init__(self, instance, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instance"] = (instance if (
    isinstance(instance, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InnerRefAttr')) else
      _ods_ir.AttrBuilder.get('InnerRefAttr')(instance, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def instance(self) -> _ods_ir.Attribute:
    return self.operation.attributes["instance"]

  @instance.setter
  def instance(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instance"] = value

def bind(instance, *, loc=None, ip=None) -> BindOp:
  return BindOp(instance=instance, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CaseOp(_ods_ir.OpView):
  r"""
  See SystemVerilog 2017 12.5.
  """

  OPERATION_NAME = "sv.case"

  _ODS_REGIONS = (0, False)

  def __init__(self, cond, casePatterns, caseValues, num_caseRegions, *, caseStyle=None, validationQualifier=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    operands.extend(_get_op_results_or_values(caseValues))
    _ods_context = _ods_get_default_loc_context(loc)
    if caseStyle is not None: attributes["caseStyle"] = (caseStyle if (
        isinstance(caseStyle, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('CaseStmtTypeAttr')) else
          _ods_ir.AttrBuilder.get('CaseStmtTypeAttr')(caseStyle, context=_ods_context))
    attributes["casePatterns"] = (casePatterns if (
    isinstance(casePatterns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(casePatterns, context=_ods_context))
    if validationQualifier is not None: attributes["validationQualifier"] = (validationQualifier if (
        isinstance(validationQualifier, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ValidationQualifierTypeAttr')) else
          _ods_ir.AttrBuilder.get('ValidationQualifierTypeAttr')(validationQualifier, context=_ods_context))
    results = []
    _ods_successors = None
    regions = 0 + num_caseRegions
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def caseValues(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def caseStyle(self) -> _ods_ir.Attribute:
    return self.operation.attributes["caseStyle"]

  @caseStyle.setter
  def caseStyle(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["caseStyle"] = value

  @builtins.property
  def casePatterns(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["casePatterns"]

  @casePatterns.setter
  def casePatterns(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["casePatterns"] = value

  @builtins.property
  def validationQualifier(self) -> _ods_ir.Attribute:
    return self.operation.attributes["validationQualifier"]

  @validationQualifier.setter
  def validationQualifier(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["validationQualifier"] = value

  @builtins.property
  def caseRegions(self) -> _ods_ir.RegionSequence:
    return self.regions[0:]

def case(cond, case_patterns, case_values, num_case_regions, *, case_style=None, validation_qualifier=None, loc=None, ip=None) -> CaseOp:
  return CaseOp(cond=cond, casePatterns=case_patterns, caseValues=case_values, num_caseRegions=num_case_regions, caseStyle=case_style, validationQualifier=validation_qualifier, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConstantStrOp(_ods_ir.OpView):
  r"""
  This operation produces a constant string literal.
  """

  OPERATION_NAME = "sv.constantStr"

  _ODS_REGIONS = (0, True)

  def __init__(self, str, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["str"] = (str if (
    isinstance(str, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(str, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def str(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["str"]

  @str.setter
  def str(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["str"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constantStr(str, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantStrOp(str=str, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantXOp(_ods_ir.OpView):
  r"""
  This operation produces a constant value of 'x'.  This 'x' follows the
  System Verilog rules for 'x' propagation.
  """

  OPERATION_NAME = "sv.constantX"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constantX(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantXOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantZOp(_ods_ir.OpView):
  r"""
  This operation produces a constant value of 'z'.  This 'z' follows the
  System Verilog rules for 'z' propagation.
  """

  OPERATION_NAME = "sv.constantZ"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constantZ(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantZOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CoverConcurrentOp(_ods_ir.OpView):
  r"""
  Specify that a specific property should be monitored for coverage, i.e., a
  simulation will watch if it occurrs and how many times it occurs.  See
  section 16.5 of the SystemVerilog 2017 specification.
  """

  OPERATION_NAME = "sv.cover.concurrent"

  _ODS_REGIONS = (0, True)

  def __init__(self, event, clock, property, substitutions, *, label=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(clock)
    operands.append(property)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["event"] = (event if (
    isinstance(event, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
      _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def property(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def event(self) -> _ods_ir.Attribute:
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["event"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def cover_concurrent(event, clock, property, substitutions, *, label=None, message=None, loc=None, ip=None) -> CoverConcurrentOp:
  return CoverConcurrentOp(event=event, clock=clock, property=property, substitutions=substitutions, label=label, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CoverOp(_ods_ir.OpView):
  r"""
  Specify that a Boolean expression should be monitored for coverage, i.e., a
  simulator will watch if it occurs and how many times it occurs.  See section
  16.3 of the SystemVerilog 2017 specification.
  """

  OPERATION_NAME = "sv.cover"

  _ODS_REGIONS = (0, True)

  def __init__(self, expression, defer, substitutions, *, label=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(expression)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["defer"] = (defer if (
    isinstance(defer, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DeferAssertAttr')) else
      _ods_ir.AttrBuilder.get('DeferAssertAttr')(defer, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def expression(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def defer(self) -> _ods_ir.Attribute:
    return self.operation.attributes["defer"]

  @defer.setter
  def defer(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["defer"] = value

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def cover(expression, defer, substitutions, *, label=None, message=None, loc=None, ip=None) -> CoverOp:
  return CoverOp(expression=expression, defer=defer, substitutions=substitutions, label=label, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CoverPropertyOp(_ods_ir.OpView):
  r"""
  Cover when a given SVA-style property holds. This is only checked when 
  the disable signal is low and a clock event occurs. This is analogous to 
  the verif.cover operation, but with a flipped enable polarity.
  """

  OPERATION_NAME = "sv.cover_property"

  _ODS_OPERAND_SEGMENTS = [1,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, property, *, event=None, clock=None, disable=None, label=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(property)
    operands.append(clock)
    operands.append(disable)
    _ods_context = _ods_get_default_loc_context(loc)
    if event is not None: attributes["event"] = (event if (
        isinstance(event, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
          _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    if label is not None: attributes["label"] = (label if (
        isinstance(label, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def property(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def clock(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def disable(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def event(self) -> _Optional[_ods_ir.Attribute]:
    if "event" not in self.operation.attributes:
      return None
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["event"] = value
    elif "event" in self.operation.attributes:
      del self.operation.attributes["event"]

  @event.deleter
  def event(self):
    del self.operation.attributes["event"]

  @builtins.property
  def label(self) -> _Optional[_ods_ir.StringAttr]:
    if "label" not in self.operation.attributes:
      return None
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["label"] = value
    elif "label" in self.operation.attributes:
      del self.operation.attributes["label"]

  @label.deleter
  def label(self):
    del self.operation.attributes["label"]

def cover_property(property, *, event=None, clock=None, disable=None, label=None, loc=None, ip=None) -> CoverPropertyOp:
  return CoverPropertyOp(property=property, event=event, clock=clock, disable=disable, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DepositOp(_ods_ir.OpView):
  r"""
  This system task sets the value of a net or variable, but doesn't hold it.
  This is a common simulation vendor extension.
  """

  OPERATION_NAME = "sv.nonstandard.deposit"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def nonstandard_deposit(dest, src, *, loc=None, ip=None) -> DepositOp:
  return DepositOp(dest=dest, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ErrorOp(_ods_ir.OpView):
  r"""
  This system task indicates a run-time error.
  
  If present, the optional message is printed with any additional operands
  interpolated into the message string.
  """

  OPERATION_NAME = "sv.error"

  _ODS_REGIONS = (0, True)

  def __init__(self, substitutions, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def error(substitutions, *, message=None, loc=None, ip=None) -> ErrorOp:
  return ErrorOp(substitutions=substitutions, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExitOp(_ods_ir.OpView):
  r"""
  Waits for all `program` blocks to complete and then makes an implicit call
  to `$finish` with default verbosity (level 1) to conclude the simulation.
  """

  OPERATION_NAME = "sv.exit"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def exit(*, loc=None, ip=None) -> ExitOp:
  return ExitOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FFlushOp(_ods_ir.OpView):
  r"""
  The $fflush system task flushes the output buffer of the specified file
  descriptor. If no file descriptor is specified, all open files are flushed.
  
  See IEEE 1800-2023 Section 21.3.6.
  """

  OPERATION_NAME = "sv.fflush"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, fd=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if fd is not None: operands.append(fd)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fd(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

def fflush(*, fd=None, loc=None, ip=None) -> FFlushOp:
  return FFlushOp(fd=fd, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.fwrite"

  _ODS_REGIONS = (0, True)

  def __init__(self, fd, format_string, substitutions, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(fd)
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format_string"] = (format_string if (
    isinstance(format_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format_string, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fd(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def format_string(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format_string"]

  @format_string.setter
  def format_string(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format_string"] = value

def fwrite(fd, format_string, substitutions, *, loc=None, ip=None) -> FWriteOp:
  return FWriteOp(fd=fd, format_string=format_string, substitutions=substitutions, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FatalOp(_ods_ir.OpView):
  r"""
  Generates a run-time fatal error which terminates the simulation with an
  error code. Makes an implicit call to `$finish`, forwarding the `verbosity`
  operand. If present, the optional message is printed with any additional
  operands interpolated into the message string.
  """

  OPERATION_NAME = "sv.fatal"

  _ODS_REGIONS = (0, True)

  def __init__(self, substitutions, *, verbosity=None, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    if verbosity is not None: attributes["verbosity"] = (verbosity if (
        isinstance(verbosity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VerbosityIntAttr')) else
          _ods_ir.AttrBuilder.get('VerbosityIntAttr')(verbosity, context=_ods_context))
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def verbosity(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["verbosity"]

  @verbosity.setter
  def verbosity(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbosity"] = value

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def fatal(substitutions, *, verbosity=None, message=None, loc=None, ip=None) -> FatalOp:
  return FatalOp(substitutions=substitutions, verbosity=verbosity, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FinishOp(_ods_ir.OpView):
  r"""
  Stops the simulation and exits/terminates the simulator process. In practice
  most GUI-based simulators will show a prompt to the user offering them an
  opportunity to not close the simulator altogether.
  
  Other tasks such as `$exit` or `$fatal` implicitly call this system task.
  
  The optional `verbosity` parameter controls how much diagnostic information
  is printed when the system task is executed (see section 20.2 of IEEE
  1800-2017):
  
  - `0`: Prints nothing
  - `1`: Prints simulation time and location (default)
  - `2`: Prints simulation time, location, and statistics about the memory and
    CPU time used in simulation
  """

  OPERATION_NAME = "sv.finish"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, verbosity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if verbosity is not None: attributes["verbosity"] = (verbosity if (
        isinstance(verbosity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VerbosityIntAttr')) else
          _ods_ir.AttrBuilder.get('VerbosityIntAttr')(verbosity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def verbosity(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["verbosity"]

  @verbosity.setter
  def verbosity(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbosity"] = value

def finish(*, verbosity=None, loc=None, ip=None) -> FinishOp:
  return FinishOp(verbosity=verbosity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ForOp(_ods_ir.OpView):
  r"""
  The `sv.for` operation in System Verilog defines a for statement that requires
  three SSA operands: `lowerBounds`, `upperBound`, and `step`. It functions
  similarly to `scf.for`, where the loop iterates the induction variable from
  `lowerBound` to `upperBound` with a step size of `step`, i.e:
  
  ```
   for (logic ... indVar = lowerBound; indVar < upperBound; indVar += step) begin
   end
  ```
  
  It's important to note that since we are using a bit precise type instead of a Verilog
  `integer` type, users must be cautious about potential overflow. For example, if
  you wish to iterate over all 2-bit values, you must use a 3-bit value as the
  induction variable type.
  """

  OPERATION_NAME = "sv.for"

  _ODS_REGIONS = (1, True)

  def __init__(self, lowerBound, upperBound, step, *, inductionVarName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lowerBound)
    operands.append(upperBound)
    operands.append(step)
    _ods_context = _ods_get_default_loc_context(loc)
    if inductionVarName is not None: attributes["inductionVarName"] = (inductionVarName if (
        isinstance(inductionVarName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(inductionVarName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lowerBound(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def upperBound(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def step(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def inductionVarName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["inductionVarName"]

  @inductionVarName.setter
  def inductionVarName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inductionVarName"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def for_(lower_bound, upper_bound, step, *, induction_var_name=None, loc=None, ip=None) -> ForOp:
  return ForOp(lowerBound=lower_bound, upperBound=upper_bound, step=step, inductionVarName=induction_var_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ForceOp(_ods_ir.OpView):
  r"""
  A SystemVerilog force procedural statement 'force x = y;'.  These
  occur in initial, always, task, and function blocks.
  A force statement shall override a procedural assignment until
  a release statement is executed on the variable.
  The left-hand side of the assignment can be a variable, a net,
  a constant bit-select of a vector net, a part-select of a vector
  net or a concatenation. It cannot be a memory word or a bit-select
  or part-select of a vector variable. See SV Spec 10.6.2.
  """

  OPERATION_NAME = "sv.force"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def force(dest, src, *, loc=None, ip=None) -> ForceOp:
  return ForceOp(dest=dest, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FuncCallOp(_ods_ir.OpView):
  r"""
  This op represents a function call in a non-procedural region.
  A function call in a non-procedural region must have a return
  value and no output argument.
  """

  OPERATION_NAME = "sv.func.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, callee, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

def func_call(result, callee, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FuncCallOp]:
  op = FuncCallOp(result=result, callee=callee, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FuncCallProceduralOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.func.call.procedural"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, callee, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

def func_call_procedural(result, callee, inputs, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FuncCallProceduralOp]:
  op = FuncCallProceduralOp(result=result, callee=callee, inputs=inputs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FuncDPIImportOp(_ods_ir.OpView):
  r"""
  `sv.func.dpi.import` represents DPI function import statement defined in
  IEEE 1800-2017 section 35.4.
  """

  OPERATION_NAME = "sv.func.dpi.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, callee, *, linkage_name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if linkage_name is not None: attributes["linkage_name"] = (linkage_name if (
        isinstance(linkage_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(linkage_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def linkage_name(self) -> _Optional[_ods_ir.StringAttr]:
    if "linkage_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["linkage_name"]

  @linkage_name.setter
  def linkage_name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["linkage_name"] = value
    elif "linkage_name" in self.operation.attributes:
      del self.operation.attributes["linkage_name"]

  @linkage_name.deleter
  def linkage_name(self):
    del self.operation.attributes["linkage_name"]

def func_dpi_import(callee, *, linkage_name=None, loc=None, ip=None) -> FuncDPIImportOp:
  return FuncDPIImportOp(callee=callee, linkage_name=linkage_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  `sv.func` represents SystemVerilog function in IEEE 1800-2017 section 13.4
   "Functions". Similar to HW module, it's allowed to mix the order of input
  and output arguments. `sv.func` can be used for both function
  declaration and definition, i.e. a function without a body
  region is a declaration.
  
  In SV there are two representations for function results,
  "output argument" and "return value". Currently an output argument
  is considered as as a return value if it's is the last argument
  and has a special attribute `sv.func.explicitly_returned`.
  """

  OPERATION_NAME = "sv.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, module_type, *, per_argument_attrs=None, input_locs=None, result_locs=None, verilogName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["module_type"] = (module_type if (
    isinstance(module_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_650')) else
      _ods_ir.AttrBuilder.get('anonymous_650')(module_type, context=_ods_context))
    if per_argument_attrs is not None: attributes["per_argument_attrs"] = (per_argument_attrs if (
        isinstance(per_argument_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(per_argument_attrs, context=_ods_context))
    if input_locs is not None: attributes["input_locs"] = (input_locs if (
        isinstance(input_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(input_locs, context=_ods_context))
    if result_locs is not None: attributes["result_locs"] = (result_locs if (
        isinstance(result_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(result_locs, context=_ods_context))
    if verilogName is not None: attributes["verilogName"] = (verilogName if (
        isinstance(verilogName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verilogName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def module_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["module_type"]

  @module_type.setter
  def module_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module_type"] = value

  @builtins.property
  def per_argument_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "per_argument_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["per_argument_attrs"]

  @per_argument_attrs.setter
  def per_argument_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["per_argument_attrs"] = value
    elif "per_argument_attrs" in self.operation.attributes:
      del self.operation.attributes["per_argument_attrs"]

  @per_argument_attrs.deleter
  def per_argument_attrs(self):
    del self.operation.attributes["per_argument_attrs"]

  @builtins.property
  def input_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "input_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["input_locs"]

  @input_locs.setter
  def input_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["input_locs"] = value
    elif "input_locs" in self.operation.attributes:
      del self.operation.attributes["input_locs"]

  @input_locs.deleter
  def input_locs(self):
    del self.operation.attributes["input_locs"]

  @builtins.property
  def result_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "result_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["result_locs"]

  @result_locs.setter
  def result_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["result_locs"] = value
    elif "result_locs" in self.operation.attributes:
      del self.operation.attributes["result_locs"]

  @result_locs.deleter
  def result_locs(self):
    del self.operation.attributes["result_locs"]

  @builtins.property
  def verilogName(self) -> _Optional[_ods_ir.StringAttr]:
    if "verilogName" not in self.operation.attributes:
      return None
    return self.operation.attributes["verilogName"]

  @verilogName.setter
  def verilogName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["verilogName"] = value
    elif "verilogName" in self.operation.attributes:
      del self.operation.attributes["verilogName"]

  @verilogName.deleter
  def verilogName(self):
    del self.operation.attributes["verilogName"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(sym_name, module_type, *, per_argument_attrs=None, input_locs=None, result_locs=None, verilog_name=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(sym_name=sym_name, module_type=module_type, per_argument_attrs=per_argument_attrs, input_locs=input_locs, result_locs=result_locs, verilogName=verilog_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GenerateCaseOp(_ods_ir.OpView):
  r"""
  See SystemVerilog 2017 27.5.
  """

  OPERATION_NAME = "sv.generate.case"

  _ODS_REGIONS = (0, False)

  def __init__(self, cond, casePatterns, caseNames, num_caseRegions, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cond"] = (cond if (
    isinstance(cond, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(cond, context=_ods_context))
    attributes["casePatterns"] = (casePatterns if (
    isinstance(casePatterns, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PatternArrayAttr')) else
      _ods_ir.AttrBuilder.get('PatternArrayAttr')(casePatterns, context=_ods_context))
    attributes["caseNames"] = (caseNames if (
    isinstance(caseNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(caseNames, context=_ods_context))
    results = []
    _ods_successors = None
    regions = 0 + num_caseRegions
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Attribute:
    return self.operation.attributes["cond"]

  @cond.setter
  def cond(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cond"] = value

  @builtins.property
  def casePatterns(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["casePatterns"]

  @casePatterns.setter
  def casePatterns(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["casePatterns"] = value

  @builtins.property
  def caseNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["caseNames"]

  @caseNames.setter
  def caseNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["caseNames"] = value

  @builtins.property
  def caseRegions(self) -> _ods_ir.RegionSequence:
    return self.regions[0:]

def generate_case(cond, case_patterns, case_names, num_case_regions, *, loc=None, ip=None) -> GenerateCaseOp:
  return GenerateCaseOp(cond=cond, casePatterns=case_patterns, caseNames=case_names, num_caseRegions=num_case_regions, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GenerateOp(_ods_ir.OpView):
  r"""
  See SystemVerilog 2017 27.
  """

  OPERATION_NAME = "sv.generate"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def generate(sym_name, *, loc=None, ip=None) -> GenerateOp:
  return GenerateOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GetModportOp(_ods_ir.OpView):
  r"""
  Use this to extract a modport view to an instantiated interface. For
  example, to get the 'dataflow_in' modport on the 'handshake_example'
  interface:
  ```
  %ifaceModport = sv.modport.get @dataflow_in %iface :
    !sv.interface<@handshake_example> ->
    !sv.modport<@handshake_example::@dataflow_in>
  ```
  """

  OPERATION_NAME = "sv.modport.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, iface, field, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(iface)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["field"] = (field if (
    isinstance(field, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(field, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def iface(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def field(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["field"]

  @field.setter
  def field(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["field"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def modport_get(result, iface, field, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetModportOp(result=result, iface=iface, field=field, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IfDefOp(_ods_ir.OpView):
  r"""
  This operation is an #ifdef block, which has a "then" and "else" region.
  This operation is for non-procedural regions and its body is non-procedural.
  """

  OPERATION_NAME = "sv.ifdef"

  _ODS_REGIONS = (2, True)

  def __init__(self, cond, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cond"] = (cond if (
    isinstance(cond, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MacroIdentAttr')) else
      _ods_ir.AttrBuilder.get('MacroIdentAttr')(cond, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Attribute:
    return self.operation.attributes["cond"]

  @cond.setter
  def cond(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cond"] = value

  @builtins.property
  def thenRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def elseRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def ifdef(cond, *, loc=None, ip=None) -> IfDefOp:
  return IfDefOp(cond=cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IfDefProceduralOp(_ods_ir.OpView):
  r"""
  This operation is an #ifdef block, which has a "then" and "else" region.
  This operation is for procedural regions and its body is procedural.
  """

  OPERATION_NAME = "sv.ifdef.procedural"

  _ODS_REGIONS = (2, True)

  def __init__(self, cond, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cond"] = (cond if (
    isinstance(cond, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MacroIdentAttr')) else
      _ods_ir.AttrBuilder.get('MacroIdentAttr')(cond, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Attribute:
    return self.operation.attributes["cond"]

  @cond.setter
  def cond(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cond"] = value

  @builtins.property
  def thenRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def elseRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def ifdef_procedural(cond, *, loc=None, ip=None) -> IfDefProceduralOp:
  return IfDefProceduralOp(cond=cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.if"

  _ODS_REGIONS = (2, True)

  def __init__(self, cond, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(cond)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cond(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def thenRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def elseRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def if_(cond, *, loc=None, ip=None) -> IfOp:
  return IfOp(cond=cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IncludeOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.include"

  _ODS_REGIONS = (0, True)

  def __init__(self, style, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["style"] = (style if (
    isinstance(style, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IncludeStyleAttr')) else
      _ods_ir.AttrBuilder.get('IncludeStyleAttr')(style, context=_ods_context))
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(target, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def style(self) -> _ods_ir.Attribute:
    return self.operation.attributes["style"]

  @style.setter
  def style(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["style"] = value

  @builtins.property
  def target(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

def include(style, target, *, loc=None, ip=None) -> IncludeOp:
  return IncludeOp(style=style, target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IndexedPartSelectInOutOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.indexed_part_select_inout"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, width, *, decrement=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(base)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["width"] = (width if (
    isinstance(width, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(width, context=_ods_context))
    if bool(decrement): attributes["decrement"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def width(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["width"]

  @width.setter
  def width(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["width"] = value

  @builtins.property
  def decrement(self) -> bool:
    return "decrement" in self.operation.attributes

  @decrement.setter
  def decrement(self, value):
    if bool(value):
      self.operation.attributes["decrement"] = _ods_ir.UnitAttr.get()
    elif "decrement" in self.operation.attributes:
      del self.operation.attributes["decrement"]

  @decrement.deleter
  def decrement(self):
    del self.operation.attributes["decrement"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def indexed_part_select_inout(input, base, width, *, decrement=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IndexedPartSelectInOutOp(input=input, base=base, width=width, decrement=decrement, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IndexedPartSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.indexed_part_select"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, width, *, decrement=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(base)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["width"] = (width if (
    isinstance(width, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(width, context=_ods_context))
    if bool(decrement): attributes["decrement"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def width(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["width"]

  @width.setter
  def width(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["width"] = value

  @builtins.property
  def decrement(self) -> bool:
    return "decrement" in self.operation.attributes

  @decrement.setter
  def decrement(self, value):
    if bool(value):
      self.operation.attributes["decrement"] = _ods_ir.UnitAttr.get()
    elif "decrement" in self.operation.attributes:
      del self.operation.attributes["decrement"]

  @decrement.deleter
  def decrement(self):
    del self.operation.attributes["decrement"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def indexed_part_select(input, base, width, *, decrement=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IndexedPartSelectOp(input=input, base=base, width=width, decrement=decrement, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InfoOp(_ods_ir.OpView):
  r"""
  This system task indicates a message with no specific severity.
  
  If present, the optional message is printed with any additional operands
  interpolated into the message string.
  """

  OPERATION_NAME = "sv.info"

  _ODS_REGIONS = (0, True)

  def __init__(self, substitutions, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def info(substitutions, *, message=None, loc=None, ip=None) -> InfoOp:
  return InfoOp(substitutions=substitutions, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InitialOp(_ods_ir.OpView):
  r"""
  See SV Spec 9.2.1.
  """

  OPERATION_NAME = "sv.initial"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def initial(*, loc=None, ip=None) -> InitialOp:
  return InitialOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InterfaceInstanceOp(_ods_ir.OpView):
  r"""
  Use this to declare an instance of an interface:
  ```
  %iface = sv.interface.instance : !sv.interface<@handshake_example>
  ```
  """

  OPERATION_NAME = "sv.interface.instance"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, *, inner_sym=None, doNotPrint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    if bool(doNotPrint): attributes["doNotPrint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def doNotPrint(self) -> bool:
    return "doNotPrint" in self.operation.attributes

  @doNotPrint.setter
  def doNotPrint(self, value):
    if bool(value):
      self.operation.attributes["doNotPrint"] = _ods_ir.UnitAttr.get()
    elif "doNotPrint" in self.operation.attributes:
      del self.operation.attributes["doNotPrint"]

  @doNotPrint.deleter
  def doNotPrint(self):
    del self.operation.attributes["doNotPrint"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def interface_instance(result, name, *, inner_sym=None, do_not_print=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return InterfaceInstanceOp(result=result, name=name, inner_sym=inner_sym, doNotPrint=do_not_print, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceModportOp(_ods_ir.OpView):
  r"""
  This operation defines a named modport within an interface. Its name is a
  symbol that can be looked up inside its parent interface. There is an array
  of structs that contains two fields: an enum to indicate the direction of
  the signal in the modport, and a symbol reference to refer to the signal.
  
  Example:
  
  ```mlir
  sv.interface.modport @input_port (input @data)
  sv.interface.modport @output_port (output @data)
  ```
  """

  OPERATION_NAME = "sv.interface.modport"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, ports, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["ports"] = (ports if (
    isinstance(ports, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ModportStructArrayAttr')) else
      _ods_ir.AttrBuilder.get('ModportStructArrayAttr')(ports, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def ports(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["ports"]

  @ports.setter
  def ports(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ports"] = value

def interface_modport(sym_name, ports, *, loc=None, ip=None) -> InterfaceModportOp:
  return InterfaceModportOp(sym_name=sym_name, ports=ports, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InterfaceOp(_ods_ir.OpView):
  r"""
  This operation defines a named interface. Its name is a symbol that can
  be looked up when declared inside a SymbolTable operation. This operation is
  also a SymbolTable itself, so the symbols in its region can be looked up.
  
  Example:
  
  ```mlir
  sv.interface @myinterface {
    sv.interface.signal @data : i32
    sv.interface.modport @input_port (input @data)
    sv.interface.modport @output_port (output @data)
  }
  ```
  """

  OPERATION_NAME = "sv.interface"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, comment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if comment is not None: attributes["comment"] = (comment if (
        isinstance(comment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(comment, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def comment(self) -> _Optional[_ods_ir.StringAttr]:
    if "comment" not in self.operation.attributes:
      return None
    return self.operation.attributes["comment"]

  @comment.setter
  def comment(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["comment"] = value
    elif "comment" in self.operation.attributes:
      del self.operation.attributes["comment"]

  @comment.deleter
  def comment(self):
    del self.operation.attributes["comment"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def interface(sym_name, *, comment=None, loc=None, ip=None) -> InterfaceOp:
  return InterfaceOp(sym_name=sym_name, comment=comment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InterfaceSignalOp(_ods_ir.OpView):
  r"""
  This operation defines a named signal within an interface. Its type is
  specified in an attribute, and currently supports IntegerTypes.
  
  Example:
  
  ```mlir
  sv.interface.signal @data : i32
  ```
  """

  OPERATION_NAME = "sv.interface.signal"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SignalTypeAttr')) else
      _ods_ir.AttrBuilder.get('SignalTypeAttr')(type_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

def interface_signal(sym_name, type_, *, loc=None, ip=None) -> InterfaceSignalOp:
  return InterfaceSignalOp(sym_name=sym_name, type_=type_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LocalParamOp(_ods_ir.OpView):
  r"""
  The localparam operation produces a `localparam` declaration. See SV spec
  6.20.4 p125.
  """

  OPERATION_NAME = "sv.localparam"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, name, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if results is None:
      _ods_result_type_source_attr = attributes["value"]
      _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
      results = [_ods_derived_result_type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def localparam(value, name, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LocalParamOp(value=value, name=name, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicOp(_ods_ir.OpView):
  r"""
  Declare a SystemVerilog Variable Declaration of 'logic' type.
  See SV Spec 6.8, pp100.
  """

  OPERATION_NAME = "sv.logic"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, *, inner_sym=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def logic(result, name, *, inner_sym=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicOp(result=result, name=name, inner_sym=inner_sym, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MacroDeclOp(_ods_ir.OpView):
  r"""
  The `sv.macro.def` declares a macro in System Verilog.  This is a
  declaration; the body of the macro, which produces a verilog macro
  definition is created with a `macro.def` operation.
  
  Lacking args will be a macro without "()".  An empty args will be an empty "()".
  
  The verilog name is the spelling of the macro when emitting verilog.
  """

  OPERATION_NAME = "sv.macro.decl"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, *, args=None, verilogName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if args is not None: attributes["args"] = (args if (
        isinstance(args, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(args, context=_ods_context))
    if verilogName is not None: attributes["verilogName"] = (verilogName if (
        isinstance(verilogName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verilogName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def args(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "args" not in self.operation.attributes:
      return None
    return self.operation.attributes["args"]

  @args.setter
  def args(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["args"] = value
    elif "args" in self.operation.attributes:
      del self.operation.attributes["args"]

  @args.deleter
  def args(self):
    del self.operation.attributes["args"]

  @builtins.property
  def verilogName(self) -> _Optional[_ods_ir.StringAttr]:
    if "verilogName" not in self.operation.attributes:
      return None
    return self.operation.attributes["verilogName"]

  @verilogName.setter
  def verilogName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["verilogName"] = value
    elif "verilogName" in self.operation.attributes:
      del self.operation.attributes["verilogName"]

  @verilogName.deleter
  def verilogName(self):
    del self.operation.attributes["verilogName"]

def macro_decl(sym_name, *, args=None, verilog_name=None, loc=None, ip=None) -> MacroDeclOp:
  return MacroDeclOp(sym_name=sym_name, args=args, verilogName=verilog_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MacroDefOp(_ods_ir.OpView):
  r"""
  The `sv.macro.def` defines a macro in System Verilog which optionally takes
  a body.
  
  This is modeled similarly to verbatim in that the contents of the macro are
  opaque (plain string).  Given the general power of macros, this op does not
  try to capture a return type.
  
  This operation produces a definition for the macro declaration referenced by
  `sym_name`.  Argument lists are picked up from that operation.
  
  sv.macro.def allows operand substitutions with {{0}} syntax.
  """

  OPERATION_NAME = "sv.macro.def"

  _ODS_REGIONS = (0, True)

  def __init__(self, macroName, format_string, *, symbols=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["macroName"] = (macroName if (
    isinstance(macroName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(macroName, context=_ods_context))
    attributes["format_string"] = (format_string if (
    isinstance(format_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format_string, context=_ods_context))
    if symbols is not None: attributes["symbols"] = (symbols if (
        isinstance(symbols, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('NameRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('NameRefArrayAttr')(symbols, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def macroName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["macroName"]

  @macroName.setter
  def macroName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["macroName"] = value

  @builtins.property
  def format_string(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format_string"]

  @format_string.setter
  def format_string(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format_string"] = value

  @builtins.property
  def symbols(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["symbols"]

  @symbols.setter
  def symbols(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbols"] = value

def macro_def(macro_name, format_string, *, symbols=None, loc=None, ip=None) -> MacroDefOp:
  return MacroDefOp(macroName=macro_name, format_string=format_string, symbols=symbols, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MacroErrorOp(_ods_ir.OpView):
  r"""
  The `sv.macro.error` op represents a static error in System Verilog. Since
  System Verilog lacks an error preprocessor directive, this is emitted as a
  reference to an undefined macro definition.
  
  We reserve the macro prefix _ERROR for emitting static assertions.
  """

  OPERATION_NAME = "sv.macro.error"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def macro_error(*, message=None, loc=None, ip=None) -> MacroErrorOp:
  return MacroErrorOp(message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MacroRefExprOp(_ods_ir.OpView):
  r"""
  This operation produces a value by referencing a named macro.
  
  Presently, it is assumed that the referenced macro is a constant with no
  side effects.  This expression is subject to CSE.  It can be duplicated
  and emitted inline by the Verilog emitter.
  """

  OPERATION_NAME = "sv.macro.ref.expr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, macroName, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["macroName"] = (macroName if (
    isinstance(macroName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(macroName, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def macroName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["macroName"]

  @macroName.setter
  def macroName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["macroName"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def macro_ref_expr(result, macro_name, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MacroRefExprOp(result=result, macroName=macro_name, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MacroRefExprSEOp(_ods_ir.OpView):
  r"""
  This operation produces a value by referencing a named macro.
  
  Presently, it is assumed that the referenced macro is not constant and has
  side effects.  This expression is not subject to CSE.  It can not be
  duplicated, but can be emitted inline by the Verilog emitter.
  """

  OPERATION_NAME = "sv.macro.ref.expr.se"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, macroName, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["macroName"] = (macroName if (
    isinstance(macroName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(macroName, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def macroName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["macroName"]

  @macroName.setter
  def macroName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["macroName"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def macro_ref_expr_se(result, macro_name, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MacroRefExprSEOp(result=result, macroName=macro_name, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MacroRefOp(_ods_ir.OpView):
  r"""
  This operation represent a statement by referencing a named macro.
  """

  OPERATION_NAME = "sv.macro.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, macroName, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["macroName"] = (macroName if (
    isinstance(macroName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(macroName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def macroName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["macroName"]

  @macroName.setter
  def macroName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["macroName"] = value

def macro_ref(macro_name, inputs, *, loc=None, ip=None) -> MacroRefOp:
  return MacroRefOp(macroName=macro_name, inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class OrderedOutputOp(_ods_ir.OpView):
  r"""
  This operation groups operations into a region whose purpose is to force
  verilog emission to be statement-by-statement, in-order.  This allows
  side-effecting operations, or macro expansions which applie to subsequent
  operations to be properly sequenced.
  This operation is for non-procedural regions and its body is non-procedural.
  """

  OPERATION_NAME = "sv.ordered"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def ordered(*, loc=None, ip=None) -> OrderedOutputOp:
  return OrderedOutputOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PAssignOp(_ods_ir.OpView):
  r"""
  A SystemVerilog nonblocking procedural assignment statement 'x <= y;'.
  These occur in initial, always, task, and function blocks.  The statement
  can be scheduled without blocking procedural flow.  See SV Spec 10.4.2.
  """

  OPERATION_NAME = "sv.passign"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, src, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    operands.append(src)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def src(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def passign(dest, src, *, loc=None, ip=None) -> PAssignOp:
  return PAssignOp(dest=dest, src=src, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReadInOutOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.read_inout"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def read_inout(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadInOutOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReadInterfaceSignalOp(_ods_ir.OpView):
  r"""
  This is an expression to access a signal inside of an interface.
  
  ```
    %ifaceData = sv.interface.signal.read %iface
        (@handshake_example::@data) : i32
  ```
  
  Could result in the following SystemVerilog:
  ```
    wire [31:0] ifaceData = iface.data;
  ```
  """

  OPERATION_NAME = "sv.interface.signal.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, signalData, iface, signalName, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(iface)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["signalName"] = (signalName if (
    isinstance(signalName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(signalName, context=_ods_context))
    results = []
    results.append(signalData)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def iface(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def signalName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["signalName"]

  @signalName.setter
  def signalName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["signalName"] = value

  @builtins.property
  def signalData(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def interface_signal_read(signal_data, iface, signal_name, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReadInterfaceSignalOp(signalData=signal_data, iface=iface, signalName=signal_name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReadMemOp(_ods_ir.OpView):
  r"""
  Load a memory from a file using either `$readmemh` or `$readmemb` based on
  an attribute.
  
  See Section 21.4 of IEEE 1800-2017 for more information.
  """

  OPERATION_NAME = "sv.readmem"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, filename, base, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["filename"] = (filename if (
    isinstance(filename, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(filename, context=_ods_context))
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MemBaseTypeAttr')) else
      _ods_ir.AttrBuilder.get('MemBaseTypeAttr')(base, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def filename(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["filename"]

  @filename.setter
  def filename(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["filename"] = value

  @builtins.property
  def base(self) -> _ods_ir.Attribute:
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

def readmem(dest, filename, base, *, loc=None, ip=None) -> ReadMemOp:
  return ReadMemOp(dest=dest, filename=filename, base=base, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RegOp(_ods_ir.OpView):
  r"""
  Declare a SystemVerilog Variable Declaration of 'reg' type.
  See SV Spec 6.8, pp100.
  """

  OPERATION_NAME = "sv.reg"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, *, init=None, inner_sym=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if init is not None: operands.append(init)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def init(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reg(result, name, *, init=None, inner_sym=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RegOp(result=result, name=name, init=init, inner_sym=inner_sym, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReleaseOp(_ods_ir.OpView):
  r"""
  Release is used in conjunction with force. When released,
  then if the variable does not currently have an active assign
  procedural continuous assignment, the variable shall not immediately
  change value. The variable shall maintain its current value until
  the next procedural assignment or procedural continuous assignment
  to the variable. Releasing a variable that currently has an
  active assign procedural continuous assignment shall immediately
  reestablish that assignment. See SV Spec 10.6.2.
  """

  OPERATION_NAME = "sv.release"

  _ODS_REGIONS = (0, True)

  def __init__(self, dest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(dest)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dest(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def release(dest, *, loc=None, ip=None) -> ReleaseOp:
  return ReleaseOp(dest=dest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReserveNamesOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.reserve_names"

  _ODS_REGIONS = (0, True)

  def __init__(self, reservedNames, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reservedNames"] = (reservedNames if (
    isinstance(reservedNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(reservedNames, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def reservedNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["reservedNames"]

  @reservedNames.setter
  def reservedNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reservedNames"] = value

def reserve_names(reserved_names, *, loc=None, ip=None) -> ReserveNamesOp:
  return ReserveNamesOp(reservedNames=reserved_names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SFormatFOp(_ods_ir.OpView):
  r"""
  This operations represents `$sformatf` task that produces a string from
  a format string and substitutions.
  
  See section 21.3.3 of 1800-2023 for more details.
  """

  OPERATION_NAME = "sv.sformatf"

  _ODS_REGIONS = (0, True)

  def __init__(self, format_string, substitutions, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format_string"] = (format_string if (
    isinstance(format_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format_string, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def format_string(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format_string"]

  @format_string.setter
  def format_string(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format_string"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def sformatf(format_string, substitutions, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SFormatFOp(format_string=format_string, substitutions=substitutions, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class STimeOp(_ods_ir.OpView):
  r"""
  Return a 32-bit integer value representing the time at which the function
  was called.
  """

  OPERATION_NAME = "sv.system.stime"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def system_stime(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return STimeOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SampledOp(_ods_ir.OpView):
  r"""
  Sample a value using System Verilog sampling semantics (see Section 16.5.1
  of the SV 2017 specification for more information).
  
  A use of `$sampled` is to safely read the value of a net/variable in a
  concurrent assertion action block such that the value will be the same as
  the value used when the assertion is triggered.  See Section 16.9.3 of the
  SV 2017 specification for more information.
  """

  OPERATION_NAME = "sv.system.sampled"

  _ODS_REGIONS = (0, True)

  def __init__(self, expression, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(expression)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def expression(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def sampledValue(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def system_sampled(expression, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SampledOp(expression=expression, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StopOp(_ods_ir.OpView):
  r"""
  Causes the simulation to be suspended. Does not terminate the simulator.
  
  The optional `verbosity` parameter controls how much diagnostic information
  is printed when the system task is executed (see section 20.2 of IEEE
  1800-2017):
  
  - `0`: Prints nothing
  - `1`: Prints simulation time and location (default)
  - `2`: Prints simulation time, location, and statistics about the memory and
    CPU time used in simulation
  """

  OPERATION_NAME = "sv.stop"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, verbosity=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if verbosity is not None: attributes["verbosity"] = (verbosity if (
        isinstance(verbosity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('VerbosityIntAttr')) else
          _ods_ir.AttrBuilder.get('VerbosityIntAttr')(verbosity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def verbosity(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["verbosity"]

  @verbosity.setter
  def verbosity(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbosity"] = value

def stop(*, verbosity=None, loc=None, ip=None) -> StopOp:
  return StopOp(verbosity=verbosity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class StructFieldInOutOp(_ods_ir.OpView):
  r"""
  See SV Spec 7.2.
  """

  OPERATION_NAME = "sv.struct_field_inout"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, field, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["field"] = (field if (
    isinstance(field, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(field, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def field(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["field"]

  @field.setter
  def field(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["field"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def struct_field_inout(input, field, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StructFieldInOutOp(input=input, field=field, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SystemFunctionOp(_ods_ir.OpView):
  r"""
  This operation calls the indicated system verilog system function.  This
  supports functions which take normal expression arguments.
  
  See section 20 of the 2012 SV spec.
  """

  OPERATION_NAME = "sv.system"

  _ODS_REGIONS = (0, True)

  def __init__(self, out, fnName, args, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fnName"] = (fnName if (
    isinstance(fnName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(fnName, context=_ods_context))
    results = []
    results.append(out)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def fnName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["fnName"]

  @fnName.setter
  def fnName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fnName"] = value

  @builtins.property
  def out(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def system(out, fn_name, args, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SystemFunctionOp(out=out, fnName=fn_name, args=args, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TimeOp(_ods_ir.OpView):
  r"""
  Return a 64-bit integer value representing the time at which the function
  was called.
  """

  OPERATION_NAME = "sv.system.time"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def system_time(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return TimeOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnpackedArrayCreateOp(_ods_ir.OpView):
  r"""
  Creates an unpacked array from a variable set of values. One or more values must be
  listed.
  
  See the HW-SV rationale document for details on operand ordering.
  """

  OPERATION_NAME = "sv.unpacked_array_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def unpacked_array_create(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnpackedArrayCreateOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnpackedOpenArrayCastOp(_ods_ir.OpView):
  OPERATION_NAME = "sv.unpacked_open_array_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def unpacked_open_array_cast(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnpackedOpenArrayCastOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VerbatimExprOp(_ods_ir.OpView):
  r"""
  This operation produces a typed value expressed by a string of
  SystemVerilog.  This can be used to access macros and other values that are
  only sensible as Verilog text.
  
  The text string is expected to have the highest precedence, so you should
  include parentheses in the string if it isn't a single token.  This is also
  assumed to not have side effects (use sv.verbatim.expr.se) if you need them.
  
  sv.verbatim.expr allows operand substitutions with {{0}} syntax.
  """

  OPERATION_NAME = "sv.verbatim.expr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, format_string, substitutions, *, symbols=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format_string"] = (format_string if (
    isinstance(format_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format_string, context=_ods_context))
    if symbols is not None: attributes["symbols"] = (symbols if (
        isinstance(symbols, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('NameRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('NameRefArrayAttr')(symbols, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def format_string(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format_string"]

  @format_string.setter
  def format_string(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format_string"] = value

  @builtins.property
  def symbols(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["symbols"]

  @symbols.setter
  def symbols(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbols"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def verbatim_expr(result, format_string, substitutions, *, symbols=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return VerbatimExprOp(result=result, format_string=format_string, substitutions=substitutions, symbols=symbols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VerbatimExprSEOp(_ods_ir.OpView):
  r"""
  This operation produces a typed value expressed by a string of
  SystemVerilog.  This can be used to access macros and other values that are
  only sensible as Verilog text.
  
  The text string is expected to have the highest precedence, so you should
  include parentheses in the string if it isn't a single token.  This is
  allowed to have side effects.
  
  sv.verbatim.se.expr allows operand substitutions with {{0}} syntax.
  """

  OPERATION_NAME = "sv.verbatim.expr.se"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, format_string, substitutions, *, symbols=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format_string"] = (format_string if (
    isinstance(format_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format_string, context=_ods_context))
    if symbols is not None: attributes["symbols"] = (symbols if (
        isinstance(symbols, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('NameRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('NameRefArrayAttr')(symbols, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def format_string(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format_string"]

  @format_string.setter
  def format_string(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format_string"] = value

  @builtins.property
  def symbols(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["symbols"]

  @symbols.setter
  def symbols(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbols"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def verbatim_expr_se(result, format_string, substitutions, *, symbols=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return VerbatimExprSEOp(result=result, format_string=format_string, substitutions=substitutions, symbols=symbols, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VerbatimOp(_ods_ir.OpView):
  r"""
  This operation produces opaque text inline in the SystemVerilog output.
  
  sv.verbatim allows operand substitutions with {{0}} syntax.
  """

  OPERATION_NAME = "sv.verbatim"

  _ODS_REGIONS = (0, True)

  def __init__(self, format_string, substitutions, *, symbols=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format_string"] = (format_string if (
    isinstance(format_string, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format_string, context=_ods_context))
    if symbols is not None: attributes["symbols"] = (symbols if (
        isinstance(symbols, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('NameRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('NameRefArrayAttr')(symbols, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def format_string(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["format_string"]

  @format_string.setter
  def format_string(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format_string"] = value

  @builtins.property
  def symbols(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["symbols"]

  @symbols.setter
  def symbols(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["symbols"] = value

def verbatim(format_string, substitutions, *, symbols=None, loc=None, ip=None) -> VerbatimOp:
  return VerbatimOp(format_string=format_string, substitutions=substitutions, symbols=symbols, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WarningOp(_ods_ir.OpView):
  r"""
  This system task indicates a run-time warning.
  
  If present, the optional message is printed with any additional operands
  interpolated into the message string.
  """

  OPERATION_NAME = "sv.warning"

  _ODS_REGIONS = (0, True)

  def __init__(self, substitutions, *, message=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(substitutions))
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def substitutions(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def message(self) -> _Optional[_ods_ir.StringAttr]:
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def warning(substitutions, *, message=None, loc=None, ip=None) -> WarningOp:
  return WarningOp(substitutions=substitutions, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class WireOp(_ods_ir.OpView):
  r"""
  Declare a SystemVerilog Net Declaration of 'wire' type.
   See SV Spec 6.7, pp97.
  """

  OPERATION_NAME = "sv.wire"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, name, *, inner_sym=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    isinstance(name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wire(result, name, *, inner_sym=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return WireOp(result=result, name=name, inner_sym=inner_sym, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XMROp(_ods_ir.OpView):
  r"""
  This represents a non-local hierarchical name to a net, sometimes called a
  cross-module reference.  A hierarchical name may be absolute, when prefixed
  with '$root', in which case it is resolved from the set of top-level modules
  (any non-instantiated modules).  Non-absolute paths are resolved by
  attempting resolution of the path locally, then recursively up the instance
  graph. See SV Spec 23.6, pp721.
  
  It is impossible to completely resolve a hierarchical name without making a
  closed-world assumption in the compiler.  We therefore don't try to link
  hierarchical names to what they resolve to at compile time.  A frontend
  generating this op should ensure that any instance or object in the intended
  path has public visibility so paths are not invalidated.
  """

  OPERATION_NAME = "sv.xmr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, path, terminal, *, isRooted=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(isRooted): attributes["isRooted"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    attributes["path"] = (path if (
    isinstance(path, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(path, context=_ods_context))
    attributes["terminal"] = (terminal if (
    isinstance(terminal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(terminal, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def isRooted(self) -> bool:
    return "isRooted" in self.operation.attributes

  @isRooted.setter
  def isRooted(self, value):
    if bool(value):
      self.operation.attributes["isRooted"] = _ods_ir.UnitAttr.get()
    elif "isRooted" in self.operation.attributes:
      del self.operation.attributes["isRooted"]

  @isRooted.deleter
  def isRooted(self):
    del self.operation.attributes["isRooted"]

  @builtins.property
  def path(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["path"]

  @path.setter
  def path(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["path"] = value

  @builtins.property
  def terminal(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["terminal"]

  @terminal.setter
  def terminal(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["terminal"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def xmr(result, path, terminal, *, is_rooted=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XMROp(result=result, path=path, terminal=terminal, isRooted=is_rooted, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class XMRRefOp(_ods_ir.OpView):
  r"""
  This represents a hierarchical path, but using something which the compiler
  can understand.  In contrast to the XMROp (which models pure Verilog
  hierarchical paths which may not map to anything knowable in the circuit),
  this op uses a `hw.hierpath` to refer to something which exists in the
  circuit.
  
  Generally, this operation is always preferred for situations where
  hierarchical paths cannot be known statically and may change.
  
  `verbatimSuffix` should only be populated when the final operation on the
  path is an instance of an external module.
  """

  OPERATION_NAME = "sv.xmr.ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, ref, *, verbatimSuffix=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ref"] = (ref if (
    isinstance(ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(ref, context=_ods_context))
    if verbatimSuffix is not None: attributes["verbatimSuffix"] = (verbatimSuffix if (
        isinstance(verbatimSuffix, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verbatimSuffix, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ref(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["ref"]

  @ref.setter
  def ref(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ref"] = value

  @builtins.property
  def verbatimSuffix(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["verbatimSuffix"]

  @verbatimSuffix.setter
  def verbatimSuffix(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["verbatimSuffix"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def xmr_ref(result, ref, *, verbatim_suffix=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return XMRRefOp(result=result, ref=ref, verbatimSuffix=verbatim_suffix, loc=loc, ip=ip).result
