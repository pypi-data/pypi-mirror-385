
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "ltl"

@_ods_cext.register_operation(_Dialect)
class AndOp(_ods_ir.OpView):
  r"""
  If any of the `$inputs` is of type `!ltl.property`, the result of the op is
  an `!ltl.property`. Otherwise it is an `!ltl.sequence`.
  """

  OPERATION_NAME = "ltl.and"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def and_(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AndOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ClockOp(_ods_ir.OpView):
  r"""
  Specifies the `$edge` on a given `$clock` to be the clock for an `$input`
  property or sequence. All cycle delays in the `$input` implicitly refer to a
  clock that advances the state to the next cycle. The `ltl.clock` operation
  provides that clock. The clock applies to the entire property or sequence
  expression tree below `$input`, up to any other nested `ltl.clock`
  operations.
  
  The operation returns a property if the `$input` is a property, and a
  sequence otherwise.
  """

  OPERATION_NAME = "ltl.clock"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, edge, clock, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(clock)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["edge"] = (edge if (
    isinstance(edge, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ClockEdgeAttr')) else
      _ods_ir.AttrBuilder.get('ClockEdgeAttr')(edge, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def clock(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def edge(self) -> _ods_ir.Attribute:
    return self.operation.attributes["edge"]

  @edge.setter
  def edge(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["edge"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def clock(input, edge, clock, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ClockOp(input=input, edge=edge, clock=clock, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConcatOp(_ods_ir.OpView):
  r"""
  Concatenates all of the `$inputs` sequences one after another into one
  longer sequence. The sequences are arranged such that the end time of the
  previous sequences coincides with the start time of the next sequence. This
  means there is no implicit cycle of delay between the concatenated
  sequences, which may be counterintuitive.
  
  If a sequence should follow in the cycle after another sequence finishes,
  that cycle of delay needs to be explicit. For example, *"u followed by v in
  next cycle"* (`u ##1 v` in SVA) is represented as
  `concat(u, delay(v, 1, 0))`:
  ```
  %0 = ltl.delay %v, 1, 0 : i1
  ltl.concat %u, %v : !ltl.sequence, !ltl.sequence
  ```
  The resulting sequence checks for `u` in the first cycle and `v` in the
  second, `[u, v]` in short.
  
  Without this explicit delay, the previous sequence's end overlaps with the
  next sequence's start. For example, consider the two sequences `u = a ##1 b`
  and `v = c ##1 d`, which check for `a` and `c` in the first, and `b` and `d`
  in the second cycle. When these two sequences are concatenated,
  `concat(u, v)`, the end time of the first sequence coincides with the start
  time of the second. As a result, the check for `b` at the end of the first
  sequence will coincide with the check for `c` at the start of the second
  sequence: `concat(u, v) = a ##1 (b && c) ##1 d`. The resulting sequence
  checks for `a` in the first cycle, `b` and `c` in the second, and `d` in the
  third, `[a, (b && c), d]` in short.
  
  By making the delay between concatenated sequences explicit, the `concat`
  operation behaves nicely in the presence of zero-length sequences. An empty,
  zero-length sequence in a concatenation behaves as if the sequence wasn't
  present at all. Compare this to SVAs which struggle with empty sequences.
  For example, `x ##1 y ##1 z` would become `x ##2 z` if `y` was empty.
  Similarly, expressing zero or more repetitions of a sequence, `w ##[*]`, is
  challenging in SVA since concatenation always implies a cycle of delay, but
  trivial if the delay is made explicit. This is related to the handling of
  empty rules in a parser's grammar.
  
  Note that concatenating two boolean values *a* and *b* is equivalent to
  computing the logical AND of them. Booleans are sequences that check if the
  boolean is true in the current cycle, which means that the sequence starts
  and ends in the same cycle. Since concatenation aligns the sequences such
  that end time of *a* and start time of *b* coincide, the resulting sequence
  checks if *a* and *b* both are true in the current cycle, which is an AND
  operation.
  """

  OPERATION_NAME = "ltl.concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def concat(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConcatOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DelayOp(_ods_ir.OpView):
  r"""
  Delays the `$input` sequence by the number of cycles specified by `$delay`.
  The delay must be greater than or equal to zero. The optional `$length`
  specifies during how many cycles after the initial delay the sequence can
  match. Omitting `$length` indicates an unbounded but finite delay. For
  example:
  
  - `ltl.delay %seq, 2, 0` delays `%seq` by exactly 2 cycles. The resulting
    sequence matches if `%seq` matches exactly 2 cycles in the future.
  - `ltl.delay %seq, 2, 2` delays `%seq` by 2, 3, or 4 cycles. The resulting
    sequence matches if `%seq` matches 2, 3, or 4 cycles in the future.
  - `ltl.delay %seq, 2` delays `%seq` by 2 or more cycles. The number of
    cycles is unbounded but finite, which means that `%seq` *has* to match at
    some point, instead of effectively never occuring by being delayed an
    infinite number of cycles.
  - `ltl.delay %seq, 0, 0` is equivalent to just `%seq`.
  
  #### Clocking
  
  The cycle delay specified on the operation refers to a clocking event. This
  event is not directly specified by the delay operation itself. Instead, the
  [`ltl.clock`](#ltlclock-circtltlclockop) operation can be used to associate
  all delays within a sequence with a clock.
  """

  OPERATION_NAME = "ltl.delay"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, delay, *, length=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["delay"] = (delay if (
    isinstance(delay, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(delay, context=_ods_context))
    if length is not None: attributes["length"] = (length if (
        isinstance(length, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(length, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def delay(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["delay"]

  @delay.setter
  def delay(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delay"] = value

  @builtins.property
  def length(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "length" not in self.operation.attributes:
      return None
    return self.operation.attributes["length"]

  @length.setter
  def length(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["length"] = value
    elif "length" in self.operation.attributes:
      del self.operation.attributes["length"]

  @length.deleter
  def length(self):
    del self.operation.attributes["length"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def delay(input, delay, *, length=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DelayOp(input=input, delay=delay, length=length, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EventuallyOp(_ods_ir.OpView):
  r"""
  Checks that the `$input` property will hold at a future time. This operator
  is strong: it requires that the `$input` holds after a *finite* number of
  cycles. The operator does *not* hold if the `$input` can't hold in the
  future.
  """

  OPERATION_NAME = "ltl.eventually"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def eventually(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EventuallyOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GoToRepeatOp(_ods_ir.OpView):
  r"""
  Non-consecutive repetition of the `$input` sequence. This must hold between `$base` 
  and `$base + $more` times in a finite number of evaluations. The final evaluation 
  in the sequence has to match. The `$base` must be greater than or equal to zero 
  and the range `$more` can't be omitted. For example, a !b b b !b !b b c represents 
  a matching observation of `ltl.goto_repeat %b, 1, 2`, but a !b b b !b !b b !b c doesn't.
  """

  OPERATION_NAME = "ltl.goto_repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, more, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    attributes["more"] = (more if (
    isinstance(more, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(more, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def base(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def more(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["more"]

  @more.setter
  def more(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["more"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def goto_repeat(input, base, more, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GoToRepeatOp(input=input, base=base, more=more, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImplicationOp(_ods_ir.OpView):
  r"""
  Preconditions the checking of the `$consequent` property on the
  `$antecedent` sequence. In a nutshell, if the `$antecedent` sequence matches
  at a given point in time, the `$consequent` property is checked starting at
  the point in time at which the matched sequence ends. The result property of
  the `ltl.implication` holds if the `$consequent` holds. Conversely, if the
  `$antecedent` does *not* match at a given point in time, the result property
  trivially holds. This is conceptually identical to the implication operator
  →, but with additional temporal semantics.
  """

  OPERATION_NAME = "ltl.implication"

  _ODS_REGIONS = (0, True)

  def __init__(self, antecedent, consequent, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(antecedent)
    operands.append(consequent)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def antecedent(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def consequent(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def implication(antecedent, consequent, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImplicationOp(antecedent=antecedent, consequent=consequent, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IntersectOp(_ods_ir.OpView):
  r"""
  The intersection of two properties. This checks that both properties both hold 
  and have the same start and end times. This differs from `ltl.and` which doesn't 
  consider the timings of each operand, only their results. 
  """

  OPERATION_NAME = "ltl.intersect"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def intersect(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IntersectOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NonConsecutiveRepeatOp(_ods_ir.OpView):
  r"""
  Non-consecutive repetition of the `$input` sequence. This must hold between `$base` 
  and `$base + $more` times in a finite number of evaluations. The final evaluation 
  in the sequence does not have to match. The `$base` must be greater than or equal to zero 
  and the range `$more` can't be omitted. For example, both a !b b b !b !b b c and 
  a !b b b !b !b b !b c represent matching observations of 
  `ltl.non_consecutive_repeat %b, 1, 2`.
  """

  OPERATION_NAME = "ltl.non_consecutive_repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, more, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    attributes["more"] = (more if (
    isinstance(more, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(more, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def base(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def more(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["more"]

  @more.setter
  def more(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["more"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def non_consecutive_repeat(input, base, more, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NonConsecutiveRepeatOp(input=input, base=base, more=more, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  r"""
  Negates the `$input` property. The resulting property evaluates to true if
  `$input` evaluates to false, and it evaluates to false if `$input` evaluates
  to true.
  """

  OPERATION_NAME = "ltl.not"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def not_(input, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotOp(input=input, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrOp(_ods_ir.OpView):
  r"""
  If any of the `$inputs` is of type `!ltl.property`, the result of the op is
  an `!ltl.property`. Otherwise it is an `!ltl.sequence`.
  """

  OPERATION_NAME = "ltl.or"

  _ODS_REGIONS = (0, True)

  def __init__(self, inputs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def or_(inputs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrOp(inputs=inputs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PastOp(_ods_ir.OpView):
  r"""
  Semantically works like `ltl.delay %seq, -$delay, 0`
  """

  OPERATION_NAME = "ltl.past"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, delay, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["delay"] = (delay if (
    isinstance(delay, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(delay, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def delay(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["delay"]

  @delay.setter
  def delay(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delay"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def past(input, delay, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PastOp(input=input, delay=delay, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RepeatOp(_ods_ir.OpView):
  r"""
  Repeat the `$input` sequence at least `$base` times, at most `$base` +
  `$more` times. The number must be greater than or equal to zero. Omitting
  `$more` indicates an unbounded but finite repetition. For example:
  
  - `ltl.repeat %seq, 2, 0` repeats `%seq` exactly 2 times.
  - `ltl.repeat %seq, 2, 2` repeats `%seq` 2, 3, or 4 times.
  - `ltl.repeat %seq, 2` repeats `%seq` 2 or more times. The number of times
    is unbounded but finite.
  - `ltl.repeat %seq, 0, 0` represents an empty sequence.
  """

  OPERATION_NAME = "ltl.repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, base, *, more=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    isinstance(base, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    if more is not None: attributes["more"] = (more if (
        isinstance(more, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(more, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def base(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def more(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "more" not in self.operation.attributes:
      return None
    return self.operation.attributes["more"]

  @more.setter
  def more(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["more"] = value
    elif "more" in self.operation.attributes:
      del self.operation.attributes["more"]

  @more.deleter
  def more(self):
    del self.operation.attributes["more"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def repeat(input, base, *, more=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RepeatOp(input=input, base=base, more=more, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UntilOp(_ods_ir.OpView):
  r"""
  Checks that the `$input` property always holds until the `$condition`
  property holds once. This operator is weak: the property will hold even if
  `$input` always holds and `$condition` never holds. This operator is
  nonoverlapping: `$input` does not have to hold when `$condition` holds.
  """

  OPERATION_NAME = "ltl.until"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, condition, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def condition(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def until(input, condition, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UntilOp(input=input, condition=condition, results=results, loc=loc, ip=ip).result
