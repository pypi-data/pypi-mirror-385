
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "hw"

@_ods_cext.register_operation(_Dialect)
class AggregateConstantOp(_ods_ir.OpView):
  r"""
  This operation produces a constant value of an aggregate type. Clock and
  reset values are supported. For nested aggregates, embedded arrays are
  used.
  
  Examples:
  ```mlir
    %result = hw.aggregate_constant [1 : i1, 2 : i2, 3 : i2] : !hw.struct<a: i8, b: i8, c: i8>
    %result = hw.aggregate_constant [1 : i1, [2 : i2, 3 : i2]] : !hw.struct<a: i8, b: vector<i8, 2>>
  ```
  """

  OPERATION_NAME = "hw.aggregate_constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, fields, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fields"] = (fields if (
    isinstance(fields, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(fields, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fields(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["fields"]

  @fields.setter
  def fields(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fields"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def aggregate_constant(result, fields, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AggregateConstantOp(result=result, fields=fields, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayConcatOp(_ods_ir.OpView):
  r"""
  Creates an array by concatenating a variable set of arrays. One or more
  values must be listed.
  
  ```
  // %a, %b, %c are hw arrays of i4 with sizes 2, 5, and 4 respectively.
  %array = hw.array_concat %a, %b, %c : (2, 5, 4 x i4)
  // %array is !hw.array<11 x i4>
  ```
  
  See the HW-SV rationale document for details on operand ordering.
  """

  OPERATION_NAME = "hw.array_concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_concat(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayConcatOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayCreateOp(_ods_ir.OpView):
  r"""
  Creates an array from a variable set of values. One or more values must be
  listed.
  
  ```
  // %a, %b, %c are all i4
  %array = hw.array_create %a, %b, %c : i4
  ```
  
  See the HW-SV rationale document for details on operand ordering.
  """

  OPERATION_NAME = "hw.array_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_create(result, inputs, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayCreateOp(result=result, inputs=inputs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayGetOp(_ods_ir.OpView):
  r"""
  Extracts the element at `index` from the given `input` array. The index must
  be exactly `ceil(log2(length(input)))` bits wide.
  """

  OPERATION_NAME = "hw.array_get"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_get(input, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayGetOp(input=input, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArrayInjectOp(_ods_ir.OpView):
  r"""
  Takes an `input` array, changes the element at `index` to the given
  `element` value, and returns the updated array value as a result. The index
  must be exactly `ceil(log2(length(input)))` bits wide. The element type
  must match the input array's element type.
  
  If the `index` is out of bounds, the result is undefined.
  """

  OPERATION_NAME = "hw.array_inject"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, index, element, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(index)
    operands.append(element)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def element(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_inject(input, index, element, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArrayInjectOp(input=input, index=index, element=element, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ArraySliceOp(_ods_ir.OpView):
  r"""
  Extracts a sub-range from an array. The range is from `lowIndex` to
  `lowIndex` + the number of elements in the return type, non-inclusive on
  the high end. For instance,
  
  ```
  // Slices 16 elements starting at '%offset'.
  %subArray = hw.slice %largerArray at %offset :
      (!hw.array<1024xi8>) -> !hw.array<16xi8>
  ```
  
  Width of 'idx' is defined to be the precise number of bits required to
  index the 'input' array. More precisely: for an input array of size M,
  the width of 'idx' is ceil(log2(M)). Lower and upper bound indexes which
  are larger than the size of the 'input' array results in undefined
  behavior.
  """

  OPERATION_NAME = "hw.array_slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, dst, input, lowIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(lowIndex)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(dst)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def lowIndex(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dst(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def array_slice(dst, input, low_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ArraySliceOp(dst=dst, input=input, lowIndex=low_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastOp(_ods_ir.OpView):
  OPERATION_NAME = "hw.bitcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bitcast(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  The constant operation produces a constant value of standard integer type
  without a sign.
  ```
    %result = hw.constant 42 : t1
  ```
  """

  OPERATION_NAME = "hw.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('APIntAttr')) else
      _ods_ir.AttrBuilder.get('APIntAttr')(value, context=_ods_context))
    if results is None:
      _ods_result_type_source_attr = attributes["value"]
      _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
      results = [_ods_derived_result_type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def constant(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EnumCmpOp(_ods_ir.OpView):
  r"""
  This operation compares two values with the same canonical enumeration
  type, returning 0 if they are different, and 1 if they are the same.
  
  Example:
  ```mlir
    %enumcmp = hw.enum.cmp %A, %B : !hw.enum<A, B, C>, !hw.enum<A, B, C>
  ```
  """

  OPERATION_NAME = "hw.enum.cmp"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def enum_cmp(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EnumCmpOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EnumConstantOp(_ods_ir.OpView):
  r"""
  The enum.constant operation produces an enumeration value of the specified
  enum value attribute.
  ```
    %0 = hw.enum.constant A : !hw.enum<A, B, C>
  ```
  """

  OPERATION_NAME = "hw.enum.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, field, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["field"] = (field if (
    isinstance(field, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EnumFieldAttr')) else
      _ods_ir.AttrBuilder.get('EnumFieldAttr')(field, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def field(self) -> _ods_ir.Attribute:
    return self.operation.attributes["field"]

  @field.setter
  def field(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["field"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def enum_constant(result, field, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return EnumConstantOp(result=result, field=field, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class HWGeneratorSchemaOp(_ods_ir.OpView):
  r"""
  The "hw.generator.schema" operation declares a kind of generated module by
  declaring the schema of meta-data required.
  A generated module instance of a schema is independent of the external
  method of producing it.  It is assumed that for well known schema instances,
  multiple external tools might exist which can process it.  Generator nodes
  list attributes required by hw.module.generated instances.
  
  Example:
  ```mlir
  generator.schema @MEMORY, "Simple-Memory", ["ports", "write_latency", "read_latency"]
  module.generated @mymem, @MEMORY(ports)
    -> (ports) {write_latency=1, read_latency=1, ports=["read","write"]}
  ```
  """

  OPERATION_NAME = "hw.generator.schema"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, descriptor, requiredAttrs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["descriptor"] = (descriptor if (
    isinstance(descriptor, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(descriptor, context=_ods_context))
    attributes["requiredAttrs"] = (requiredAttrs if (
    isinstance(requiredAttrs, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(requiredAttrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def descriptor(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["descriptor"]

  @descriptor.setter
  def descriptor(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["descriptor"] = value

  @builtins.property
  def requiredAttrs(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["requiredAttrs"]

  @requiredAttrs.setter
  def requiredAttrs(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["requiredAttrs"] = value

def generator_schema(sym_name, descriptor, required_attrs, *, loc=None, ip=None) -> HWGeneratorSchemaOp:
  return HWGeneratorSchemaOp(sym_name=sym_name, descriptor=descriptor, requiredAttrs=required_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class HWModuleExternOp(_ods_ir.OpView):
  r"""
  The "hw.module.extern" operation represents an external reference to a
  Verilog module, including a given name and a list of ports.
  
  The 'verilogName' attribute (when present) specifies the spelling of the
  module name in Verilog we can use.  TODO: This is a hack because we don't
  have proper parameterization in the hw.dialect.  We need a way to represent
  parameterized types instead of just concrete types.
  """

  OPERATION_NAME = "hw.module.extern"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, module_type, parameters, *, per_port_attrs=None, port_locs=None, verilogName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["module_type"] = (module_type if (
    isinstance(module_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_617')) else
      _ods_ir.AttrBuilder.get('anonymous_617')(module_type, context=_ods_context))
    if per_port_attrs is not None: attributes["per_port_attrs"] = (per_port_attrs if (
        isinstance(per_port_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(per_port_attrs, context=_ods_context))
    if port_locs is not None: attributes["port_locs"] = (port_locs if (
        isinstance(port_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(port_locs, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('ParamDeclArrayAttr')(parameters, context=_ods_context))
    if verilogName is not None: attributes["verilogName"] = (verilogName if (
        isinstance(verilogName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verilogName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def module_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["module_type"]

  @module_type.setter
  def module_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module_type"] = value

  @builtins.property
  def per_port_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "per_port_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["per_port_attrs"]

  @per_port_attrs.setter
  def per_port_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["per_port_attrs"] = value
    elif "per_port_attrs" in self.operation.attributes:
      del self.operation.attributes["per_port_attrs"]

  @per_port_attrs.deleter
  def per_port_attrs(self):
    del self.operation.attributes["per_port_attrs"]

  @builtins.property
  def port_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "port_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["port_locs"]

  @port_locs.setter
  def port_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["port_locs"] = value
    elif "port_locs" in self.operation.attributes:
      del self.operation.attributes["port_locs"]

  @port_locs.deleter
  def port_locs(self):
    del self.operation.attributes["port_locs"]

  @builtins.property
  def parameters(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def verilogName(self) -> _Optional[_ods_ir.StringAttr]:
    if "verilogName" not in self.operation.attributes:
      return None
    return self.operation.attributes["verilogName"]

  @verilogName.setter
  def verilogName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["verilogName"] = value
    elif "verilogName" in self.operation.attributes:
      del self.operation.attributes["verilogName"]

  @verilogName.deleter
  def verilogName(self):
    del self.operation.attributes["verilogName"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def module_extern(sym_name, module_type, parameters, *, per_port_attrs=None, port_locs=None, verilog_name=None, loc=None, ip=None) -> HWModuleExternOp:
  return HWModuleExternOp(sym_name=sym_name, module_type=module_type, parameters=parameters, per_port_attrs=per_port_attrs, port_locs=port_locs, verilogName=verilog_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class HWModuleGeneratedOp(_ods_ir.OpView):
  r"""
  The "hw.module.generated" operation represents a reference to an external
  module that will be produced by some external process.
  This represents the name and list of ports to be generated.
  
  The 'verilogName' attribute (when present) specifies the spelling of the
  module name in Verilog we can use.  See hw.module for an explanation.
  """

  OPERATION_NAME = "hw.module.generated"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, generatorKind, module_type, parameters, *, per_port_attrs=None, port_locs=None, verilogName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["generatorKind"] = (generatorKind if (
    isinstance(generatorKind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(generatorKind, context=_ods_context))
    attributes["module_type"] = (module_type if (
    isinstance(module_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_617')) else
      _ods_ir.AttrBuilder.get('anonymous_617')(module_type, context=_ods_context))
    if per_port_attrs is not None: attributes["per_port_attrs"] = (per_port_attrs if (
        isinstance(per_port_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(per_port_attrs, context=_ods_context))
    if port_locs is not None: attributes["port_locs"] = (port_locs if (
        isinstance(port_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(port_locs, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('ParamDeclArrayAttr')(parameters, context=_ods_context))
    if verilogName is not None: attributes["verilogName"] = (verilogName if (
        isinstance(verilogName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verilogName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def generatorKind(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["generatorKind"]

  @generatorKind.setter
  def generatorKind(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["generatorKind"] = value

  @builtins.property
  def module_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["module_type"]

  @module_type.setter
  def module_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module_type"] = value

  @builtins.property
  def per_port_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "per_port_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["per_port_attrs"]

  @per_port_attrs.setter
  def per_port_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["per_port_attrs"] = value
    elif "per_port_attrs" in self.operation.attributes:
      del self.operation.attributes["per_port_attrs"]

  @per_port_attrs.deleter
  def per_port_attrs(self):
    del self.operation.attributes["per_port_attrs"]

  @builtins.property
  def port_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "port_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["port_locs"]

  @port_locs.setter
  def port_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["port_locs"] = value
    elif "port_locs" in self.operation.attributes:
      del self.operation.attributes["port_locs"]

  @port_locs.deleter
  def port_locs(self):
    del self.operation.attributes["port_locs"]

  @builtins.property
  def parameters(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def verilogName(self) -> _Optional[_ods_ir.StringAttr]:
    if "verilogName" not in self.operation.attributes:
      return None
    return self.operation.attributes["verilogName"]

  @verilogName.setter
  def verilogName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["verilogName"] = value
    elif "verilogName" in self.operation.attributes:
      del self.operation.attributes["verilogName"]

  @verilogName.deleter
  def verilogName(self):
    del self.operation.attributes["verilogName"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def module_generated(sym_name, generator_kind, module_type, parameters, *, per_port_attrs=None, port_locs=None, verilog_name=None, loc=None, ip=None) -> HWModuleGeneratedOp:
  return HWModuleGeneratedOp(sym_name=sym_name, generatorKind=generator_kind, module_type=module_type, parameters=parameters, per_port_attrs=per_port_attrs, port_locs=port_locs, verilogName=verilog_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class HWModuleOp(_ods_ir.OpView):
  r"""
  The "hw.module" operation represents a Verilog module, including a given
  name, a list of ports, a list of parameters, and a body that represents the
  connections within the module.
  """

  OPERATION_NAME = "hw.module"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, module_type, parameters, *, per_port_attrs=None, result_locs=None, comment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["module_type"] = (module_type if (
    isinstance(module_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_617')) else
      _ods_ir.AttrBuilder.get('anonymous_617')(module_type, context=_ods_context))
    if per_port_attrs is not None: attributes["per_port_attrs"] = (per_port_attrs if (
        isinstance(per_port_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(per_port_attrs, context=_ods_context))
    if result_locs is not None: attributes["result_locs"] = (result_locs if (
        isinstance(result_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LocationArrayAttr')) else
          _ods_ir.AttrBuilder.get('LocationArrayAttr')(result_locs, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('ParamDeclArrayAttr')(parameters, context=_ods_context))
    if comment is not None: attributes["comment"] = (comment if (
        isinstance(comment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(comment, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def module_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["module_type"]

  @module_type.setter
  def module_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["module_type"] = value

  @builtins.property
  def per_port_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "per_port_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["per_port_attrs"]

  @per_port_attrs.setter
  def per_port_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["per_port_attrs"] = value
    elif "per_port_attrs" in self.operation.attributes:
      del self.operation.attributes["per_port_attrs"]

  @per_port_attrs.deleter
  def per_port_attrs(self):
    del self.operation.attributes["per_port_attrs"]

  @builtins.property
  def result_locs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "result_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["result_locs"]

  @result_locs.setter
  def result_locs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["result_locs"] = value
    elif "result_locs" in self.operation.attributes:
      del self.operation.attributes["result_locs"]

  @result_locs.deleter
  def result_locs(self):
    del self.operation.attributes["result_locs"]

  @builtins.property
  def parameters(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def comment(self) -> _Optional[_ods_ir.StringAttr]:
    if "comment" not in self.operation.attributes:
      return None
    return self.operation.attributes["comment"]

  @comment.setter
  def comment(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["comment"] = value
    elif "comment" in self.operation.attributes:
      del self.operation.attributes["comment"]

  @comment.deleter
  def comment(self):
    del self.operation.attributes["comment"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def module(sym_name, module_type, parameters, *, per_port_attrs=None, result_locs=None, comment=None, loc=None, ip=None) -> HWModuleOp:
  return HWModuleOp(sym_name=sym_name, module_type=module_type, parameters=parameters, per_port_attrs=per_port_attrs, result_locs=result_locs, comment=comment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class HierPathOp(_ods_ir.OpView):
  r"""
  The "hw.hierpath" operation represents a path through the hierarchy.
  This is used to specify namable things for use in other operations, for
  example in verbatim substitution. Non-local annotations also use these.
  """

  OPERATION_NAME = "hw.hierpath"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, namepath, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["namepath"] = (namepath if (
    isinstance(namepath, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('NameRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('NameRefArrayAttr')(namepath, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def namepath(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["namepath"]

  @namepath.setter
  def namepath(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["namepath"] = value

def hierpath(sym_name, namepath, *, loc=None, ip=None) -> HierPathOp:
  return HierPathOp(sym_name=sym_name, namepath=namepath, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstanceChoiceOp(_ods_ir.OpView):
  r"""
  This represents an instance to a module which is determined based on the
  target through the ABI. Besides a default implementation, other targets can
  be associated with a string, which will later determined which reference
  is chosen.
  
  For the purposes of analyses and transformations, it is assumed that any of
  the targets is a possibility.
  
  Example:
  ```mlir
  %b = hw.instance_choice "inst" sym
      @TargetDefault or
      @TargetA if "A" or
      @TargetB if "B"
      (a: %a: i32) -> (b: i32)
  ```
  """

  OPERATION_NAME = "hw.instance_choice"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, instanceName, moduleNames, optionName, caseNames, inputs, argNames, resultNames, parameters, *, inner_sym=None, doNotPrint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instanceName"] = (instanceName if (
    isinstance(instanceName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(instanceName, context=_ods_context))
    attributes["moduleNames"] = (moduleNames if (
    isinstance(moduleNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefArrayAttr')(moduleNames, context=_ods_context))
    attributes["optionName"] = (optionName if (
    isinstance(optionName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(optionName, context=_ods_context))
    attributes["caseNames"] = (caseNames if (
    isinstance(caseNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(caseNames, context=_ods_context))
    attributes["argNames"] = (argNames if (
    isinstance(argNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(argNames, context=_ods_context))
    attributes["resultNames"] = (resultNames if (
    isinstance(resultNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(resultNames, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('ParamDeclArrayAttr')(parameters, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    if bool(doNotPrint): attributes["doNotPrint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def instanceName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["instanceName"]

  @instanceName.setter
  def instanceName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceName"] = value

  @builtins.property
  def moduleNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["moduleNames"]

  @moduleNames.setter
  def moduleNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["moduleNames"] = value

  @builtins.property
  def optionName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["optionName"]

  @optionName.setter
  def optionName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["optionName"] = value

  @builtins.property
  def caseNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["caseNames"]

  @caseNames.setter
  def caseNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["caseNames"] = value

  @builtins.property
  def argNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["argNames"]

  @argNames.setter
  def argNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["argNames"] = value

  @builtins.property
  def resultNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["resultNames"]

  @resultNames.setter
  def resultNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resultNames"] = value

  @builtins.property
  def parameters(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def doNotPrint(self) -> bool:
    return "doNotPrint" in self.operation.attributes

  @doNotPrint.setter
  def doNotPrint(self, value):
    if bool(value):
      self.operation.attributes["doNotPrint"] = _ods_ir.UnitAttr.get()
    elif "doNotPrint" in self.operation.attributes:
      del self.operation.attributes["doNotPrint"]

  @doNotPrint.deleter
  def doNotPrint(self):
    del self.operation.attributes["doNotPrint"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def instance_choice(results_, instance_name, module_names, option_name, case_names, inputs, arg_names, result_names, parameters, *, inner_sym=None, do_not_print=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, InstanceChoiceOp]:
  op = InstanceChoiceOp(results_=results_, instanceName=instance_name, moduleNames=module_names, optionName=option_name, caseNames=case_names, inputs=inputs, argNames=arg_names, resultNames=result_names, parameters=parameters, inner_sym=inner_sym, doNotPrint=do_not_print, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class InstanceOp(_ods_ir.OpView):
  r"""
  This represents an instance of a module. The inputs and outputs are
  the referenced module's inputs and outputs.  The `argNames` and
  `resultNames` attributes must match the referenced module.
  
  Any parameters in the "old" format (slated to be removed) are stored in the
  `oldParameters` dictionary.
  """

  OPERATION_NAME = "hw.instance"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, instanceName, moduleName, inputs, argNames, resultNames, parameters, *, inner_sym=None, doNotPrint=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["instanceName"] = (instanceName if (
    isinstance(instanceName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(instanceName, context=_ods_context))
    attributes["moduleName"] = (moduleName if (
    isinstance(moduleName, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(moduleName, context=_ods_context))
    attributes["argNames"] = (argNames if (
    isinstance(argNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(argNames, context=_ods_context))
    attributes["resultNames"] = (resultNames if (
    isinstance(resultNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(resultNames, context=_ods_context))
    attributes["parameters"] = (parameters if (
    isinstance(parameters, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ParamDeclArrayAttr')) else
      _ods_ir.AttrBuilder.get('ParamDeclArrayAttr')(parameters, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    if bool(doNotPrint): attributes["doNotPrint"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def instanceName(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["instanceName"]

  @instanceName.setter
  def instanceName(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["instanceName"] = value

  @builtins.property
  def moduleName(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["moduleName"]

  @moduleName.setter
  def moduleName(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["moduleName"] = value

  @builtins.property
  def argNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["argNames"]

  @argNames.setter
  def argNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["argNames"] = value

  @builtins.property
  def resultNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["resultNames"]

  @resultNames.setter
  def resultNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resultNames"] = value

  @builtins.property
  def parameters(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["parameters"]

  @parameters.setter
  def parameters(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["parameters"] = value

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def doNotPrint(self) -> bool:
    return "doNotPrint" in self.operation.attributes

  @doNotPrint.setter
  def doNotPrint(self, value):
    if bool(value):
      self.operation.attributes["doNotPrint"] = _ods_ir.UnitAttr.get()
    elif "doNotPrint" in self.operation.attributes:
      del self.operation.attributes["doNotPrint"]

  @doNotPrint.deleter
  def doNotPrint(self):
    del self.operation.attributes["doNotPrint"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def instance(results_, instance_name, module_name, inputs, arg_names, result_names, parameters, *, inner_sym=None, do_not_print=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, InstanceOp]:
  op = InstanceOp(results_=results_, instanceName=instance_name, moduleName=module_name, inputs=inputs, argNames=arg_names, resultNames=result_names, parameters=parameters, inner_sym=inner_sym, doNotPrint=do_not_print, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  r"""
  "hw.output" marks the end of a region in the HW dialect and the values
  to put on the output ports.
  """

  OPERATION_NAME = "hw.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def outputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def output(outputs, *, loc=None, ip=None) -> OutputOp:
  return OutputOp(outputs=outputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ParamValueOp(_ods_ir.OpView):
  OPERATION_NAME = "hw.param.value"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    if results is None:
      _ods_result_type_source_attr = attributes["value"]
      _ods_derived_result_type = (
        _ods_ir.TypeAttr(_ods_result_type_source_attr).value
        if _ods_ir.TypeAttr.isinstance(_ods_result_type_source_attr) else
        _ods_result_type_source_attr.type)
      results = [_ods_derived_result_type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def param_value(value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ParamValueOp(value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StructCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "hw.struct_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def struct_create(result, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return StructCreateOp(result=result, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StructExplodeOp(_ods_ir.OpView):
  r"""
  ```
  %result:2 = hw.struct_explode %input : !hw.struct<foo: i19, bar: i7>
  ```
  """

  OPERATION_NAME = "hw.struct_explode"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def struct_explode(result, input, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, StructExplodeOp]:
  op = StructExplodeOp(result=result, input=input, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class StructExtractOp(_ods_ir.OpView):
  r"""
  ```
  %result = hw.struct_extract %input["field"] : !hw.struct<field: type>
  ```
  """

  OPERATION_NAME = "hw.struct_extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, fieldIndex, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fieldIndex"] = (fieldIndex if (
    isinstance(fieldIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(fieldIndex, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fieldIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fieldIndex"]

  @fieldIndex.setter
  def fieldIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldIndex"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def struct_extract(result, input, field_index, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return StructExtractOp(result=result, input=input, fieldIndex=field_index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StructInjectOp(_ods_ir.OpView):
  r"""
  ```
  %result = hw.struct_inject %input["field"], %newValue
      : !hw.struct<field: type>
  ```
  """

  OPERATION_NAME = "hw.struct_inject"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, fieldIndex, newValue, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    operands.append(newValue)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fieldIndex"] = (fieldIndex if (
    isinstance(fieldIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(fieldIndex, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def newValue(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def fieldIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fieldIndex"]

  @fieldIndex.setter
  def fieldIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldIndex"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def struct_inject(input, field_index, new_value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return StructInjectOp(input=input, fieldIndex=field_index, newValue=new_value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TriggeredOp(_ods_ir.OpView):
  r"""
  A procedural region that can be triggered by an event. The trigger
  condition is a 1-bit value that is activated based on some event control
  attribute.
  The operation is `IsolatedFromAbove`, and thus requires values passed into
  the trigger region to be explicitly passed in through the `inputs` list.
  """

  OPERATION_NAME = "hw.triggered"

  _ODS_REGIONS = (1, True)

  def __init__(self, event, trigger, inputs, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(trigger)
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["event"] = (event if (
    isinstance(event, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EventControlAttr')) else
      _ods_ir.AttrBuilder.get('EventControlAttr')(event, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def trigger(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def inputs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def event(self) -> _ods_ir.Attribute:
    return self.operation.attributes["event"]

  @event.setter
  def event(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["event"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def triggered(event, trigger, inputs, *, loc=None, ip=None) -> TriggeredOp:
  return TriggeredOp(event=event, trigger=trigger, inputs=inputs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TypeScopeOp(_ods_ir.OpView):
  r"""
  An operation whose one body block contains type declarations. This op
  provides a scope for type declarations at the top level of an MLIR module.
  It is a symbol that may be looked up within the module, as well as a symbol
  table itself, so type declarations may be looked up.
  """

  OPERATION_NAME = "hw.type_scope"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def type_scope(sym_name, *, loc=None, ip=None) -> TypeScopeOp:
  return TypeScopeOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TypedeclOp(_ods_ir.OpView):
  r"""
  Associate a symbolic name with a type.
  """

  OPERATION_NAME = "hw.typedecl"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, verilogName=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if verilogName is not None: attributes["verilogName"] = (verilogName if (
        isinstance(verilogName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(verilogName, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def verilogName(self) -> _Optional[_ods_ir.StringAttr]:
    if "verilogName" not in self.operation.attributes:
      return None
    return self.operation.attributes["verilogName"]

  @verilogName.setter
  def verilogName(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["verilogName"] = value
    elif "verilogName" in self.operation.attributes:
      del self.operation.attributes["verilogName"]

  @verilogName.deleter
  def verilogName(self):
    del self.operation.attributes["verilogName"]

def typedecl(sym_name, type_, *, verilog_name=None, loc=None, ip=None) -> TypedeclOp:
  return TypedeclOp(sym_name=sym_name, type_=type_, verilogName=verilog_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UnionCreateOp(_ods_ir.OpView):
  r"""
  Create a union with the value 'input', which can then be accessed via the
  specified field.
  
  ```
    %x = hw.constant 0 : i3
    %z = hw.union_create "bar", %x : !hw.union<bar: i3, baz: i8>
  ```
  """

  OPERATION_NAME = "hw.union_create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, fieldIndex, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fieldIndex"] = (fieldIndex if (
    isinstance(fieldIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(fieldIndex, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fieldIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fieldIndex"]

  @fieldIndex.setter
  def fieldIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldIndex"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def union_create(result, field_index, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnionCreateOp(result=result, fieldIndex=field_index, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnionExtractOp(_ods_ir.OpView):
  r"""
  Get the value of a union, interpreting it as the type of the specified
  member field.  Extracting a value belonging to a different field than the
  union was initially created will result in undefined behavior.
  
  ```
    %u = ...
    %v = hw.union_extract %u["foo"] : !hw.union<foo: i3, bar: i16>
    // %v is of type 'i3'
  ```
  """

  OPERATION_NAME = "hw.union_extract"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, fieldIndex, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fieldIndex"] = (fieldIndex if (
    isinstance(fieldIndex, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(fieldIndex, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def fieldIndex(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["fieldIndex"]

  @fieldIndex.setter
  def fieldIndex(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fieldIndex"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def union_extract(input, field_index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnionExtractOp(input=input, fieldIndex=field_index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WireOp(_ods_ir.OpView):
  r"""
  An `hw.wire` is used to assign a human-readable name or a symbol for remote
  references to an SSA edge. It takes a single operand and returns its value
  unchanged as a result. The operation guarantees the following:
  
  - If the wire has a symbol, the value of its operand remains observable
    under that symbol within the IR.
  
  - If the wire has a name, the name is treated as a hint. If the wire
    persists until code generation the resulting wire will have this name,
    with a potential suffix to ensure uniqueness. If the wire is canonicalized
    away, its name is propagated to its input operand as a name hint.
  
  - The users of its result will always observe the operand through the
    operation itself, meaning that optimizations cannot bypass the wire. This
    ensures that if the wire's value is *forced*, for example through a
    Verilog force statement, the forced value will affect all users of the
    wire in the output.
  
  Example:
  ```
  %1 = hw.wire %0 : i42
  %2 = hw.wire %0 sym @mySym : i42
  %3 = hw.wire %0 name "myWire" : i42
  %myWire = hw.wire %0 : i42
  ```
  """

  OPERATION_NAME = "hw.wire"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, *, name=None, inner_sym=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if inner_sym is not None: attributes["inner_sym"] = (inner_sym if (
        isinstance(inner_sym, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('InnerSymAttr')) else
          _ods_ir.AttrBuilder.get('InnerSymAttr')(inner_sym, context=_ods_context))
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def inner_sym(self) -> _Optional[_ods_ir.Attribute]:
    if "inner_sym" not in self.operation.attributes:
      return None
    return self.operation.attributes["inner_sym"]

  @inner_sym.setter
  def inner_sym(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["inner_sym"] = value
    elif "inner_sym" in self.operation.attributes:
      del self.operation.attributes["inner_sym"]

  @inner_sym.deleter
  def inner_sym(self):
    del self.operation.attributes["inner_sym"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def wire(input, *, name=None, inner_sym=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return WireOp(input=input, name=name, inner_sym=inner_sym, results=results, loc=loc, ip=ip).result
