# ---------------------------------------------------------------------------- #

[package]
name        = "monolithium"
version     = "1.2.0"
authors     = ["Tremeschin"]
description = "Finding the Largest Minecraft Alpha Monoliths"
repository  = "https://github.com/Tremeschin/Monolithium"
readme      = "../.github/readme.md"
license     = "MIT"
edition     = "2024"

[workspace]
resolver = "3"

# ---------------------------------------------------------------------------- #

[lib]
name = "monolithium"
path = "monolithium/lib.rs"

[[bin]]
name = "monolithium"
path = "monolithium/main.rs"

# ---------------------------------------------------------------------------- #

[dependencies]
ahash         = {version="0.8.12", features=["compile-time-rng", "std"], default-features=false}
clap          = {version="4.5.49", features=["derive"]}
fastrand      = "2.3.0"
indicatif     = {version="0.18.0", features=["rayon"]}
microbench    = "0.5.0"
png           = "0.18.0"
rand          = "0.9.2"
rayon         = "1.11.0"
serde         = {version="1.0.228", features=["derive"]}
serde_json    = "1.0.145"
smart-default = "0.7.1"

# ---------------------------------------------------------------------------- #

[features]
default = [
    "grad-lookup",
    "fast-area",
]

# ------------------------------------ #
# Accurate optimizations

# Use a lookup table for `utils::grad()`
grad-lookup = []

# ------------------------------------ #
# Lossy optimizations

# Step by 4 blocks when calculating areas, as each noise coordinate is the world
# position divided by 4. This causes a small error in area calculation due to
# interpolation, but the average of over/under-shoots gives at most 1% error
fast-area = []

# Ignores the last few octaves in noises, as they contribute very little. Causes
# minor errors in the hill noise, as values for monoliths are relatively tight
most-octaves = []

# Assumes `JavaRNG::next_i32_bound()` never rejects values, skipping
# three math operations check per call (low error for perlin values)
# â€¢ Monte Carlo says 0.03474% error rates for minecraft values
skip-rejection = []

# Use a Skip Table for fast LCG stepping, same loss as `skip-rejection`
skip-table = []

# ------------------------------------ #
# Behavioral changes

# About 40% of all blocks have valid |depth| > 8000 for monoliths, which makes
# the hill noise almost always (~85% Monte Carlo) an accurate source of truth
# for such. This change removes the 'depth' calculations, **only yielding seed
# candidates** (all results are "mostly wrong" with ~34% greater areas).
#
# A second pass searching the largest monoliths for the best candidates inbounds
# is highly recommended with the 'find --step 512 --seed <seed>'. Many records
# were found this way in the middle ages of monolith hunting, as the hill noise
# repeats every 524288 blocks giving multiple chances of lucky depth values.
only-hill = []

# Filter out seeds in which the fractional part of perlin noises offsets aren't
# close to a half in the 'search' command (see graphs in world.rs). Such seeds
# generally generates larger monoliths overall. By default, only the hill noise
# coefficients are checked, you can enable 'depth-fracts' to include depth.
#
# Reason being the lattices of perlin noises are zero-valued, with the highest
# values often found at halfway points between grid coordinates.
#
# Such cutoffs can be tweaked with the QUALITY=x compile time variable.
filter-fracts = []

# With the 'filter-fracts' feature, include the depth noise deviations.
depth-fracts = []

# Scale seed probing deviations with their octave.
scaled-deviation = []

# ------------------------------------ #
# Groups

candidates = [
    "only-hill",
    "filter-fracts",
    "scaled-deviation",
]

fast = [
    "most-octaves",
    "skip-rejection",
    "skip-table",
]

# ---------------------------------------------------------------------------- #

[profile.dev]
strip = true

[profile.release]
overflow-checks = false
codegen-units = 1
opt-level = 3
panic = "abort"
lto = "fat"
