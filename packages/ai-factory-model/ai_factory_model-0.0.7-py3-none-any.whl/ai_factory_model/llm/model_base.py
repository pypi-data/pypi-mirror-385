from abc import ABC, abstractmethod
import datetime
import re
from decouple import config
from jinja2 import Template
from ..logger import info, debug
from ..config import get_var, kwargs_decouple
from .model_utils import read_template, render_template, SEP_PATTERN


REGEX_VAR = r"{(.+?)}"

# Label constants
LABEL_MODEL_NAME = "model_name"
LABEL_MODEL_VERSION = "model_version"
LABEL_API_KEY = "api_key"
LABEL_API_ENDPOINT = "api_endpoint"
LABEL_API_AUTH = "api_auth"
LABEL_MODEL_PARAMS = "model_params"

# Value constants
VALUE_SERVICE_PRINCIPAL = "service_principal"
VALUE_API_KEY = "api_key"


class BaseModel(ABC):

    # Create attribute
    auth_client = None
    client = None

    def __init__(self, config: dict[str, str]):
        self.config = config

        self.model_name = self.render_var(LABEL_MODEL_NAME)
        self.version = self.render_var(LABEL_MODEL_VERSION)

        if LABEL_API_ENDPOINT in config:
            self.endpoint = self.render_var(LABEL_API_ENDPOINT)

        # Authentication
        self.api_auth = self.render_var(LABEL_API_AUTH, default=VALUE_SERVICE_PRINCIPAL)
        if self.api_auth == VALUE_SERVICE_PRINCIPAL:
            # Create attribute
            self.auth_client = None
        elif self.api_auth == VALUE_API_KEY and LABEL_API_KEY in config:
            self.api_key = self.render_var(LABEL_API_KEY, cast=str)

        self.params = self.render_var(LABEL_MODEL_PARAMS, default={})

        # Client will be initialized in initialize_model
        self.client = None

    @abstractmethod
    def initialize_model(self):
        """
        Initialization of model AI implementation.
        """
        pass

    @property
    def get_client(self):
        return self.client

    def prompt(self, params) -> str:
        """
        Execute a prompt with system and user messages using the LLM client.

        This method processes a prompt by sending system and user messages to the language model
        and returns the generated response. It also logs the execution duration for performance monitoring.

        Args:
            params (list): A list containing two elements:
                - params[0] (str): The system message that sets the context or instructions for the model
                - params[1] (str): The user input message or query to be processed

        Returns:
            str: The content of the response generated by the language model

        Note:
            The method automatically logs the execution duration in seconds with 4 decimal precision.
        """

        system = params[0]
        input = params[1]

        init = datetime.datetime.now()
        messages = [
            {"role": "system", "content": system},
            {"role": "user", "content": input}
        ]

        debug("Starting prompt ...")
        response = self.client.invoke(messages).content
        duration = (datetime.datetime.now() - init).total_seconds()
        info(f"Prompt duration: {duration:.4f} seconds")
        return response

    def prompt_template(self, path: str, params: dict, sep_pattern: str = SEP_PATTERN) -> str:
        """
        Generate a prompt using a template file and parameters.

        This method reads a template file from the specified path, substitutes the given
        parameters into the template, and then processes it through the prompt method.

        Args:
            path (str): The file path to the template file to be read and processed.
            params (dict): A dictionary of parameters to substitute into the template.
                          Keys should match placeholders in the template file.

        Returns:
            str: The processed prompt string after template substitution and prompt processing.

        Example:
            >>> model = ModelBase()
            >>> params = {"name": "John", "age": 30}
            >>> result = model.prompt_template("templates/greeting.prompt", params)
            >>> print(result)
        """
        return self.prompt(read_template(path, params, sep_pattern))

    def prompt_render(self, template: Template, params: dict, sep_pattern: str = SEP_PATTERN) -> str:
        """Render a prompt template with the given parameters and process it through the prompt method.

        Args:
            template (Template): The template object to be rendered with parameters.
            params (dict): A dictionary containing the parameters to substitute in the template.

        Returns:
            str: The processed prompt string after rendering the template and applying the prompt method.

        Raises:
            TemplateError: If the template rendering fails due to missing or invalid parameters.
            TypeError: If template is not a Template object or params is not a dictionary.
        """
        return self.prompt(render_template(template, params, sep_pattern))

    def embedding(self, text: str):
        raise Exception(f"Model {self.model_name} does not allow embedding")

    def render_var(self, var_name, *args, **kwargs):
        """
        Render environment variable using decouple and applying conventions in value as {kv:VARIABLE}
        """
        # Get decouple arguments
        decouple_kwargs = kwargs_decouple(*args, **kwargs)
        # Property has to exist
        if var_name in self.config:
            property_value: str = self.config.get(var_name)
            if isinstance(property_value, str):
                # Only render string templates
                return self.render_property(property_value, **decouple_kwargs)
            return property_value
        else:
            # Get value using decouple, will throw a ValueError if the variable doesn't exist
            # and it is not configurated a default value
            return config(var_name, **decouple_kwargs)

    def render_property(self, property_value: str, **decouple_kwargs) -> str:
        """
        Render property value or template
        """
        values_list: dict[str, str] = {}
        var_names = re.findall(REGEX_VAR, property_value)
        if var_names:
            # Template found
            for var_name in var_names:
                # Add values from environment variables using decouple
                values_list[var_name] = get_var(var_name=var_name, **decouple_kwargs)
        value = property_value.format(**values_list)
        return value
