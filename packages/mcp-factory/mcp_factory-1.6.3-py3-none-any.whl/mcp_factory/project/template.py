"""BasicTemplate: MVP version of single standard project template

Focus on core functionality validation, avoiding template selection complexity
"""

import textwrap


class BasicTemplate:
    """MVP version: Single standard template

    Design philosophy:
    - Avoid template selection complexity, focus on validating core processes
    - Single standard structure to meet 90% of user needs
    - Only includes core methods used directly by Builder
    - Supports MCP's three core capabilities: tools, resources, prompts
    - Minimalist principle: empty directory structure, no example files
    """

    def __init__(self) -> None:
        """Initialize basic template instance."""
        self.template_name = "basic-mcp-server"
        self.version = "1.0.0"

    def get_structure(self) -> dict[str, str]:
        """Return standard project structure definition - core Builder usage"""
        return {
            "config.yaml": "Server configuration file",
            "pyproject.toml": "Python project configuration",
            "server.py": "Server entry file",
            "README.md": "Project documentation",
            "AGENTS.md": "AI agent development guidelines",
            "CHANGELOG.md": "Version change log",
            ".env": "Environment variables configuration file",
            ".gitignore": "Git ignore file",
            "Dockerfile": "Docker container configuration",
            ".dockerignore": "Docker build ignore file",
            "docker-compose.yml": "Docker Compose orchestration configuration",
            "tools/": "Tools implementation directory",
            "resources/": "Resources implementation directory",
            "prompts/": "Prompt template directory",
        }

    def get_server_template(self) -> str:
        """Return server entry file template - core Builder usage"""
        return (
            textwrap.dedent(
                '''
            # !/usr/bin/env python3
            """
            {description}
            Generated by MCP Factory

            This server automatically discovers and registers components from:
            - tools/ directory: @server.tool() functions
            - resources/ directory: @server.resource() functions
            - prompts/ directory: @server.prompt() functions
            """

            import os
            import sys
            from pathlib import Path

            import yaml
            from dotenv import load_dotenv

            from mcp_factory.server import ManagedServer

            # Load environment variables from .env file
            load_dotenv()


            class ConfigurationError(Exception):
                \"\"\"Configuration error\"\"\"
                pass

            def load_config():
                """Load and validate configuration"""
                config_path = Path(__file__).parent / "config.yaml"
                try:
                    with open(config_path, encoding='utf-8') as f:
                        config = yaml.safe_load(f)

                    # Validate required configuration
                    if not config or 'server' not in config:
                        raise ConfigurationError("Invalid configuration: missing 'server' section")

                    server_config = config['server']
                    if 'name' not in server_config:
                        raise ConfigurationError("Invalid configuration: missing 'server.name'")

                    return config

                except FileNotFoundError:
                    print(f"Error: Configuration file not found: {{config_path}}")
                    sys.exit(1)
                except ConfigurationError as e:
                    print(f"Error: {{e}}")
                    sys.exit(1)

            def create_server(config):
                """Create and configure the ManagedServer"""
                server_config = config['server']
                management_config = config.get('management', {{}})

                # Create server with basic configuration first
                server_params = {{
                    'name': server_config['name'],
                    'instructions': server_config.get('instructions', ''),
                    'expose_management_tools': management_config.get('expose_management_tools', False)
                }}

                # Load middleware from configuration
                try:
                    from mcp_factory.middleware import load_middleware_from_config
                    middleware_instances = load_middleware_from_config(config)
                    if middleware_instances:
                        server_params['middleware'] = middleware_instances
                        print(f"‚úÖ Loaded {{len(middleware_instances)}} middleware(s)")
                except ImportError:
                    print("‚ö†Ô∏è  Middleware support not available, skipping middleware loading")
                except Exception as e:
                    print(f"‚ùå Failed to load middleware: {{e}}")

                server = ManagedServer(**server_params)

                # Configure external servers if present
                if 'mcpServers' in config:
                    try:
                        from mcp_factory.mounting import ServerRegistry
                        registry = ServerRegistry(server)
                        server_configs = registry.parse_external_servers_config(config)
                        registry.register_servers(server_configs)
                        lifespan = registry.create_lifespan({{"auto_start": True}})
                        if lifespan:
                            server._lifespan = lifespan
                            print("üîó External servers configured")
                    except ImportError:
                        print("‚ö†Ô∏è  ServerRegistry not available, skipping external servers")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  External servers configuration failed: {{e}}")

                # Store full config for component registration
                server._config = config

                return server

            def register_components(server):
                """Register project components using ComponentManager"""
                try:
                    from mcp_factory.project.components import ComponentManager
                    project_path = Path(__file__).parent

                    # Check if auto-discovery is enabled
                    config = getattr(server, "_config", {{}})
                    auto_discovery_config = config.get("components", {{}}).get("auto_discovery", {{}})

                    if auto_discovery_config.get("enabled", False):
                        # Auto-discover components and update server config
                        print("üîç Auto-discovering project components...")
                        discovered_components = ComponentManager.discover_project_components(project_path)

                        if discovered_components:
                            # Smart merge: keep manual configuration, add newly discovered components
                            if "components" not in config:
                                config["components"] = {{}}

                            config_updated = False
                            for comp_type, discovered_items in discovered_components.items():
                                existing_items = config["components"].get(comp_type, [])
                                existing_modules = {{item.get("module") for item in existing_items}}

                                # Ensure all existing components have enabled attribute
                                for existing_item in existing_items:
                                    if "enabled" not in existing_item:
                                        existing_item["enabled"] = True
                                        config_updated = True

                                # Only add non-existing components, deduplicate based on module path
                                for discovered_item in discovered_items:
                                    if discovered_item.get("module") not in existing_modules:
                                        # Newly discovered components are enabled by default
                                        discovered_item["enabled"] = True
                                        existing_items.append(discovered_item)
                                        config_updated = True

                                config["components"][comp_type] = existing_items

                            server._config = config

                            # No longer write back to config file, maintain static and clean configuration
                            # auto_discovery discovers components at runtime, used directly in memory
                            print("üíæ Components registered in memory only, config file remains static")

                            total_discovered = sum(len(comps) for comps in discovered_components.values())
                            print(f"üì¶ Discovered {{total_discovered}} components: {{', '.join(f'{{len(comps)}} {{name}}' for name, comps in discovered_components.items())}}")
                        else:
                            print("üìÇ No components found in project directories")

                    # Register components (both declared and discovered)
                    ComponentManager.register_components(server, project_path)
                    print("‚úÖ Components registered successfully")

                except ImportError:
                    print("‚ö†Ô∏è  ComponentManager not available, skipping auto-discovery")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Component registration failed: {{e}}")
                    print("üí° You can still add tools manually using @server.tool()")

            # Optional: Add your custom tools here
            # Example:
            # @server.tool()
            # def my_custom_tool(input_data: str) -> str:
            # \"\"\"Your custom tool description\"\"\"
            # return f"Processed: {{input_data}}"

            def main():
                """Main entry point"""
                print("üöÄ Starting MCP Server...")

                # Load configuration
                config = load_config()
                print(f"üìã Loaded configuration for: {{config['server']['name']}}")

                # Create server
                server = create_server(config)
                print(f"üèóÔ∏è  Created server: {{server.name}}")

                # Register components
                register_components(server)

                # Start server
                print(f"üéØ Instructions: {{server.instructions}}")
                print("üîÑ Starting server (Press Ctrl+C to stop)...")

                try:
                    # Get transport configuration
                    transport_config = config.get('transport', {{}})
                    transport = transport_config.get('transport', 'stdio')

                    if transport in ['sse', 'streamable-http']:
                        host = transport_config.get('host', '127.0.0.1')
                        port = transport_config.get('port', 8000)
                        print(f"üåê Server will start on: {{transport}}://{{host}}:{{port}}")
                        server.run(transport=transport, host=host, port=port)
                    else:
                        print(f"üîó Server will start with: {{transport}} transport")
                        server.run(transport=transport)
                except KeyboardInterrupt:
                    print("\\nüëã Server stopped by user")
                except Exception as e:
                    print(f"‚ùå Server error: {{e}}")
                    sys.exit(1)

            if __name__ == "__main__":
                main()
        '''
            ).strip()
            + "\n"
        )

    def get_pyproject_template(self) -> str:
        """Return pyproject.toml template"""
        return textwrap.dedent(
            """
            [build-system]
            requires = ["setuptools>=61.0", "wheel"]
            build-backend = "setuptools.build_meta"

            [project]
            name = "{name}"
            version = "1.0.0"
            description = "{description}"
            readme = "README.md"
            requires-python = ">=3.10"
            dependencies = [
                "mcp-factory>=1.6.0",
                "pydantic>=2.0.0",
                "pyyaml>=6.0.0",
                "python-dotenv>=1.0.0"
            ]



            [tool.setuptools]
            py-modules = []

            [tool.setuptools.packages.find]
            where = ["."]
            include = []

            [project.optional-dependencies]
            dev = [
                "pytest>=7.0.0",
                "pytest-asyncio>=0.21.0",
                "black>=23.0.0",
                "ruff>=0.1.0"
            ]

            [tool.black]
            line-length = 88
            target-version = ["py310"]

            [tool.ruff]
            line-length = 88
            target-version = "py310"
        """
        ).strip()

    def get_readme_template(self) -> str:
        """Return README.md template"""
        return textwrap.dedent(
            """
            # {name}

            {description}

            ## Quick Start

            ```bash
            # Install dependencies
            uv sync

            # Start server
            uv run python server.py
            ```

            ## Configuration

            Add to your Claude Desktop config (`claude_desktop_config.json`):

            ```json
            {{
              "mcpServers": {{
                "{name}": {{
                  "command": "uv",
                  "args": ["run", "python", "server.py"],
                  "cwd": "/path/to/{name}"
                }}
              }}
            }}
            ```

            ## Project Structure

            ```
            {name}/
            ‚îú‚îÄ‚îÄ config.yaml          # Server configuration
            ‚îú‚îÄ‚îÄ pyproject.toml       # Python project configuration
            ‚îú‚îÄ‚îÄ server.py            # Server entry file
            ‚îú‚îÄ‚îÄ README.md            # Documentation
            ‚îú‚îÄ‚îÄ CHANGELOG.md         # Version change log
            ‚îú‚îÄ‚îÄ .env                 # Environment variables configuration
            ‚îú‚îÄ‚îÄ .gitignore           # Git ignore file
            ‚îú‚îÄ‚îÄ Dockerfile           # Docker container configuration
            ‚îú‚îÄ‚îÄ .dockerignore        # Docker build ignore file
            ‚îú‚îÄ‚îÄ docker-compose.yml   # Docker Compose orchestration
            ‚îú‚îÄ‚îÄ tools/               # Tools implementation directory
            ‚îú‚îÄ‚îÄ resources/           # Resources implementation directory
            ‚îî‚îÄ‚îÄ prompts/             # Prompt template directory
            ```

            ## Development

            Edit `server.py` to add your functionality:

            ```python
            @server.tool()
            def my_tool(arg: str) -> str:
                \"\"\"Tool description\"\"\"
                return f"Result: {{{{arg}}}}"
            ```

            ## Deployment

            ### Docker Deployment (Recommended)

            #### Using docker-compose (Easiest)

            ```bash
            # 1. Start the service
            docker-compose up -d

            # 2. View logs
            docker-compose logs -f

            # 3. Stop the service
            docker-compose down
            ```

            #### Using Docker commands

            ```bash
            # Build image
            docker build -t {name} .

            # Run container
            docker run -d \\
              --name {name} \\
              --env-file .env \\
              -v $(pwd)/data:/app/data \\
              -v $(pwd)/logs:/app/logs \\
              {name}
            ```

            ### Local Development

            ```bash
            # Install dependencies
            uv sync

            # Run server
            uv run python server.py
            ```

            ### Production Deployment

            For production deployment, ensure you:
            1. Configure environment variables in `.env`
            2. Set up proper logging and monitoring
            3. Use `restart: unless-stopped` in docker-compose (already configured)
            4. Mount persistent volumes for data

            ### Health Check

            ```bash
            # Check if container is running
            docker ps | grep {name}

            # View container logs
            docker logs {name}

            # Check service status with docker-compose
            docker-compose ps
            ```

            ## Advanced Usage

            For advanced features and examples, see the [examples directory](../examples/) in the mcp-factory repository.

            ---

            *Generated by [MCP Factory](https://github.com/ACNet-AI/mcp-factory)*
        """
        ).strip()

    def get_env_template(self) -> str:
        """Return .env file template"""
        return textwrap.dedent(
            """
            # JWT authentication configuration
            FASTMCP_AUTH_BEARER_ISSUER=https://your-auth-server.com
            FASTMCP_AUTH_BEARER_AUDIENCE=your-app-name
            FASTMCP_AUTH_BEARER_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----
            # Please replace with your JWT verification public key
            MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
            -----END PUBLIC KEY-----"

            # Optional: JWKS endpoint (for dynamic key retrieval)
            # FASTMCP_AUTH_BEARER_JWKS_URI=https://your-auth-server.com/.well-known/jwks.json

            # Other environment variables
            DEBUG=true
            LOG_LEVEL=INFO
        """
        ).strip()

    def get_changelog_template(self) -> str:
        """Return CHANGELOG.md template"""
        return textwrap.dedent(
            """
            # Changelog

            All notable changes to this MCP server will be documented in this file.

            The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
            and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

            # # [Unreleased]

            # ## Added
            - Initial MCP server implementation

            # ## Changed

            # ## Deprecated

            # ## Removed

            # ## Fixed

            # ## Security

            # # [1.0.0] - {date}

            # ## Added
            - Initial release
            - Basic server configuration
            - Core MCP functionality
            - Tools, resources, and prompts modules
        """
        ).strip()

    def get_gitignore_template(self) -> str:
        """Return .gitignore file template"""
        return textwrap.dedent(
            """
            # Python
            __pycache__/
            *.py[cod]
            *$py.class
            *.so

            # Distribution / packaging
            .Python
            build/
            develop-eggs/
            dist/
            downloads/
            eggs/
            .eggs/
            lib/
            lib64/
            parts/
            sdist/
            var/
            wheels/
            *.egg-info/
            .installed.cfg
            *.egg
            MANIFEST

            # Unit test / coverage reports
            htmlcov/
            .tox/
            .coverage
            .coverage.*
            .cache
            nosetests.xml
            coverage.xml
            *.cover
            .hypothesis/
            .pytest_cache/

            # Environments
            .env
            .env.*
            .venv
            env/
            venv/
            ENV/
            env.bak/
            venv.bak/

            # IDE
            .vscode/
            .idea/
            *.swp
            *.swo

            # OS
            .DS_Store
            Thumbs.db
            Desktop.ini

            # Logs
            *.log
            logs/

            # MCP Server specific
            cache/
            data/local/
            temp/
            *.pid
            *.sock

            # Local config overrides
            config.local.yaml
            .env.production
            .env.staging
        """
        ).strip()

    def get_agents_template(self) -> str:
        """Return AGENTS.md template - optimized for AI coding agents"""
        return textwrap.dedent(
            """
            # Project Overview
            MCP server: {name}

            {description}

            This is an MCP (Model Context Protocol) server built with mcp-factory. It provides tools, resources, and prompts accessible via the MCP protocol.

            ## Server Configuration
            **Claude Desktop Configuration (`claude_desktop_config.json`):**
            ```json
            {{
              "mcpServers": {{
                "{name}": {{
                  "command": "uv",
                  "args": ["run", "python", "server.py"],
                  "cwd": "/path/to/{name}"
                }}
              }}
            }}
            ```

            **Direct Connection:**
            ```bash
            # Navigate to project directory first
            cd /path/to/{name}
            uv run python server.py
            ```

            > **Note**: For alternative configuration methods (different environments, authentication, etc.),
            > see the [MCP Configuration Guide](https://github.com/modelcontextprotocol/docs) or consult
            > your MCP client documentation.

            ## Dev environment tips
            - Navigate to project directory: `cd /path/to/{name}`
            - Start server: `uv run python server.py`
            - Install dependencies: `uv sync`
            - Format code: `uv run ruff format .`
            - Check linting: `uv run ruff check .`
            - Add new tools in `tools/` directory with `@server.tool()` decorator
            - Tools are auto-discovered from `tools/`, `resources/`, `prompts/` directories

            ## Testing instructions
            - Use mcp-inspector-server tools for all testing
            - Call `inspect_mcp_server` to verify server connectivity and registration
            - Use `comprehensive_server_test` for complete validation of all tools
            - Test individual tools with `call_mcp_tool`
            - Run `uv run ruff check .` before committing - all checks must pass
            - Ensure all tools have comprehensive docstrings (required for MCP)

            ## PR instructions
            - Title format: `[{name}] <Description>`
            - Always run `uv run ruff check .` and `uv run ruff format .` before committing
            - Add or update tests for new/modified tools
            - Update CHANGELOG.md with your changes
            - All tool functions must return `dict[str, Any]` for MCP compatibility

            ## Code Style Guidelines
            - Use `uv run ruff format .` to format code (from project directory)
            - Run `uv run ruff check .` before committing
            - Use type hints: functions return `dict[str, Any]` for tools
            - Add docstrings to all functions (required for MCP registration)
            - Use direct function parameters, not Pydantic models

            ## Component Management
            This project supports dynamic component discovery and registration:

            **Adding Components:**
            - Tools: Create `.py` files in `tools/` directory with functions decorated with `@server.tool()`
            - Resources: Create `.py` files in `resources/` directory with functions decorated with `@server.resource()`
            - Prompts: Create `.py` files in `prompts/` directory with functions decorated with `@server.prompt()`

            **Component Discovery:**
            - Components are automatically discovered and registered in `config.yaml`
            - Use descriptive function names and comprehensive docstrings
            - Ensure all parameters are JSON-serializable for MCP compatibility
        """
        ).strip()

    def get_dockerfile_template(self) -> str:
        """Return Dockerfile template - multi-stage build for optimized image size"""
        return textwrap.dedent(
            """
            # Multi-stage build for optimized image size
            FROM python:3.12-slim as builder

            WORKDIR /app

            # Install uv for faster dependency management
            RUN pip install uv

            # Copy dependency files
            COPY pyproject.toml uv.lock* ./

            # Install dependencies
            RUN uv sync --frozen

            # Production image
            FROM python:3.12-slim

            WORKDIR /app

            # Copy virtual environment and code from builder
            COPY --from=builder /app/.venv /app/.venv
            COPY . .

            # Set environment variables
            ENV PATH="/app/.venv/bin:$PATH"
            ENV PYTHONUNBUFFERED=1

            # Run the server
            CMD ["python", "server.py"]
            """
        ).strip()

    def get_dockerignore_template(self) -> str:
        """Return .dockerignore template - optimize Docker build"""
        return textwrap.dedent(
            """
            # Python
            __pycache__/
            *.py[cod]
            *$py.class
            *.so
            .Python

            # Virtual environments
            .venv/
            venv/
            env/
            ENV/

            # Git
            .git/
            .github/
            .gitignore

            # Documentation
            *.md
            docs/

            # Tests
            tests/
            .pytest_cache/
            .coverage
            htmlcov/

            # Build
            dist/
            build/
            *.egg-info/

            # IDE
            .vscode/
            .idea/
            *.swp
            *.swo
            *~

            # OS
            .DS_Store
            Thumbs.db

            # Logs
            *.log
            logs/

            # Environment
            .env
            .env.local
            """
        ).strip()

    def get_docker_compose_template(self) -> str:
        """Return docker-compose.yml template - local development and deployment"""
        return textwrap.dedent(
            """
            version: '3.8'

            services:
              mcp-server:
                build:
                  context: .
                  dockerfile: Dockerfile
                container_name: ${{PROJECT_NAME:-{name}}}
                restart: unless-stopped
                environment:
                  - LOG_LEVEL=${{LOG_LEVEL:-INFO}}
                  - PYTHONUNBUFFERED=1
                env_file:
                  - .env
                volumes:
                  # Persist data
                  - ./data:/app/data
                  # Mount logs for debugging
                  - ./logs:/app/logs
                networks:
                  - mcp-network

            networks:
              mcp-network:
                driver: bridge
            """
        ).strip()
