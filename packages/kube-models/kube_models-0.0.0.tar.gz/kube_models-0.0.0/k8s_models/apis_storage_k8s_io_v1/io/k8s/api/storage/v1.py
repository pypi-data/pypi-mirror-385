# generated by puzl.cloud generator:
#   filename:  apis__storage.k8s.io__v1_openapi.json
#   timestamp: 2025-10-20T15:38:48+00:00

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import ClassVar, Dict, List, Set

from k8s_models.const import *
from k8s_models.loader import *
from k8s_models.loader import LazyLoadModel
from k8s_models.resource import *

from ...apimachinery.pkg.api.resource import Quantity
from ...apimachinery.pkg.apis.meta.v1 import LabelSelector, ListMeta, ObjectMeta, Time
from ..core.v1 import PersistentVolumeSpec, TopologySelectorTerm


@dataclass(kw_only=True, frozen=True)
class TokenRequest(LazyLoadModel):
    audience: str
    expirationSeconds: int | None = None


@dataclass(kw_only=True, frozen=True)
class VolumeNodeResources(LazyLoadModel):
    count: int | None = None


@dataclass(kw_only=True, frozen=True)
class CSIDriverSpec(LazyLoadModel):
    attachRequired: bool | None = None
    fsGroupPolicy: str | None = None
    nodeAllocatableUpdatePeriodSeconds: int | None = None
    podInfoOnMount: bool | None = None
    requiresRepublish: bool | None = None
    seLinuxMount: bool | None = None
    storageCapacity: bool | None = None
    tokenRequests: List[TokenRequest] | None = None
    volumeLifecycleModes: List[str] | None = None


@dataclass(kw_only=True, frozen=True)
class CSINodeDriver(LazyLoadModel):
    name: str
    nodeID: str
    allocatable: VolumeNodeResources | None = None
    topologyKeys: List[str] | None = None


@dataclass(kw_only=True, frozen=True)
class CSINodeSpec(LazyLoadModel):
    drivers: List[CSINodeDriver] = field(
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        }
    )


@dataclass(kw_only=True, frozen=True)
class VolumeError(LazyLoadModel):
    errorCode: int | None = None
    message: str | None = None
    time: Time | None = None


@dataclass(kw_only=True, frozen=True)
class CSIDriver(K8sResource):
    spec: CSIDriverSpec
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSIDriver'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    api_path_: ClassVar[str] = 'apis/storage.k8s.io/v1/csidrivers'
    plural_: ClassVar[str] = 'csidrivers'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    apiVersion_: ClassVar[str] = 'storage.k8s.io/v1'
    kind_: ClassVar[str] = 'CSIDriver'
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        'application/merge-patch+json',
        'application/json-patch+json',
        'application/apply-patch+yaml',
        'application/strategic-merge-patch+json',
        'application/apply-patch+cbor',
    }


@dataclass(kw_only=True, frozen=True)
class CSIDriverList(LazyLoadModel):
    items: List[CSIDriver]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSIDriverList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(kw_only=True, frozen=True)
class CSINode(K8sResource):
    spec: CSINodeSpec
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSINode'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    api_path_: ClassVar[str] = 'apis/storage.k8s.io/v1/csinodes'
    plural_: ClassVar[str] = 'csinodes'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    apiVersion_: ClassVar[str] = 'storage.k8s.io/v1'
    kind_: ClassVar[str] = 'CSINode'
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        'application/merge-patch+json',
        'application/json-patch+json',
        'application/apply-patch+yaml',
        'application/strategic-merge-patch+json',
        'application/apply-patch+cbor',
    }


@dataclass(kw_only=True, frozen=True)
class CSINodeList(LazyLoadModel):
    items: List[CSINode]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSINodeList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(kw_only=True, frozen=True)
class CSIStorageCapacity(K8sResource):
    storageClassName: str
    apiVersion: str = 'storage.k8s.io/v1'
    capacity: Quantity | None = None
    kind: str = 'CSIStorageCapacity'
    maximumVolumeSize: Quantity | None = None
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    nodeTopology: LabelSelector | None = None
    api_path_: ClassVar[str] = (
        'apis/storage.k8s.io/v1/namespaces/{namespace}/csistoragecapacities'
    )
    plural_: ClassVar[str] = 'csistoragecapacities'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    apiVersion_: ClassVar[str] = 'storage.k8s.io/v1'
    kind_: ClassVar[str] = 'CSIStorageCapacity'
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        'application/merge-patch+json',
        'application/json-patch+json',
        'application/apply-patch+yaml',
        'application/strategic-merge-patch+json',
        'application/apply-patch+cbor',
    }


@dataclass(kw_only=True, frozen=True)
class CSIStorageCapacityList(LazyLoadModel):
    items: List[CSIStorageCapacity]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'CSIStorageCapacityList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(kw_only=True, frozen=True)
class StorageClass(K8sResource):
    provisioner: str
    allowVolumeExpansion: bool | None = None
    allowedTopologies: List[TopologySelectorTerm] | None = None
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'StorageClass'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    mountOptions: List[str] | None = None
    parameters: Dict[str, str] | None = None
    reclaimPolicy: str | None = None
    volumeBindingMode: str | None = None
    api_path_: ClassVar[str] = 'apis/storage.k8s.io/v1/storageclasses'
    plural_: ClassVar[str] = 'storageclasses'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    apiVersion_: ClassVar[str] = 'storage.k8s.io/v1'
    kind_: ClassVar[str] = 'StorageClass'
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        'application/merge-patch+json',
        'application/json-patch+json',
        'application/apply-patch+yaml',
        'application/strategic-merge-patch+json',
        'application/apply-patch+cbor',
    }


@dataclass(kw_only=True, frozen=True)
class StorageClassList(LazyLoadModel):
    items: List[StorageClass]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'StorageClassList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(kw_only=True, frozen=True)
class VolumeAttachmentSource(LazyLoadModel):
    inlineVolumeSpec: PersistentVolumeSpec | None = None
    persistentVolumeName: str | None = None


@dataclass(kw_only=True, frozen=True)
class VolumeAttachmentSpec(LazyLoadModel):
    attacher: str
    nodeName: str
    source: VolumeAttachmentSource


@dataclass(kw_only=True, frozen=True)
class VolumeAttachmentStatus(LazyLoadModel):
    attached: bool
    attachError: VolumeError | None = None
    attachmentMetadata: Dict[str, str] | None = None
    detachError: VolumeError | None = None


@dataclass(kw_only=True, frozen=True)
class VolumeAttributesClass(K8sResource):
    driverName: str
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'VolumeAttributesClass'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    parameters: Dict[str, str] | None = None
    api_path_: ClassVar[str] = 'apis/storage.k8s.io/v1/volumeattributesclasses'
    plural_: ClassVar[str] = 'volumeattributesclasses'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    apiVersion_: ClassVar[str] = 'storage.k8s.io/v1'
    kind_: ClassVar[str] = 'VolumeAttributesClass'
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        'application/merge-patch+json',
        'application/json-patch+json',
        'application/apply-patch+yaml',
        'application/strategic-merge-patch+json',
        'application/apply-patch+cbor',
    }


@dataclass(kw_only=True, frozen=True)
class VolumeAttributesClassList(LazyLoadModel):
    items: List[VolumeAttributesClass]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'VolumeAttributesClassList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(kw_only=True, frozen=True)
class VolumeAttachment(K8sResource):
    spec: VolumeAttachmentSpec
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'VolumeAttachment'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    status: VolumeAttachmentStatus | None = None
    api_path_: ClassVar[str] = 'apis/storage.k8s.io/v1/volumeattachments'
    plural_: ClassVar[str] = 'volumeattachments'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = 'storage.k8s.io'
    apiVersion_: ClassVar[str] = 'storage.k8s.io/v1'
    kind_: ClassVar[str] = 'VolumeAttachment'
    patch_strategies_: ClassVar[Set[PatchRequestType]] = {
        'application/merge-patch+json',
        'application/json-patch+json',
        'application/apply-patch+yaml',
        'application/strategic-merge-patch+json',
        'application/apply-patch+cbor',
    }


@dataclass(kw_only=True, frozen=True)
class VolumeAttachmentList(LazyLoadModel):
    items: List[VolumeAttachment]
    apiVersion: str = 'storage.k8s.io/v1'
    kind: str = 'VolumeAttachmentList'
    metadata: ListMeta = field(default_factory=ObjectMeta)
