# GitLab CI/CD Pipeline for {{ project_name }}

variables:
  PYTHON_VERSION: "3.11"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA

stages:
  - test
  - build
  - deploy

# Cache configuration
cache:
  paths:
    - .cache/pip
    - .venv/

# Test stage
test:unit:
  stage: test
  image: python:$PYTHON_VERSION
  before_script:
    - pip install poetry
    - poetry config virtualenvs.in-project true
    - poetry install --no-interaction --no-ansi
  script:
    - poetry run pytest --cov=app --cov=worker --cov-report=xml --cov-report=term
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
    expire_in: 1 week

lint:black:
  stage: test
  image: python:$PYTHON_VERSION
  before_script:
    - pip install poetry
    - poetry install --no-interaction --no-ansi
  script:
    - poetry run black --check .
  allow_failure: false

lint:ruff:
  stage: test
  image: python:$PYTHON_VERSION
  before_script:
    - pip install poetry
    - poetry install --no-interaction --no-ansi
  script:
    - poetry run ruff check .
  allow_failure: false

lint:mypy:
  stage: test
  image: python:$PYTHON_VERSION
  before_script:
    - pip install poetry
    - poetry install --no-interaction --no-ansi
  script:
    - poetry run mypy app worker
  allow_failure: true

# Build stage
build:docker:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE_TAG .
    - docker tag $IMAGE_TAG $CI_REGISTRY_IMAGE:latest
    - docker push $IMAGE_TAG
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main
    - develop
  needs:
    - test:unit
    - lint:black
    - lint:ruff

# Deploy stage
deploy:production:
  stage: deploy
  image: alpine/helm:3.13.0
  before_script:
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    - mkdir -p ~/.kube
    - echo "$KUBECONFIG_CONTENT" | base64 -d > ~/.kube/config
  script:
    - |
      helm upgrade --install {{ project_slug }} ./helm \
        --namespace production \
        --create-namespace \
        --set image.repository=$CI_REGISTRY_IMAGE \
        --set image.tag=$CI_COMMIT_SHORT_SHA \
        --wait \
        --timeout 5m
  environment:
    name: production
    url: https://{{ project_slug }}.example.com
  only:
    - main
  needs:
    - build:docker
  when: manual

deploy:staging:
  stage: deploy
  image: alpine/helm:3.13.0
  before_script:
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    - mkdir -p ~/.kube
    - echo "$KUBECONFIG_CONTENT" | base64 -d > ~/.kube/config
  script:
    - |
      helm upgrade --install {{ project_slug }}-staging ./helm \
        --namespace staging \
        --create-namespace \
        --set image.repository=$CI_REGISTRY_IMAGE \
        --set image.tag=$CI_COMMIT_SHORT_SHA \
        --set config.appEnv=staging \
        --wait \
        --timeout 5m
  environment:
    name: staging
    url: https://{{ project_slug }}-staging.example.com
  only:
    - develop
  needs:
    - build:docker

