"""
Git Hooks Management System for GitFlow Studio
Provides comprehensive Git hooks management for automated workflows
"""

import os
import json
import shutil
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich import box
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich.syntax import Syntax

console = Console()

class GitHooksManager:
    """Manages Git hooks for automated workflow integration"""
    
    def __init__(self, config_dir: Optional[str] = None):
        self.config_dir = config_dir or os.path.expanduser("~/.gitflow-studio")
        self.hooks_dir = Path(self.config_dir) / "hooks"
        self.templates_dir = Path(self.config_dir) / "hook_templates"
        self._ensure_directories()
        self._load_default_templates()
    
    def _ensure_directories(self):
        """Ensure required directories exist"""
        Path(self.config_dir).mkdir(parents=True, exist_ok=True)
        self.hooks_dir.mkdir(parents=True, exist_ok=True)
        self.templates_dir.mkdir(parents=True, exist_ok=True)
    
    def _load_default_templates(self):
        """Load default hook templates"""
        default_hooks = {
            "pre-commit": """#!/bin/bash
# Pre-commit hook generated by GitFlow Studio
# Run linting, formatting, and tests before commit

set -e

echo "üîç Running pre-commit checks..."

# Run linting if available
if command -v flake8 >/dev/null 2>&1; then
    echo "Running flake8..."
    flake8 --max-line-length=88 --extend-ignore=E203 .
fi

# Run tests if available
if [ -f "requirements.txt" ] && command -v pytest >/dev/null 2>&1; then
    echo "Running tests..."
    pytest --tb=short -q
fi

echo "‚úÖ Pre-commit checks passed!"
""",
            "commit-msg": """#!/bin/bash
# Commit message hook generated by GitFlow Studio
# Validate commit message format

commit_regex='^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?: .{1,100}'

if ! grep -qE "$commit_regex" "$1"; then
    echo "‚ùå Invalid commit message format!"
    echo "Expected: <type>(<scope>): <description>"
    echo "Example: feat(cli): add new command for branch management"
    exit 1
fi

echo "‚úÖ Commit message format is valid"
""",
            "post-merge": """#!/bin/bash
# Post-merge hook generated by GitFlow Studio
# Update dependencies and clear caches after merge

echo "üîÑ Running post-merge tasks..."

# Update virtual environment if requirements changed
if [ -f "requirements.txt" ] && [ -d "venv" ]; then
    echo "Updating dependencies..."
    source venv/bin/activate && pip install -r requirements.txt
fi

# Clear application caches
find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true

echo "‚úÖ Post-merge tasks completed!"
""",
            "pre-push": """#!/bin/bash
# Pre-push hook generated by GitFlow Studio
# Run comprehensive checks before pushing

set -e

echo "üöÄ Running pre-push checks..."

# Ensure all tests pass
if command -v pytest >/dev/null 2>&1; then
    echo "Running full test suite..."
    pytest --tb=short
fi

# Check for secrets and sensitive data
echo "Checking for potential secrets..."
if command -v detect-secrets >/dev/null 2>&1; then
    detect-secrets scan --baseline .secrets.baseline || true
fi

echo "‚úÖ All pre-push checks passed!"
""",
            "prepare-commit-msg": """#!/bin/bash
# Prepare commit message hook generated by GitFlow Studio
# Add branch name to commit message if in feature branch

branch=$(git rev-parse --abbrev-ref HEAD)

if [[ $branch == feature/* ]]; then
    # Extract feature name
    feature_name=${branch#feature/}
    commit_msg_file=$1
    
    # Add feature name to commit message if not already present
    if ! grep -q "$feature_name" "$commit_msg_file"; then
        sed -i "1s/^/$feature_name: /" "$commit_msg_file"
    fi
fi
""",
            "post-commit": """#!/bin/bash
# Post-commit hook generated by GitFlow Studio
# Automatically update issue trackers and documentation

commit_hash=$(git rev-parse HEAD)
commit_message=$(git log -1 --pretty=%B)
branch=$(git rev-parse --abbrev-ref HEAD)

echo "üìù Commit $commit_hash completed on branch $branch"

# Log commit for analytics
if [ -d ".gitflow-studio" ]; then
    echo "{\\"hash\\":\\"$commit_hash\\",\\"branch\\":\\"$branch\\",\\"timestamp\\":\\"$(date -Iseconds)\\"}" >> .gitflow-studio/commit_log.json
fi
"""
        }
        
        for hook_name, content in default_hooks.items():
            template_path = self.templates_dir / f"{hook_name}.sh"
            if not template_path.exists():
                with open(template_path, 'w') as f:
                    f.write(content)
                # Make executable
                os.chmod(template_path, 0o755)
    
    def list_hooks(self, repo_path: str = None) -> Dict[str, Dict[str, Any]]:
        """List all available hooks for a repository"""
        if repo_path:
            hooks_dir = Path(repo_path) / ".git" / "hooks"
        else:
            hooks_dir = Path.cwd() / ".git" / "hooks"
        
        if not hooks_dir.exists():
            console.print("[red]No Git repository found or hooks directory missing[/]")
            return {}
        
        hooks_info = {}
        
        # Standard Git hooks
        standard_hooks = [
            "applypatch-msg", "pre-applypatch", "post-applypatch",
            "pre-commit", "prepare-commit-msg", "commit-msg", "post-commit",
            "pre-rebase", "post-rewrite", "pre-push", "post-update",
            "pre-receive", "update", "post-receive", "post-update",
            "pre-auto-gc", "post-merge", "push-to-checkout"
        ]
        
        for hook_name in standard_hooks:
            hook_path = hooks_dir / hook_name
            hooks_info[hook_name] = {
                "path": str(hook_path),
                "exists": hook_path.exists(),
                "executable": hook_path.exists() and os.access(hook_path, os.X_OK),
                "size": hook_path.stat().st_size if hook_path.exists() else 0,
                "modified": datetime.fromtimestamp(hook_path.stat().st_mtime).isoformat() if hook_path.exists() else None
            }
        
        return hooks_info
    
    def install_hook(self, hook_name: str, repo_path: str = None, 
                     template: str = None, custom_content: str = None) -> bool:
        """Install a Git hook"""
        if repo_path:
            hooks_dir = Path(repo_path) / ".git" / "hooks"
        else:
            hooks_dir = Path.cwd() / ".git" / "hooks"
        
        if not hooks_dir.exists():
            console.print(f"[red]No Git repository found at {repo_path or 'current directory'}[/]")
            return False
        
        hook_path = hooks_dir / hook_name
        
        # Determine content source
        if custom_content:
            content = custom_content
        elif template:
            template_path = self.templates_dir / f"{template}.sh"
            if template_path.exists():
                with open(template_path, 'r') as f:
                    content = f.read()
            else:
                console.print(f"[red]Template '{template}' not found[/]")
                return False
        else:
            # Use default template for hook_name
            template_path = self.templates_dir / f"{hook_name}.sh"
            if template_path.exists():
                with open(template_path, 'r') as f:
                    content = f.read()
            else:
                console.print(f"[red]No template available for '{hook_name}'[/]")
                return False
        
        try:
            with open(hook_path, 'w') as f:
                f.write(content)
            
            # Make executable
            os.chmod(hook_path, 0o755)
            
            console.print(f"[green]‚úÖ Hook '{hook_name}' installed successfully[/]")
            return True
            
        except Exception as e:
            console.print(f"[red]Error installing hook '{hook_name}': {e}[/]")
            return False
    
    def uninstall_hook(self, hook_name: str, repo_path: str = None) -> bool:
        """Uninstall a Git hook"""
        if repo_path:
            hooks_dir = Path(repo_path) / ".git" / "hooks"
        else:
            hooks_dir = Path.cwd() / ".git" / "hooks"
        
        hook_path = hooks_dir / hook_name
        
        if not hook_path.exists():
            console.print(f"[yellow]Hook '{hook_name}' is not installed[/]")
            return False
        
        try:
            hook_path.unlink()
            console.print(f"[green]‚úÖ Hook '{hook_name}' uninstalled successfully[/]")
            return True
            
        except Exception as e:
            console.print(f"[red]Error uninstalling hook '{hook_name}': {e}[/]")
            return False
    
    def create_custom_hook(self, hook_name: str, content: str, description: str = "") -> bool:
        """Create a custom hook template"""
        template_path = self.templates_dir / f"{hook_name}.sh"
        
        try:
            with open(template_path, 'w') as f:
                f.write(f"#!/bin/bash\n# {description}\n{content}")
            
            os.chmod(template_path, 0o755)
            
            # Save metadata
            metadata_path = self.templates_dir / f"{hook_name}.json"
            metadata = {
                "name": hook_name,
                "description": description,
                "created": datetime.now().isoformat(),
                "type": "custom"
            }
            
            with open(metadata_path, 'w') as f:
                json.dump(metadata, f, indent=2)
            
            console.print(f"[green]‚úÖ Custom hook template '{hook_name}' created[/]")
            return True
            
        except Exception as e:
            console.print(f"[red]Error creating custom hook: {e}[/]")
            return False
    
    def install_workflow_preset(self, preset_name: str, repo_path: str = None) -> bool:
        """Install a preset workflow with multiple hooks"""
        presets = {
            "basic": ["pre-commit"],
            "testing": ["pre-commit", "pre-push"],
            "conventional-commits": ["commit-msg", "prepare-commit-msg"],
            "full": ["pre-commit", "commit-msg", "pre-push", "post-merge"],
            "ci-ready": ["pre-commit", "pre-push", "post-merge", "post-commit"]
        }
        
        if preset_name not in presets:
            console.print(f"[red]Unknown preset: {preset_name}[/]")
            console.print(f"Available presets: {', '.join(presets.keys())}")
            return False
        
        console.print(f"[blue]Installing '{preset_name}' workflow preset...[/]")
        
        success_count = 0
        hooks = presets[preset_name]
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            task = progress.add_task(f"Installing {preset_name} preset...", total=len(hooks))
            
            for hook_name in hooks:
                progress.update(task, description=f"Installing {hook_name}...")
                if self.install_hook(hook_name, repo_path):
                    success_count += 1
                progress.advance(task)
        
        console.print(f"[green]‚úÖ Installed {success_count}/{len(hooks)} hooks from '{preset_name}' preset[/]")
        return success_count == len(hooks)
    
    def show_hook_status(self, repo_path: str = None) -> None:
        """Display hook status in a formatted table"""
        hooks_info = self.list_hooks(repo_path)
        
        if not hooks_info:
            console.print("[yellow]No hooks information available[/]")
            return
        
        table = Table(title="Git Hooks Status", box=box.ROUNDED)
        table.add_column("Hook Name", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Size", justify="right", style="blue")
        table.add_column("Modified", style="dim")
        
        for hook_name, info in hooks_info.items():
            if info["exists"]:
                status = "‚úÖ Installed" if info["executable"] else "‚ö†Ô∏è Not Executable"
                size = f"{info['size']} bytes"
                modified = info["modified"][:19] if info["modified"] else "Unknown"
            else:
                status = "‚ùå Not Installed"
                size = "-"
                modified = "-"
            
            table.add_row(hook_name, status, size, modified)
        
        console.print(table)
    
    def backup_hooks(self, repo_path: str = None, backup_name: str = None) -> str:
        """Backup current hooks configuration"""
        if repo_path:
            hooks_dir = Path(repo_path) / ".git" / "hooks"
        else:
            hooks_dir = Path.cwd() / ".git" / "hooks"
        
        if not hooks_dir.exists():
            console.print("[red]No Git repository found[/]")
            return ""
        
        if not backup_name:
            backup_name = f"hooks_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        backup_dir = self.hooks_dir / backup_name
        backup_dir.mkdir(parents=True, exist_ok=True)
        
        try:
            # Copy all hook files
            for hook_file in hooks_dir.glob("*"):
                if hook_file.is_file() and not hook_file.name.endswith('.sample'):
                    shutil.copy2(hook_file, backup_dir / hook_file.name)
            
            # Create backup metadata
            metadata = {
                "backup_name": backup_name,
                "created": datetime.now().isoformat(),
                "repo_path": str(repo_path or Path.cwd()),
                "hooks": list(hooks_info.keys()) if (hooks_info := self.list_hooks(repo_path)) else []
            }
            
            with open(backup_dir / "backup_info.json", 'w') as f:
                json.dump(metadata, f, indent=2)
            
            console.print(f"[green]‚úÖ Hooks backed up to {backup_dir}[/]")
            return str(backup_dir)
            
        except Exception as e:
            console.print(f"[red]Error backing up hooks: {e}[/]")
            return ""
    
    def restore_hooks(self, backup_name: str, repo_path: str = None) -> bool:
        """Restore hooks from backup"""
        backup_dir = self.hooks_dir / backup_name
        
        if not backup_dir.exists():
            console.print(f"[red]Backup '{backup_name}' not found[/]")
            return False
        
        if repo_path:
            hooks_dir = Path(repo_path) / ".git" / "hooks"
        else:
            hooks_dir = Path.cwd() / ".git" / "hooks"
        
        if not hooks_dir.exists():
            console.print("[red]No Git repository found[/]")
            return False
        
        try:
            # Clear existing hooks first
            for hook_file in hooks_dir.glob("*"):
                if hook_file.is_file() and not hook_file.name.endswith('.sample'):
                    hook_file.unlink()
            
            # Restore hooks from backup
            for hook_file in backup_dir.glob("*"):
                if hook_file.is_file() and hook_file.name != "backup_info.json":
                    shutil.copy2(hook_file, hooks_dir / hook_file.name)
                    os.chmod(hooks_dir / hook_file.name, 0o755)
            
            console.print(f"[green]‚úÖ Hooks restored from backup '{backup_name}'[/]")
            return True
            
        except Exception as e:
            console.print(f"[red]Error restoring hooks: {e}[/]")
            return False
