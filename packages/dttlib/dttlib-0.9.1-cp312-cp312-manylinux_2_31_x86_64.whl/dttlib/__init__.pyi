# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

class AnalysisHeaderId:
    r"""
    This is the name of a result
    Can be of the simple form "SomeChannelName"
    Or the compound form "Name(OtherID1, OtherID2, ...)"

    Structured to avoid unnecessary string parsing
    """
    @staticmethod
    def from_channel(channel: ChannelHeader) -> AnalysisHeaderId: ...
    def __new__(
        cls, name: builtins.str, args: typing.Sequence[AnalysisHeaderId]
    ) -> AnalysisHeaderId: ...
    def first_channel(self) -> ChannelHeader:
        r"""
        get the first channel
        """
    def add_to_set_recursive(
        self, set: builtins.set[AnalysisHeaderId]
    ) -> builtins.set[AnalysisHeaderId]:
        r"""
        The set is pass-through ownership so that the function is usable from python

        This function is needed to "flesh out" the collection of analyses request
        by the user to include all intermediate analyses
        """
    def add_trend(self, trend: TrendType) -> AnalysisHeaderId: ...
    def to_analysis_name_id(self) -> AnalysisNameId: ...
    def get_channels(self) -> builtins.set[ChannelHeader]: ...
    class Simple(AnalysisHeaderId):
        __match_args__ = ("channel",)
        @property
        def channel(self) -> ChannelHeader: ...
        def __new__(cls, channel: ChannelHeader) -> AnalysisHeaderId.Simple: ...

    class Compound(AnalysisHeaderId):
        __match_args__ = (
            "name",
            "args",
        )
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> builtins.list[AnalysisHeaderId]: ...
        def __new__(
            cls, name: builtins.str, args: typing.Sequence[AnalysisHeaderId]
        ) -> AnalysisHeaderId.Compound: ...

class AnalysisId:
    r"""
    This is the name of a result
    Can be of the simple form "SomeChannelName"
    Or the compound form "Name(OtherID1, OtherID2, ...)"

    Structured to avoid unnecessary string parsing
    """
    @staticmethod
    def from_channel(channel: Channel) -> AnalysisId: ...
    def __new__(
        cls, name: builtins.str, args: typing.Sequence[AnalysisId]
    ) -> AnalysisId: ...
    def first_channel(self) -> Channel:
        r"""
        get the first channel
        """
    def add_to_set_recursive(
        self, set: builtins.set[AnalysisId]
    ) -> builtins.set[AnalysisId]:
        r"""
        The set is pass-through ownership so that the function is usable from python

        This function is needed to "flesh out" the collection of analyses request
        by the user to include all intermediate analyses
        """
    def add_trend(self, trend: TrendType) -> AnalysisId: ...
    def to_analysis_name_id(self) -> AnalysisNameId: ...
    def get_channels(self) -> builtins.set[Channel]: ...
    class Simple(AnalysisId):
        __match_args__ = ("channel",)
        @property
        def channel(self) -> Channel: ...
        def __new__(cls, channel: Channel) -> AnalysisId.Simple: ...

    class Compound(AnalysisId):
        __match_args__ = (
            "name",
            "args",
        )
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> builtins.list[AnalysisId]: ...
        def __new__(
            cls, name: builtins.str, args: typing.Sequence[AnalysisId]
        ) -> AnalysisId.Compound: ...

class AnalysisNameId:
    r"""
    This is the name of a result
    Can be of the simple form "SomeChannelName"
    Or the compound form "Name(OtherID1, OtherID2, ...)"

    Structured to avoid unnecessary string parsing
    """
    @staticmethod
    def from_channel(channel: ChannelName) -> AnalysisNameId: ...
    def __new__(
        cls, name: builtins.str, args: typing.Sequence[AnalysisNameId]
    ) -> AnalysisNameId: ...
    def first_channel(self) -> ChannelName:
        r"""
        get the first channel
        """
    def add_to_set_recursive(
        self, set: builtins.set[AnalysisNameId]
    ) -> builtins.set[AnalysisNameId]:
        r"""
        The set is pass-through ownership so that the function is usable from python

        This function is needed to "flesh out" the collection of analyses request
        by the user to include all intermediate analyses
        """
    def add_trend(self, trend: TrendType) -> AnalysisRequestId: ...
    def to_analysis_name_id(self) -> AnalysisNameId: ...
    def get_channels(self) -> builtins.set[ChannelName]: ...
    class Simple(AnalysisNameId):
        __match_args__ = ("channel",)
        @property
        def channel(self) -> ChannelName: ...
        def __new__(cls, channel: ChannelName) -> AnalysisNameId.Simple: ...

    class Compound(AnalysisNameId):
        __match_args__ = (
            "name",
            "args",
        )
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> builtins.list[AnalysisNameId]: ...
        def __new__(
            cls, name: builtins.str, args: typing.Sequence[AnalysisNameId]
        ) -> AnalysisNameId.Compound: ...

class AnalysisRequestId:
    r"""
    This is the name of a result
    Can be of the simple form "SomeChannelName"
    Or the compound form "Name(OtherID1, OtherID2, ...)"

    Structured to avoid unnecessary string parsing
    """
    @staticmethod
    def from_channel(channel: ChannelId) -> AnalysisRequestId: ...
    def __new__(
        cls, name: builtins.str, args: typing.Sequence[AnalysisRequestId]
    ) -> AnalysisRequestId: ...
    def first_channel(self) -> ChannelId:
        r"""
        get the first channel
        """
    def add_to_set_recursive(
        self, set: builtins.set[AnalysisRequestId]
    ) -> builtins.set[AnalysisRequestId]:
        r"""
        The set is pass-through ownership so that the function is usable from python

        This function is needed to "flesh out" the collection of analyses request
        by the user to include all intermediate analyses
        """
    def add_trend(self, trend: TrendType) -> AnalysisRequestId: ...
    def to_analysis_name_id(self) -> AnalysisNameId: ...
    def get_channels(self) -> builtins.set[ChannelId]: ...
    class Simple(AnalysisRequestId):
        __match_args__ = ("channel",)
        @property
        def channel(self) -> ChannelId: ...
        def __new__(cls, channel: ChannelId) -> AnalysisRequestId.Simple: ...

    class Compound(AnalysisRequestId):
        __match_args__ = (
            "name",
            "args",
        )
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> builtins.list[AnalysisRequestId]: ...
        def __new__(
            cls, name: builtins.str, args: typing.Sequence[AnalysisRequestId]
        ) -> AnalysisRequestId.Compound: ...

class AnalysisSettingsId:
    r"""
    This is the name of a result
    Can be of the simple form "SomeChannelName"
    Or the compound form "Name(OtherID1, OtherID2, ...)"

    Structured to avoid unnecessary string parsing
    """
    @staticmethod
    def from_channel(channel: ChannelSettings) -> AnalysisSettingsId: ...
    def __new__(
        cls, name: builtins.str, args: typing.Sequence[AnalysisSettingsId]
    ) -> AnalysisSettingsId: ...
    def first_channel(self) -> ChannelSettings:
        r"""
        get the first channel
        """
    def add_to_set_recursive(
        self, set: builtins.set[AnalysisSettingsId]
    ) -> builtins.set[AnalysisSettingsId]:
        r"""
        The set is pass-through ownership so that the function is usable from python

        This function is needed to "flesh out" the collection of analyses request
        by the user to include all intermediate analyses
        """
    def add_trend(self, trend: TrendType) -> AnalysisSettingsId: ...
    def to_analysis_name_id(self) -> AnalysisNameId: ...
    def get_channels(self) -> builtins.set[ChannelSettings]: ...
    class Simple(AnalysisSettingsId):
        __match_args__ = ("channel",)
        @property
        def channel(self) -> ChannelSettings: ...
        def __new__(cls, channel: ChannelSettings) -> AnalysisSettingsId.Simple: ...

    class Compound(AnalysisSettingsId):
        __match_args__ = (
            "name",
            "args",
        )
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> builtins.list[AnalysisSettingsId]: ...
        def __new__(
            cls, name: builtins.str, args: typing.Sequence[AnalysisSettingsId]
        ) -> AnalysisSettingsId.Compound: ...

class Channel:
    @property
    def name(self) -> builtins.str: ...
    @property
    def data_type(self) -> NDSDataType: ...
    @property
    def channel_type(self) -> ChannelType: ...
    @property
    def period(self) -> PipDuration: ...
    @property
    def dcu_id(self) -> typing.Optional[builtins.int]: ...
    @property
    def channel_number(self) -> typing.Optional[builtins.int]: ...
    @property
    def calibration(self) -> typing.Optional[builtins.int]: ...
    @property
    def heterodyne_freq_hz(self) -> typing.Optional[builtins.float]: ...
    @property
    def gain(self) -> typing.Optional[builtins.float]: ...
    @property
    def slope(self) -> typing.Optional[builtins.float]: ...
    @property
    def offset(self) -> typing.Optional[builtins.float]: ...
    @property
    def use_active_time(self) -> builtins.bool: ...
    @property
    def units(self) -> Unit: ...
    @property
    def trend_stat(self) -> TrendStat: ...
    @property
    def trend_type(self) -> TrendType: ...
    @property
    def online(self) -> builtins.bool: ...
    @property
    def testpoint(self) -> builtins.bool: ...
    @property
    def rate_hz(self) -> builtins.float: ...
    def __new__(
        cls, name: builtins.str, data_type: NDSDataType, period: PipDuration
    ) -> Channel: ...

class ChannelHeader:
    r"""
    Used internally to map full name and trend info
    this is the minimum needed information
    to generate a request to the cache or other data source
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def trend_type(self) -> TrendType: ...
    @property
    def trend_stat(self) -> TrendStat: ...

class ChannelId:
    r"""
    Provides enough info to query a channel from an NDS server by name.
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def trend_type(self) -> TrendType: ...
    def __new__(cls, name: builtins.str, trend_type: TrendType) -> ChannelId: ...
    def expected_stats(self) -> builtins.list[TrendStat]:
        r"""
        These are the stats we expect to get for a single trend request.
        One ChannelID will return into a channel for each.
        """

class ChannelName:
    r"""
    Provides enough info to query a channel from an NDS server by name.
    """
    @property
    def name(self) -> builtins.str: ...
    def __new__(cls, name: builtins.str) -> ChannelName: ...

class ChannelParams:
    @property
    def active(self) -> builtins.bool: ...
    @property
    def channel(self) -> Channel: ...

class ChannelQuery:
    r"""
    Constraints on a channel query
    to a data source
    """
    def __new__(
        cls,
        pattern: typing.Optional[builtins.str] = None,
        channel_types: typing.Optional[typing.Sequence[ChannelType]] = None,
        data_types: typing.Optional[typing.Sequence[NDSDataType]] = None,
        min_sample_rate: typing.Optional[builtins.float] = None,
        max_sample_rate: typing.Optional[builtins.float] = None,
        gps_start: typing.Optional[builtins.int] = None,
        gps_end: typing.Optional[builtins.int] = None,
    ) -> ChannelQuery: ...

class ChannelSettings:
    r"""
    full record of a channel including some pre-calculated timeline info used
    in DTT tests.
    """
    @property
    def channel(self) -> Channel: ...
    @property
    def raw_decimation_params(self) -> DecimationParameters: ...
    @property
    def heterodyned_decimation_params(self) -> DecimationParameters: ...
    @property
    def do_heterodyne(self) -> builtins.bool: ...
    @property
    def decimation_delays(self) -> DecimationDelays: ...

class ChannelSettingsParams:
    @property
    def active(self) -> builtins.bool: ...
    @property
    def channel(self) -> ChannelSettings: ...

class CustomPipeline: ...

class DTT:
    r"""
    ## immutable "global" values
    A DTT struct stores channels used to communicate with the user.
    The user owns the struct and merely drops it when done.
    The entire core will shut down at that point.
    Most public API is called on this structure.

    Applications should use the init_...() functions to create this structure.
    """
    def set_data_source(self, data_source: DataSource) -> None:
        r"""
        set the desired data source
        """
    def set_test_params(self, params: TestParams) -> None:
        r"""
        Set up a test.  Eventually, the library will send an updated Timeline object
        on the associated output receiver.
        Start the test with run_test().
        An error means the DTT management process has died.
        """
    def run_test(self) -> None:
        r"""
        Start a test.
        The test must already be configured with set_test_params.
        As the test is run, status messages and results will appear on
        the associated output receiver.
        An error means the DTT management process has died.
        """
    def no_op(self) -> None:
        r"""
        Send a no-op message.
        """
    def new_online_scope_view(
        self, set: ViewSet, span_pip: PipDuration
    ) -> ScopeViewHandle:
        r"""
        Create a new online scope view and return a handle to it.
        Drop all clones of the handle to close the view.
        """
    def new_fixed_scope_view(
        self, set: ViewSet, start_pip: PipInstant, end_pip: PipInstant
    ) -> ScopeViewHandle:
        r"""
        Create a new fixed scope view and return a handle to it.
        Drop all clones of the handle to close the view
        """
    def find_channels(self, query: ChannelQuery) -> None: ...
    def __new__(cls, callback: typing.Any) -> DTT:
        r"""
        Creation of a DTT object from Python requires a callback function as an argument.
        The call back will receive [ResponseToUser] messages from the [DTT] object
        Since the [DTT] object is asynchronous under the hood, most methods
        return immediately without any result.  [ResponseToUser] messages
        are the primary way to get feedback from the DTT object.
        """

class DataSource:
    r"""
    wrappers needed for python
    """
    def now(self) -> PipInstant: ...

class DecimationDelays:
    r"""
    collects the delays associated with the total decimation on the channel
    """

    ...

class DecimationParameters:
    r"""
    Values used to generate a decimation pipeline for a single stage of decimation
    """
    @property
    def filter(self) -> DecimationFilter:
        r"""
        anti-aliasing filter
        """
    @property
    def num_decs(self) -> builtins.int:
        r"""
        number of x2 decimations
        """

class Excitation:
    @property
    def channel(self) -> Channel: ...
    @property
    def read_back_channel(self) -> typing.Optional[Channel]: ...

class ExcitationParams:
    @property
    def active(self) -> builtins.bool: ...
    @property
    def excitation(self) -> Excitation: ...

class ExcitationSettings:
    @property
    def channel(self) -> ChannelSettings: ...
    @property
    def read_back_channel(self) -> typing.Optional[ChannelSettings]: ...

class ExcitationSettingsParams:
    @property
    def active(self) -> builtins.bool: ...
    @property
    def excitation(self) -> ExcitationSettings: ...

class FreqDomainArray:
    @property
    def start_gps_pip(self) -> PipInstant: ...
    @property
    def start_hz(self) -> builtins.float: ...
    @property
    def bucket_width_hz(self) -> builtins.float: ...
    @property
    def overlap(self) -> builtins.float: ...
    @property
    def sequence_index(self) -> builtins.int: ...
    @property
    def sequence_size(self) -> builtins.int: ...
    @property
    def n(self) -> builtins.float: ...
    @property
    def data(self) -> typing.Any: ...
    @property
    def id(self) -> AnalysisId: ...
    @property
    def unit(self) -> Unit: ...
    def clone_metadata(
        self, id: AnalysisId, unit: Unit, new_data: typing.Any
    ) -> FreqDomainArray:
        r"""
        Copy everything from another object except replace the data
        with a new python list of data
        """

class InlineFFTParams:
    @property
    def bandwidth_hz(self) -> builtins.float: ...
    @property
    def overlap(self) -> builtins.float: ...
    @property
    def start_pip(self) -> PipInstant: ...
    @property
    def end_pip(self) -> PipInstant: ...
    @property
    def window(self) -> FFTWindow: ...
    @bandwidth_hz.setter
    def bandwidth_hz(self, value: builtins.float) -> None: ...
    @overlap.setter
    def overlap(self, value: builtins.float) -> None: ...
    @start_pip.setter
    def start_pip(self, value: PipInstant) -> None: ...
    @end_pip.setter
    def end_pip(self, value: PipInstant) -> None: ...
    @window.setter
    def window(self, value: FFTWindow) -> None: ...
    def __new__(cls) -> InlineFFTParams: ...

class MessageJob:
    def get_tag(self) -> builtins.str:
        r"""
        Helps with sorting messages without having to match on them first
        """
    class SetMessage(MessageJob):
        __match_args__ = (
            "tag",
            "msg",
        )
        @property
        def tag(self) -> builtins.str: ...
        @property
        def msg(self) -> UserMessage: ...
        def __new__(
            cls, tag: builtins.str, msg: UserMessage
        ) -> MessageJob.SetMessage: ...

    class ClearMessage(MessageJob):
        __match_args__ = ("tag",)
        @property
        def tag(self) -> builtins.str: ...
        def __new__(cls, tag: builtins.str) -> MessageJob.ClearMessage: ...

class NDS2Cache:
    r"""
    Data source that gets all its data directly from an NDS2 server (no local caching).
    """
    def __new__(
        cls, size_bytes: builtins.int, default_file_path: builtins.str
    ) -> NDS2Cache: ...
    def as_ref(self) -> DataSource: ...

class PipDuration:
    def __sub__(self, other: PipDuration) -> PipDuration: ...
    def __add__(self, other: typing.Any) -> typing.Any:
        r"""
        Add a duration to get a combined duration
        or Add a instant to get a new instant
        """
    def __mul__(self, other: typing.Any) -> typing.Any:
        r"""
        Multiply by a number to get a scaled duration
        """
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __truediv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio.
        """
    def __floordiv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio
        """
    def __mod__(self, other: typing.Any) -> typing.Any:
        r"""
        Get the remainder from an equivalent integer division
        """
    def __neg__(self) -> typing.Any: ...
    def __pos__(self) -> typing.Any: ...
    def __abs__(self) -> typing.Any: ...
    @staticmethod
    def freq_hz_to_period(rate_hz: builtins.float) -> PipDuration:
        r"""
        Convert a frequency as Hz into a duration that represents the corresponding period.
        """
    def period_to_freq_hz(self) -> builtins.float:
        r"""
        Convert a duration that represents a period into the corresponding frequency as Hz.
        """
    @staticmethod
    def from_seconds(seconds: builtins.float) -> PipDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_seconds(self) -> builtins.float:
        r"""
        Return the length of the duration as seconds.
        """
    @staticmethod
    def from_sec(seconds: builtins.int) -> PipDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_sec(self) -> builtins.int:
        r"""
        Round the duration to the nearest second.

        Return 0 for negative durations.
        """
    @staticmethod
    def from_nanoseconds(nanoseconds: builtins.int) -> PipDuration:
        r"""
        Create a duration given the length in nanoseconds.
        """
    def to_nanoseconds(self) -> builtins.int:
        r"""
        Return the length to the nearest nanosecond,
        but return zero if the duration is negative.
        """
    def to_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the length as seconds and nanoseconds
        """
    @staticmethod
    def from_pips(pips: builtins.int) -> PipDuration:
        r"""
        Create  a duration object from a numerical value of the same units.
        """
    @staticmethod
    def from_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> PipDuration:
        r"""
        Create a duration given the length as seconds and nanoseconds
        """
    def to_pips(self) -> builtins.int:
        r"""
        Return duration in units of the type..
        """
    def is_empty(self) -> builtins.bool:
        r"""
        True if the length of the duration is zero.
        """
    def abs(self) -> PipDuration:
        r"""
        Return a non-negative duration of the same magnitude.
        """
    def snap_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: PipDuration) -> PipDuration:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class PipInstant:
    def __add__(self, other: PipDuration) -> PipInstant: ...
    def __sub__(self, other: typing.Any) -> typing.Any:
        r"""
        Subtract a duration to get an instant,
        or subtract a instant to get the difference as a duration.
        """
    @staticmethod
    def now() -> PipInstant:
        r"""
        return the current time
        """
    def to_gpst_pips(self) -> builtins.int:
        r"""
        Return the number of steps since the GPS epoch.
        """
    def to_gpst_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the nearest nanosecond since the GPS epoch.
        """
    def to_gpst_nanoseconds(self) -> builtins.int:
        r"""
        If positive, return nanoseconds since the GPS epoch, otherwise zero.
        """
    def to_gpst_sec(self) -> builtins.int:
        r"""
        Return the seconds since GPS epoch rounded down to the latest second
        earlier than or coincident with the instant.

        Returns 0 for instants before the GPS epoch.
        """
    def to_gpst_seconds(self) -> builtins.float:
        r"""
        Return the number of seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> PipInstant:
        r"""
        Create an instant given seconds + nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_nanoseconds(nano: builtins.int) -> PipInstant:
        r"""
        Create an instant given nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds(seconds: builtins.float) -> PipInstant:
        r"""
        Create an instant given seconds since the GPS epoch.
        """
    @staticmethod
    def gpst_epoch() -> PipInstant:
        r"""
        Create an instant at Midnight UTC, Jan 6 1980,
        the reference epoch for the GPS time system.
        """
    @staticmethod
    def from_gpst_sec(seconds: builtins.int) -> PipInstant:
        r"""
        Create an instant given whole seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_pips(pips: builtins.int) -> PipInstant:
        r"""
        Create an instant given steps since the GPS epoch.
        """
    def snap_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: PipDuration) -> PipInstant:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class ResponseToUser:
    r"""
    Any data sent to the user from a [DTT] struct
    In python, these will be passed to the callback function
    passed to the [dttlib.init](crate::python::dttlib::init) function
    """
    class AllMessages(ResponseToUser):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.dict[builtins.str, UserMessage]: ...
        def __new__(
            cls, _0: typing.Mapping[builtins.str, UserMessage]
        ) -> ResponseToUser.AllMessages: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class UpdateMessages(ResponseToUser):
        __match_args__ = ("message_job",)
        @property
        def message_job(self) -> MessageJob: ...
        def __new__(cls, message_job: MessageJob) -> ResponseToUser.UpdateMessages: ...

    class NewTimeline(ResponseToUser):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Timeline: ...
        def __new__(cls, _0: Timeline) -> ResponseToUser.NewTimeline: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class NewResult(ResponseToUser):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> typing.Any: ...
        def __new__(cls, _0: typing.Any) -> ResponseToUser.NewResult: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class FinalResults(ResponseToUser):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> ResultsRecord: ...
        def __new__(cls, _0: ResultsRecord) -> ResponseToUser.FinalResults: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class ScopeViewResult(ResponseToUser):
        __match_args__ = (
            "id",
            "result",
        )
        @property
        def id(self) -> builtins.int: ...
        @property
        def result(self) -> typing.Any: ...
        def __new__(
            cls, id: builtins.int, result: typing.Any
        ) -> ResponseToUser.ScopeViewResult: ...

    class ScopeViewDone(ResponseToUser):
        __match_args__ = ("id",)
        @property
        def id(self) -> builtins.int: ...
        def __new__(cls, id: builtins.int) -> ResponseToUser.ScopeViewDone: ...

    class ChannelQueryResult(ResponseToUser):
        __match_args__ = ("channels",)
        @property
        def channels(self) -> builtins.list[Channel]: ...
        def __new__(
            cls, channels: typing.Sequence[Channel]
        ) -> ResponseToUser.ChannelQueryResult: ...

    ...

class ResultsRecord:
    r"""
    Store analysis results for a given test.
    """

    ...

class ScopeViewHandle:
    r"""
    Clonable handle used to update a view
    """
    @property
    def id(self) -> builtins.int: ...
    def set_fft_params(self, params: InlineFFTParams) -> None: ...
    def update(
        self,
        span_pip: typing.Optional[PipDuration] = None,
        start_pip: typing.Optional[PipInstant] = None,
        end_pip: typing.Optional[PipInstant] = None,
    ) -> None:
        r"""
        Update the span of a view.  This is a pythonic wrapper.  Rust code should call update_online() or update_fixed().
        """
    def close(self) -> None: ...
    def get_result_store(self) -> builtins.dict[AnalysisId, typing.Any]: ...

class SimpleUnit:
    r"""
    allow some standard units
    to take care of custom string generation
    and handling of slightly different unit names for the same units
    and, potentially for some automatic conversion.
    """
    class Counts(SimpleUnit):
        __match_args__ = ((),)
        def __new__(cls) -> SimpleUnit.Counts: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class Custom(SimpleUnit):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0: builtins.str) -> SimpleUnit.Custom: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    ...

class StartTime:
    r"""
    An unbound StartTime will be bound when the run starts.
    """
    @staticmethod
    def new(start_pip: typing.Optional[PipInstant]) -> StartTime: ...
    class Unbound(StartTime):
        r"""
        An unbound start time means the start of the test is not yet determined.
        """

        __match_args__ = ((),)
        def __new__(cls) -> StartTime.Unbound: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...

    class Bound(StartTime):
        r"""
        A bound start time holds the start time of the test
        """

        __match_args__ = ("start_pip",)
        @property
        def start_pip(self) -> PipInstant:
            r"""
            The start time of the test.
            """
        def __new__(cls, start_pip: PipInstant) -> StartTime.Bound: ...

class TestParams:
    @property
    def version(self) -> builtins.int:
        r"""
        # Version
        increment this number if releasing a new version of the struct
        """
    @property
    def test_type(self) -> TestType:
        r"""
        # Test Type
        """
    @property
    def start_time_pip(self) -> StartTime:
        r"""
        # Start Time
        """
    @property
    def measurement_time_pip(self) -> PipDuration:
        r"""
        # time constraints
        if both time and cycles are set to true,
        then the measurement span will be
        the least time that satisfies both.
        minimum time span of a single segment
        """
    @property
    def use_measurement_time(self) -> builtins.bool: ...
    @property
    def measurement_cycles(self) -> builtins.int:
        r"""
        minimum number of cycles
        """
    @property
    def use_measurement_cycles(self) -> builtins.bool: ...
    @property
    def settling_time_frac(self) -> builtins.float:
        r"""
        # ramps and settling
        fraction of measurement time needed to "settle" the system
        """
    @property
    def ramp_down_pip(self) -> PipDuration:
        r"""
        time to ramp down excitations
        """
    @property
    def ramp_up_pip(self) -> PipDuration:
        r"""
        time to ramp up excitations
        """
    @property
    def calc_power_spectrum(self) -> builtins.bool:
        r"""
        # sine_options config
        Whether to calculate power spectrum
        Needed for sine response and swept sine
        """
    @property
    def max_harmonic_order(self) -> builtins.int:
        r"""
        Maximum harmonic order to calculate
        """
    @property
    def average_size(self) -> builtins.int:
        r"""
        # Averaging
        Total number of segments to average
        """
    @property
    def average_type(self) -> AverageType: ...
    @property
    def measurement_channels(self) -> builtins.list[ChannelSettingsParams]:
        r"""
        ## channel parameters
        """
    @property
    def excitations(self) -> builtins.list[ExcitationSettingsParams]: ...
    @property
    def start_hz(self) -> builtins.float:
        r"""
        # FFT Tools params
        """
    @property
    def stop_hz(self) -> builtins.float: ...
    @property
    def band_width_hz(self) -> builtins.float: ...
    @property
    def overlap(self) -> builtins.float:
        r"""
        as a fraction of the length of one segment
        """
    @property
    def remove_mean(self) -> builtins.bool:
        r"""
        when true, subtract out the mean
        """
    @property
    def quiet_time_pip(self) -> PipDuration:
        r"""
        time of from end of excitation to end of measurement
        purpose is to prevent correlation from one segment to the next
        due to time delay when using a random input
        """
    @property
    def remove_decimation_delay(self) -> builtins.bool:
        r"""
        when false, don't remove the delay incurred by decimation filters
        this should maybe always be true!
        """
    @property
    def fft_window(self) -> FFTWindow:
        r"""
        Attenuation window to use on FFT input
        """
    @property
    def custom_pipelines(self) -> builtins.list[CustomPipeline]:
        r"""
        Custom pipelines
        User-provided pipelines written in python.
        """
    @staticmethod
    def default_fft_params() -> TestParams: ...

class ThumpDuration:
    def __sub__(self, other: ThumpDuration) -> ThumpDuration: ...
    def __add__(self, other: typing.Any) -> typing.Any:
        r"""
        Add a duration to get a combined duration
        or Add a instant to get a new instant
        """
    def __mul__(self, other: typing.Any) -> typing.Any:
        r"""
        Multiply by a number to get a scaled duration
        """
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __truediv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio.
        """
    def __floordiv__(self, other: typing.Any) -> typing.Any:
        r"""
        Divide by a float or number to get a scaled duration
        Divide by a duration to get a ratio
        """
    def __mod__(self, other: typing.Any) -> typing.Any:
        r"""
        Get the remainder from an equivalent integer division
        """
    def __neg__(self) -> typing.Any: ...
    def __pos__(self) -> typing.Any: ...
    def __abs__(self) -> typing.Any: ...
    @staticmethod
    def freq_hz_to_period(rate_hz: builtins.float) -> ThumpDuration:
        r"""
        Convert a frequency as Hz into a duration that represents the corresponding period.
        """
    def period_to_freq_hz(self) -> builtins.float:
        r"""
        Convert a duration that represents a period into the corresponding frequency as Hz.
        """
    @staticmethod
    def from_seconds(seconds: builtins.float) -> ThumpDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_seconds(self) -> builtins.float:
        r"""
        Return the length of the duration as seconds.
        """
    @staticmethod
    def from_sec(seconds: builtins.int) -> ThumpDuration:
        r"""
        Create a duration given the length in seconds.
        """
    def to_sec(self) -> builtins.int:
        r"""
        Round the duration to the nearest second.

        Return 0 for negative durations.
        """
    @staticmethod
    def from_nanoseconds(nanoseconds: builtins.int) -> ThumpDuration:
        r"""
        Create a duration given the length in nanoseconds.
        """
    def to_nanoseconds(self) -> builtins.int:
        r"""
        Return the length to the nearest nanosecond,
        but return zero if the duration is negative.
        """
    def to_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the length as seconds and nanoseconds
        """
    @staticmethod
    def from_thumps(thumps: builtins.int) -> ThumpDuration:
        r"""
        Create  a duration object from a numerical value of the same units.
        """
    @staticmethod
    def from_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> ThumpDuration:
        r"""
        Create a duration given the length as seconds and nanoseconds
        """
    def to_thumps(self) -> builtins.int:
        r"""
        Return duration in units of the type..
        """
    def is_empty(self) -> builtins.bool:
        r"""
        True if the length of the duration is zero.
        """
    def abs(self) -> ThumpDuration:
        r"""
        Return a non-negative duration of the same magnitude.
        """
    def snap_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: ThumpDuration) -> ThumpDuration:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class ThumpInstant:
    def __add__(self, other: ThumpDuration) -> ThumpInstant: ...
    def __sub__(self, other: typing.Any) -> typing.Any:
        r"""
        Subtract a duration to get an instant,
        or subtract a instant to get the difference as a duration.
        """
    @staticmethod
    def now() -> ThumpInstant:
        r"""
        return the current time
        """
    def to_gpst_thumps(self) -> builtins.int:
        r"""
        Return the number of steps since the GPS epoch.
        """
    def to_gpst_seconds_nanoseconds(self) -> tuple[builtins.int, builtins.int]:
        r"""
        Return the nearest nanosecond since the GPS epoch.
        """
    def to_gpst_nanoseconds(self) -> builtins.int:
        r"""
        If positive, return nanoseconds since the GPS epoch, otherwise zero.
        """
    def to_gpst_sec(self) -> builtins.int:
        r"""
        Return the seconds since GPS epoch rounded down to the latest second
        earlier than or coincident with the instant.

        Returns 0 for instants before the GPS epoch.
        """
    def to_gpst_seconds(self) -> builtins.float:
        r"""
        Return the number of seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds_nanoseconds(
        seconds: builtins.int, nano: builtins.int
    ) -> ThumpInstant:
        r"""
        Create an instant given seconds + nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_nanoseconds(nano: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given nanoseconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_seconds(seconds: builtins.float) -> ThumpInstant:
        r"""
        Create an instant given seconds since the GPS epoch.
        """
    @staticmethod
    def gpst_epoch() -> ThumpInstant:
        r"""
        Create an instant at Midnight UTC, Jan 6 1980,
        the reference epoch for the GPS time system.
        """
    @staticmethod
    def from_gpst_sec(seconds: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given whole seconds since the GPS epoch.
        """
    @staticmethod
    def from_gpst_thumps(thumps: builtins.int) -> ThumpInstant:
        r"""
        Create an instant given steps since the GPS epoch.
        """
    def snap_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the nearest integer multiple of a step size.
        """
    def snap_down_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the largest integer <= self that's a multiple of a step size.

        Like snap_to_step, but takes the floor rather than the nearest.
        """
    def snap_up_to_step(self, step: ThumpDuration) -> ThumpInstant:
        r"""
        Snap to the smallest integer >= self that's a multiple of a step size.

        Like snap_to_step, but takes the ceiling rather than the nearest.
        """
    @staticmethod
    def rate_hz() -> builtins.int:
        r"""
        Return the rate of the units in Hz
        """

class TimeDomainArray:
    @property
    def start_gps_pip(self) -> PipInstant: ...
    @property
    def period_pip(self) -> PipDuration: ...
    @property
    def n(self) -> builtins.float: ...
    @property
    def sequence_index(self) -> builtins.int: ...
    @property
    def sequence_size(self) -> builtins.int: ...
    @property
    def data(self) -> typing.Any: ...
    @property
    def total_gap_size(self) -> builtins.int: ...
    @property
    def id(self) -> AnalysisId: ...
    @property
    def unit(self) -> Unit: ...
    @property
    def rate_hz(self) -> builtins.float: ...
    def end_gps_pip(self) -> PipInstant:
        r"""
        return the time of the first timestamp after the end of the time series
        equal to the start time of the following series if it is contiguous.
        """
    def len(self) -> builtins.int: ...
    def is_empty(self) -> builtins.bool: ...
    def index_to_gps_instant(self, index: builtins.int) -> PipInstant: ...
    def gps_instant_to_index(self, instant: PipInstant) -> builtins.int:
        r"""
        return the a non-negative index that's closes to the time given
        if the time given is before the start, the return value is zero
        but the return value can be greater or equal to the length of the array
        and therefore out of bounds
        """
    def timestamps(self) -> builtins.list[PipInstant]: ...
    def delta_t_seconds(self, t0: PipInstant) -> builtins.list[builtins.float]:
        r"""
        Get the timestamps transformed into a delta time from some t0
        return values in seconds as floating point
        Useful for getting relative timestamps to a point of time on a graph
        """

class Timeline: ...

class Unit:
    r"""
    map a simple unit to a rational power
    """

    ...

class UserMessage:
    @property
    def severity(self) -> Severity: ...
    @property
    def message(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class ViewSet:
    @staticmethod
    def from_channels(channels: typing.Sequence[Channel]) -> ViewSet:
        r"""
        convenience function
        for turning a simple list of channels into a ViewSet
        """
    @staticmethod
    def from_channel_names(
        channel_names: typing.Sequence[builtins.str], trend: TrendType
    ) -> ViewSet:
        r"""
        convenience function
        for turning a simple list of channel names into a ViewSet with
        unresolved channel names
        """
    @staticmethod
    def from_analysis_request_ids(
        request_ids: builtins.set[AnalysisRequestId],
    ) -> ViewSet: ...
    def has_unresolved_channels(self) -> builtins.bool: ...
    def to_resolved_channel_names(self) -> builtins.list[builtins.str]:
        r"""
        Return the resolved names of any channels in the set
        Including expected resolved names of unresolved channels.
        """

class AverageType(Enum):
    Fixed = ...
    Exponential = ...
    Accumulative = ...
    ConvergingExponential = ...

class ChannelType(Enum):
    r"""
    channel type is used in NDS queries.  I'm not sure how
    important these are, or how they map to NDS records.
    """

    Unknown = ...
    Online = ...
    Raw = ...
    RDS = ...
    STrend = ...
    MTrend = ...
    TestPoint = ...
    Static = ...

class DataFlow(Enum):
    Unordered = ...
    r"""
    Data is sent repeatedly as
    more of the request is filled in.
    
    Each response gives all the data available.
    
    This is how NDScope expects data.
    """
    Ordered = ...
    r"""
    Data is returned from the earliest time stamp to the latest.
    Data is returned only once.
    This is how DTT expects data.
    """

class DecimationFilter(Enum):
    FirLS1 = ...
    FirPM1 = ...
    FirLS2 = ...
    FirLS3 = ...

class FFTWindow(Enum):
    Uniform = ...
    Hann = ...
    FlatTop = ...
    Welch = ...
    Bartlett = ...
    BlackmanHarris = ...
    Hamming = ...

class NDSDataType(Enum):
    r"""
    These values are taken from the NDS2 client
    With a hoped-for extension for
    Complex128
    Note the names for complex take the total size of the number
    Not the size of real or imaginary components as the actual NDS2 client does.

    So an NDS2 Client type Complex32 is an NDSDataType::Complex64
    """

    Int16 = ...
    Int32 = ...
    Int64 = ...
    Float32 = ...
    Float64 = ...
    Complex64 = ...
    UInt32 = ...
    Complex128 = ...
    r"""
    not yet implemented in NDS or Arrakis
    """
    UInt64 = ...
    UInt16 = ...
    Int8 = ...
    UInt8 = ...

class Severity(Enum):
    Debug = ...
    Notice = ...
    ConfigurationWarning = ...
    Warning = ...
    Error = ...
    ConfigurationError = ...
    FatalError = ...
    SystemError = ...

class TestType(Enum):
    r"""
    Parameters unique to the test type
    """

    FFTTools = ...
    SweptSine = ...
    SineResponse = ...
    TimeSeries = ...

class TrendStat(Enum):
    r"""
    Channel statistics type for a trend channel, or Raw for raw channels
    """

    Raw = ...
    r"""
    Raw data, not a trend channel
    """
    Mean = ...
    Rms = ...
    r"""
    Root-mean-square
    """
    Min = ...
    Max = ...
    N = ...
    r"""
    Number of data points in the trend bucket
    """

    def data_name(self) -> builtins.str:
        r"""
        used for names of exported data blocks
        """

class TrendType(Enum):
    r"""
    The trend of a ChannelId
    """

    Raw = ...
    Minute = ...
    Second = ...
