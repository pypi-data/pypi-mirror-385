#!/usr/bin/env python3
"""
Nmap NSE Vulnerability Analyzer
Based on vulnerscom/nmap-vulners NSE scripts research

This module provides vulnerability scanning capabilities inspired by:
- vulnerscom/nmap-vulners: https://github.com/vulnerscom/nmap-vulners
- vulners.nse: Core vulnerability detection script
- vulners_enterprise.nse: Enterprise API integration
- http-vulners-regex.nse: HTTP service vulnerability detection

Author: Security Research Team
Date: 2024
Version: 1.5
"""

import xml.etree.ElementTree as ET
import json
import re
import requests
import time
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass
from urllib.parse import quote
import hashlib

# Vulnerability Analyzer Integration
try:
    from vulnerability_analyzer import VulnerabilityAnalyzer
    VULN_ANALYZER_AVAILABLE = True
except ImportError:
    VULN_ANALYZER_AVAILABLE = False

@dataclass
class VulnerabilityMatch:
    """Represents a vulnerability match with detailed information"""
    cve_id: str
    severity: str
    cvss_score: float
    description: str
    published_date: str
    modified_date: str
    source: str  # 'vulners_api', 'local_db', 'pattern_match', 'nse_script'
    confidence: float
    exploit_available: bool = False
    metasploit_module: str = ""
    references: List[str] = None
    
    def __post_init__(self):
        if self.references is None:
            self.references = []

class NmapVulnersAnalyzer:
    """
    NSE Vulnerability Analysis Engine
    
    Implements vulnerability detection patterns from vulnerscom/nmap-vulners:
    - vulners.nse: General vulnerability scanning
    - vulners_enterprise.nse: API-based enterprise scanning  
    - http-vulners-regex.nse: HTTP service regex patterns
    """
    
    def __init__(self, xml_file: str, vuln_db_path: str = None, api_key: str = None):
        self.xml_file = Path(xml_file)
        self.vuln_db_path = vuln_db_path
        self.api_key = api_key
        self.tree = None
        self.root = None
        
        # Initialize vulnerability analyzer
        if VULN_ANALYZER_AVAILABLE and vuln_db_path:
            try:
                self.vuln_analyzer = VulnerabilityAnalyzer(vuln_db_path)
                self.logger.info(f"Local vulnerability database loaded: {self.vuln_analyzer.get_vulnerability_count()} entries")
            except Exception as e:
                self.logger.warning(f"Could not load local vulnerability database: {e}")
                self.vuln_analyzer = None
        else:
            self.vuln_analyzer = None
        
        # Load NSE-based vulnerability patterns
        self.nse_patterns = self._load_nse_patterns()
        self.http_regex_patterns = self._load_http_regex_patterns()
        self.service_vulns = self._load_service_vulnerabilities()
        
        # API configuration
        self.vulners_api_base = "https://vulners.com/api/v3"
        self.api_rate_limit = 1.0  # seconds between API calls
        self.last_api_call = 0
        
        # Statistics tracking
        self.stats = {
            'vulnerabilities_found': 0,
            'api_calls_made': 0,
            'local_db_hits': 0,
            'pattern_matches': 0,
            'nse_detections': 0
        }
        
        self._setup_logging()
        self._parse_xml()
    
    def _setup_logging(self):
        """Configure detailed logging for vulnerability analysis"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('nmap_vulners_analysis.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _load_nse_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Load NSE script patterns based on vulnerscom/nmap-vulners research
        
        Patterns derived from:
        - vulners.nse: General service vulnerability patterns
        - vulners_enterprise.nse: Enterprise-specific patterns
        """
        return {
            'ssh_vulns': [
                {
                    'pattern': r'OpenSSH[_\s]+([0-9]+\.[0-9]+)',
                    'severity_map': {
                        '6.6': 'medium',  # CVE-2014-2653
                        '6.7': 'medium',  # CVE-2014-2653  
                        '6.8': 'medium',  # CVE-2015-5352
                        '6.9': 'low',     # CVE-2015-6563
                        '7.0': 'medium',  # CVE-2015-8325
                        '7.1': 'medium',  # CVE-2016-0777
                        '7.2': 'medium',  # CVE-2016-0778
                        '7.3': 'low',     # CVE-2016-6210
                        '7.4': 'high',    # CVE-2016-10009
                    },
                    'description': 'OpenSSH version vulnerability check'
                },
                {
                    'pattern': r'libssh[_\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '0.6.3': 'critical',  # CVE-2016-0739
                        '0.7.3': 'high',      # CVE-2017-6318
                        '0.8.5': 'medium',    # CVE-2018-10933
                    },
                    'description': 'libssh vulnerability check'
                }
            ],
            'web_vulns': [
                {
                    'pattern': r'Apache[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '2.2.34': 'high',    # CVE-2017-15710
                        '2.4.25': 'medium',  # CVE-2016-8743
                        '2.4.29': 'medium',  # CVE-2017-9798
                        '2.4.33': 'medium',  # CVE-2018-1283
                    },
                    'description': 'Apache HTTP Server vulnerability check'
                },
                {
                    'pattern': r'nginx[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '1.10.3': 'medium',  # CVE-2017-7529
                        '1.12.2': 'medium',  # CVE-2017-7529
                        '1.13.12': 'medium', # CVE-2018-16843
                    },
                    'description': 'Nginx vulnerability check'
                },
                {
                    'pattern': r'Microsoft-IIS[/\s]+([0-9]+\.[0-9]+)',
                    'severity_map': {
                        '6.0': 'high',    # Multiple CVEs
                        '7.0': 'high',    # CVE-2010-2730
                        '7.5': 'medium',  # CVE-2015-1635
                        '8.0': 'medium',  # CVE-2015-1635
                        '8.5': 'low',     # Minimal known vulns
                    },
                    'description': 'Microsoft IIS vulnerability check'
                }
            ],
            'database_vulns': [
                {
                    'pattern': r'MySQL[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '5.5.60': 'medium',  # CVE-2018-2767
                        '5.6.40': 'medium',  # CVE-2018-2817
                        '5.7.22': 'medium',  # CVE-2018-3066
                        '8.0.11': 'medium',  # CVE-2018-3133
                    },
                    'description': 'MySQL vulnerability check'
                },
                {
                    'pattern': r'PostgreSQL[/\s]+([0-9]+\.[0-9]+)',
                    'severity_map': {
                        '9.3': 'medium',   # CVE-2018-1058
                        '9.4': 'medium',   # CVE-2018-1058
                        '9.5': 'medium',   # CVE-2018-1058
                        '9.6': 'low',      # CVE-2018-1115
                        '10.0': 'low',     # CVE-2018-1115
                    },
                    'description': 'PostgreSQL vulnerability check'
                }
            ],
            'ftp_vulns': [
                {
                    'pattern': r'vsftpd[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '2.3.4': 'critical',  # Backdoor
                        '3.0.2': 'medium',    # CVE-2015-1419
                        '3.0.3': 'low',       # Minimal issues
                    },
                    'description': 'vsftpd vulnerability check'
                },
                {
                    'pattern': r'ProFTPD[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '1.3.3': 'high',     # CVE-2011-4130
                        '1.3.4': 'medium',   # CVE-2013-4359
                        '1.3.5': 'medium',   # CVE-2015-3306
                    },
                    'description': 'ProFTPD vulnerability check'
                }
            ],
            'smb_vulns': [
                {
                    'pattern': r'Samba[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                    'severity_map': {
                        '3.5.0': 'critical',  # CVE-2012-1182
                        '3.6.25': 'high',     # CVE-2017-7494
                        '4.0.25': 'high',     # CVE-2017-7494
                        '4.4.14': 'medium',   # CVE-2017-12163
                    },
                    'description': 'Samba vulnerability check'
                }
            ]
        }
    
    def _load_http_regex_patterns(self) -> List[Dict[str, Any]]:
        """
        Load HTTP regex patterns from http-vulners-regex.nse research
        
        Based on: https://github.com/vulnerscom/nmap-vulners/blob/master/http-vulners-regex.nse
        """
        return [
            {
                'name': 'Apache Struts',
                'pattern': r'Struts[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                'paths': ['/struts/', '/struts2/', '/S2-'],
                'severity': 'critical',
                'description': 'Apache Struts framework detection'
            },
            {
                'name': 'Spring Framework',
                'pattern': r'Spring[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                'paths': ['/spring/', '/springframework/'],
                'severity': 'medium',
                'description': 'Spring Framework detection'
            },
            {
                'name': 'Django',
                'pattern': r'Django[/\s]+([0-9]+\.[0-9]+)',
                'paths': ['/django/', '/admin/', '/__debug__/'],
                'severity': 'low',
                'description': 'Django framework detection'
            },
            {
                'name': 'WordPress',
                'pattern': r'WordPress[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                'paths': ['/wp-admin/', '/wp-content/', '/wp-includes/'],
                'severity': 'medium',
                'description': 'WordPress CMS detection'
            },
            {
                'name': 'Joomla',
                'pattern': r'Joomla[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                'paths': ['/administrator/', '/components/', '/modules/'],
                'severity': 'medium',
                'description': 'Joomla CMS detection'
            },
            {
                'name': 'Drupal',
                'pattern': r'Drupal[/\s]+([0-9]+\.[0-9]+)',
                'paths': ['/drupal/', '/sites/default/', '/core/'],
                'severity': 'medium',
                'description': 'Drupal CMS detection'
            },
            {
                'name': 'phpMyAdmin',
                'pattern': r'phpMyAdmin[/\s]+([0-9]+\.[0-9]+\.[0-9]+)',
                'paths': ['/phpmyadmin/', '/pma/', '/phpMyAdmin/'],
                'severity': 'high',
                'description': 'phpMyAdmin interface detection'
            },
            {
                'name': 'Jenkins',
                'pattern': r'Jenkins[/\s]+([0-9]+\.[0-9]+)',
                'paths': ['/jenkins/', '/job/', '/view/'],
                'severity': 'high',
                'description': 'Jenkins CI/CD detection'
            }
        ]
    
    def _load_service_vulnerabilities(self) -> Dict[str, List[str]]:
        """
        Load service-specific vulnerability databases
        
        Service patterns for common vulnerable configurations
        """
        return {
            'telnet': [
                'CVE-1999-0619',  # Telnet environment variable passing
                'CVE-2011-4862',  # Telnet encryption bypass
            ],
            'rlogin': [
                'CVE-1999-0651',  # rlogin trusted host bypass
                'CVE-2002-0391',  # Integer overflow in BSD rlogin
            ],
            'rsh': [
                'CVE-1999-0651',  # rsh trusted host bypass
                'CVE-2019-6116',  # rsh arbitrary command execution
            ],
            'finger': [
                'CVE-1999-0612',  # Finger information disclosure
                'CVE-2003-0914',  # GNU Finger buffer overflow
            ],
            'nntp': [
                'CVE-2002-0909',  # INN NNTP server buffer overflow
                'CVE-2004-0574',  # Multiple NNTP server vulnerabilities
            ],
            'pop2': [
                'CVE-2000-0840',  # POP2 server buffer overflow
                'CVE-2005-1937',  # Multiple POP2 vulnerabilities
            ],
            'uucp': [
                'CVE-1999-0169',  # UUCP arbitrary file access
                'CVE-2004-2771',  # UUCP privilege escalation
            ],
            'chargen': [
                'CVE-1999-0103',  # UDP chargen amplification attack
                'CVE-2019-19781',  # Chargen DDoS amplification
            ],
            'discard': [
                'CVE-1999-0103',  # UDP discard amplification attack
            ],
            'echo': [
                'CVE-1999-0103',  # UDP echo amplification attack
            ],
            'systat': [
                'CVE-1999-0626',  # Systat information disclosure
            ],
            'netstat': [
                'CVE-1999-0626',  # Netstat information disclosure
            ],
            'x11': [
                'CVE-1999-0526',  # X11 unauthorized access
                'CVE-2004-0419',  # X11 font server vulnerabilities
            ]
        }
    
    def _parse_xml(self):
        """Parse Nmap XML with focus on NSE script output"""
        try:
            self.logger.info(f"Parsing Nmap XML: {self.xml_file}")
            self.tree = ET.parse(self.xml_file)
            self.root = self.tree.getroot()
            self.logger.info("XML parsing completed successfully")
            
        except ET.ParseError as e:
            self.logger.error(f"XML parsing error: {e}")
            raise
        except FileNotFoundError:
            self.logger.error(f"XML file not found: {self.xml_file}")
            raise
    
    def analyze_vulnerabilities(self) -> Dict[str, Any]:
        """
        Main vulnerability analysis method
        
        Implements multi-source vulnerability detection:
        1. NSE script output parsing
        2. Service version analysis
        3. Vulners API integration (if API key provided)
        4. Local vulnerability database lookup
        5. Pattern-based detection
        """
        results = {
            'hosts': [],
            'summary': {
                'total_vulnerabilities': 0,
                'critical_count': 0,
                'high_count': 0,
                'medium_count': 0,
                'low_count': 0,
                'info_count': 0
            },
            'statistics': self.stats,
            'analysis_metadata': {
                'analyzer_version': '1.5',
                'analysis_time': datetime.now().isoformat(),
                'sources': {
                    'nse_scripts': True,
                    'service_patterns': True,
                    'local_database': self.vuln_analyzer is not None,
                    'vulners_api': self.api_key is not None,
                    'http_regex_patterns': True
                }
            },
            'github_references': {
                'nmap_vulners': 'https://github.com/vulnerscom/nmap-vulners',
                'vulners_nse': 'https://github.com/vulnerscom/nmap-vulners/blob/master/vulners.nse',
                'vulners_enterprise': 'https://github.com/vulnerscom/nmap-vulners/blob/master/vulners_enterprise.nse',
                'http_vulners_regex': 'https://github.com/vulnerscom/nmap-vulners/blob/master/http-vulners-regex.nse'
            }
        }
        
        # Process each host
        for host_elem in self.root.findall('host'):
            host_result = self._analyze_host(host_elem)
            if host_result:
                results['hosts'].append(host_result)
                
                # Update summary statistics
                for vuln in host_result.get('vulnerabilities', []):
                    results['summary']['total_vulnerabilities'] += 1
                    severity = vuln.severity.lower()
                    
                    if severity == 'critical':
                        results['summary']['critical_count'] += 1
                    elif severity == 'high':
                        results['summary']['high_count'] += 1
                    elif severity == 'medium':
                        results['summary']['medium_count'] += 1
                    elif severity == 'low':
                        results['summary']['low_count'] += 1
                    else:
                        results['summary']['info_count'] += 1
        
        results['statistics'] = self.stats
        
        self.logger.info(f"Vulnerability analysis completed: {results['summary']['total_vulnerabilities']} vulnerabilities found")
        return results
    
    def _analyze_host(self, host_elem) -> Optional[Dict[str, Any]]:
        """Analyze individual host for vulnerabilities"""
        # Extract basic host information
        addresses = []
        for addr_elem in host_elem.findall('address'):
            addresses.append({
                'addr': addr_elem.get('addr'),
                'addrtype': addr_elem.get('addrtype')
            })
        
        if not addresses:
            return None
            
        # Check if host is up
        status_elem = host_elem.find('status')
        if status_elem is None or status_elem.get('state') != 'up':
            return None
        
        host_result = {
            'ip': addresses[0]['addr'],
            'addresses': addresses,
            'hostnames': [],
            'vulnerabilities': [],
            'services': [],
            'nse_scripts': []
        }
        
        # Extract hostnames
        hostnames_elem = host_elem.find('hostnames')
        if hostnames_elem is not None:
            for hostname_elem in hostnames_elem.findall('hostname'):
                host_result['hostnames'].append(hostname_elem.get('name'))
        
        # Analyze ports and services
        ports_elem = host_elem.find('ports')
        if ports_elem is not None:
            for port_elem in ports_elem.findall('port'):
                port_result = self._analyze_port(port_elem)
                if port_result:
                    host_result['services'].append(port_result)
                    host_result['vulnerabilities'].extend(port_result.get('vulnerabilities', []))
                    host_result['nse_scripts'].extend(port_result.get('nse_scripts', []))
        
        # Analyze host-level NSE scripts
        hostscript_elem = host_elem.find('hostscript')
        if hostscript_elem is not None:
            for script_elem in hostscript_elem.findall('script'):
                script_vulns = self._analyze_nse_script(script_elem)
                host_result['vulnerabilities'].extend(script_vulns)
                host_result['nse_scripts'].append({
                    'id': script_elem.get('id'),
                    'output': script_elem.get('output', ''),
                    'vulnerabilities_found': len(script_vulns)
                })
        
        return host_result
    
    def _analyze_port(self, port_elem) -> Optional[Dict[str, Any]]:
        """Analyze individual port for vulnerabilities"""
        port_result = {
            'port': int(port_elem.get('portid')),
            'protocol': port_elem.get('protocol'),
            'state': {},
            'service': {},
            'vulnerabilities': [],
            'nse_scripts': []
        }
        
        # Extract state information
        state_elem = port_elem.find('state')
        if state_elem is not None:
            port_result['state'] = {
                'state': state_elem.get('state'),
                'reason': state_elem.get('reason')
            }
            
            # Skip closed/filtered ports
            if state_elem.get('state') not in ['open', 'open|filtered']:
                return None
        
        # Extract service information
        service_elem = port_elem.find('service')
        if service_elem is not None:
            port_result['service'] = {
                'name': service_elem.get('name', ''),
                'product': service_elem.get('product', ''),
                'version': service_elem.get('version', ''),
                'extrainfo': service_elem.get('extrainfo', ''),
                'ostype': service_elem.get('ostype', ''),
                'method': service_elem.get('method', ''),
                'conf': service_elem.get('conf', '')
            }
            
            # Extract CPE information
            cpe_elems = service_elem.findall('cpe')
            if cpe_elems:
                port_result['service']['cpes'] = [cpe.text for cpe in cpe_elems]
        
        # Analyze NSE scripts for this port
        for script_elem in port_elem.findall('script'):
            script_vulns = self._analyze_nse_script(script_elem)
            port_result['vulnerabilities'].extend(script_vulns)
            port_result['nse_scripts'].append({
                'id': script_elem.get('id'),
                'output': script_elem.get('output', ''),
                'vulnerabilities_found': len(script_vulns)
            })
        
        # Service-based vulnerability analysis
        service_vulns = self._analyze_service_vulnerabilities(port_result['service'])
        port_result['vulnerabilities'].extend(service_vulns)
        
        # Pattern-based vulnerability analysis
        pattern_vulns = self._analyze_service_patterns(port_result['service'])
        port_result['vulnerabilities'].extend(pattern_vulns)
        
        # HTTP regex pattern analysis (if HTTP service)
        if self._is_http_service(port_result['service']):
            http_vulns = self._analyze_http_patterns(port_result)
            port_result['vulnerabilities'].extend(http_vulns)
        
        return port_result
    
    def _analyze_nse_script(self, script_elem) -> List[VulnerabilityMatch]:
        """
        Analyze NSE script output for vulnerability indicators
        
        Based on vulnerscom/nmap-vulners NSE script patterns
        """
        vulnerabilities = []
        script_id = script_elem.get('id', '')
        script_output = script_elem.get('output', '')
        
        self.stats['nse_detections'] += 1
        
        # Direct CVE extraction from NSE output
        cve_matches = re.findall(r'CVE-(\d{4}-\d{4,7})', script_output, re.IGNORECASE)
        for cve_match in cve_matches:
            cve_id = f"CVE-{cve_match}"
            
            # Try to get additional info from local database
            vuln_info = self._get_vulnerability_info(cve_id)
            
            vulnerability = VulnerabilityMatch(
                cve_id=cve_id,
                severity=vuln_info.get('severity', 'medium'),
                cvss_score=vuln_info.get('cvss_score', 5.0),
                description=vuln_info.get('description', f'Vulnerability found in NSE script {script_id}'),
                published_date=vuln_info.get('published_date', ''),
                modified_date=vuln_info.get('modified_date', ''),
                source='nse_script',
                confidence=0.9,
                references=[f'NSE Script: {script_id}']
            )
            vulnerabilities.append(vulnerability)
        
        # Vulners.nse specific output parsing
        if 'vulners' in script_id.lower():
            vulners_vulns = self._parse_vulners_nse_output(script_output)
            vulnerabilities.extend(vulners_vulns)
        
        # HTTP vulnerability script analysis
        if 'http' in script_id.lower() and any(keyword in script_output.lower() 
                                              for keyword in ['vulnerable', 'exploit', 'backdoor']):
            http_vulns = self._parse_http_vulnerability_output(script_id, script_output)
            vulnerabilities.extend(http_vulns)
        
        # SSL/TLS vulnerability detection
        if any(ssl_term in script_id.lower() for ssl_term in ['ssl', 'tls']):
            ssl_vulns = self._parse_ssl_vulnerability_output(script_id, script_output)
            vulnerabilities.extend(ssl_vulns)
        
        # SMB vulnerability detection
        if 'smb' in script_id.lower():
            smb_vulns = self._parse_smb_vulnerability_output(script_id, script_output)
            vulnerabilities.extend(smb_vulns)
        
        self.stats['vulnerabilities_found'] += len(vulnerabilities)
        return vulnerabilities
    
    def _parse_vulners_nse_output(self, output: str) -> List[VulnerabilityMatch]:
        """
        Parse vulners.nse script output
        
        Expected format from vulnerscom/nmap-vulners:
        CVE-YYYY-NNNN    score    description
        """
        vulnerabilities = []
        
        # Match vulners.nse output format
        vulners_pattern = r'(CVE-\d{4}-\d{4,7})\s+(\d+\.\d+)\s+(.+)'
        matches = re.findall(vulners_pattern, output, re.MULTILINE)
        
        for cve_id, score, description in matches:
            # Determine severity from CVSS score
            cvss_score = float(score)
            if cvss_score >= 9.0:
                severity = 'critical'
            elif cvss_score >= 7.0:
                severity = 'high'
            elif cvss_score >= 4.0:
                severity = 'medium'
            else:
                severity = 'low'
            
            vulnerability = VulnerabilityMatch(
                cve_id=cve_id,
                severity=severity,
                cvss_score=cvss_score,
                description=description.strip(),
                published_date='',
                modified_date='',
                source='vulners_nse',
                confidence=0.95,
                references=['vulners.nse', 'https://vulners.com/']
            )
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _parse_http_vulnerability_output(self, script_id: str, output: str) -> List[VulnerabilityMatch]:
        """Parse HTTP-related vulnerability script output"""
        vulnerabilities = []
        
        # Common HTTP vulnerability indicators
        http_vulns = {
            'slowloris': {'severity': 'high', 'cvss': 7.8},
            'shellshock': {'severity': 'critical', 'cvss': 10.0},
            'heartbleed': {'severity': 'high', 'cvss': 7.5},
            'poodle': {'severity': 'medium', 'cvss': 4.3},
            'beast': {'severity': 'medium', 'cvss': 4.3},
            'crime': {'severity': 'medium', 'cvss': 4.3},
            'breach': {'severity': 'medium', 'cvss': 4.3},
            'logjam': {'severity': 'medium', 'cvss': 5.3}
        }
        
        output_lower = output.lower()
        for vuln_name, info in http_vulns.items():
            if vuln_name in output_lower or vuln_name.replace('_', '-') in output_lower:
                vulnerability = VulnerabilityMatch(
                    cve_id=f'HTTP-{vuln_name.upper()}',
                    severity=info['severity'],
                    cvss_score=info['cvss'],
                    description=f'{vuln_name.title()} vulnerability detected via {script_id}',
                    published_date='',
                    modified_date='',
                    source='nse_http_script',
                    confidence=0.8,
                    references=[f'NSE Script: {script_id}']
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _parse_ssl_vulnerability_output(self, script_id: str, output: str) -> List[VulnerabilityMatch]:
        """Parse SSL/TLS vulnerability script output"""
        vulnerabilities = []
        
        # SSL/TLS specific vulnerabilities
        ssl_vulns = {
            'heartbleed': {'cve': 'CVE-2014-0160', 'severity': 'high', 'cvss': 7.5},
            'poodle': {'cve': 'CVE-2014-3566', 'severity': 'medium', 'cvss': 4.3},
            'beast': {'cve': 'CVE-2011-3389', 'severity': 'medium', 'cvss': 4.3},
            'crime': {'cve': 'CVE-2012-4929', 'severity': 'medium', 'cvss': 4.3},
            'breach': {'cve': 'CVE-2013-3587', 'severity': 'medium', 'cvss': 4.3},
            'logjam': {'cve': 'CVE-2015-4000', 'severity': 'medium', 'cvss': 5.3},
            'freak': {'cve': 'CVE-2015-0204', 'severity': 'medium', 'cvss': 4.3},
            'drown': {'cve': 'CVE-2016-0800', 'severity': 'medium', 'cvss': 5.9},
            'sweet32': {'cve': 'CVE-2016-2183', 'severity': 'medium', 'cvss': 5.3}
        }
        
        output_lower = output.lower()
        for vuln_name, info in ssl_vulns.items():
            if (vuln_name in output_lower or 
                info['cve'].lower() in output_lower or
                'vulnerable' in output_lower):
                
                vulnerability = VulnerabilityMatch(
                    cve_id=info['cve'],
                    severity=info['severity'],
                    cvss_score=info['cvss'],
                    description=f'{vuln_name.title()} SSL/TLS vulnerability detected via {script_id}',
                    published_date='',
                    modified_date='',
                    source='nse_ssl_script',
                    confidence=0.85,
                    references=[f'NSE Script: {script_id}', info['cve']]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _parse_smb_vulnerability_output(self, script_id: str, output: str) -> List[VulnerabilityMatch]:
        """Parse SMB vulnerability script output"""
        vulnerabilities = []
        
        # SMB specific vulnerabilities
        smb_vulns = {
            'ms08-067': {'cve': 'CVE-2008-4250', 'severity': 'critical', 'cvss': 10.0},
            'ms17-010': {'cve': 'CVE-2017-0144', 'severity': 'critical', 'cvss': 9.3},
            'eternalblue': {'cve': 'CVE-2017-0144', 'severity': 'critical', 'cvss': 9.3},
            'ms09-050': {'cve': 'CVE-2009-3103', 'severity': 'high', 'cvss': 8.5},
            'ms10-061': {'cve': 'CVE-2010-2550', 'severity': 'critical', 'cvss': 10.0}
        }
        
        output_lower = output.lower()
        for vuln_name, info in smb_vulns.items():
            if (vuln_name in output_lower or 
                info['cve'].lower() in output_lower or
                ('vulnerable' in output_lower and 'smb' in output_lower)):
                
                vulnerability = VulnerabilityMatch(
                    cve_id=info['cve'],
                    severity=info['severity'],
                    cvss_score=info['cvss'],
                    description=f'{vuln_name.upper()} SMB vulnerability detected via {script_id}',
                    published_date='',
                    modified_date='',
                    source='nse_smb_script',
                    confidence=0.9,
                    exploit_available=True,
                    references=[f'NSE Script: {script_id}', info['cve']]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _analyze_service_vulnerabilities(self, service: Dict[str, Any]) -> List[VulnerabilityMatch]:
        """Analyze service for known vulnerabilities based on service name"""
        vulnerabilities = []
        service_name = service.get('name', '').lower()
        
        if service_name in self.service_vulns:
            for cve_id in self.service_vulns[service_name]:
                vuln_info = self._get_vulnerability_info(cve_id)
                
                vulnerability = VulnerabilityMatch(
                    cve_id=cve_id,
                    severity=vuln_info.get('severity', 'medium'),
                    cvss_score=vuln_info.get('cvss_score', 5.0),
                    description=vuln_info.get('description', f'Known vulnerability in {service_name} service'),
                    published_date=vuln_info.get('published_date', ''),
                    modified_date=vuln_info.get('modified_date', ''),
                    source='service_database',
                    confidence=0.7,
                    references=[f'Service: {service_name}']
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _analyze_service_patterns(self, service: Dict[str, Any]) -> List[VulnerabilityMatch]:
        """Analyze service using NSE patterns"""
        vulnerabilities = []
        
        service_product = service.get('product', '')
        service_version = service.get('version', '')
        service_string = f"{service_product} {service_version}".strip()
        
        if not service_string:
            return vulnerabilities
        
        self.stats['pattern_matches'] += 1
        
        # Check all NSE patterns
        for category, patterns in self.nse_patterns.items():
            for pattern_info in patterns:
                match = re.search(pattern_info['pattern'], service_string, re.IGNORECASE)
                if match:
                    version = match.group(1) if match.groups() else ''
                    
                    # Check if version has known vulnerabilities
                    if version and version in pattern_info.get('severity_map', {}):
                        severity = pattern_info['severity_map'][version]
                        
                        # Create vulnerability entry
                        vulnerability = VulnerabilityMatch(
                            cve_id=f'PATTERN-{category.upper()}-{version}',
                            severity=severity,
                            cvss_score=self._severity_to_cvss(severity),
                            description=f"{pattern_info['description']}: {service_string}",
                            published_date='',
                            modified_date='',
                            source='pattern_match',
                            confidence=0.6,
                            references=[f'Pattern: {pattern_info["pattern"]}']
                        )
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _analyze_http_patterns(self, port_result: Dict[str, Any]) -> List[VulnerabilityMatch]:
        """
        Analyze HTTP services using http-vulners-regex.nse patterns
        
        Based on: https://github.com/vulnerscom/nmap-vulners/blob/master/http-vulners-regex.nse
        """
        vulnerabilities = []
        
        # Look for HTTP-specific NSE script outputs
        for nse_script in port_result.get('nse_scripts', []):
            script_id = nse_script.get('id', '')
            script_output = nse_script.get('output', '')
            
            # Process HTTP regex patterns
            for pattern_info in self.http_regex_patterns:
                pattern_match = re.search(pattern_info['pattern'], script_output, re.IGNORECASE)
                
                # Also check for path-based detection
                path_match = any(path in script_output.lower() 
                               for path in pattern_info.get('paths', []))
                
                if pattern_match or path_match:
                    version = pattern_match.group(1) if pattern_match and pattern_match.groups() else 'unknown'
                    
                    vulnerability = VulnerabilityMatch(
                        cve_id=f'HTTP-{pattern_info["name"].upper().replace(" ", "-")}-{version}',
                        severity=pattern_info['severity'],
                        cvss_score=self._severity_to_cvss(pattern_info['severity']),
                        description=f"{pattern_info['description']}: {pattern_info['name']} {version} detected",
                        published_date='',
                        modified_date='',
                        source='http_regex_pattern',
                        confidence=0.7,
                        references=[f'HTTP Pattern: {pattern_info["name"]}']
                    )
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _is_http_service(self, service: Dict[str, Any]) -> bool:
        """Check if service is HTTP-related"""
        service_name = service.get('name', '').lower()
        service_product = service.get('product', '').lower()
        
        http_indicators = ['http', 'https', 'web', 'apache', 'nginx', 'iis', 'lighttpd', 'tomcat']
        
        return any(indicator in service_name or indicator in service_product 
                  for indicator in http_indicators)
    
    def _get_vulnerability_info(self, cve_id: str) -> Dict[str, Any]:
        """
        Get vulnerability information from multiple sources
        
        Priority order:
        1. Local vulnerability database
        2. Vulners API (if available)
        3. Default/fallback information
        """
        # Try local database first
        if self.vuln_analyzer:
            try:
                local_vulns = self.vuln_analyzer.search_vulnerabilities_by_cve(cve_id)
                if local_vulns:
                    self.stats['local_db_hits'] += 1
                    return local_vulns[0]  # Return first match
            except Exception as e:
                self.logger.warning(f"Local database lookup failed for {cve_id}: {e}")
        
        # Try Vulners API if available
        if self.api_key:
            try:
                api_info = self._query_vulners_api(cve_id)
                if api_info:
                    self.stats['api_calls_made'] += 1
                    return api_info
            except Exception as e:
                self.logger.warning(f"Vulners API lookup failed for {cve_id}: {e}")
        
        # Return default information
        return {
            'cve_id': cve_id,
            'severity': 'medium',
            'cvss_score': 5.0,
            'description': f'Vulnerability {cve_id} - details not available',
            'published_date': '',
            'modified_date': ''
        }
    
    def _query_vulners_api(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        Query Vulners API for vulnerability information
        
        Based on vulnerscom/nmap-vulners enterprise integration
        """
        # Rate limiting
        current_time = time.time()
        if current_time - self.last_api_call < self.api_rate_limit:
            time.sleep(self.api_rate_limit - (current_time - self.last_api_call))
        
        try:
            url = f"{self.vulners_api_base}/search/id/"
            params = {
                'id': cve_id,
                'apikey': self.api_key
            }
            
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if data.get('result') == 'OK' and data.get('data', {}).get('documents'):
                doc = data['data']['documents'][0]
                
                return {
                    'cve_id': cve_id,
                    'severity': self._cvss_to_severity(doc.get('cvss', {}).get('score', 5.0)),
                    'cvss_score': doc.get('cvss', {}).get('score', 5.0),
                    'description': doc.get('description', ''),
                    'published_date': doc.get('published', ''),
                    'modified_date': doc.get('modified', '')
                }
            
            self.last_api_call = time.time()
            
        except Exception as e:
            self.logger.warning(f"Vulners API error for {cve_id}: {e}")
            
        return None
    
    def _severity_to_cvss(self, severity: str) -> float:
        """Convert severity string to CVSS score"""
        severity_map = {
            'critical': 9.5,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5,
            'informational': 1.0,
            'info': 1.0
        }
        return severity_map.get(severity.lower(), 5.0)
    
    def _cvss_to_severity(self, cvss_score: float) -> str:
        """Convert CVSS score to severity string"""
        if cvss_score >= 9.0:
            return 'critical'
        elif cvss_score >= 7.0:
            return 'high'
        elif cvss_score >= 4.0:
            return 'medium'
        else:
            return 'low'
    
    def export_results(self, results: Dict[str, Any], output_file: str = None, format_type: str = 'json'):
        """Export vulnerability analysis results"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"nmap_vulners_analysis_{timestamp}.{format_type}"
        
        if format_type == 'json':
            # Convert VulnerabilityMatch objects to dictionaries
            serializable_results = self._make_serializable(results)
            
            with open(output_file, 'w') as f:
                json.dump(serializable_results, f, indent=2, default=str)
        
        elif format_type == 'csv':
            self._export_csv(results, output_file)
        
        elif format_type == 'html':
            self._export_html(results, output_file)
        
        self.logger.info(f"Results exported to {output_file}")
        return output_file
    
    def _make_serializable(self, obj):
        """Convert objects to JSON-serializable format"""
        if isinstance(obj, VulnerabilityMatch):
            return {
                'cve_id': obj.cve_id,
                'severity': obj.severity,
                'cvss_score': obj.cvss_score,
                'description': obj.description,
                'published_date': obj.published_date,
                'modified_date': obj.modified_date,
                'source': obj.source,
                'confidence': obj.confidence,
                'exploit_available': obj.exploit_available,
                'metasploit_module': obj.metasploit_module,
                'references': obj.references
            }
        elif isinstance(obj, dict):
            return {k: self._make_serializable(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._make_serializable(item) for item in obj]
        else:
            return obj
    
    def _export_csv(self, results: Dict[str, Any], output_file: str):
        """Export results to CSV format"""
        import csv
        
        with open(output_file, 'w', newline='') as csvfile:
            fieldnames = [
                'ip_address', 'hostname', 'port', 'service', 'cve_id', 
                'severity', 'cvss_score', 'description', 'source', 'confidence'
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for host in results.get('hosts', []):
                ip_addr = host.get('ip', '')
                hostname = host.get('hostnames', [''])[0] if host.get('hostnames') else ''
                
                for vuln in host.get('vulnerabilities', []):
                    vuln_dict = self._make_serializable(vuln)
                    writer.writerow({
                        'ip_address': ip_addr,
                        'hostname': hostname,
                        'port': '',  # Port info would need to be tracked separately
                        'service': '',
                        'cve_id': vuln_dict.get('cve_id', ''),
                        'severity': vuln_dict.get('severity', ''),
                        'cvss_score': vuln_dict.get('cvss_score', ''),
                        'description': vuln_dict.get('description', ''),
                        'source': vuln_dict.get('source', ''),
                        'confidence': vuln_dict.get('confidence', '')
                    })
    
    def _export_html(self, results: Dict[str, Any], output_file: str):
        """Export results to HTML format"""
        html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nmap Vulners Analysis Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }}
        h1, h2 {{ color: #333; border-bottom: 2px solid #e74c3c; padding-bottom: 10px; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }}
        .stat-card {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; text-align: center; }}
        .critical {{ background: linear-gradient(135deg, #ff6b6b, #ee5a24); }}
        .high {{ background: linear-gradient(135deg, #ffa726, #ff7043); }}
        .medium {{ background: linear-gradient(135deg, #ffee58, #ffc107); }}
        .low {{ background: linear-gradient(135deg, #81c784, #4caf50); }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f8f9fa; }}
        .github-refs {{ background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 20px 0; }}
        .github-refs h3 {{ margin-top: 0; color: #2c3e50; }}
        .github-refs a {{ color: #3498db; text-decoration: none; }}
        .github-refs a:hover {{ text-decoration: underline; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 Nmap Vulners Vulnerability Analysis</h1>
        
        <div class="github-refs">
            <h3>📚 Based on vulnerscom/nmap-vulners Research</h3>
            <p><strong>Core NSE Scripts:</strong> <a href="https://github.com/vulnerscom/nmap-vulners/blob/master/vulners.nse" target="_blank">vulners.nse</a></p>
            <p><strong>Enterprise API:</strong> <a href="https://github.com/vulnerscom/nmap-vulners/blob/master/vulners_enterprise.nse" target="_blank">vulners_enterprise.nse</a></p>
            <p><strong>HTTP Patterns:</strong> <a href="https://github.com/vulnerscom/nmap-vulners/blob/master/http-vulners-regex.nse" target="_blank">http-vulners-regex.nse</a></p>
        </div>
        
        <h2>📊 Vulnerability Summary</h2>
        <div class="summary">
            <div class="stat-card critical">
                <div style="font-size: 2em; font-weight: bold;">{critical_count}</div>
                <div>Critical</div>
            </div>
            <div class="stat-card high">
                <div style="font-size: 2em; font-weight: bold;">{high_count}</div>
                <div>High</div>
            </div>
            <div class="stat-card medium">
                <div style="font-size: 2em; font-weight: bold;">{medium_count}</div>
                <div>Medium</div>
            </div>
            <div class="stat-card low">
                <div style="font-size: 2em; font-weight: bold;">{low_count}</div>
                <div>Low</div>
            </div>
        </div>
        
        <h2>🎯 Analysis Statistics</h2>
        <table>
            <tr><th>Metric</th><th>Value</th></tr>
            <tr><td>Total Hosts Analyzed</td><td>{host_count}</td></tr>
            <tr><td>Total Vulnerabilities</td><td>{total_vulns}</td></tr>
            <tr><td>NSE Script Detections</td><td>{nse_detections}</td></tr>
            <tr><td>Pattern Matches</td><td>{pattern_matches}</td></tr>
            <tr><td>Local DB Hits</td><td>{local_db_hits}</td></tr>
            <tr><td>API Calls Made</td><td>{api_calls}</td></tr>
        </table>
        
        {host_details}
        
        <footer style="text-align: center; margin-top: 50px; padding: 20px; border-top: 1px solid #ddd;">
            <p>Generated by Nmap Vulners Analyzer v1.5 | Based on vulnerscom/nmap-vulners | {timestamp}</p>
        </footer>
    </div>
</body>
</html>
        """
        
        # Generate host details
        host_details = ""
        for host in results.get('hosts', []):
            host_details += f"""
            <h2>🖥️ Host: {host.get('ip', 'Unknown')}</h2>
            <p><strong>Hostnames:</strong> {', '.join(host.get('hostnames', ['None']))}</p>
            <p><strong>Vulnerabilities Found:</strong> {len(host.get('vulnerabilities', []))}</p>
            """
            
            if host.get('vulnerabilities'):
                host_details += """
                <table>
                    <thead>
                        <tr><th>CVE ID</th><th>Severity</th><th>CVSS</th><th>Description</th><th>Source</th></tr>
                    </thead>
                    <tbody>
                """
                
                for vuln in host.get('vulnerabilities', []):
                    vuln_dict = self._make_serializable(vuln)
                    host_details += f"""
                        <tr>
                            <td>{vuln_dict.get('cve_id', 'N/A')}</td>
                            <td class="{vuln_dict.get('severity', 'low')}">{vuln_dict.get('severity', 'Unknown').title()}</td>
                            <td>{vuln_dict.get('cvss_score', 'N/A')}</td>
                            <td>{vuln_dict.get('description', 'N/A')[:100]}...</td>
                            <td>{vuln_dict.get('source', 'N/A')}</td>
                        </tr>
                    """
                
                host_details += """
                    </tbody>
                </table>
                """
        
        # Fill template
        html_content = html_template.format(
            critical_count=results['summary']['critical_count'],
            high_count=results['summary']['high_count'],
            medium_count=results['summary']['medium_count'],
            low_count=results['summary']['low_count'],
            host_count=len(results.get('hosts', [])),
            total_vulns=results['summary']['total_vulnerabilities'],
            nse_detections=results['statistics']['nse_detections'],
            pattern_matches=results['statistics']['pattern_matches'],
            local_db_hits=results['statistics']['local_db_hits'],
            api_calls=results['statistics']['api_calls_made'],
            host_details=host_details,
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Nmap NSE Vulnerability Analyzer based on vulnerscom/nmap-vulners",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python nmap_vulners_analyzer.py scan.xml
    python nmap_vulners_analyzer.py scan.xml --vuln-db vulnerability_db.json
    python nmap_vulners_analyzer.py scan.xml --api-key YOUR_VULNERS_API_KEY
    python nmap_vulners_analyzer.py scan.xml --output-format html

GitHub Reference:
    vulnerscom/nmap-vulners: https://github.com/vulnerscom/nmap-vulners
        """
    )
    
    parser.add_argument('xml_file', help='Nmap XML output file to analyze')
    parser.add_argument('--vuln-db', help='Path to local vulnerability database')
    parser.add_argument('--api-key', help='Vulners API key for enhanced lookups')
    parser.add_argument('--output-format', choices=['json', 'csv', 'html'], 
                       default='json', help='Output format')
    parser.add_argument('--output-file', help='Output file path')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        print("🔍 Starting Nmap Vulners Analysis...")
        print("📚 Based on vulnerscom/nmap-vulners NSE scripts")
        
        analyzer = NmapVulnersAnalyzer(args.xml_file, args.vuln_db, args.api_key)
        results = analyzer.analyze_vulnerabilities()
        
        print(f"\n📊 Analysis Complete!")
        print(f"   Hosts analyzed: {len(results.get('hosts', []))}")
        print(f"   Total vulnerabilities: {results['summary']['total_vulnerabilities']}")
        print(f"   Critical: {results['summary']['critical_count']}")
        print(f"   High: {results['summary']['high_count']}")
        print(f"   Medium: {results['summary']['medium_count']}")
        print(f"   Low: {results['summary']['low_count']}")
        
        output_file = analyzer.export_results(results, args.output_file, args.output_format)
        print(f"📄 Results exported to: {output_file}")
        
        print(f"\n🔗 GitHub References:")
        for name, url in results['github_references'].items():
            print(f"   {name}: {url}")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1
    
    return 0

if __name__ == "__main__":
    import sys
    sys.exit(main())