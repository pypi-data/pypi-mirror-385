#!/usr/bin/env python3
"""
Comprehensive Nmap Scan Analysis with Vulnerability Integration
Enhanced with GitHub repository references and vulnerability matching

Author: Security Research Team
Date: 2024
Version: 2.0

References:
- vulnerscom/nmap-vulners: https://github.com/vulnerscom/nmap-vulners (NSE vulnerability scripts)
- ernw/nmap-parse-output: https://github.com/ernw/nmap-parse-output (XML parsing tools)
- VulnDB: vulnerability analyzer integration
"""

import xml.etree.ElementTree as ET
import json
import csv
import re
import ipaddress
import hashlib
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple, Set
import argparse
import logging
import subprocess
import os
import sys

# Vulnerability Analyzer Integration
try:
    import requests
    from vulnerability_analyzer import VulnerabilityAnalyzer
    VULN_ANALYZER_AVAILABLE = True
except ImportError:
    VULN_ANALYZER_AVAILABLE = False
    print("Warning: Vulnerability Analyzer not available. Install dependencies for full functionality.")

class NmapAnalyzer:
    """
    Comprehensive Nmap XML analysis with vulnerability integration
    
    Inspired by:
    - vulnerscom/nmap-vulners NSE scripts for vulnerability detection
    - ernw/nmap-parse-output XSLT transformations for data extraction
    """
    
    def __init__(self, xml_file: str, vuln_db_path: str = None):
        self.xml_file = Path(xml_file)
        self.vuln_db_path = vuln_db_path
        self.tree = None
        self.root = None
        self.hosts = []
        self.scan_info = {}
        self.vulnerability_stats = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'informational': 0
        }
        
        # Initialize vulnerability analyzer if available
        if VULN_ANALYZER_AVAILABLE and vuln_db_path:
            try:
                self.vuln_analyzer = VulnerabilityAnalyzer(vuln_db_path)
                print(f"✓ Vulnerability Analyzer loaded with {self.vuln_analyzer.get_vulnerability_count()} vulnerabilities")
            except Exception as e:
                print(f"Warning: Could not load vulnerability analyzer: {e}")
                self.vuln_analyzer = None
        else:
            self.vuln_analyzer = None
            
        # Vulnerability patterns from vulnerscom/nmap-vulners research
        self.vuln_patterns = self._load_vulnerability_patterns()
        
        # Service fingerprints for enhanced detection
        self.service_patterns = self._load_service_patterns()
        
        self._setup_logging()
        self._parse_xml()
    
    def _setup_logging(self):
        """Configure logging for detailed analysis tracking"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('nmap_analysis.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def _load_vulnerability_patterns(self) -> Dict[str, List[str]]:
        """
        Load vulnerability patterns inspired by vulnerscom/nmap-vulners
        
        Based on research from:
        https://github.com/vulnerscom/nmap-vulners/blob/master/vulners.nse
        https://github.com/vulnerscom/nmap-vulners/blob/master/http-vulners-regex.nse
        """
        return {
            'web_vulnerabilities': [
                r'Apache.*2\.[0-2]\.',  # Apache vulnerabilities
                r'nginx.*1\.[0-9]\.',   # Nginx vulnerabilities
                r'Microsoft-IIS.*[6-8]\.',  # IIS vulnerabilities
                r'PHP.*[5-7]\.[0-2]\.',  # PHP vulnerabilities
                r'OpenSSL.*1\.0\.',     # OpenSSL vulnerabilities
            ],
            'ssh_vulnerabilities': [
                r'OpenSSH.*[6-7]\.[0-4]',  # SSH vulnerabilities
                r'libssh.*0\.[6-7]\.',     # libssh vulnerabilities
            ],
            'ftp_vulnerabilities': [
                r'vsftpd.*2\.[3-4]\.',     # vsftpd vulnerabilities
                r'ProFTPD.*1\.[3-4]\.',    # ProFTPD vulnerabilities
            ],
            'smb_vulnerabilities': [
                r'Samba.*[3-4]\.[0-5]\.',  # Samba vulnerabilities
                r'Microsoft Windows.*SMB.*', # Windows SMB
            ],
            'database_vulnerabilities': [
                r'MySQL.*[5-8]\.[0-7]\.',   # MySQL vulnerabilities
                r'PostgreSQL.*(9|10|11|12|13)\.[0-9]\.',  # PostgreSQL vulnerabilities
                r'Microsoft SQL Server.*',  # MSSQL vulnerabilities
            ]
        }
    
    def _load_service_patterns(self) -> Dict[str, Dict[str, Any]]:
        """
        Load service detection patterns for enhanced fingerprinting
        
        Enhanced patterns for better service identification and vulnerability mapping
        """
        return {
            'http': {
                'patterns': [r'http', r'https', r'web', r'apache', r'nginx', r'iis'],
                'ports': [80, 443, 8080, 8443, 8000, 8888, 9000],
                'risk_level': 'medium'
            },
            'ssh': {
                'patterns': [r'ssh', r'openssh'],
                'ports': [22, 2222],
                'risk_level': 'low'
            },
            'ftp': {
                'patterns': [r'ftp', r'vsftpd', r'proftpd'],
                'ports': [21, 2121],
                'risk_level': 'medium'
            },
            'telnet': {
                'patterns': [r'telnet'],
                'ports': [23],
                'risk_level': 'critical'
            },
            'smtp': {
                'patterns': [r'smtp', r'postfix', r'sendmail'],
                'ports': [25, 587, 465],
                'risk_level': 'low'
            },
            'dns': {
                'patterns': [r'dns', r'domain', r'bind'],
                'ports': [53],
                'risk_level': 'low'
            },
            'pop3': {
                'patterns': [r'pop3'],
                'ports': [110, 995],
                'risk_level': 'medium'
            },
            'imap': {
                'patterns': [r'imap'],
                'ports': [143, 993],
                'risk_level': 'medium'
            },
            'snmp': {
                'patterns': [r'snmp'],
                'ports': [161, 162],
                'risk_level': 'high'
            },
            'smb': {
                'patterns': [r'smb', r'cifs', r'netbios', r'microsoft-ds'],
                'ports': [139, 445],
                'risk_level': 'high'
            },
            'rdp': {
                'patterns': [r'rdp', r'ms-wbt-server', r'terminal'],
                'ports': [3389],
                'risk_level': 'high'
            },
            'vnc': {
                'patterns': [r'vnc'],
                'ports': [5900, 5901, 5902],
                'risk_level': 'high'
            },
            'mysql': {
                'patterns': [r'mysql'],
                'ports': [3306],
                'risk_level': 'medium'
            },
            'postgresql': {
                'patterns': [r'postgresql', r'postgres'],
                'ports': [5432],
                'risk_level': 'medium'
            },
            'oracle': {
                'patterns': [r'oracle', r'oracle-tns'],
                'ports': [1521, 1522, 1526],
                'risk_level': 'medium'
            },
            'mssql': {
                'patterns': [r'mssql', r'ms-sql'],
                'ports': [1433, 1434],
                'risk_level': 'medium'
            }
        }
    
    def _parse_xml(self):
        """Parse Nmap XML file with comprehensive error handling"""
        try:
            self.logger.info(f"Parsing XML file: {self.xml_file}")
            self.tree = ET.parse(self.xml_file)
            self.root = self.tree.getroot()
            
            # Extract scan information
            self._extract_scan_info()
            
            # Parse hosts
            self._parse_hosts()
            
            self.logger.info(f"Successfully parsed {len(self.hosts)} hosts")
            
        except ET.ParseError as e:
            self.logger.error(f"XML parsing error: {e}")
            raise
        except FileNotFoundError:
            self.logger.error(f"File not found: {self.xml_file}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error parsing XML: {e}")
            raise
    
    def _extract_scan_info(self):
        """Extract scan metadata and statistics"""
        self.scan_info = {
            'nmap_version': self.root.get('version', 'unknown'),
            'arguments': self.root.get('args', ''),
            'start_time': self.root.get('startstr', ''),
            'scanner': self.root.get('scanner', 'nmap'),
            'xml_output_version': self.root.get('xmloutputversion', ''),
        }
        
        # Extract run statistics
        runstats = self.root.find('runstats')
        if runstats is not None:
            finished = runstats.find('finished')
            hosts_elem = runstats.find('hosts')
            
            if finished is not None:
                self.scan_info.update({
                    'end_time': finished.get('timestr', ''),
                    'elapsed_time': finished.get('elapsed', ''),
                    'exit_status': finished.get('exit', 'success')
                })
            
            if hosts_elem is not None:
                self.scan_info.update({
                    'hosts_up': int(hosts_elem.get('up', 0)),
                    'hosts_down': int(hosts_elem.get('down', 0)),
                    'hosts_total': int(hosts_elem.get('total', 0))
                })
    
    def _parse_hosts(self):
        """Parse all hosts with detailed service and vulnerability analysis"""
        for host_elem in self.root.findall('host'):
            host_data = self._parse_host(host_elem)
            if host_data:
                self.hosts.append(host_data)
    
    def _parse_host(self, host_elem) -> Optional[Dict[str, Any]]:
        """Parse individual host with comprehensive analysis"""
        # Extract basic host information
        host_data = {
            'addresses': [],
            'hostnames': [],
            'status': {},
            'ports': [],
            'os': {},
            'scripts': [],
            'vulnerabilities': [],
            'risk_score': 0,
            'services': set(),
            'cves': set()
        }
        
        # Parse addresses
        for addr_elem in host_elem.findall('address'):
            host_data['addresses'].append({
                'addr': addr_elem.get('addr'),
                'addrtype': addr_elem.get('addrtype'),
                'vendor': addr_elem.get('vendor', '')
            })
        
        # Parse hostnames
        hostnames_elem = host_elem.find('hostnames')
        if hostnames_elem is not None:
            for hostname_elem in hostnames_elem.findall('hostname'):
                host_data['hostnames'].append({
                    'name': hostname_elem.get('name'),
                    'type': hostname_elem.get('type')
                })
        
        # Parse status
        status_elem = host_elem.find('status')
        if status_elem is not None:
            host_data['status'] = {
                'state': status_elem.get('state'),
                'reason': status_elem.get('reason'),
                'reason_ttl': status_elem.get('reason_ttl', '')
            }
        
        # Skip if host is down
        if host_data['status'].get('state') != 'up':
            return None
        
        # Parse ports with vulnerability analysis
        ports_elem = host_elem.find('ports')
        if ports_elem is not None:
            for port_elem in ports_elem.findall('port'):
                port_data = self._parse_port(port_elem)
                if port_data:
                    host_data['ports'].append(port_data)
                    
                    # Add to services set
                    if port_data.get('service', {}).get('name'):
                        host_data['services'].add(port_data['service']['name'])
                    
                    # Add vulnerabilities and CVEs
                    if 'vulnerabilities' in port_data:
                        host_data['vulnerabilities'].extend(port_data['vulnerabilities'])
                    if 'cves' in port_data:
                        host_data['cves'].update(port_data['cves'])
        
        # Parse OS information
        os_elem = host_elem.find('os')
        if os_elem is not None:
            host_data['os'] = self._parse_os(os_elem)
        
        # Parse host scripts
        hostscript_elem = host_elem.find('hostscript')
        if hostscript_elem is not None:
            for script_elem in hostscript_elem.findall('script'):
                script_data = self._parse_script(script_elem)
                if script_data:
                    host_data['scripts'].append(script_data)
        
        # Calculate risk score
        host_data['risk_score'] = self._calculate_host_risk_score(host_data)
        
        return host_data
    
    def _parse_port(self, port_elem) -> Dict[str, Any]:
        """Parse port with service detection and vulnerability analysis"""
        port_data = {
            'portid': int(port_elem.get('portid')),
            'protocol': port_elem.get('protocol'),
            'state': {},
            'service': {},
            'scripts': [],
            'vulnerabilities': [],
            'cves': set(),
            'risk_level': 'low'
        }
        
        # Parse state
        state_elem = port_elem.find('state')
        if state_elem is not None:
            port_data['state'] = {
                'state': state_elem.get('state'),
                'reason': state_elem.get('reason'),
                'reason_ttl': state_elem.get('reason_ttl', ''),
                'reason_ip': state_elem.get('reason_ip', '')
            }
        
        # Parse service
        service_elem = port_elem.find('service')
        if service_elem is not None:
            port_data['service'] = {
                'name': service_elem.get('name', ''),
                'product': service_elem.get('product', ''),
                'version': service_elem.get('version', ''),
                'extrainfo': service_elem.get('extrainfo', ''),
                'ostype': service_elem.get('ostype', ''),
                'method': service_elem.get('method', ''),
                'conf': service_elem.get('conf', ''),
                'tunnel': service_elem.get('tunnel', '')
            }
            
            # Extract CPE (Common Platform Enumeration) for vulnerability matching
            cpe_elems = service_elem.findall('cpe')
            if cpe_elems:
                port_data['service']['cpes'] = [cpe.text for cpe in cpe_elems]
        
        # Parse scripts
        for script_elem in port_elem.findall('script'):
            script_data = self._parse_script(script_elem)
            if script_data:
                port_data['scripts'].append(script_data)
        
        # Analyze vulnerabilities
        self._analyze_port_vulnerabilities(port_data)
        
        # Determine risk level
        port_data['risk_level'] = self._calculate_port_risk_level(port_data)
        
        return port_data
    
    def _parse_script(self, script_elem) -> Dict[str, Any]:
        """Parse NSE script output with vulnerability extraction"""
        script_data = {
            'id': script_elem.get('id'),
            'output': script_elem.get('output', ''),
            'elements': []
        }
        
        # Parse structured elements
        for elem in script_elem.findall('elem'):
            element = {
                'key': elem.get('key', ''),
                'value': elem.text or ''
            }
            script_data['elements'].append(element)
        
        # Parse tables
        for table in script_elem.findall('table'):
            table_data = {'key': table.get('key', ''), 'elements': []}
            for elem in table.findall('elem'):
                table_data['elements'].append({
                    'key': elem.get('key', ''),
                    'value': elem.text or ''
                })
            script_data['elements'].append(table_data)
        
        return script_data
    
    def _parse_os(self, os_elem) -> Dict[str, Any]:
        """Parse OS fingerprinting information"""
        os_data = {
            'portused': [],
            'osmatch': [],
            'osfingerprint': []
        }
        
        # Parse port used for OS detection
        for portused in os_elem.findall('portused'):
            os_data['portused'].append({
                'state': portused.get('state'),
                'proto': portused.get('proto'),
                'portid': portused.get('portid')
            })
        
        # Parse OS matches
        for osmatch in os_elem.findall('osmatch'):
            match_data = {
                'name': osmatch.get('name'),
                'accuracy': int(osmatch.get('accuracy', 0)),
                'line': osmatch.get('line', ''),
                'osclasses': []
            }
            
            # Parse OS classes
            for osclass in osmatch.findall('osclass'):
                match_data['osclasses'].append({
                    'type': osclass.get('type'),
                    'vendor': osclass.get('vendor'),
                    'osfamily': osclass.get('osfamily'),
                    'osgen': osclass.get('osgen', ''),
                    'accuracy': int(osclass.get('accuracy', 0)),
                    'cpe': [cpe.text for cpe in osclass.findall('cpe')]
                })
            
            os_data['osmatch'].append(match_data)
        
        return os_data
    
    def _analyze_port_vulnerabilities(self, port_data: Dict[str, Any]):
        """
        Analyze port for vulnerabilities using multiple methods
        
        Based on vulnerscom/nmap-vulners approach:
        1. Service version analysis
        2. CPE-based vulnerability lookup
        3. Script output parsing
        4. Pattern matching
        """
        vulnerabilities = []
        cves = set()
        
        service = port_data.get('service', {})
        service_name = service.get('name', '').lower()
        service_product = service.get('product', '').lower()
        service_version = service.get('version', '').lower()
        
        # Method 1: Pattern-based vulnerability detection
        service_string = f"{service_product} {service_version}".strip()
        for category, patterns in self.vuln_patterns.items():
            for pattern in patterns:
                if re.search(pattern, service_string, re.IGNORECASE):
                    vulnerability = {
                        'type': 'pattern_match',
                        'category': category,
                        'pattern': pattern,
                        'service_string': service_string,
                        'severity': self._get_pattern_severity(category),
                        'description': f"Potential {category.replace('_', ' ')} vulnerability in {service_string}"
                    }
                    vulnerabilities.append(vulnerability)
        
        # Method 2: Vulnerability Analyzer integration
        if self.vuln_analyzer and service_product and service_version:
            try:
                analyzer_vulns = self.vuln_analyzer.search_vulnerabilities(
                    product=service_product,
                    version=service_version
                )
                
                for vuln in analyzer_vulns:
                    vulnerability = {
                        'type': 'vulnerability_db',
                        'cve_id': vuln.get('cve_id'),
                        'severity': vuln.get('severity', 'unknown'),
                        'description': vuln.get('description', ''),
                        'cvss_score': vuln.get('cvss_score', 0),
                        'published_date': vuln.get('published_date', ''),
                        'modified_date': vuln.get('modified_date', '')
                    }
                    vulnerabilities.append(vulnerability)
                    
                    if vuln.get('cve_id'):
                        cves.add(vuln['cve_id'])
                        
            except Exception as e:
                self.logger.warning(f"Vulnerability analyzer error: {e}")
        
        # Method 3: CPE-based analysis
        if 'cpes' in service:
            for cpe in service['cpes']:
                # Extract product and version from CPE
                cpe_parts = cpe.split(':')
                if len(cpe_parts) >= 5:
                    cpe_product = cpe_parts[3]
                    cpe_version = cpe_parts[4]
                    
                    # Look up vulnerabilities for CPE
                    if self.vuln_analyzer:
                        try:
                            cpe_vulns = self.vuln_analyzer.search_vulnerabilities(
                                product=cpe_product,
                                version=cpe_version
                            )
                            
                            for vuln in cpe_vulns:
                                vulnerability = {
                                    'type': 'cpe_match',
                                    'cpe': cpe,
                                    'cve_id': vuln.get('cve_id'),
                                    'severity': vuln.get('severity', 'unknown'),
                                    'description': vuln.get('description', ''),
                                    'cvss_score': vuln.get('cvss_score', 0)
                                }
                                vulnerabilities.append(vulnerability)
                                
                                if vuln.get('cve_id'):
                                    cves.add(vuln['cve_id'])
                                    
                        except Exception as e:
                            self.logger.warning(f"CPE vulnerability lookup error: {e}")
        
        # Method 4: Script output analysis
        for script in port_data.get('scripts', []):
            script_id = script.get('id', '')
            script_output = script.get('output', '')
            
            # Look for CVE references in script output
            cve_matches = re.findall(r'CVE-\d{4}-\d{4,7}', script_output, re.IGNORECASE)
            for cve in cve_matches:
                cves.add(cve.upper())
                
                # Create vulnerability entry for each CVE found
                vulnerability = {
                    'type': 'script_detection',
                    'script_id': script_id,
                    'cve_id': cve.upper(),
                    'severity': 'unknown',
                    'description': f"CVE found in {script_id} script output",
                    'script_output': script_output[:200] + '...' if len(script_output) > 200 else script_output
                }
                vulnerabilities.append(vulnerability)
            
            # Look for vulnerability keywords
            vuln_keywords = ['exploit', 'vulnerability', 'vulnerable', 'backdoor', 'weakness']
            for keyword in vuln_keywords:
                if keyword in script_output.lower():
                    vulnerability = {
                        'type': 'script_keyword',
                        'script_id': script_id,
                        'keyword': keyword,
                        'severity': 'informational',
                        'description': f"Potential vulnerability keyword '{keyword}' found in {script_id}",
                        'script_output': script_output[:200] + '...' if len(script_output) > 200 else script_output
                    }
                    vulnerabilities.append(vulnerability)
        
        port_data['vulnerabilities'] = vulnerabilities
        port_data['cves'] = cves
        
        # Update vulnerability statistics
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'informational').lower()
            if severity in self.vulnerability_stats:
                self.vulnerability_stats[severity] += 1
    
    def _get_pattern_severity(self, category: str) -> str:
        """Determine severity based on vulnerability category"""
        severity_map = {
            'web_vulnerabilities': 'medium',
            'ssh_vulnerabilities': 'low',
            'ftp_vulnerabilities': 'medium',
            'smb_vulnerabilities': 'high',
            'database_vulnerabilities': 'medium'
        }
        return severity_map.get(category, 'informational')
    
    def _calculate_port_risk_level(self, port_data: Dict[str, Any]) -> str:
        """Calculate risk level for a port based on multiple factors"""
        risk_score = 0
        
        # Base score by port number and service
        port_num = port_data.get('portid', 0)
        service_name = port_data.get('service', {}).get('name', '').lower()
        
        # Check service patterns
        for service_type, config in self.service_patterns.items():
            if (port_num in config['ports'] or 
                any(pattern in service_name for pattern in config['patterns'])):
                
                risk_levels = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}
                risk_score = max(risk_score, risk_levels.get(config['risk_level'], 1))
                break
        
        # Increase score based on vulnerabilities
        vulnerabilities = port_data.get('vulnerabilities', [])
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'informational').lower()
            severity_scores = {
                'critical': 4,
                'high': 3,
                'medium': 2,
                'low': 1,
                'informational': 0
            }
            risk_score = max(risk_score, severity_scores.get(severity, 0))
        
        # Convert score to risk level
        if risk_score >= 4:
            return 'critical'
        elif risk_score >= 3:
            return 'high'
        elif risk_score >= 2:
            return 'medium'
        else:
            return 'low'
    
    def _calculate_host_risk_score(self, host_data: Dict[str, Any]) -> int:
        """Calculate overall risk score for a host"""
        risk_score = 0
        
        # Score based on open ports
        open_ports = len([p for p in host_data.get('ports', []) 
                         if p.get('state', {}).get('state') == 'open'])
        risk_score += min(open_ports * 5, 50)  # Cap at 50
        
        # Score based on services
        risky_services = ['telnet', 'ftp', 'snmp', 'smb', 'rdp', 'vnc']
        for service in host_data.get('services', []):
            if service.lower() in risky_services:
                risk_score += 20
        
        # Score based on vulnerabilities
        for vuln in host_data.get('vulnerabilities', []):
            severity = vuln.get('severity', 'informational').lower()
            severity_scores = {
                'critical': 50,
                'high': 30,
                'medium': 15,
                'low': 5,
                'informational': 1
            }
            risk_score += severity_scores.get(severity, 0)
        
        return min(risk_score, 1000)  # Cap at 1000
    
    def get_summary(self) -> Dict[str, Any]:
        """Generate comprehensive analysis summary"""
        total_ports = sum(len(host.get('ports', [])) for host in self.hosts)
        open_ports = sum(len([p for p in host.get('ports', []) 
                             if p.get('state', {}).get('state') == 'open']) 
                        for host in self.hosts)
        
        all_services = set()
        all_cves = set()
        total_vulns = 0
        
        for host in self.hosts:
            all_services.update(host.get('services', []))
            all_cves.update(host.get('cves', []))
            total_vulns += len(host.get('vulnerabilities', []))
        
        # Top risky hosts
        risky_hosts = sorted(
            [(host.get('addresses', [{}])[0].get('addr', 'unknown'), 
              host.get('risk_score', 0)) for host in self.hosts],
            key=lambda x: x[1],
            reverse=True
        )[:10]
        
        return {
            'scan_info': self.scan_info,
            'statistics': {
                'total_hosts': len(self.hosts),
                'hosts_up': len([h for h in self.hosts if h.get('status', {}).get('state') == 'up']),
                'total_ports': total_ports,
                'open_ports': open_ports,
                'unique_services': len(all_services),
                'total_vulnerabilities': total_vulns,
                'unique_cves': len(all_cves)
            },
            'vulnerability_stats': self.vulnerability_stats,
            'top_services': list(all_services)[:20],
            'discovered_cves': list(all_cves)[:50],
            'risky_hosts': risky_hosts,
            'github_references': {
                'nmap_vulners': 'https://github.com/vulnerscom/nmap-vulners',
                'nmap_parse_output': 'https://github.com/ernw/nmap-parse-output',
                'vulnerability_analyzer': 'Local vulnerability database integration'
            }
        }
    
    def export_json(self, output_file: str = None):
        """Export analysis results to JSON"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"nmap_analysis_{timestamp}.json"
        
        data = {
            'scan_info': self.scan_info,
            'hosts': self.hosts,
            'summary': self.get_summary(),
            'analysis_metadata': {
                'analyzer_version': '2.0',
                'analysis_time': datetime.now().isoformat(),
                'xml_file': str(self.xml_file),
                'github_references': {
                    'vulnerscom_nmap_vulners': 'https://github.com/vulnerscom/nmap-vulners',
                    'ernw_nmap_parse_output': 'https://github.com/ernw/nmap-parse-output'
                }
            }
        }
        
        # Convert sets to lists for JSON serialization
        def serialize_sets(obj):
            if isinstance(obj, set):
                return list(obj)
            elif isinstance(obj, dict):
                return {k: serialize_sets(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [serialize_sets(item) for item in obj]
            return obj
        
        data = serialize_sets(data)
        
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2, default=str)
        
        self.logger.info(f"Analysis exported to {output_file}")
        return output_file
    
    def export_csv(self, output_file: str = None):
        """Export host and port information to CSV"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"nmap_analysis_{timestamp}.csv"
        
        with open(output_file, 'w', newline='') as csvfile:
            fieldnames = [
                'ip_address', 'hostname', 'port', 'protocol', 'state',
                'service', 'product', 'version', 'risk_level',
                'vulnerabilities_count', 'cves_count', 'host_risk_score'
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for host in self.hosts:
                ip_addr = host.get('addresses', [{}])[0].get('addr', 'unknown')
                hostname = host.get('hostnames', [{}])[0].get('name', '') if host.get('hostnames') else ''
                host_risk = host.get('risk_score', 0)
                
                for port in host.get('ports', []):
                    if port.get('state', {}).get('state') == 'open':
                        writer.writerow({
                            'ip_address': ip_addr,
                            'hostname': hostname,
                            'port': port.get('portid', ''),
                            'protocol': port.get('protocol', ''),
                            'state': port.get('state', {}).get('state', ''),
                            'service': port.get('service', {}).get('name', ''),
                            'product': port.get('service', {}).get('product', ''),
                            'version': port.get('service', {}).get('version', ''),
                            'risk_level': port.get('risk_level', 'low'),
                            'vulnerabilities_count': len(port.get('vulnerabilities', [])),
                            'cves_count': len(port.get('cves', [])),
                            'host_risk_score': host_risk
                        })
        
        self.logger.info(f"CSV report exported to {output_file}")
        return output_file
    
    def generate_html_report(self, output_file: str = None):
        """Generate comprehensive HTML report"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"nmap_analysis_{timestamp}.html"
        
        summary = self.get_summary()
        
        html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nmap Analysis Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; text-align: center; }
        .stat-number { font-size: 2em; font-weight: bold; margin-bottom: 5px; }
        .stat-label { font-size: 0.9em; opacity: 0.9; }
        .vuln-critical { background: linear-gradient(135deg, #ff6b6b, #ee5a24); }
        .vuln-high { background: linear-gradient(135deg, #ffa726, #ff7043); }
        .vuln-medium { background: linear-gradient(135deg, #ffee58, #ffc107); }
        .vuln-low { background: linear-gradient(135deg, #81c784, #4caf50); }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f8f9fa; font-weight: bold; }
        .risk-critical { color: #d32f2f; font-weight: bold; }
        .risk-high { color: #f57c00; font-weight: bold; }
        .risk-medium { color: #fbc02d; }
        .risk-low { color: #388e3c; }
        .host-section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .port-item { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px; }
        .github-refs { background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 20px 0; }
        .github-refs h3 { margin-top: 0; color: #1976d2; }
        .github-refs a { color: #1976d2; text-decoration: none; }
        .github-refs a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 Nmap Security Analysis Report</h1>
        
        <div class="github-refs">
            <h3>📚 Analysis Framework References</h3>
            <p><strong>Vulnerability Detection:</strong> <a href="https://github.com/vulnerscom/nmap-vulners" target="_blank">vulnerscom/nmap-vulners</a> - NSE scripts for vulnerability scanning</p>
            <p><strong>XML Parsing Tools:</strong> <a href="https://github.com/ernw/nmap-parse-output" target="_blank">ernw/nmap-parse-output</a> - XSLT-based Nmap output processing</p>
            <p><strong>Local Database:</strong> Integrated vulnerability analyzer with {vuln_count} vulnerability entries</p>
        </div>
        
        <h2>📊 Executive Summary</h2>
        <div class="summary-grid">
            <div class="stat-card">
                <div class="stat-number">{total_hosts}</div>
                <div class="stat-label">Total Hosts</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{open_ports}</div>
                <div class="stat-label">Open Ports</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{unique_services}</div>
                <div class="stat-label">Unique Services</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{total_vulnerabilities}</div>
                <div class="stat-label">Vulnerabilities</div>
            </div>
        </div>
        
        <h2>🚨 Vulnerability Distribution</h2>
        <div class="summary-grid">
            <div class="stat-card vuln-critical">
                <div class="stat-number">{critical_vulns}</div>
                <div class="stat-label">Critical</div>
            </div>
            <div class="stat-card vuln-high">
                <div class="stat-number">{high_vulns}</div>
                <div class="stat-label">High</div>
            </div>
            <div class="stat-card vuln-medium">
                <div class="stat-number">{medium_vulns}</div>
                <div class="stat-label">Medium</div>
            </div>
            <div class="stat-card vuln-low">
                <div class="stat-number">{low_vulns}</div>
                <div class="stat-label">Low</div>
            </div>
        </div>
        
        <h2>🎯 Top Risk Hosts</h2>
        <table>
            <thead>
                <tr><th>IP Address</th><th>Risk Score</th><th>Risk Level</th></tr>
            </thead>
            <tbody>
                {risk_hosts_rows}
            </tbody>
        </table>
        
        <h2>🔧 Discovered Services</h2>
        <p>{services_list}</p>
        
        <h2>🔍 CVE References</h2>
        <p>{cves_list}</p>
        
        <h2>📋 Scan Information</h2>
        <table>
            <tr><th>Nmap Version</th><td>{nmap_version}</td></tr>
            <tr><th>Arguments</th><td>{scan_args}</td></tr>
            <tr><th>Start Time</th><td>{start_time}</td></tr>
            <tr><th>End Time</th><td>{end_time}</td></tr>
            <tr><th>Total Hosts</th><td>{scan_total_hosts}</td></tr>
        </table>
        
        {host_details}
        
        <footer style="text-align: center; margin-top: 50px; padding: 20px; border-top: 1px solid #ddd;">
            <p>Generated by Comprehensive Nmap Analyzer v2.0 | {generation_time}</p>
        </footer>
    </div>
</body>
</html>
"""
        
        # Prepare template variables
        vuln_count = self.vuln_analyzer.get_vulnerability_count() if self.vuln_analyzer else 0
        
        risk_hosts_rows = ""
        for ip, score in summary['risky_hosts']:
            risk_level = 'critical' if score >= 300 else 'high' if score >= 200 else 'medium' if score >= 100 else 'low'
            risk_hosts_rows += f'<tr><td>{ip}</td><td>{score}</td><td class="risk-{risk_level}">{risk_level.title()}</td></tr>'
        
        services_list = ", ".join(summary['top_services']) if summary['top_services'] else "No services detected"
        cves_list = ", ".join(summary['discovered_cves'][:20]) if summary['discovered_cves'] else "No CVEs found"
        
        # Generate host details
        host_details = ""
        for i, host in enumerate(self.hosts[:10]):  # Limit to top 10 hosts
            ip_addr = host.get('addresses', [{}])[0].get('addr', 'unknown')
            hostname = host.get('hostnames', [{}])[0].get('name', 'No hostname') if host.get('hostnames') else 'No hostname'
            
            host_details += f"""
            <div class="host-section">
                <h3>🖥️ Host: {ip_addr} ({hostname})</h3>
                <p><strong>Risk Score:</strong> {host.get('risk_score', 0)} | <strong>Open Ports:</strong> {len([p for p in host.get('ports', []) if p.get('state', {}).get('state') == 'open'])}</p>
            """
            
            for port in host.get('ports', [])[:5]:  # Show first 5 ports
                if port.get('state', {}).get('state') == 'open':
                    service = port.get('service', {})
                    port_details = f"""
                    <div class="port-item">
                        <strong>Port {port.get('portid')}/{port.get('protocol')}</strong> - 
                        {service.get('name', 'unknown')} 
                        {service.get('product', '')} 
                        {service.get('version', '')}
                        <span class="risk-{port.get('risk_level', 'low')}">[{port.get('risk_level', 'low').title()}]</span>
                        <br>Vulnerabilities: {len(port.get('vulnerabilities', []))}, CVEs: {len(port.get('cves', []))}
                    </div>
                    """
                    host_details += port_details
            
            host_details += "</div>"
        
        # Fill template
        html_content = html_template.format(
            vuln_count=vuln_count,
            total_hosts=summary['statistics']['total_hosts'],
            open_ports=summary['statistics']['open_ports'],
            unique_services=summary['statistics']['unique_services'],
            total_vulnerabilities=summary['statistics']['total_vulnerabilities'],
            critical_vulns=summary['vulnerability_stats']['critical'],
            high_vulns=summary['vulnerability_stats']['high'],
            medium_vulns=summary['vulnerability_stats']['medium'],
            low_vulns=summary['vulnerability_stats']['low'],
            risk_hosts_rows=risk_hosts_rows,
            services_list=services_list,
            cves_list=cves_list,
            nmap_version=summary['scan_info']['nmap_version'],
            scan_args=summary['scan_info']['arguments'],
            start_time=summary['scan_info']['start_time'],
            end_time=summary['scan_info']['end_time'],
            scan_total_hosts=summary['scan_info'].get('hosts_total', 0),
            host_details=host_details,
            generation_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        self.logger.info(f"HTML report generated: {output_file}")
        return output_file

def main():
    parser = argparse.ArgumentParser(
        description="Comprehensive Nmap XML Analysis with Vulnerability Integration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python nmap_analysis_comprehensive.py scan.xml
    python nmap_analysis_comprehensive.py scan.xml --vuln-db vulnerability_db.json
    python nmap_analysis_comprehensive.py scan.xml --output-format all
    python nmap_analysis_comprehensive.py scan.xml --html-report report.html

GitHub References:
    vulnerscom/nmap-vulners: https://github.com/vulnerscom/nmap-vulners
    ernw/nmap-parse-output: https://github.com/ernw/nmap-parse-output
        """
    )
    
    parser.add_argument('xml_file', help='Nmap XML output file to analyze')
    parser.add_argument('--vuln-db', help='Path to vulnerability database file')
    parser.add_argument('--output-format', choices=['json', 'csv', 'html', 'all'], 
                       default='json', help='Output format (default: json)')
    parser.add_argument('--json-output', help='JSON output file path')
    parser.add_argument('--csv-output', help='CSV output file path')
    parser.add_argument('--html-report', help='HTML report file path')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        # Initialize analyzer
        print("🔍 Starting Comprehensive Nmap Analysis...")
        print("📚 Framework based on vulnerscom/nmap-vulners and ernw/nmap-parse-output")
        
        analyzer = NmapAnalyzer(args.xml_file, args.vuln_db)
        
        # Generate summary
        summary = analyzer.get_summary()
        
        print(f"\n📊 Analysis Complete!")
        print(f"   Hosts analyzed: {summary['statistics']['total_hosts']}")
        print(f"   Open ports: {summary['statistics']['open_ports']}")
        print(f"   Services found: {summary['statistics']['unique_services']}")
        print(f"   Vulnerabilities: {summary['statistics']['total_vulnerabilities']}")
        print(f"   CVEs discovered: {summary['statistics']['unique_cves']}")
        
        # Export results
        if args.output_format in ['json', 'all']:
            json_file = analyzer.export_json(args.json_output)
            print(f"📄 JSON report: {json_file}")
        
        if args.output_format in ['csv', 'all']:
            csv_file = analyzer.export_csv(args.csv_output)
            print(f"📊 CSV report: {csv_file}")
        
        if args.output_format in ['html', 'all'] or args.html_report:
            html_file = analyzer.generate_html_report(args.html_report)
            print(f"🌐 HTML report: {html_file}")
        
        print(f"\n🔗 GitHub References:")
        print(f"   Vulnerability Scripts: https://github.com/vulnerscom/nmap-vulners")
        print(f"   XML Parse Tools: https://github.com/ernw/nmap-parse-output")
        
    except FileNotFoundError:
        print(f"❌ Error: XML file not found: {args.xml_file}")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()