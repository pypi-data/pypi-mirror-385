#!/usr/bin/env python3
"""
PCAP Analysis using Tshark (subprocess)
Advanced packet analysis with vulnerability detection

Wireshark GitHub: https://github.com/wireshark/wireshark
Wireshark Official: https://www.wireshark.org/
Tshark Documentation: https://www.wireshark.org/docs/man-pages/tshark.html

Requirements: Wireshark installation with tshark command available
Tshark is the command-line version of Wireshark, providing powerful
packet analysis capabilities through subprocess calls.
"""

import os
import sys
import subprocess
import json
import shutil
from pathlib import Path

# Add the src directory to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root / 'src'))

import vulnerability_analyzer


def analyze_pcap_with_tshark(pcap_file):
    """Analyze PCAP using Tshark subprocess"""
    try:
        # Check if tshark is available
        if not shutil.which('tshark'):
            print("  [!] Tshark not found. Install Wireshark to get tshark command.")
            return []
        
        print(f"[*] Loading PCAP with Tshark: {pcap_file}")
        
        # First get basic packet count
        cmd_count = ['tshark', '-r', pcap_file, '-q', '-z', 'io,stat,0']
        result = subprocess.run(cmd_count, capture_output=True, text=True, check=True)
        
        # Extract packet count from output
        lines = result.stdout.split('\n')
        for line in lines:
            if 'Frames:' in line:
                packet_count = line.split('Frames:')[1].strip().split()[0]
                print(f"  Total packets: {packet_count}")
                break
        
        services = []
        
        # Extract TCP streams with payload data
        cmd_tcp = [
            'tshark', '-r', pcap_file,
            '-Y', 'tcp and tcp.len > 0',  # TCP packets with payload
            '-T', 'fields',
            '-e', 'ip.src',
            '-e', 'ip.dst', 
            '-e', 'tcp.srcport',
            '-e', 'tcp.dstport',
            '-e', 'tcp.payload',
            '-e', 'frame.number'
        ]
        
        result = subprocess.run(cmd_tcp, capture_output=True, text=True, check=True)
        
        conversations = {}  # Track unique conversations
        
        for line in result.stdout.strip().split('\n'):
            if not line:
                continue
                
            fields = line.split('\t')
            if len(fields) < 6:
                continue
                
            src_ip = fields[0]
            dst_ip = fields[1]
            src_port = int(fields[2]) if fields[2] else 0
            dst_port = int(fields[3]) if fields[3] else 0
            payload_hex = fields[4]
            frame_number = fields[5]
            
            # Skip if we don't have essential info
            if not all([src_ip, dst_ip, dst_port, payload_hex]):
                continue
            
            conv_key = f"{dst_ip}:{dst_port}"
            
            # Convert hex payload to text
            try:
                payload_bytes = bytes.fromhex(payload_hex.replace(':', ''))
                payload = payload_bytes.decode('utf-8', errors='ignore')
            except:
                continue
            
            # Only process if we haven't seen this conversation yet
            if conv_key not in conversations and payload.strip():
                service_info = detect_service_from_payload(dst_port, payload)
                if service_info:
                    service_info.update({
                        'src_ip': src_ip,
                        'dst_ip': dst_ip,
                        'src_port': src_port,
                        'dst_port': dst_port,
                        'packet_number': frame_number,
                        'payload_preview': payload[:200],
                        'detected_by': 'tshark'
                    })
                    services.append(service_info)
                    conversations[conv_key] = True
                    print(f"    Detected {service_info['service']} on {dst_ip}:{dst_port}")
        
        # Also check for SYN packets to common ports
        cmd_syn = [
            'tshark', '-r', pcap_file,
            '-Y', 'tcp.flags.syn==1 and tcp.flags.ack==0',  # SYN only
            '-T', 'fields',
            '-e', 'ip.src',
            '-e', 'ip.dst',
            '-e', 'tcp.srcport',
            '-e', 'tcp.dstport',
            '-e', 'frame.number'
        ]
        
        result = subprocess.run(cmd_syn, capture_output=True, text=True, check=True)
        
        for line in result.stdout.strip().split('\n'):
            if not line:
                continue
                
            fields = line.split('\t')
            if len(fields) < 5:
                continue
                
            src_ip = fields[0]
            dst_ip = fields[1]
            src_port = int(fields[2]) if fields[2] else 0
            dst_port = int(fields[3]) if fields[3] else 0
            frame_number = fields[4]
            
            conv_key = f"{dst_ip}:{dst_port}"
            
            if conv_key not in conversations:
                service_info = detect_service_from_port(dst_port)
                if service_info:
                    service_info.update({
                        'src_ip': src_ip,
                        'dst_ip': dst_ip,
                        'src_port': src_port,
                        'dst_port': dst_port,
                        'packet_number': frame_number,
                        'payload_preview': f"SYN to port {dst_port}",
                        'detected_by': 'tshark'
                    })
                    services.append(service_info)
                    conversations[conv_key] = True
                    print(f"    Detected {service_info['service']} service attempt on {dst_ip}:{dst_port}")
        
        return services
        
    except FileNotFoundError:
        print("  [!] Tshark not found. Install Wireshark to get tshark command.")
        return []
    except subprocess.CalledProcessError as e:
        print(f"  [!] Tshark error: {e}")
        return []
    except Exception as e:
        print(f"  [!] Error with Tshark: {e}")
        return []


def detect_service_from_payload(port, payload):
    """Enhanced service detection from payload"""
    payload_lower = payload.lower()
    
    service_info = {
        'port': port,
        'service': '',
        'product': '',
        'version': '',
        'banner': payload.strip()
    }
    
    # SSH Detection
    if 'ssh-' in payload_lower:
        service_info['service'] = 'ssh'
        if 'openssh' in payload_lower:
            service_info['product'] = 'OpenSSH'
            # Extract version: SSH-2.0-OpenSSH_6.2
            try:
                if 'openssh_' in payload_lower:
                    version_part = payload.split('OpenSSH_')[1]
                    version = version_part.split()[0].split('\r')[0].split('\n')[0]
                    service_info['version'] = version
            except:
                pass
    
    # HTTP Detection
    elif any(x in payload_lower for x in ['http/', 'get /', 'post /', 'server:']):
        service_info['service'] = 'http'
        
        # Apache detection
        if 'apache' in payload_lower:
            service_info['product'] = 'Apache httpd'
            try:
                if 'apache/' in payload_lower:
                    version = payload_lower.split('apache/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
        
        # Nginx detection  
        elif 'nginx' in payload_lower:
            service_info['product'] = 'nginx'
            try:
                if 'nginx/' in payload_lower:
                    version = payload_lower.split('nginx/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
        
        # IIS detection
        elif 'microsoft-iis' in payload_lower:
            service_info['product'] = 'Microsoft IIS'
            try:
                if 'microsoft-iis/' in payload_lower:
                    version = payload_lower.split('microsoft-iis/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
    
    # FTP Detection
    elif payload_lower.startswith('220') and ('ftp' in payload_lower or port == 21):
        service_info['service'] = 'ftp'
        if 'vsftpd' in payload_lower:
            service_info['product'] = 'vsftpd'
            try:
                # Extract version from banner like "220 (vsFTPd 3.0.3)"
                if '(vsftpd' in payload_lower:
                    version = payload_lower.split('(vsftpd')[1].split(')')[0].strip()
                    service_info['version'] = version
            except:
                pass
        elif 'proftpd' in payload_lower:
            service_info['product'] = 'ProFTPD'
    
    # SMTP Detection
    elif payload_lower.startswith('220') and ('smtp' in payload_lower or port == 25):
        service_info['service'] = 'smtp'
        if 'postfix' in payload_lower:
            service_info['product'] = 'Postfix'
        elif 'sendmail' in payload_lower:
            service_info['product'] = 'Sendmail'
        elif 'exim' in payload_lower:
            service_info['product'] = 'Exim'
    
    # MySQL Detection
    elif 'mysql' in payload_lower or port == 3306:
        service_info['service'] = 'mysql'
        service_info['product'] = 'MySQL'
        try:
            # MySQL version detection is complex, often in binary protocol
            if 'server' in payload_lower:
                # Simple text-based version extraction
                parts = payload.split()
                for part in parts:
                    if any(char.isdigit() for char in part) and '.' in part:
                        service_info['version'] = part
                        break
        except:
            pass
    
    # DNS Detection
    elif port == 53:
        service_info['service'] = 'domain'
        service_info['product'] = 'DNS Server'
    
    # Return only if we detected a service
    return service_info if service_info['service'] else None


def detect_service_from_port(port):
    """Detect likely service from port number only"""
    port_services = {
        21: {'service': 'ftp', 'product': 'FTP Server'},
        22: {'service': 'ssh', 'product': 'SSH Server'},
        23: {'service': 'telnet', 'product': 'Telnet Server'},
        25: {'service': 'smtp', 'product': 'SMTP Server'},
        53: {'service': 'domain', 'product': 'DNS Server'},
        80: {'service': 'http', 'product': 'HTTP Server'},
        110: {'service': 'pop3', 'product': 'POP3 Server'},
        143: {'service': 'imap', 'product': 'IMAP Server'},
        443: {'service': 'https', 'product': 'HTTPS Server'},
        993: {'service': 'imaps', 'product': 'IMAPS Server'},
        995: {'service': 'pop3s', 'product': 'POP3S Server'},
        3306: {'service': 'mysql', 'product': 'MySQL Server'},
        5432: {'service': 'postgresql', 'product': 'PostgreSQL Server'},
    }
    
    if port in port_services:
        service_info = {
            'port': port,
            'service': port_services[port]['service'],
            'product': port_services[port]['product'],
            'version': '',
            'banner': f'Port {port} service detection'
        }
        return service_info
    
    return None


def analyze_services_for_vulnerabilities(services):
    """Analyze detected services for vulnerabilities"""
    if not services:
        print("  [!] No services detected from PCAP")
        return 0
    
    print(f"\n[*] VULNERABILITY ANALYSIS")
    print("=" * 50)
    
    # Initialize vulnerability analyzer
    analyzer = vulnerability_analyzer.VulnerabilityAnalyzer()
    
    # Group services by destination IP
    services_by_host = {}
    for service in services:
        dst_ip = service['dst_ip']
        if dst_ip not in services_by_host:
            services_by_host[dst_ip] = []
        
        # Convert to format expected by analyzer
        service_data = {
            'port': service['port'],
            'service': service['service'],
            'product': service['product'],
            'version': service['version'],
            'banner': service['banner']
        }
        services_by_host[dst_ip].append(service_data)
    
    total_vulnerabilities = 0
    
    for host_ip, host_services in services_by_host.items():
        print(f"\n[*] Analyzing host: {host_ip}")
        print(f"  Services detected: {len(host_services)}")
        
        # Show detected services
        for service in host_services:
            product_version = f"{service['product']} {service['version']}".strip()
            print(f"    - {service['service']}:{service['port']} - {product_version}")
        
        # Analyze vulnerabilities
        results = analyzer.analyze_service_vulnerabilities(host_ip, host_services)
        
        vuln_count = len(results['vulnerabilities_found'])
        total_vulnerabilities += vuln_count
        
        print(f"  Vulnerabilities found: {vuln_count}")
        print(f"  Risk score: {results['risk_score']:.1f}/10")
        
        # Show sample vulnerabilities
        for vuln in results['vulnerabilities_found'][:3]:
            print(f"    - {vuln['cve_id']}: {vuln['severity']} (Score: {vuln['base_score']})")
            print(f"      {vuln['title'][:80]}...")
    
    return total_vulnerabilities


def main():
    """Main function for Tshark PCAP analysis"""
    print("[*] TSHARK PCAP ANALYSIS WITH VULNERABILITY DETECTION")
    print("=" * 70)
    
    # Path to PCAP file
    pcap_file = Path(__file__).parent / 'sample_data' / 'vulnerable_traffic.pcap'
    
    if not pcap_file.exists():
        print(f"[!] PCAP file not found: {pcap_file}")
        print("  Place a PCAP file at examples/sample_data/vulnerable_traffic.pcap")
        return
    
    print(f"[*] Target PCAP: {pcap_file}")
    print(f"  File size: {pcap_file.stat().st_size} bytes")
    
    # Analyze with Tshark
    services = analyze_pcap_with_tshark(str(pcap_file))
    
    print(f"\n[*] SERVICES DETECTED:")
    print("-" * 40)
    for service in services:
        product_version = f"{service['product']} {service['version']}".strip()
        print(f"  {service['dst_ip']}:{service['dst_port']} - {service['service']} - {product_version}")
        print(f"    Packet #{service['packet_number']}: {service['payload_preview'][:60]}...")
    
    # Analyze for vulnerabilities
    total_vulns = analyze_services_for_vulnerabilities(services)
    
    print(f"\n[*] TSHARK ANALYSIS COMPLETE")
    print("=" * 40)
    print(f"Services detected: {len(services)}")
    print(f"Total vulnerabilities: {total_vulns}")
    print("Method: Tshark subprocess")


if __name__ == "__main__":
    main()