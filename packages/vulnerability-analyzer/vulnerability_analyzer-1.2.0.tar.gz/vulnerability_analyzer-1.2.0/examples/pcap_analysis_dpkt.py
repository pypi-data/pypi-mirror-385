#!/usr/bin/env python3
"""
PCAP Analysis using DPKT
Advanced packet analysis with vulnerability detection

DPKT GitHub: https://github.com/kbandla/dpkt
Documentation: https://dpkt.readthedocs.io/
Installation: pip install dpkt

DPKT is a python module for fast, simple packet creation/parsing, 
with definitions for the basic TCP/IP protocols. It provides a 
simple, fast way to create and parse packets.
"""

import os
import sys
from pathlib import Path

# Add the src directory to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root / 'src'))

import vulnerability_analyzer


def analyze_pcap_with_dpkt(pcap_file):
    """Analyze PCAP using DPKT library"""
    try:
        import dpkt
        import socket
        print(f"[*] Loading PCAP with DPKT: {pcap_file}")
        
        services = []
        conversations = {}  # Track unique conversations
        packet_count = 0
        
        with open(pcap_file, 'rb') as f:
            pcap = dpkt.pcap.Reader(f)
            
            for timestamp, buf in pcap:
                packet_count += 1
                
                try:
                    # Parse Ethernet frame
                    eth = dpkt.ethernet.Ethernet(buf)
                    
                    # Only process IP packets
                    if not isinstance(eth.data, dpkt.ip.IP):
                        continue
                        
                    ip = eth.data
                    
                    # Convert IP addresses to readable format
                    src_ip = socket.inet_ntoa(ip.src)
                    dst_ip = socket.inet_ntoa(ip.dst)
                    
                    # Only process TCP packets
                    if not isinstance(ip.data, dpkt.tcp.TCP):
                        continue
                        
                    tcp = ip.data
                    src_port = tcp.sport
                    dst_port = tcp.dport
                    
                    # Create conversation key
                    conv_key = f"{dst_ip}:{dst_port}"
                    
                    # Extract payload if available
                    payload = ""
                    if tcp.data:
                        try:
                            payload = tcp.data.decode('utf-8', errors='ignore')
                        except:
                            # Try to decode as bytes
                            payload = str(tcp.data)
                    
                    # Only process if we haven't seen this conversation yet and have payload
                    if conv_key not in conversations and payload.strip():
                        service_info = detect_service_from_payload(dst_port, payload)
                        if service_info:
                            service_info.update({
                                'src_ip': src_ip,
                                'dst_ip': dst_ip,
                                'src_port': src_port,
                                'dst_port': dst_port,
                                'packet_number': packet_count,
                                'payload_preview': payload[:200],
                                'detected_by': 'dpkt',
                                'timestamp': timestamp
                            })
                            services.append(service_info)
                            conversations[conv_key] = True
                            print(f"    Detected {service_info['service']} on {dst_ip}:{dst_port}")
                            
                    # Check for SYN packets to common ports even without payload
                    elif (tcp.flags & dpkt.tcp.TH_SYN) and not (tcp.flags & dpkt.tcp.TH_ACK):
                        if conv_key not in conversations:
                            service_info = detect_service_from_port(dst_port)
                            if service_info:
                                service_info.update({
                                    'src_ip': src_ip,
                                    'dst_ip': dst_ip,
                                    'src_port': src_port,
                                    'dst_port': dst_port,
                                    'packet_number': packet_count,
                                    'payload_preview': f"SYN to port {dst_port}",
                                    'detected_by': 'dpkt',
                                    'timestamp': timestamp
                                })
                                services.append(service_info)
                                conversations[conv_key] = True
                                print(f"    Detected {service_info['service']} service attempt on {dst_ip}:{dst_port}")
                
                except (dpkt.dpkt.NeedData, dpkt.dpkt.UnpackError):
                    # Skip malformed packets
                    continue
                except Exception as e:
                    # Skip other packet parsing errors
                    continue
        
        print(f"  Total packets processed: {packet_count}")
        return services
        
    except ImportError:
        print("  [!] DPKT not installed. Install with: pip install dpkt")
        return []
    except Exception as e:
        print(f"  [!] Error with DPKT: {e}")
        return []


def detect_service_from_payload(port, payload):
    """Enhanced service detection from payload"""
    payload_lower = payload.lower()
    
    service_info = {
        'port': port,
        'service': '',
        'product': '',
        'version': '',
        'banner': payload.strip()
    }
    
    # SSH Detection
    if 'ssh-' in payload_lower:
        service_info['service'] = 'ssh'
        if 'openssh' in payload_lower:
            service_info['product'] = 'OpenSSH'
            # Extract version: SSH-2.0-OpenSSH_6.2
            try:
                if 'openssh_' in payload_lower:
                    version_part = payload.split('OpenSSH_')[1]
                    version = version_part.split()[0].split('\r')[0].split('\n')[0]
                    service_info['version'] = version
            except:
                pass
    
    # HTTP Detection
    elif any(x in payload_lower for x in ['http/', 'get /', 'post /', 'server:']):
        service_info['service'] = 'http'
        
        # Apache detection
        if 'apache' in payload_lower:
            service_info['product'] = 'Apache httpd'
            try:
                if 'apache/' in payload_lower:
                    version = payload_lower.split('apache/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
        
        # Nginx detection  
        elif 'nginx' in payload_lower:
            service_info['product'] = 'nginx'
            try:
                if 'nginx/' in payload_lower:
                    version = payload_lower.split('nginx/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
        
        # IIS detection
        elif 'microsoft-iis' in payload_lower:
            service_info['product'] = 'Microsoft IIS'
            try:
                if 'microsoft-iis/' in payload_lower:
                    version = payload_lower.split('microsoft-iis/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
    
    # FTP Detection
    elif payload_lower.startswith('220') and ('ftp' in payload_lower or port == 21):
        service_info['service'] = 'ftp'
        if 'vsftpd' in payload_lower:
            service_info['product'] = 'vsftpd'
            try:
                # Extract version from banner like "220 (vsFTPd 3.0.3)"
                if '(vsftpd' in payload_lower:
                    version = payload_lower.split('(vsftpd')[1].split(')')[0].strip()
                    service_info['version'] = version
            except:
                pass
        elif 'proftpd' in payload_lower:
            service_info['product'] = 'ProFTPD'
    
    # SMTP Detection
    elif payload_lower.startswith('220') and ('smtp' in payload_lower or port == 25):
        service_info['service'] = 'smtp'
        if 'postfix' in payload_lower:
            service_info['product'] = 'Postfix'
        elif 'sendmail' in payload_lower:
            service_info['product'] = 'Sendmail'
        elif 'exim' in payload_lower:
            service_info['product'] = 'Exim'
    
    # MySQL Detection
    elif 'mysql' in payload_lower or port == 3306:
        service_info['service'] = 'mysql'
        service_info['product'] = 'MySQL'
        try:
            # MySQL version detection is complex, often in binary protocol
            if 'server' in payload_lower:
                # Simple text-based version extraction
                parts = payload.split()
                for part in parts:
                    if any(char.isdigit() for char in part) and '.' in part:
                        service_info['version'] = part
                        break
        except:
            pass
    
    # DNS Detection
    elif port == 53:
        service_info['service'] = 'domain'
        service_info['product'] = 'DNS Server'
    
    # Return only if we detected a service
    return service_info if service_info['service'] else None


def detect_service_from_port(port):
    """Detect likely service from port number only"""
    port_services = {
        21: {'service': 'ftp', 'product': 'FTP Server'},
        22: {'service': 'ssh', 'product': 'SSH Server'},
        23: {'service': 'telnet', 'product': 'Telnet Server'},
        25: {'service': 'smtp', 'product': 'SMTP Server'},
        53: {'service': 'domain', 'product': 'DNS Server'},
        80: {'service': 'http', 'product': 'HTTP Server'},
        110: {'service': 'pop3', 'product': 'POP3 Server'},
        143: {'service': 'imap', 'product': 'IMAP Server'},
        443: {'service': 'https', 'product': 'HTTPS Server'},
        993: {'service': 'imaps', 'product': 'IMAPS Server'},
        995: {'service': 'pop3s', 'product': 'POP3S Server'},
        3306: {'service': 'mysql', 'product': 'MySQL Server'},
        5432: {'service': 'postgresql', 'product': 'PostgreSQL Server'},
    }
    
    if port in port_services:
        service_info = {
            'port': port,
            'service': port_services[port]['service'],
            'product': port_services[port]['product'],
            'version': '',
            'banner': f'Port {port} service detection'
        }
        return service_info
    
    return None


def advanced_dpkt_analysis(pcap_file):
    """Advanced DPKT analysis with protocol statistics"""
    try:
        import dpkt
        import socket
        print(f"[*] Advanced DPKT analysis: {pcap_file}")
        
        protocol_stats = {}
        connection_stats = {}
        tcp_streams = {}
        
        with open(pcap_file, 'rb') as f:
            pcap = dpkt.pcap.Reader(f)
            
            for timestamp, buf in pcap:
                try:
                    eth = dpkt.ethernet.Ethernet(buf)
                    
                    if isinstance(eth.data, dpkt.ip.IP):
                        ip = eth.data
                        src_ip = socket.inet_ntoa(ip.src)
                        dst_ip = socket.inet_ntoa(ip.dst)
                        
                        # Track protocol statistics
                        if isinstance(ip.data, dpkt.tcp.TCP):
                            protocol = 'TCP'
                            tcp = ip.data
                            conn_key = f"{src_ip}:{tcp.sport}->{dst_ip}:{tcp.dport}"
                            
                            # Track connection statistics
                            if conn_key not in connection_stats:
                                connection_stats[conn_key] = {
                                    'packets': 0,
                                    'bytes': 0,
                                    'first_seen': timestamp,
                                    'last_seen': timestamp
                                }
                            
                            connection_stats[conn_key]['packets'] += 1
                            connection_stats[conn_key]['bytes'] += len(tcp.data) if tcp.data else 0
                            connection_stats[conn_key]['last_seen'] = timestamp
                            
                        elif isinstance(ip.data, dpkt.udp.UDP):
                            protocol = 'UDP'
                        elif isinstance(ip.data, dpkt.icmp.ICMP):
                            protocol = 'ICMP'
                        else:
                            protocol = 'Other'
                        
                        protocol_stats[protocol] = protocol_stats.get(protocol, 0) + 1
                
                except:
                    continue
        
        print(f"  Protocol distribution:")
        for protocol, count in sorted(protocol_stats.items(), key=lambda x: x[1], reverse=True):
            print(f"    {protocol}: {count} packets")
        
        print(f"  Top connections by packet count:")
        sorted_conns = sorted(connection_stats.items(), key=lambda x: x[1]['packets'], reverse=True)
        for conn, stats in sorted_conns[:5]:
            duration = stats['last_seen'] - stats['first_seen']
            print(f"    {conn}: {stats['packets']} packets, {stats['bytes']} bytes, {duration:.2f}s")
        
        return protocol_stats, connection_stats
        
    except Exception as e:
        print(f"  [!] Advanced DPKT analysis error: {e}")
        return {}, {}


def analyze_services_for_vulnerabilities(services):
    """Analyze detected services for vulnerabilities"""
    if not services:
        print("  [!] No services detected from PCAP")
        return 0
    
    print(f"\n[*] VULNERABILITY ANALYSIS")
    print("=" * 50)
    
    # Initialize vulnerability analyzer
    analyzer = vulnerability_analyzer.VulnerabilityAnalyzer()
    
    # Group services by destination IP
    services_by_host = {}
    for service in services:
        dst_ip = service['dst_ip']
        if dst_ip not in services_by_host:
            services_by_host[dst_ip] = []
        
        # Convert to format expected by analyzer
        service_data = {
            'port': service['port'],
            'service': service['service'],
            'product': service['product'],
            'version': service['version'],
            'banner': service['banner']
        }
        services_by_host[dst_ip].append(service_data)
    
    total_vulnerabilities = 0
    
    for host_ip, host_services in services_by_host.items():
        print(f"\n[*] Analyzing host: {host_ip}")
        print(f"  Services detected: {len(host_services)}")
        
        # Show detected services
        for service in host_services:
            product_version = f"{service['product']} {service['version']}".strip()
            print(f"    - {service['service']}:{service['port']} - {product_version}")
        
        # Analyze vulnerabilities
        results = analyzer.analyze_service_vulnerabilities(host_ip, host_services)
        
        vuln_count = len(results['vulnerabilities_found'])
        total_vulnerabilities += vuln_count
        
        print(f"  Vulnerabilities found: {vuln_count}")
        print(f"  Risk score: {results['risk_score']:.1f}/10")
        
        # Show sample vulnerabilities
        for vuln in results['vulnerabilities_found'][:3]:
            print(f"    - {vuln['cve_id']}: {vuln['severity']} (Score: {vuln['base_score']})")
            print(f"      {vuln['title'][:80]}...")
    
    return total_vulnerabilities


def main():
    """Main function for DPKT PCAP analysis"""
    print("[*] DPKT PCAP ANALYSIS WITH VULNERABILITY DETECTION")
    print("=" * 70)
    
    # Path to PCAP file
    pcap_file = Path(__file__).parent / 'sample_data' / 'vulnerable_traffic.pcap'
    
    if not pcap_file.exists():
        print(f"[!] PCAP file not found: {pcap_file}")
        print("  Place a PCAP file at examples/sample_data/vulnerable_traffic.pcap")
        return
    
    print(f"[*] Target PCAP: {pcap_file}")
    print(f"  File size: {pcap_file.stat().st_size} bytes")
    
    # Basic DPKT analysis
    services = analyze_pcap_with_dpkt(str(pcap_file))
    
    print(f"\n[*] SERVICES DETECTED:")
    print("-" * 40)
    for service in services:
        product_version = f"{service['product']} {service['version']}".strip()
        print(f"  {service['dst_ip']}:{service['dst_port']} - {service['service']} - {product_version}")
        print(f"    Packet #{service['packet_number']}: {service['payload_preview'][:60]}...")
    
    # Advanced DPKT analysis
    protocol_stats, connection_stats = advanced_dpkt_analysis(str(pcap_file))
    
    # Analyze for vulnerabilities
    total_vulns = analyze_services_for_vulnerabilities(services)
    
    print(f"\n[*] DPKT ANALYSIS COMPLETE")
    print("=" * 40)
    print(f"Services detected: {len(services)}")
    print(f"Total vulnerabilities: {total_vulns}")
    print(f"Protocols analyzed: {len(protocol_stats)}")
    print(f"Connections tracked: {len(connection_stats)}")
    print("Method: DPKT packet parsing")


if __name__ == "__main__":
    main()