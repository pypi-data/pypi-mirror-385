#!/usr/bin/env python3
"""
PCAP Analysis using Scapy
Advanced packet analysis with vulnerability detection

GitHub Repository: https://github.com/secdev/scapy
Documentation: https://scapy.readthedocs.io/
Installation: pip install scapy

Scapy is a powerful Python-based interactive packet manipulation program and library.
It is able to forge or decode packets of a wide number of protocols, send them on 
the wire, capture them, store or read them using pcap files, match requests and replies.
"""

import os
import sys
from pathlib import Path

# Add the src directory to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root / 'src'))

import vulnerability_analyzer


def analyze_pcap_with_scapy(pcap_file):
    """Analyze PCAP using Scapy library"""
    try:
        import scapy.all as scapy
        print(f"[*] Loading PCAP with Scapy: {pcap_file}")
        
        # Read all packets from PCAP
        packets = scapy.rdpcap(pcap_file)
        print(f"  Total packets loaded: {len(packets)}")
        
        services = []
        conversations = {}  # Track unique conversations
        
        for i, packet in enumerate(packets):
            if packet.haslayer(scapy.TCP):
                tcp = packet[scapy.TCP]
                
                # Extract network info
                if packet.haslayer(scapy.IP):
                    src_ip = packet[scapy.IP].src
                    dst_ip = packet[scapy.IP].dst
                else:
                    continue
                
                src_port = tcp.sport
                dst_port = tcp.dport
                
                # Create conversation key
                conv_key = f"{dst_ip}:{dst_port}"
                
                # Extract payload if available
                if packet.haslayer(scapy.Raw):
                    try:
                        payload = packet[scapy.Raw].load.decode('utf-8', errors='ignore')
                        
                        # Only process if we haven't seen this conversation yet
                        if conv_key not in conversations and payload.strip():
                            service_info = detect_service_from_payload(dst_port, payload)
                            if service_info:
                                service_info.update({
                                    'src_ip': src_ip,
                                    'dst_ip': dst_ip,
                                    'src_port': src_port,
                                    'dst_port': dst_port,
                                    'packet_number': i + 1,
                                    'payload_preview': payload[:200],
                                    'detected_by': 'scapy'
                                })
                                services.append(service_info)
                                conversations[conv_key] = True
                                print(f"    Detected {service_info['service']} on {dst_ip}:{dst_port}")
                    except:
                        pass  # Skip binary/malformed data
                        
                # Check for SYN packets to common ports even without payload
                elif tcp.flags == 2:  # SYN flag
                    if conv_key not in conversations:
                        service_info = detect_service_from_port(dst_port)
                        if service_info:
                            service_info.update({
                                'src_ip': src_ip,
                                'dst_ip': dst_ip,
                                'src_port': src_port,
                                'dst_port': dst_port,
                                'packet_number': i + 1,
                                'payload_preview': f"SYN to port {dst_port}",
                                'detected_by': 'scapy'
                            })
                            services.append(service_info)
                            conversations[conv_key] = True
                            print(f"    Detected {service_info['service']} service attempt on {dst_ip}:{dst_port}")
        
        return services
        
    except ImportError:
        print("  [!] Scapy not installed. Install with: pip install scapy")
        return []
    except Exception as e:
        print(f"  [!] Error with Scapy: {e}")
        return []


def detect_service_from_payload(port, payload):
    """Enhanced service detection from payload"""
    payload_lower = payload.lower()
    
    service_info = {
        'port': port,
        'service': '',
        'product': '',
        'version': '',
        'banner': payload.strip()
    }
    
    # SSH Detection
    if 'ssh-' in payload_lower:
        service_info['service'] = 'ssh'
        if 'openssh' in payload_lower:
            service_info['product'] = 'OpenSSH'
            # Extract version: SSH-2.0-OpenSSH_6.2
            try:
                if 'openssh_' in payload_lower:
                    version_part = payload.split('OpenSSH_')[1]
                    version = version_part.split()[0].split('\r')[0].split('\n')[0]
                    service_info['version'] = version
            except:
                pass
    
    # HTTP Detection
    elif any(x in payload_lower for x in ['http/', 'get /', 'post /', 'server:']):
        service_info['service'] = 'http'
        
        # Apache detection
        if 'apache' in payload_lower:
            service_info['product'] = 'Apache httpd'
            try:
                if 'apache/' in payload_lower:
                    version = payload_lower.split('apache/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
        
        # Nginx detection  
        elif 'nginx' in payload_lower:
            service_info['product'] = 'nginx'
            try:
                if 'nginx/' in payload_lower:
                    version = payload_lower.split('nginx/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
        
        # IIS detection
        elif 'microsoft-iis' in payload_lower:
            service_info['product'] = 'Microsoft IIS'
            try:
                if 'microsoft-iis/' in payload_lower:
                    version = payload_lower.split('microsoft-iis/')[1].split()[0]
                    service_info['version'] = version
            except:
                pass
    
    # FTP Detection
    elif payload_lower.startswith('220') and ('ftp' in payload_lower or port == 21):
        service_info['service'] = 'ftp'
        if 'vsftpd' in payload_lower:
            service_info['product'] = 'vsftpd'
            try:
                # Extract version from banner like "220 (vsFTPd 3.0.3)"
                if '(vsftpd' in payload_lower:
                    version = payload_lower.split('(vsftpd')[1].split(')')[0].strip()
                    service_info['version'] = version
            except:
                pass
        elif 'proftpd' in payload_lower:
            service_info['product'] = 'ProFTPD'
    
    # SMTP Detection
    elif payload_lower.startswith('220') and ('smtp' in payload_lower or port == 25):
        service_info['service'] = 'smtp'
        if 'postfix' in payload_lower:
            service_info['product'] = 'Postfix'
        elif 'sendmail' in payload_lower:
            service_info['product'] = 'Sendmail'
        elif 'exim' in payload_lower:
            service_info['product'] = 'Exim'
    
    # MySQL Detection
    elif 'mysql' in payload_lower or port == 3306:
        service_info['service'] = 'mysql'
        service_info['product'] = 'MySQL'
        try:
            # MySQL version detection is complex, often in binary protocol
            if 'server' in payload_lower:
                # Simple text-based version extraction
                parts = payload.split()
                for part in parts:
                    if any(char.isdigit() for char in part) and '.' in part:
                        service_info['version'] = part
                        break
        except:
            pass
    
    # DNS Detection
    elif port == 53:
        service_info['service'] = 'domain'
        service_info['product'] = 'DNS Server'
    
    # Return only if we detected a service
    return service_info if service_info['service'] else None


def detect_service_from_port(port):
    """Detect likely service from port number only"""
    port_services = {
        21: {'service': 'ftp', 'product': 'FTP Server'},
        22: {'service': 'ssh', 'product': 'SSH Server'},
        23: {'service': 'telnet', 'product': 'Telnet Server'},
        25: {'service': 'smtp', 'product': 'SMTP Server'},
        53: {'service': 'domain', 'product': 'DNS Server'},
        80: {'service': 'http', 'product': 'HTTP Server'},
        110: {'service': 'pop3', 'product': 'POP3 Server'},
        143: {'service': 'imap', 'product': 'IMAP Server'},
        443: {'service': 'https', 'product': 'HTTPS Server'},
        993: {'service': 'imaps', 'product': 'IMAPS Server'},
        995: {'service': 'pop3s', 'product': 'POP3S Server'},
        3306: {'service': 'mysql', 'product': 'MySQL Server'},
        5432: {'service': 'postgresql', 'product': 'PostgreSQL Server'},
    }
    
    if port in port_services:
        service_info = {
            'port': port,
            'service': port_services[port]['service'],
            'product': port_services[port]['product'],
            'version': '',
            'banner': f'Port {port} service detection'
        }
        return service_info
    
    return None


def analyze_services_for_vulnerabilities(services):
    """Analyze detected services for vulnerabilities"""
    if not services:
        print("  [!] No services detected from PCAP")
        return 0
    
    print(f"\n[*] VULNERABILITY ANALYSIS")
    print("=" * 50)
    
    # Initialize vulnerability analyzer
    analyzer = vulnerability_analyzer.VulnerabilityAnalyzer()
    
    # Group services by destination IP
    services_by_host = {}
    for service in services:
        dst_ip = service['dst_ip']
        if dst_ip not in services_by_host:
            services_by_host[dst_ip] = []
        
        # Convert to format expected by analyzer
        service_data = {
            'port': service['port'],
            'service': service['service'],
            'product': service['product'],
            'version': service['version'],
            'banner': service['banner']
        }
        services_by_host[dst_ip].append(service_data)
    
    total_vulnerabilities = 0
    
    for host_ip, host_services in services_by_host.items():
        print(f"\n[*] Analyzing host: {host_ip}")
        print(f"  Services detected: {len(host_services)}")
        
        # Show detected services
        for service in host_services:
            product_version = f"{service['product']} {service['version']}".strip()
            print(f"    - {service['service']}:{service['port']} - {product_version}")
        
        # Analyze vulnerabilities
        results = analyzer.analyze_service_vulnerabilities(host_ip, host_services)
        
        vuln_count = len(results['vulnerabilities_found'])
        total_vulnerabilities += vuln_count
        
        print(f"  Vulnerabilities found: {vuln_count}")
        print(f"  Risk score: {results['risk_score']:.1f}/10")
        
        # Show sample vulnerabilities
        for vuln in results['vulnerabilities_found'][:3]:
            print(f"    - {vuln['cve_id']}: {vuln['severity']} (Score: {vuln['base_score']})")
            print(f"      {vuln['title'][:80]}...")
    
    return total_vulnerabilities


def main():
    """Main function for Scapy PCAP analysis"""
    print("[*] SCAPY PCAP ANALYSIS WITH VULNERABILITY DETECTION")
    print("=" * 70)
    
    # Path to PCAP file
    pcap_file = Path(__file__).parent / 'sample_data' / 'vulnerable_traffic.pcap'
    
    if not pcap_file.exists():
        print(f"[!] PCAP file not found: {pcap_file}")
        print("  Place a PCAP file at examples/sample_data/vulnerable_traffic.pcap")
        return
    
    print(f"[*] Target PCAP: {pcap_file}")
    print(f"  File size: {pcap_file.stat().st_size} bytes")
    
    # Analyze with Scapy
    services = analyze_pcap_with_scapy(str(pcap_file))
    
    print(f"\n[*] SERVICES DETECTED:")
    print("-" * 40)
    for service in services:
        product_version = f"{service['product']} {service['version']}".strip()
        print(f"  {service['dst_ip']}:{service['dst_port']} - {service['service']} - {product_version}")
        print(f"    Packet #{service['packet_number']}: {service['payload_preview'][:60]}...")
    
    # Analyze for vulnerabilities
    total_vulns = analyze_services_for_vulnerabilities(services)
    
    print(f"\n[*] SCAPY ANALYSIS COMPLETE")
    print("=" * 40)
    print(f"Services detected: {len(services)}")
    print(f"Total vulnerabilities: {total_vulns}")
    print("Method: Scapy packet parsing")


if __name__ == "__main__":
    main()