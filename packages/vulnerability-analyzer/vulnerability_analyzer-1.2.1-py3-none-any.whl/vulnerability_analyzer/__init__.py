"""Vulnerability Analyzer - Advanced Vulnerability Analysis Library."""

from collections import Counter, defaultdict
from typing import Any, Dict, List, Optional, Set

__version__ = "1.2.0"
__author__ = "D14b0l1c"
__license__ = "MIT"

# Core imports - works offline with embedded data
from .database.embedded import EmbeddedVulnerabilityDatabase, get_embedded_database
from .analysis.core import (
    VulnerabilityAnalyzer,
    analyze_host,
    analyze_traffic,
    quick_scan,
)

# Advanced imports (may require external files/internet)
try:
    from .database.database import VulnerabilityDatabase
    from .analysis.pcap import PcapAnalyzer
    from .analysis.nmap import NmapAnalyzer
    from .vulnerability.matcher import VulnerabilityMatcher
    from .vulnerability.assessment import VulnerabilityAssessment
    ADVANCED_FEATURES_AVAILABLE = True
except ImportError:
    VulnerabilityDatabase = None  # type: ignore[assignment]
    PcapAnalyzer = None  # type: ignore[assignment]
    NmapAnalyzer = None  # type: ignore[assignment]
    VulnerabilityMatcher = None  # type: ignore[assignment]
    VulnerabilityAssessment = None  # type: ignore[assignment]
    ADVANCED_FEATURES_AVAILABLE = False

# Optional data source imports
try:
    from .data.cve_sources import CVEDataManager
    from .data.database_manager import (
        DatabaseManager,
        get_database_status,
        initialize_pysploit_database,
        update_vulnerability_database,
    )
    from .data.routersploit_data import (
        RouterSploitIntegration,
        RouterSploitVulnerabilityDatabase,
        assess_device_routersploit_compatibility,
        get_routersploit_database,
    )
    DATA_SOURCES_AVAILABLE = True
except ImportError:
    CVEDataManager = None  # type: ignore[assignment]
    DatabaseManager = None  # type: ignore[assignment]
    get_database_status = None  # type: ignore[assignment]
    initialize_pysploit_database = None  # type: ignore[assignment]
    update_vulnerability_database = None  # type: ignore[assignment]
    RouterSploitIntegration = None  # type: ignore[assignment]
    RouterSploitVulnerabilityDatabase = None  # type: ignore[assignment]
    assess_device_routersploit_compatibility = None  # type: ignore[assignment]
    get_routersploit_database = None  # type: ignore[assignment]
    DATA_SOURCES_AVAILABLE = False

# Optional utility imports
try:
    from .utils.reports import generate_report, ReportGenerator
    from .utils.filters import TrafficFilter, VulnerabilityFilter
    from .utils.helpers import load_config, setup_logging
    UTILS_AVAILABLE = True
except ImportError:
    generate_report = None  # type: ignore[assignment]
    ReportGenerator = None  # type: ignore[assignment]
    TrafficFilter = None  # type: ignore[assignment]
    VulnerabilityFilter = None  # type: ignore[assignment]
    load_config = None  # type: ignore[assignment]
    setup_logging = None  # type: ignore[assignment]
    UTILS_AVAILABLE = False

# Friendly alias for public API compatibility when database helpers are available
if DATA_SOURCES_AVAILABLE and initialize_pysploit_database is not None:
    initialize_vulnerability_database = initialize_pysploit_database
else:
    initialize_vulnerability_database = None  # type: ignore[assignment]

# Define what gets imported with "from vulnerability_analyzer import *"
__all__ = [
    # Core classes and helpers
    'VulnerabilityAnalyzer',
    'analyze_host',
    'analyze_traffic',
    'quick_scan',
    'EmbeddedVulnerabilityDatabase',
    'get_embedded_database',
    'quick_analyze',
    'search_vulnerabilities',
    'get_critical_vulnerabilities',
    'get_database_info',
    'get_router_vulnerabilities',
    'search_cves',

    # Package info
    '__version__',
    '__author__',
    '__license__'
]

if ADVANCED_FEATURES_AVAILABLE:
    __all__.extend([
        'VulnerabilityDatabase',
        'PcapAnalyzer',
        'NmapAnalyzer',
        'VulnerabilityMatcher',
        'VulnerabilityAssessment',
    ])

if DATA_SOURCES_AVAILABLE:
    __all__.extend([
        'CVEDataManager',
        'DatabaseManager',
        'RouterSploitVulnerabilityDatabase',
        'RouterSploitIntegration',
        'initialize_pysploit_database',
        'initialize_vulnerability_database',
        'update_vulnerability_database',
        'get_database_status',
        'get_routersploit_database',
        'assess_device_routersploit_compatibility',
    ])

if UTILS_AVAILABLE:
    __all__.extend([
        'generate_report',
        'ReportGenerator',
        'TrafficFilter',
        'VulnerabilityFilter',
        'load_config',
        'setup_logging',
    ])

# Package-level convenience functions
def quick_analyze(
    pcap_path: Optional[str] = None,
    nmap_file: Optional[str] = None,
    output_format: str = "json",
) -> Dict[str, Any]:
    """Run a streamlined vulnerability analysis for PCAP and/or Nmap data."""

    if not ADVANCED_FEATURES_AVAILABLE:
        raise RuntimeError(
            "quick_analyze requires optional advanced dependencies. "
            "Install vulnerability-analyzer with the 'advanced' extras to enable this feature."
        )

    if not pcap_path and not nmap_file:
        raise ValueError("At least one of pcap_path or nmap_file must be provided.")

    analyzer = VulnerabilityAnalyzer()
    traffic_summary: Optional[Dict[str, Any]] = None
    nmap_summary: Optional[Dict[str, Any]] = None
    service_assessments: List[Dict[str, Any]] = []
    vulnerability_matches: List[Dict[str, Any]] = []
    host_sources: Dict[str, Set[str]] = defaultdict(set)
    host_assessments: Dict[str, List[Dict[str, Any]]] = defaultdict(list)

    def _collect_services(host: Dict[str, Any]) -> List[Dict[str, Any]]:
        services: List[Dict[str, Any]] = []
        for port in host.get('ports', []) or []:
            service_details = port.get('service', {}) or {}
            service_name = (
                service_details.get('name')
                or service_details.get('product')
                or next(iter(port.get('services', []) or []), 'unknown')
            )
            services.append(
                {
                    'port': port.get('portid'),
                    'service': service_name,
                    'product': service_details.get('product', ''),
                    'version': service_details.get('version', ''),
                    'banner': service_details.get('extrainfo', ''),
                    'cpe': service_details.get('cpe', ''),
                }
            )
        return services

    def _host_identifier(host: Dict[str, Any]) -> str:
        for address in host.get('addresses', []) or []:
            addr = address.get('addr')
            if addr:
                return str(addr)
        return str(host.get('ip', 'unknown'))

    def _analyze_hosts(hosts: List[Dict[str, Any]], source_label: str):
        for host in hosts:
            services = _collect_services(host)
            if not services:
                continue
            host_id = _host_identifier(host)
            host_sources[host_id].add(source_label)
            assessment = analyzer.analyze_service_vulnerabilities(host_id, services)
            assessment['source'] = source_label
            service_assessments.append(assessment)
            host_assessments[host_id].append(assessment)
            for finding in assessment.get('vulnerabilities_found', []):
                match = dict(finding)
                match['host'] = host_id
                match['source'] = source_label
                vulnerability_matches.append(match)

    if pcap_path:
        if PcapAnalyzer is None:
            raise RuntimeError(
                "PcapAnalyzer is unavailable. Install advanced dependencies to enable PCAP analysis."
            )
        pcap_analyzer = PcapAnalyzer()
        traffic_summary = pcap_analyzer.analyze(pcap_path)
        _analyze_hosts(traffic_summary.get('hosts', []), 'pcap')

    if nmap_file:
        if NmapAnalyzer is None:
            raise RuntimeError(
                "NmapAnalyzer is unavailable. Install advanced dependencies to enable Nmap analysis."
            )
        nmap_analyzer = NmapAnalyzer(nmap_file)
        nmap_summary = nmap_analyzer.analyze()
        _analyze_hosts(nmap_summary.get('hosts', []), 'nmap')

    def _extract_source_vulnerabilities(source_label: str, summary: Optional[Dict[str, Any]]) -> List[Dict[str, Any]]:
        records: List[Dict[str, Any]] = []
        if not summary:
            return records
        for host in summary.get('hosts', []) or []:
            host_id = _host_identifier(host)
            for vuln in host.get('vulnerabilities', []) or []:
                entry = dict(vuln)
                entry['host'] = host_id
                entry['source'] = source_label
                records.append(entry)
        return records

    source_vulnerabilities: Dict[str, List[Dict[str, Any]]] = {}
    if traffic_summary:
        source_vulnerabilities['pcap'] = _extract_source_vulnerabilities('pcap', traffic_summary)
    if nmap_summary:
        source_vulnerabilities['nmap'] = _extract_source_vulnerabilities('nmap', nmap_summary)

    severity_counter: Counter[str] = Counter()
    source_match_counts: Counter[str] = Counter()
    for match in vulnerability_matches:
        severity = str(match.get('severity', 'unknown')).lower() or 'unknown'
        severity_counter[severity] += 1
        source_match_counts[str(match.get('source', 'unknown')).lower()] += 1

    def _ingest_source_severity(records: List[Dict[str, Any]]) -> None:
        for record in records:
            severity = record.get('severity') or record.get('risk_level') or 'unknown'
            normalized = str(severity).lower() or 'unknown'
            severity_counter[normalized] += 1

    for records in source_vulnerabilities.values():
        _ingest_source_severity(records)

    host_breakdown: List[Dict[str, Any]] = []
    for host_id, sources in host_sources.items():
        assessments = host_assessments.get(host_id, [])
        risk_scores = [
            assessment.get('risk_score', 0)
            for assessment in assessments
            if isinstance(assessment.get('risk_score'), (int, float))
        ]
        matched = [match for match in vulnerability_matches if match.get('host') == host_id]
        raw_findings = [
            finding
            for entries in source_vulnerabilities.values()
            for finding in entries
            if finding.get('host') == host_id
        ]
        host_breakdown.append(
            {
                'host': host_id,
                'sources': sorted(sources),
                'service_vulnerability_matches': len(matched),
                'raw_source_vulnerabilities': len(raw_findings),
                'max_risk_score': max(risk_scores) if risk_scores else 0,
                'average_risk_score': (sum(risk_scores) / len(risk_scores)) if risk_scores else 0,
            }
        )

    source_summaries: Dict[str, Dict[str, Any]] = {}
    if traffic_summary:
        source_summaries['pcap'] = {
            'hosts': len(traffic_summary.get('hosts', []) or []),
            'service_vulnerability_matches': source_match_counts.get('pcap', 0),
            'raw_vulnerabilities': len(source_vulnerabilities.get('pcap', [])),
            'scan_info': traffic_summary.get('scan_info'),
            'summary': traffic_summary.get('summary'),
        }
    if nmap_summary:
        source_summaries['nmap'] = {
            'hosts': len(nmap_summary.get('hosts', []) or []),
            'service_vulnerability_matches': source_match_counts.get('nmap', 0),
            'raw_vulnerabilities': len(source_vulnerabilities.get('nmap', [])),
            'scan_info': nmap_summary.get('scan_info'),
            'summary': nmap_summary.get('summary'),
        }

    combined_summary = {
        'sources': source_summaries,
        'overall': {
            'total_hosts': len(host_sources) or 0,
            'service_assessments': len(service_assessments),
            'service_vulnerability_matches': len(vulnerability_matches),
            'raw_source_vulnerabilities': sum(len(entries) for entries in source_vulnerabilities.values()),
            'severity_breakdown': {key: value for key, value in sorted(severity_counter.items())},
        },
        'host_breakdown': host_breakdown,
    }

    report: Optional[str] = None
    if generate_report is not None:
        report = generate_report(vulnerability_matches, format=output_format)

    result: Dict[str, Any] = {
        'pcap_analysis': traffic_summary,
        'nmap_analysis': nmap_summary,
        'traffic_summary': traffic_summary,
        'nmap_summary': nmap_summary,
        'service_assessments': service_assessments,
        'vulnerability_matches': vulnerability_matches,
        'source_vulnerabilities': source_vulnerabilities,
        'combined_summary': combined_summary,
        'report': report,
        'metadata': {
            'advanced_features_available': ADVANCED_FEATURES_AVAILABLE,
            'utils_available': UTILS_AVAILABLE,
        },
    }

    return result

# Standalone convenience functions (work offline with embedded data)
def search_vulnerabilities(query: str, severity: str = None):
    """
    Search embedded vulnerability database (works offline)
    
    Args:
        query (str): Search term (vendor, CVE ID, etc.)
        severity (str, optional): Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)
    
    Returns:
        list: Matching vulnerability records
    """
    db = get_embedded_database()
    
    if query.upper().startswith('CVE-'):
        return db.search_by_cve(query)
    elif severity:
        return [v for v in db.search_by_vendor(query) if v['severity'] == severity.upper()]
    else:
        return db.search_by_vendor(query)

def get_critical_vulnerabilities():
    """
    Get all critical vulnerabilities from embedded database
    
    Returns:
        list: Critical vulnerability records
    """
    db = get_embedded_database()
    return db.get_critical_vulnerabilities()

def get_database_info():
    """
    Get information about the embedded vulnerability database
    
    Returns:
        dict: Database statistics and information
    """
    analyzer = VulnerabilityAnalyzer()
    return analyzer.get_database_info()

def get_router_vulnerabilities():
    """
    Get router-specific vulnerabilities from embedded RouterSploit data
    
    Returns:
        list: Router vulnerability records
    """
    db = get_embedded_database()
    return db.search_routersploit()

# Legacy function compatibility
def search_cves(query: str, limit: int = 20):
    """Legacy CVE search function - uses embedded database"""
    return search_vulnerabilities(query)[:limit]

# Initialize logging when package is imported
import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)