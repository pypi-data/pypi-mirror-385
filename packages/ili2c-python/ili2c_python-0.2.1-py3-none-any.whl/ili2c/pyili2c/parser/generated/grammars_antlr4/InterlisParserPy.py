# Generated from grammars-antlr4/InterlisParserPy.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,223,2259,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,1,0,1,0,1,0,1,0,3,0,247,8,0,1,0,1,0,1,0,3,0,252,8,0,1,1,3,
        1,255,8,1,1,1,3,1,258,8,1,1,1,1,1,1,1,1,1,1,1,3,1,265,8,1,1,1,1,
        1,1,1,1,1,1,1,3,1,272,8,1,3,1,274,8,1,1,1,1,1,1,1,1,1,1,1,1,1,3,
        1,282,8,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,290,8,1,1,1,1,1,3,1,294,8,
        1,1,1,1,1,1,1,3,1,299,8,1,1,1,5,1,302,8,1,10,1,12,1,305,9,1,1,1,
        5,1,308,8,1,10,1,12,1,311,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,5,1,324,8,1,10,1,12,1,327,9,1,1,1,1,1,1,1,1,1,1,2,3,2,
        334,8,2,1,2,1,2,1,2,1,2,1,2,3,2,341,8,2,1,2,1,2,3,2,345,8,2,1,2,
        1,2,3,2,349,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,359,8,2,1,2,
        3,2,362,8,2,1,2,3,2,365,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,
        375,8,2,1,2,1,2,1,2,1,2,3,2,381,8,2,1,2,3,2,384,8,2,1,2,1,2,1,2,
        1,2,1,2,5,2,391,8,2,10,2,12,2,394,9,2,1,2,1,2,3,2,398,8,2,1,2,1,
        2,1,2,1,2,1,2,5,2,405,8,2,10,2,12,2,408,9,2,1,2,1,2,3,2,412,8,2,
        1,2,5,2,415,8,2,10,2,12,2,418,9,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,435,8,3,1,4,1,4,3,4,439,8,4,1,
        4,1,4,1,5,1,5,1,6,1,6,1,6,1,6,1,6,3,6,450,8,6,1,6,1,6,3,6,454,8,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,466,8,6,1,6,1,6,3,
        6,470,8,6,1,6,3,6,473,8,6,1,6,3,6,476,8,6,1,6,1,6,1,6,1,6,1,7,1,
        7,1,7,1,7,1,7,3,7,487,8,7,1,7,1,7,3,7,491,8,7,1,7,1,7,3,7,495,8,
        7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,5,8,509,8,8,10,
        8,12,8,512,9,8,1,8,1,8,1,8,5,8,517,8,8,10,8,12,8,520,9,8,3,8,522,
        8,8,1,9,3,9,525,8,9,1,9,4,9,528,8,9,11,9,12,9,529,1,9,4,9,533,8,
        9,11,9,12,9,534,1,9,3,9,538,8,9,1,9,4,9,541,8,9,11,9,12,9,542,4,
        9,545,8,9,11,9,12,9,546,1,10,1,10,1,10,1,10,1,10,5,10,554,8,10,10,
        10,12,10,557,9,10,1,10,1,10,1,10,5,10,562,8,10,10,10,12,10,565,9,
        10,3,10,567,8,10,1,11,1,11,3,11,571,8,11,1,12,3,12,574,8,12,1,12,
        3,12,577,8,12,1,12,1,12,1,12,1,12,3,12,583,8,12,1,12,1,12,1,12,3,
        12,588,8,12,1,12,3,12,591,8,12,1,12,1,12,1,12,5,12,596,8,12,10,12,
        12,12,599,9,12,3,12,601,8,12,1,12,1,12,1,13,3,13,606,8,13,1,13,1,
        13,1,13,1,13,3,13,612,8,13,1,13,1,13,1,13,1,13,3,13,618,8,13,1,13,
        1,13,1,13,1,13,1,13,3,13,625,8,13,1,13,1,13,3,13,629,8,13,1,13,1,
        13,3,13,633,8,13,1,14,1,14,1,14,1,14,3,14,639,8,14,1,15,1,15,1,15,
        1,15,1,15,3,15,646,8,15,1,15,1,15,1,16,1,16,3,16,652,8,16,1,16,1,
        16,1,16,1,16,1,16,5,16,659,8,16,10,16,12,16,662,9,16,1,16,1,16,3,
        16,666,8,16,1,17,1,17,3,17,670,8,17,1,18,1,18,1,18,3,18,675,8,18,
        1,18,1,18,1,18,1,18,1,18,5,18,682,8,18,10,18,12,18,685,9,18,1,18,
        1,18,3,18,689,8,18,1,19,1,19,3,19,693,8,19,1,19,1,19,1,19,1,19,1,
        19,5,19,700,8,19,10,19,12,19,703,9,19,1,19,1,19,3,19,707,8,19,1,
        20,1,20,3,20,711,8,20,1,20,1,20,1,20,3,20,716,8,20,1,20,1,20,3,20,
        720,8,20,1,20,1,20,1,20,3,20,725,8,20,1,20,1,20,1,20,1,20,1,20,1,
        20,3,20,733,8,20,1,20,3,20,736,8,20,1,20,5,20,739,8,20,10,20,12,
        20,742,9,20,1,20,1,20,5,20,746,8,20,10,20,12,20,749,9,20,3,20,751,
        8,20,1,20,1,20,1,20,1,20,1,20,3,20,758,8,20,1,20,5,20,761,8,20,10,
        20,12,20,764,9,20,1,20,1,20,3,20,768,8,20,1,20,1,20,1,21,1,21,1,
        21,1,21,3,21,776,8,21,3,21,778,8,21,1,21,1,21,1,22,1,22,1,22,1,22,
        1,22,5,22,787,8,22,10,22,12,22,790,9,22,3,22,792,8,22,1,22,3,22,
        795,8,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,806,8,
        22,1,22,3,22,809,8,22,1,22,1,22,1,22,5,22,814,8,22,10,22,12,22,817,
        9,22,1,22,1,22,3,22,821,8,22,1,22,1,22,1,22,1,22,1,22,3,22,828,8,
        22,1,22,1,22,1,22,1,22,3,22,834,8,22,1,22,1,22,3,22,838,8,22,1,23,
        1,23,1,23,1,23,1,23,3,23,845,8,23,3,23,847,8,23,1,23,1,23,1,24,3,
        24,852,8,24,1,24,1,24,1,24,1,24,3,24,858,8,24,1,24,1,24,3,24,862,
        8,24,1,24,1,24,3,24,866,8,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
        1,24,1,24,1,24,1,24,1,24,5,24,880,8,24,10,24,12,24,883,9,24,1,24,
        1,24,3,24,887,8,24,3,24,889,8,24,1,24,1,24,1,24,1,24,1,24,1,24,1,
        24,1,24,1,24,5,24,900,8,24,10,24,12,24,903,9,24,3,24,905,8,24,1,
        24,4,24,908,8,24,11,24,12,24,909,1,25,1,25,1,25,1,25,1,25,3,25,917,
        8,25,1,26,1,26,1,26,1,26,5,26,923,8,26,10,26,12,26,926,9,26,3,26,
        928,8,26,1,26,1,26,1,26,1,26,3,26,934,8,26,1,27,1,27,1,27,1,27,1,
        27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,949,8,27,1,28,1,
        28,1,28,1,28,1,28,1,28,1,28,3,28,958,8,28,1,29,1,29,1,29,3,29,963,
        8,29,1,29,1,29,1,29,3,29,968,8,29,1,29,1,29,3,29,972,8,29,1,30,1,
        30,1,31,1,31,1,31,1,31,1,31,5,31,981,8,31,10,31,12,31,984,9,31,1,
        31,1,31,3,31,988,8,31,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,5,
        33,998,8,33,10,33,12,33,1001,9,33,1,33,1,33,3,33,1005,8,33,1,33,
        1,33,3,33,1009,8,33,1,34,1,34,1,34,5,34,1014,8,34,10,34,12,34,1017,
        9,34,1,34,3,34,1020,8,34,1,35,1,35,1,35,1,35,5,35,1026,8,35,10,35,
        12,35,1029,9,35,1,35,1,35,3,35,1033,8,35,1,35,3,35,1036,8,35,1,36,
        1,36,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
        1,38,1,38,3,38,1054,8,38,1,38,3,38,1057,8,38,1,38,1,38,1,38,1,38,
        3,38,1063,8,38,1,38,3,38,1066,8,38,1,38,1,38,1,38,1,38,1,38,1,38,
        3,38,1074,8,38,1,38,1,38,1,38,3,38,1079,8,38,1,39,1,39,1,39,1,39,
        3,39,1085,8,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,3,39,1095,
        8,39,1,39,1,39,1,39,1,39,3,39,1101,8,39,1,39,1,39,1,39,1,39,1,39,
        3,39,1108,8,39,3,39,1110,8,39,1,40,1,40,1,40,1,40,1,40,3,40,1117,
        8,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,3,40,1126,8,40,1,40,1,40,
        3,40,1130,8,40,1,41,1,41,1,42,1,42,1,42,1,42,1,42,3,42,1139,8,42,
        1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,3,43,1159,8,43,1,44,1,44,3,44,1163,8,44,
        1,44,3,44,1166,8,44,1,44,1,44,1,44,5,44,1171,8,44,10,44,12,44,1174,
        9,44,1,44,1,44,3,44,1178,8,44,1,44,1,44,1,45,1,45,1,45,3,45,1185,
        8,45,1,45,1,45,1,45,3,45,1190,8,45,1,46,1,46,1,47,1,47,1,48,1,48,
        1,48,1,48,3,48,1200,8,48,1,48,1,48,1,48,3,48,1205,8,48,1,48,1,48,
        1,48,3,48,1210,8,48,3,48,1212,8,48,3,48,1214,8,48,1,48,1,48,1,48,
        1,48,1,48,1,48,3,48,1222,8,48,1,48,1,48,3,48,1226,8,48,3,48,1228,
        8,48,3,48,1230,8,48,1,49,1,49,1,49,1,49,1,49,1,49,1,50,3,50,1239,
        8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,5,50,1248,8,50,10,50,12,
        50,1251,9,50,1,50,1,50,4,50,1255,8,50,11,50,12,50,1256,1,51,1,51,
        1,51,1,51,3,51,1263,8,51,1,51,3,51,1266,8,51,1,52,1,52,1,52,1,53,
        1,53,1,53,1,53,1,53,1,53,5,53,1277,8,53,10,53,12,53,1280,9,53,1,
        53,1,53,3,53,1284,8,53,1,53,1,53,1,53,1,53,1,53,1,53,5,53,1292,8,
        53,10,53,12,53,1295,9,53,1,53,1,53,3,53,1299,8,53,3,53,1301,8,53,
        1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,3,54,1311,8,54,3,54,1313,
        8,54,1,54,1,54,1,54,1,54,1,54,5,54,1320,8,54,10,54,12,54,1323,9,
        54,1,54,1,54,3,54,1327,8,54,1,55,1,55,1,55,1,56,1,56,1,56,1,56,1,
        56,3,56,1337,8,56,1,56,1,56,1,57,3,57,1342,8,57,1,57,1,57,1,57,1,
        57,3,57,1348,8,57,1,57,1,57,1,57,3,57,1353,8,57,1,57,3,57,1356,8,
        57,1,57,3,57,1359,8,57,1,57,3,57,1362,8,57,1,57,1,57,1,57,3,57,1367,
        8,57,1,58,1,58,1,58,1,58,1,58,5,58,1374,8,58,10,58,12,58,1377,9,
        58,1,58,1,58,1,59,1,59,1,59,1,59,1,59,3,59,1386,8,59,1,60,1,60,1,
        60,1,60,5,60,1392,8,60,10,60,12,60,1395,9,60,1,61,1,61,1,61,1,61,
        1,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,63,3,63,1412,
        8,63,1,63,1,63,1,63,1,63,3,63,1418,8,63,1,63,1,63,1,63,3,63,1423,
        8,63,1,63,1,63,3,63,1427,8,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,
        1435,8,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,1443,8,63,1,63,1,63,
        1,64,1,64,1,64,5,64,1450,8,64,10,64,12,64,1453,9,64,1,64,1,64,1,
        64,1,64,1,65,1,65,1,65,1,65,1,65,1,65,3,65,1465,8,65,1,65,1,65,1,
        65,1,65,1,65,1,65,3,65,1473,8,65,5,65,1475,8,65,10,65,12,65,1478,
        9,65,1,65,1,65,1,66,1,66,1,66,5,66,1485,8,66,10,66,12,66,1488,9,
        66,1,66,1,66,1,66,3,66,1493,8,66,1,67,1,67,1,67,1,67,3,67,1499,8,
        67,1,67,1,67,3,67,1503,8,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,
        67,1,67,5,67,1514,8,67,10,67,12,67,1517,9,67,1,67,3,67,1520,8,67,
        4,67,1522,8,67,11,67,12,67,1523,1,68,1,68,1,68,1,68,3,68,1530,8,
        68,3,68,1532,8,68,1,68,1,68,1,69,1,69,1,69,3,69,1539,8,69,1,69,1,
        69,1,70,1,70,1,70,1,70,1,70,3,70,1548,8,70,1,70,1,70,1,70,1,70,1,
        70,3,70,1555,8,70,3,70,1557,8,70,1,70,1,70,1,71,1,71,1,71,3,71,1564,
        8,71,1,71,1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
        3,72,1578,8,72,1,73,1,73,1,73,1,73,3,73,1584,8,73,1,73,1,73,1,73,
        1,74,1,74,1,74,3,74,1592,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,75,
        1,75,1,75,1,75,3,75,1604,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
        1,75,1,76,1,76,1,76,3,76,1617,8,76,1,76,1,76,1,76,3,76,1622,8,76,
        1,76,1,76,3,76,1626,8,76,1,76,1,76,4,76,1630,8,76,11,76,12,76,1631,
        1,76,1,76,1,77,1,77,1,77,5,77,1639,8,77,10,77,12,77,1642,9,77,1,
        78,1,78,1,79,1,79,1,79,1,79,3,79,1650,8,79,1,79,1,79,3,79,1654,8,
        79,1,79,1,79,1,79,1,79,5,79,1660,8,79,10,79,12,79,1663,9,79,1,79,
        1,79,1,79,1,79,5,79,1669,8,79,10,79,12,79,1672,9,79,3,79,1674,8,
        79,1,79,1,79,1,80,1,80,1,80,1,80,1,80,3,80,1683,8,80,1,80,1,80,1,
        80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,3,80,1696,8,80,1,80,1,
        80,1,80,1,80,3,80,1702,8,80,1,80,3,80,1705,8,80,1,80,1,80,1,81,1,
        81,1,81,1,81,1,81,5,81,1714,8,81,10,81,12,81,1717,9,81,1,81,1,81,
        1,81,1,82,1,82,1,83,1,83,1,83,1,83,3,83,1728,8,83,1,84,1,84,1,84,
        5,84,1733,8,84,10,84,12,84,1736,9,84,1,85,1,85,1,85,5,85,1741,8,
        85,10,85,12,85,1744,9,85,1,86,1,86,1,86,1,86,3,86,1750,8,86,1,87,
        1,87,3,87,1754,8,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,
        1,87,1,87,1,87,1,87,3,87,1769,8,87,1,88,1,88,1,88,1,88,1,88,1,88,
        1,88,1,88,1,88,3,88,1780,8,88,1,89,1,89,1,89,1,89,3,89,1786,8,89,
        1,89,1,89,3,89,1790,8,89,1,89,1,89,1,89,1,89,1,89,1,89,1,89,1,89,
        5,89,1800,8,89,10,89,12,89,1803,9,89,3,89,1805,8,89,1,89,3,89,1808,
        8,89,1,89,1,89,1,89,3,89,1813,8,89,1,89,1,89,1,89,1,89,3,89,1819,
        8,89,1,89,1,89,3,89,1823,8,89,1,90,1,90,1,90,1,90,5,90,1829,8,90,
        10,90,12,90,1832,9,90,1,91,1,91,1,92,1,92,1,92,1,92,1,92,1,92,1,
        92,1,92,3,92,1844,8,92,1,92,1,92,1,92,1,92,1,92,1,92,1,92,1,92,3,
        92,1854,8,92,1,93,3,93,1857,8,93,1,93,1,93,1,94,1,94,1,94,1,94,3,
        94,1865,8,94,1,94,3,94,1868,8,94,1,95,1,95,3,95,1872,8,95,1,95,1,
        95,3,95,1876,8,95,1,95,1,95,1,95,1,95,1,95,5,95,1883,8,95,10,95,
        12,95,1886,9,95,1,95,1,95,1,96,1,96,1,96,1,96,1,96,1,96,1,96,3,96,
        1897,8,96,3,96,1899,8,96,1,97,1,97,1,97,1,97,1,97,1,97,5,97,1907,
        8,97,10,97,12,97,1910,9,97,1,97,1,97,1,97,1,97,1,97,3,97,1917,8,
        97,1,97,1,97,1,98,3,98,1922,8,98,1,98,1,98,1,98,1,98,3,98,1928,8,
        98,1,98,1,98,3,98,1932,8,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,3,
        98,1941,8,98,1,98,3,98,1944,8,98,1,99,1,99,1,99,1,99,1,100,1,100,
        1,100,1,100,1,100,3,100,1955,8,100,1,100,1,100,3,100,1959,8,100,
        1,101,1,101,1,101,3,101,1964,8,101,1,101,1,101,1,101,3,101,1969,
        8,101,1,101,5,101,1972,8,101,10,101,12,101,1975,9,101,1,101,5,101,
        1978,8,101,10,101,12,101,1981,9,101,1,101,1,101,3,101,1985,8,101,
        1,101,5,101,1988,8,101,10,101,12,101,1991,9,101,1,101,1,101,1,101,
        1,101,1,102,1,102,1,102,1,102,3,102,2001,8,102,3,102,2003,8,102,
        1,102,1,102,1,103,1,103,1,103,1,103,1,103,3,103,2012,8,103,1,104,
        1,104,1,104,1,104,1,105,1,105,1,105,1,105,1,105,1,105,1,105,1,105,
        3,105,2026,8,105,5,105,2028,8,105,10,105,12,105,2031,9,105,1,105,
        1,105,1,106,1,106,1,106,1,106,5,106,2039,8,106,10,106,12,106,2042,
        9,106,1,106,1,106,1,107,1,107,1,107,1,107,1,107,1,107,1,107,1,107,
        3,107,2054,8,107,1,107,1,107,1,108,3,108,2059,8,108,1,108,1,108,
        1,108,1,108,1,108,1,108,1,108,1,108,5,108,2069,8,108,10,108,12,108,
        2072,9,108,1,108,1,108,1,109,1,109,3,109,2078,8,109,1,109,1,109,
        1,110,1,110,1,110,1,110,3,110,2086,8,110,3,110,2088,8,110,1,110,
        1,110,1,111,1,111,1,111,1,111,1,111,1,111,1,111,5,111,2099,8,111,
        10,111,12,111,2102,9,111,1,112,1,112,1,112,1,112,1,113,3,113,2109,
        8,113,1,113,1,113,1,113,1,113,1,113,1,113,1,113,1,113,1,113,5,113,
        2120,8,113,10,113,12,113,2123,9,113,1,113,1,113,1,113,1,113,1,113,
        4,113,2130,8,113,11,113,12,113,2131,1,113,1,113,3,113,2136,8,113,
        1,113,1,113,1,113,1,113,3,113,2142,8,113,1,114,1,114,1,114,3,114,
        2147,8,114,1,114,1,114,3,114,2151,8,114,1,114,1,114,1,114,3,114,
        2156,8,114,1,114,1,114,5,114,2160,8,114,10,114,12,114,2163,9,114,
        1,114,5,114,2166,8,114,10,114,12,114,2169,9,114,1,114,1,114,1,114,
        1,114,1,115,1,115,1,115,1,115,3,115,2179,8,115,3,115,2181,8,115,
        1,115,1,115,1,116,1,116,3,116,2187,8,116,1,116,1,116,3,116,2191,
        8,116,1,116,1,116,1,116,1,116,5,116,2197,8,116,10,116,12,116,2200,
        9,116,1,116,1,116,1,117,3,117,2205,8,117,1,117,3,117,2208,8,117,
        1,117,1,117,1,117,1,117,5,117,2214,8,117,10,117,12,117,2217,9,117,
        1,117,1,117,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,1,118,
        1,118,1,118,1,118,1,118,5,118,2234,8,118,10,118,12,118,2237,9,118,
        1,118,1,118,3,118,2241,8,118,1,119,1,119,1,119,1,119,1,119,3,119,
        2248,8,119,1,119,1,119,1,119,1,119,1,120,1,120,1,120,3,120,2257,
        8,120,1,120,0,0,121,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,
        34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,
        78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,
        116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
        148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,
        180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,
        212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,0,30,
        3,0,146,146,156,156,171,171,2,0,97,97,215,215,2,0,1,1,73,73,3,0,
        1,1,70,70,73,73,2,0,179,179,215,215,3,0,30,30,178,179,215,215,4,
        0,1,1,70,70,73,73,169,169,2,0,22,22,106,106,4,0,1,1,70,70,73,73,
        129,129,5,0,1,1,70,70,72,73,88,88,133,133,2,0,115,115,211,211,3,
        0,1,1,73,73,82,82,2,0,34,34,133,133,3,0,26,26,108,108,215,215,2,
        0,86,86,180,180,2,0,36,36,49,49,4,0,107,107,139,139,211,211,213,
        213,2,0,50,51,165,165,2,0,46,46,117,117,2,0,27,27,189,189,2,0,62,
        62,114,115,2,0,146,146,151,151,2,0,200,200,202,202,2,0,26,26,108,
        108,2,0,132,132,205,206,3,0,7,7,62,62,114,115,2,0,178,179,215,215,
        3,0,74,74,102,102,212,212,1,0,126,127,1,0,215,215,2559,0,251,1,0,
        0,0,2,254,1,0,0,0,4,333,1,0,0,0,6,434,1,0,0,0,8,438,1,0,0,0,10,442,
        1,0,0,0,12,444,1,0,0,0,14,481,1,0,0,0,16,521,1,0,0,0,18,544,1,0,
        0,0,20,566,1,0,0,0,22,570,1,0,0,0,24,573,1,0,0,0,26,632,1,0,0,0,
        28,638,1,0,0,0,30,640,1,0,0,0,32,651,1,0,0,0,34,669,1,0,0,0,36,674,
        1,0,0,0,38,692,1,0,0,0,40,708,1,0,0,0,42,777,1,0,0,0,44,837,1,0,
        0,0,46,839,1,0,0,0,48,851,1,0,0,0,50,916,1,0,0,0,52,933,1,0,0,0,
        54,948,1,0,0,0,56,957,1,0,0,0,58,971,1,0,0,0,60,973,1,0,0,0,62,975,
        1,0,0,0,64,989,1,0,0,0,66,993,1,0,0,0,68,1010,1,0,0,0,70,1021,1,
        0,0,0,72,1037,1,0,0,0,74,1039,1,0,0,0,76,1053,1,0,0,0,78,1109,1,
        0,0,0,80,1129,1,0,0,0,82,1131,1,0,0,0,84,1133,1,0,0,0,86,1158,1,
        0,0,0,88,1160,1,0,0,0,90,1189,1,0,0,0,92,1191,1,0,0,0,94,1193,1,
        0,0,0,96,1229,1,0,0,0,98,1231,1,0,0,0,100,1238,1,0,0,0,102,1265,
        1,0,0,0,104,1267,1,0,0,0,106,1300,1,0,0,0,108,1302,1,0,0,0,110,1328,
        1,0,0,0,112,1331,1,0,0,0,114,1352,1,0,0,0,116,1368,1,0,0,0,118,1385,
        1,0,0,0,120,1387,1,0,0,0,122,1396,1,0,0,0,124,1401,1,0,0,0,126,1411,
        1,0,0,0,128,1446,1,0,0,0,130,1458,1,0,0,0,132,1492,1,0,0,0,134,1494,
        1,0,0,0,136,1531,1,0,0,0,138,1538,1,0,0,0,140,1542,1,0,0,0,142,1560,
        1,0,0,0,144,1577,1,0,0,0,146,1579,1,0,0,0,148,1588,1,0,0,0,150,1599,
        1,0,0,0,152,1613,1,0,0,0,154,1635,1,0,0,0,156,1643,1,0,0,0,158,1645,
        1,0,0,0,160,1677,1,0,0,0,162,1708,1,0,0,0,164,1721,1,0,0,0,166,1723,
        1,0,0,0,168,1729,1,0,0,0,170,1737,1,0,0,0,172,1745,1,0,0,0,174,1768,
        1,0,0,0,176,1779,1,0,0,0,178,1822,1,0,0,0,180,1824,1,0,0,0,182,1833,
        1,0,0,0,184,1853,1,0,0,0,186,1856,1,0,0,0,188,1867,1,0,0,0,190,1871,
        1,0,0,0,192,1898,1,0,0,0,194,1900,1,0,0,0,196,1943,1,0,0,0,198,1945,
        1,0,0,0,200,1958,1,0,0,0,202,1960,1,0,0,0,204,2002,1,0,0,0,206,2011,
        1,0,0,0,208,2013,1,0,0,0,210,2017,1,0,0,0,212,2034,1,0,0,0,214,2045,
        1,0,0,0,216,2058,1,0,0,0,218,2077,1,0,0,0,220,2087,1,0,0,0,222,2091,
        1,0,0,0,224,2103,1,0,0,0,226,2108,1,0,0,0,228,2143,1,0,0,0,230,2180,
        1,0,0,0,232,2184,1,0,0,0,234,2207,1,0,0,0,236,2220,1,0,0,0,238,2247,
        1,0,0,0,240,2253,1,0,0,0,242,243,5,97,0,0,243,244,5,213,0,0,244,
        246,5,198,0,0,245,247,3,2,1,0,246,245,1,0,0,0,246,247,1,0,0,0,247,
        252,1,0,0,0,248,249,5,168,0,0,249,250,5,98,0,0,250,252,5,198,0,0,
        251,242,1,0,0,0,251,248,1,0,0,0,252,1,1,0,0,0,253,255,5,45,0,0,254,
        253,1,0,0,0,254,255,1,0,0,0,255,257,1,0,0,0,256,258,7,0,0,0,257,
        256,1,0,0,0,257,258,1,0,0,0,258,259,1,0,0,0,259,260,5,112,0,0,260,
        264,5,215,0,0,261,262,5,194,0,0,262,263,5,215,0,0,263,265,5,195,
        0,0,264,261,1,0,0,0,264,265,1,0,0,0,265,273,1,0,0,0,266,267,5,17,
        0,0,267,268,5,219,0,0,268,269,5,181,0,0,269,271,5,219,0,0,270,272,
        5,220,0,0,271,270,1,0,0,0,271,272,1,0,0,0,272,274,1,0,0,0,273,266,
        1,0,0,0,273,274,1,0,0,0,274,281,1,0,0,0,275,276,5,170,0,0,276,277,
        5,128,0,0,277,278,5,215,0,0,278,279,5,209,0,0,279,280,5,219,0,0,
        280,282,5,210,0,0,281,275,1,0,0,0,281,282,1,0,0,0,282,283,1,0,0,
        0,283,289,5,191,0,0,284,285,5,44,0,0,285,286,5,99,0,0,286,287,5,
        31,0,0,287,288,5,215,0,0,288,290,5,198,0,0,289,284,1,0,0,0,289,290,
        1,0,0,0,290,309,1,0,0,0,291,293,5,92,0,0,292,294,5,177,0,0,293,292,
        1,0,0,0,293,294,1,0,0,0,294,295,1,0,0,0,295,303,7,1,0,0,296,298,
        5,196,0,0,297,299,5,177,0,0,298,297,1,0,0,0,298,299,1,0,0,0,299,
        300,1,0,0,0,300,302,7,1,0,0,301,296,1,0,0,0,302,305,1,0,0,0,303,
        301,1,0,0,0,303,304,1,0,0,0,304,306,1,0,0,0,305,303,1,0,0,0,306,
        308,5,198,0,0,307,291,1,0,0,0,308,311,1,0,0,0,309,307,1,0,0,0,309,
        310,1,0,0,0,310,325,1,0,0,0,311,309,1,0,0,0,312,324,3,134,67,0,313,
        324,3,126,63,0,314,324,3,196,98,0,315,324,3,194,97,0,316,324,3,124,
        62,0,317,324,3,48,24,0,318,324,3,100,50,0,319,324,3,142,71,0,320,
        324,3,12,6,0,321,324,3,14,7,0,322,324,3,4,2,0,323,312,1,0,0,0,323,
        313,1,0,0,0,323,314,1,0,0,0,323,315,1,0,0,0,323,316,1,0,0,0,323,
        317,1,0,0,0,323,318,1,0,0,0,323,319,1,0,0,0,323,320,1,0,0,0,323,
        321,1,0,0,0,323,322,1,0,0,0,324,327,1,0,0,0,325,323,1,0,0,0,325,
        326,1,0,0,0,326,328,1,0,0,0,327,325,1,0,0,0,328,329,5,64,0,0,329,
        330,5,215,0,0,330,331,5,203,0,0,331,3,1,0,0,0,332,334,5,184,0,0,
        333,332,1,0,0,0,333,334,1,0,0,0,334,335,1,0,0,0,335,336,5,167,0,
        0,336,340,5,215,0,0,337,338,5,194,0,0,338,339,7,2,0,0,339,341,5,
        195,0,0,340,337,1,0,0,0,340,341,1,0,0,0,341,344,1,0,0,0,342,343,
        5,71,0,0,343,345,3,8,4,0,344,342,1,0,0,0,344,345,1,0,0,0,345,346,
        1,0,0,0,346,364,5,191,0,0,347,349,5,26,0,0,348,347,1,0,0,0,348,349,
        1,0,0,0,349,350,1,0,0,0,350,351,5,129,0,0,351,361,5,14,0,0,352,362,
        5,215,0,0,353,354,5,215,0,0,354,355,5,203,0,0,355,362,5,215,0,0,
        356,357,5,97,0,0,357,359,5,203,0,0,358,356,1,0,0,0,358,359,1,0,0,
        0,359,360,1,0,0,0,360,362,5,179,0,0,361,352,1,0,0,0,361,353,1,0,
        0,0,361,358,1,0,0,0,362,363,1,0,0,0,363,365,5,198,0,0,364,348,1,
        0,0,0,364,365,1,0,0,0,365,383,1,0,0,0,366,367,5,129,0,0,367,380,
        5,14,0,0,368,381,5,215,0,0,369,370,5,215,0,0,370,371,5,203,0,0,371,
        381,5,215,0,0,372,373,5,97,0,0,373,375,5,203,0,0,374,372,1,0,0,0,
        374,375,1,0,0,0,375,376,1,0,0,0,376,381,5,179,0,0,377,378,5,97,0,
        0,378,379,5,203,0,0,379,381,5,11,0,0,380,368,1,0,0,0,380,369,1,0,
        0,0,380,374,1,0,0,0,380,377,1,0,0,0,381,382,1,0,0,0,382,384,5,198,
        0,0,383,366,1,0,0,0,383,384,1,0,0,0,384,397,1,0,0,0,385,386,5,56,
        0,0,386,387,5,130,0,0,387,392,3,8,4,0,388,389,5,196,0,0,389,391,
        3,8,4,0,390,388,1,0,0,0,391,394,1,0,0,0,392,390,1,0,0,0,392,393,
        1,0,0,0,393,395,1,0,0,0,394,392,1,0,0,0,395,396,5,198,0,0,396,398,
        1,0,0,0,397,385,1,0,0,0,397,398,1,0,0,0,398,411,1,0,0,0,399,400,
        5,53,0,0,400,401,5,83,0,0,401,406,3,10,5,0,402,403,5,196,0,0,403,
        405,3,10,5,0,404,402,1,0,0,0,405,408,1,0,0,0,406,404,1,0,0,0,406,
        407,1,0,0,0,407,409,1,0,0,0,408,406,1,0,0,0,409,410,5,198,0,0,410,
        412,1,0,0,0,411,399,1,0,0,0,411,412,1,0,0,0,412,416,1,0,0,0,413,
        415,3,6,3,0,414,413,1,0,0,0,415,418,1,0,0,0,416,414,1,0,0,0,416,
        417,1,0,0,0,417,419,1,0,0,0,418,416,1,0,0,0,419,420,5,64,0,0,420,
        421,5,215,0,0,421,422,5,198,0,0,422,5,1,0,0,0,423,435,3,134,67,0,
        424,435,3,126,63,0,425,435,3,196,98,0,426,435,3,48,24,0,427,435,
        3,100,50,0,428,435,3,12,6,0,429,435,3,14,7,0,430,435,3,40,20,0,431,
        435,3,162,81,0,432,435,3,202,101,0,433,435,3,228,114,0,434,423,1,
        0,0,0,434,424,1,0,0,0,434,425,1,0,0,0,434,426,1,0,0,0,434,427,1,
        0,0,0,434,428,1,0,0,0,434,429,1,0,0,0,434,430,1,0,0,0,434,431,1,
        0,0,0,434,432,1,0,0,0,434,433,1,0,0,0,435,7,1,0,0,0,436,437,5,215,
        0,0,437,439,5,203,0,0,438,436,1,0,0,0,438,439,1,0,0,0,439,440,1,
        0,0,0,440,441,5,215,0,0,441,9,1,0,0,0,442,443,3,52,26,0,443,11,1,
        0,0,0,444,445,5,35,0,0,445,449,5,215,0,0,446,447,5,194,0,0,447,448,
        7,3,0,0,448,450,5,195,0,0,449,446,1,0,0,0,449,450,1,0,0,0,450,453,
        1,0,0,0,451,452,5,71,0,0,452,454,3,22,11,0,453,451,1,0,0,0,453,454,
        1,0,0,0,454,455,1,0,0,0,455,472,5,191,0,0,456,457,5,129,0,0,457,
        465,5,14,0,0,458,466,5,215,0,0,459,460,5,215,0,0,460,461,5,203,0,
        0,461,466,5,215,0,0,462,463,5,97,0,0,463,464,5,203,0,0,464,466,7,
        4,0,0,465,458,1,0,0,0,465,459,1,0,0,0,465,462,1,0,0,0,466,470,1,
        0,0,0,467,468,5,121,0,0,468,470,5,129,0,0,469,456,1,0,0,0,469,467,
        1,0,0,0,470,471,1,0,0,0,471,473,5,198,0,0,472,469,1,0,0,0,472,473,
        1,0,0,0,473,475,1,0,0,0,474,476,3,18,9,0,475,474,1,0,0,0,475,476,
        1,0,0,0,476,477,1,0,0,0,477,478,5,64,0,0,478,479,5,215,0,0,479,480,
        5,198,0,0,480,13,1,0,0,0,481,482,5,153,0,0,482,486,5,215,0,0,483,
        484,5,194,0,0,484,485,7,3,0,0,485,487,5,195,0,0,486,483,1,0,0,0,
        486,487,1,0,0,0,487,490,1,0,0,0,488,489,5,71,0,0,489,491,3,20,10,
        0,490,488,1,0,0,0,490,491,1,0,0,0,491,492,1,0,0,0,492,494,5,191,
        0,0,493,495,3,18,9,0,494,493,1,0,0,0,494,495,1,0,0,0,495,496,1,0,
        0,0,496,497,5,64,0,0,497,498,5,215,0,0,498,499,5,198,0,0,499,15,
        1,0,0,0,500,501,5,97,0,0,501,502,5,203,0,0,502,522,5,146,0,0,503,
        504,5,97,0,0,504,505,5,203,0,0,505,510,5,215,0,0,506,507,5,203,0,
        0,507,509,5,215,0,0,508,506,1,0,0,0,509,512,1,0,0,0,510,508,1,0,
        0,0,510,511,1,0,0,0,511,522,1,0,0,0,512,510,1,0,0,0,513,518,5,215,
        0,0,514,515,5,203,0,0,515,517,5,215,0,0,516,514,1,0,0,0,517,520,
        1,0,0,0,518,516,1,0,0,0,518,519,1,0,0,0,519,522,1,0,0,0,520,518,
        1,0,0,0,521,500,1,0,0,0,521,503,1,0,0,0,521,513,1,0,0,0,522,17,1,
        0,0,0,523,525,5,19,0,0,524,523,1,0,0,0,524,525,1,0,0,0,525,527,1,
        0,0,0,526,528,3,24,12,0,527,526,1,0,0,0,528,529,1,0,0,0,529,527,
        1,0,0,0,529,530,1,0,0,0,530,545,1,0,0,0,531,533,3,144,72,0,532,531,
        1,0,0,0,533,534,1,0,0,0,534,532,1,0,0,0,534,535,1,0,0,0,535,545,
        1,0,0,0,536,538,5,136,0,0,537,536,1,0,0,0,537,538,1,0,0,0,538,540,
        1,0,0,0,539,541,3,140,70,0,540,539,1,0,0,0,541,542,1,0,0,0,542,540,
        1,0,0,0,542,543,1,0,0,0,543,545,1,0,0,0,544,524,1,0,0,0,544,532,
        1,0,0,0,544,537,1,0,0,0,545,546,1,0,0,0,546,544,1,0,0,0,546,547,
        1,0,0,0,547,19,1,0,0,0,548,549,5,97,0,0,549,550,5,203,0,0,550,555,
        7,5,0,0,551,552,5,203,0,0,552,554,5,215,0,0,553,551,1,0,0,0,554,
        557,1,0,0,0,555,553,1,0,0,0,555,556,1,0,0,0,556,567,1,0,0,0,557,
        555,1,0,0,0,558,563,5,215,0,0,559,560,5,203,0,0,560,562,5,215,0,
        0,561,559,1,0,0,0,562,565,1,0,0,0,563,561,1,0,0,0,563,564,1,0,0,
        0,564,567,1,0,0,0,565,563,1,0,0,0,566,548,1,0,0,0,566,558,1,0,0,
        0,567,21,1,0,0,0,568,571,3,16,8,0,569,571,3,20,10,0,570,568,1,0,
        0,0,570,569,1,0,0,0,571,23,1,0,0,0,572,574,5,42,0,0,573,572,1,0,
        0,0,573,574,1,0,0,0,574,576,1,0,0,0,575,577,5,154,0,0,576,575,1,
        0,0,0,576,577,1,0,0,0,577,578,1,0,0,0,578,582,5,215,0,0,579,580,
        5,194,0,0,580,581,7,6,0,0,581,583,5,195,0,0,582,579,1,0,0,0,582,
        583,1,0,0,0,583,584,1,0,0,0,584,587,5,197,0,0,585,588,3,26,13,0,
        586,588,3,114,57,0,587,585,1,0,0,0,587,586,1,0,0,0,588,600,1,0,0,
        0,589,591,5,15,0,0,590,589,1,0,0,0,590,591,1,0,0,0,591,592,1,0,0,
        0,592,597,3,178,89,0,593,594,5,196,0,0,594,596,3,178,89,0,595,593,
        1,0,0,0,596,599,1,0,0,0,597,595,1,0,0,0,597,598,1,0,0,0,598,601,
        1,0,0,0,599,597,1,0,0,0,600,590,1,0,0,0,600,601,1,0,0,0,601,602,
        1,0,0,0,602,603,5,198,0,0,603,25,1,0,0,0,604,606,5,109,0,0,605,604,
        1,0,0,0,605,606,1,0,0,0,606,624,1,0,0,0,607,625,3,28,14,0,608,625,
        3,66,33,0,609,611,3,76,38,0,610,612,5,34,0,0,611,610,1,0,0,0,611,
        612,1,0,0,0,612,617,1,0,0,0,613,614,5,209,0,0,614,615,3,132,66,0,
        615,616,5,210,0,0,616,618,1,0,0,0,617,613,1,0,0,0,617,618,1,0,0,
        0,618,625,1,0,0,0,619,620,5,125,0,0,620,621,5,209,0,0,621,622,3,
        132,66,0,622,623,5,210,0,0,623,625,1,0,0,0,624,607,1,0,0,0,624,608,
        1,0,0,0,624,609,1,0,0,0,624,619,1,0,0,0,625,633,1,0,0,0,626,628,
        7,7,0,0,627,629,3,46,23,0,628,627,1,0,0,0,628,629,1,0,0,0,629,630,
        1,0,0,0,630,631,5,128,0,0,631,633,3,36,18,0,632,605,1,0,0,0,632,
        626,1,0,0,0,633,27,1,0,0,0,634,639,3,50,25,0,635,639,3,52,26,0,636,
        639,3,30,15,0,637,639,3,36,18,0,638,634,1,0,0,0,638,635,1,0,0,0,
        638,636,1,0,0,0,638,637,1,0,0,0,639,29,1,0,0,0,640,641,5,144,0,0,
        641,645,5,166,0,0,642,643,5,194,0,0,643,644,5,72,0,0,644,646,5,195,
        0,0,645,642,1,0,0,0,645,646,1,0,0,0,646,647,1,0,0,0,647,648,3,32,
        16,0,648,31,1,0,0,0,649,652,3,34,17,0,650,652,5,9,0,0,651,649,1,
        0,0,0,651,650,1,0,0,0,652,665,1,0,0,0,653,654,5,148,0,0,654,655,
        5,194,0,0,655,660,3,34,17,0,656,657,5,198,0,0,657,659,3,34,17,0,
        658,656,1,0,0,0,659,662,1,0,0,0,660,658,1,0,0,0,660,661,1,0,0,0,
        661,663,1,0,0,0,662,660,1,0,0,0,663,664,5,195,0,0,664,666,1,0,0,
        0,665,653,1,0,0,0,665,666,1,0,0,0,666,33,1,0,0,0,667,670,3,16,8,
        0,668,670,3,42,21,0,669,667,1,0,0,0,669,668,1,0,0,0,670,35,1,0,0,
        0,671,675,3,20,10,0,672,675,3,50,25,0,673,675,5,10,0,0,674,671,1,
        0,0,0,674,672,1,0,0,0,674,673,1,0,0,0,675,688,1,0,0,0,676,677,5,
        148,0,0,677,678,5,194,0,0,678,683,3,20,10,0,679,680,5,196,0,0,680,
        682,3,20,10,0,681,679,1,0,0,0,682,685,1,0,0,0,683,681,1,0,0,0,683,
        684,1,0,0,0,684,686,1,0,0,0,685,683,1,0,0,0,686,687,5,195,0,0,687,
        689,1,0,0,0,688,676,1,0,0,0,688,689,1,0,0,0,689,37,1,0,0,0,690,693,
        3,22,11,0,691,693,5,10,0,0,692,690,1,0,0,0,692,691,1,0,0,0,693,706,
        1,0,0,0,694,695,5,148,0,0,695,696,5,194,0,0,696,701,3,22,11,0,697,
        698,5,198,0,0,698,700,3,22,11,0,699,697,1,0,0,0,700,703,1,0,0,0,
        701,699,1,0,0,0,701,702,1,0,0,0,702,704,1,0,0,0,703,701,1,0,0,0,
        704,705,5,195,0,0,705,707,1,0,0,0,706,694,1,0,0,0,706,707,1,0,0,
        0,707,39,1,0,0,0,708,710,5,16,0,0,709,711,5,215,0,0,710,709,1,0,
        0,0,710,711,1,0,0,0,711,715,1,0,0,0,712,713,5,194,0,0,713,714,7,
        8,0,0,714,716,5,195,0,0,715,712,1,0,0,0,715,716,1,0,0,0,716,719,
        1,0,0,0,717,718,5,71,0,0,718,720,3,42,21,0,719,717,1,0,0,0,719,720,
        1,0,0,0,720,724,1,0,0,0,721,722,5,58,0,0,722,723,5,80,0,0,723,725,
        5,215,0,0,724,721,1,0,0,0,724,725,1,0,0,0,725,726,1,0,0,0,726,735,
        5,191,0,0,727,728,5,129,0,0,728,729,5,14,0,0,729,733,5,215,0,0,730,
        731,5,121,0,0,731,733,5,129,0,0,732,727,1,0,0,0,732,730,1,0,0,0,
        733,734,1,0,0,0,734,736,5,198,0,0,735,732,1,0,0,0,735,736,1,0,0,
        0,736,740,1,0,0,0,737,739,3,44,22,0,738,737,1,0,0,0,739,742,1,0,
        0,0,740,738,1,0,0,0,740,741,1,0,0,0,741,750,1,0,0,0,742,740,1,0,
        0,0,743,747,5,19,0,0,744,746,3,24,12,0,745,744,1,0,0,0,746,749,1,
        0,0,0,747,745,1,0,0,0,747,748,1,0,0,0,748,751,1,0,0,0,749,747,1,
        0,0,0,750,743,1,0,0,0,750,751,1,0,0,0,751,757,1,0,0,0,752,753,5,
        32,0,0,753,754,5,191,0,0,754,755,3,46,23,0,755,756,5,198,0,0,756,
        758,1,0,0,0,757,752,1,0,0,0,757,758,1,0,0,0,758,762,1,0,0,0,759,
        761,3,144,72,0,760,759,1,0,0,0,761,764,1,0,0,0,762,760,1,0,0,0,762,
        763,1,0,0,0,763,765,1,0,0,0,764,762,1,0,0,0,765,767,5,64,0,0,766,
        768,5,215,0,0,767,766,1,0,0,0,767,768,1,0,0,0,768,769,1,0,0,0,769,
        770,5,198,0,0,770,41,1,0,0,0,771,772,5,215,0,0,772,775,5,203,0,0,
        773,774,5,215,0,0,774,776,5,203,0,0,775,773,1,0,0,0,775,776,1,0,
        0,0,776,778,1,0,0,0,777,771,1,0,0,0,777,778,1,0,0,0,778,779,1,0,
        0,0,779,780,5,215,0,0,780,43,1,0,0,0,781,794,5,215,0,0,782,791,5,
        194,0,0,783,788,7,9,0,0,784,785,5,196,0,0,785,787,7,9,0,0,786,784,
        1,0,0,0,787,790,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,789,792,
        1,0,0,0,790,788,1,0,0,0,791,783,1,0,0,0,791,792,1,0,0,0,792,793,
        1,0,0,0,793,795,5,195,0,0,794,782,1,0,0,0,794,795,1,0,0,0,795,805,
        1,0,0,0,796,797,5,205,0,0,797,806,5,205,0,0,798,799,5,205,0,0,799,
        800,5,199,0,0,800,806,5,201,0,0,801,802,5,205,0,0,802,803,5,199,
        0,0,803,804,5,87,0,0,804,806,5,201,0,0,805,796,1,0,0,0,805,798,1,
        0,0,0,805,801,1,0,0,0,805,806,1,0,0,0,806,808,1,0,0,0,807,809,3,
        46,23,0,808,807,1,0,0,0,808,809,1,0,0,0,809,810,1,0,0,0,810,815,
        3,32,16,0,811,812,5,132,0,0,812,814,3,32,16,0,813,811,1,0,0,0,814,
        817,1,0,0,0,815,813,1,0,0,0,815,816,1,0,0,0,816,820,1,0,0,0,817,
        815,1,0,0,0,818,819,5,15,0,0,819,821,5,219,0,0,820,818,1,0,0,0,820,
        821,1,0,0,0,821,822,1,0,0,0,822,823,5,198,0,0,823,838,1,0,0,0,824,
        825,5,215,0,0,825,827,5,197,0,0,826,828,5,109,0,0,827,826,1,0,0,
        0,827,828,1,0,0,0,828,833,1,0,0,0,829,834,3,26,13,0,830,834,3,66,
        33,0,831,834,3,76,38,0,832,834,3,144,72,0,833,829,1,0,0,0,833,830,
        1,0,0,0,833,831,1,0,0,0,833,832,1,0,0,0,834,835,1,0,0,0,835,836,
        5,198,0,0,836,838,1,0,0,0,837,781,1,0,0,0,837,824,1,0,0,0,838,45,
        1,0,0,0,839,846,5,207,0,0,840,847,5,115,0,0,841,844,5,211,0,0,842,
        843,5,204,0,0,843,845,7,10,0,0,844,842,1,0,0,0,844,845,1,0,0,0,845,
        847,1,0,0,0,846,840,1,0,0,0,846,841,1,0,0,0,847,848,1,0,0,0,848,
        849,5,208,0,0,849,47,1,0,0,0,850,852,5,63,0,0,851,850,1,0,0,0,851,
        852,1,0,0,0,852,907,1,0,0,0,853,857,7,4,0,0,854,855,5,194,0,0,855,
        856,7,11,0,0,856,858,5,195,0,0,857,854,1,0,0,0,857,858,1,0,0,0,858,
        861,1,0,0,0,859,860,5,71,0,0,860,862,3,52,26,0,861,859,1,0,0,0,861,
        862,1,0,0,0,862,863,1,0,0,0,863,865,5,191,0,0,864,866,5,109,0,0,
        865,864,1,0,0,0,865,866,1,0,0,0,866,888,1,0,0,0,867,889,3,50,25,
        0,868,889,3,76,38,0,869,889,3,66,33,0,870,871,5,219,0,0,871,872,
        5,204,0,0,872,889,5,219,0,0,873,886,5,35,0,0,874,875,5,148,0,0,875,
        876,5,194,0,0,876,881,3,34,17,0,877,878,5,198,0,0,878,880,3,34,17,
        0,879,877,1,0,0,0,880,883,1,0,0,0,881,879,1,0,0,0,881,882,1,0,0,
        0,882,884,1,0,0,0,883,881,1,0,0,0,884,885,5,195,0,0,885,887,1,0,
        0,0,886,874,1,0,0,0,886,887,1,0,0,0,887,889,1,0,0,0,888,867,1,0,
        0,0,888,868,1,0,0,0,888,869,1,0,0,0,888,870,1,0,0,0,888,873,1,0,
        0,0,889,904,1,0,0,0,890,891,5,39,0,0,891,892,5,215,0,0,892,893,5,
        197,0,0,893,894,3,144,72,0,894,901,1,0,0,0,895,896,5,196,0,0,896,
        897,5,215,0,0,897,898,5,197,0,0,898,900,3,144,72,0,899,895,1,0,0,
        0,900,903,1,0,0,0,901,899,1,0,0,0,901,902,1,0,0,0,902,905,1,0,0,
        0,903,901,1,0,0,0,904,890,1,0,0,0,904,905,1,0,0,0,905,906,1,0,0,
        0,906,908,5,198,0,0,907,853,1,0,0,0,908,909,1,0,0,0,909,907,1,0,
        0,0,909,910,1,0,0,0,910,49,1,0,0,0,911,917,3,54,27,0,912,917,3,114,
        57,0,913,914,5,219,0,0,914,915,5,204,0,0,915,917,5,219,0,0,916,911,
        1,0,0,0,916,912,1,0,0,0,916,913,1,0,0,0,917,51,1,0,0,0,918,919,5,
        215,0,0,919,924,5,203,0,0,920,921,5,215,0,0,921,923,5,203,0,0,922,
        920,1,0,0,0,923,926,1,0,0,0,924,922,1,0,0,0,924,925,1,0,0,0,925,
        928,1,0,0,0,926,924,1,0,0,0,927,918,1,0,0,0,927,928,1,0,0,0,928,
        929,1,0,0,0,929,934,5,215,0,0,930,931,5,97,0,0,931,932,5,203,0,0,
        932,934,5,215,0,0,933,927,1,0,0,0,933,930,1,0,0,0,934,53,1,0,0,0,
        935,949,3,58,29,0,936,949,3,62,31,0,937,949,3,64,32,0,938,949,3,
        72,36,0,939,949,3,74,37,0,940,949,3,78,39,0,941,949,3,86,43,0,942,
        949,3,94,47,0,943,949,3,96,48,0,944,949,3,102,51,0,945,949,3,104,
        52,0,946,949,3,106,53,0,947,949,3,108,54,0,948,935,1,0,0,0,948,936,
        1,0,0,0,948,937,1,0,0,0,948,938,1,0,0,0,948,939,1,0,0,0,948,940,
        1,0,0,0,948,941,1,0,0,0,948,942,1,0,0,0,948,943,1,0,0,0,948,944,
        1,0,0,0,948,945,1,0,0,0,948,946,1,0,0,0,948,947,1,0,0,0,949,55,1,
        0,0,0,950,958,5,172,0,0,951,958,3,84,42,0,952,958,3,60,30,0,953,
        958,3,92,46,0,954,958,3,70,35,0,955,958,3,110,55,0,956,958,3,112,
        56,0,957,950,1,0,0,0,957,951,1,0,0,0,957,952,1,0,0,0,957,953,1,0,
        0,0,957,954,1,0,0,0,957,955,1,0,0,0,957,956,1,0,0,0,958,57,1,0,0,
        0,959,962,5,113,0,0,960,961,5,115,0,0,961,963,5,211,0,0,962,960,
        1,0,0,0,962,963,1,0,0,0,963,972,1,0,0,0,964,967,5,158,0,0,965,966,
        5,115,0,0,966,968,5,211,0,0,967,965,1,0,0,0,967,968,1,0,0,0,968,
        972,1,0,0,0,969,972,5,120,0,0,970,972,5,178,0,0,971,959,1,0,0,0,
        971,964,1,0,0,0,971,969,1,0,0,0,971,970,1,0,0,0,972,59,1,0,0,0,973,
        974,5,219,0,0,974,61,1,0,0,0,975,976,5,65,0,0,976,977,5,207,0,0,
        977,982,3,68,34,0,978,979,5,196,0,0,979,981,3,68,34,0,980,978,1,
        0,0,0,981,984,1,0,0,0,982,980,1,0,0,0,982,983,1,0,0,0,983,985,1,
        0,0,0,984,982,1,0,0,0,985,987,5,208,0,0,986,988,7,12,0,0,987,986,
        1,0,0,0,987,988,1,0,0,0,988,63,1,0,0,0,989,990,5,6,0,0,990,991,5,
        128,0,0,991,992,3,52,26,0,992,65,1,0,0,0,993,994,5,194,0,0,994,999,
        3,68,34,0,995,996,5,196,0,0,996,998,3,68,34,0,997,995,1,0,0,0,998,
        1001,1,0,0,0,999,997,1,0,0,0,999,1000,1,0,0,0,1000,1004,1,0,0,0,
        1001,999,1,0,0,0,1002,1003,5,197,0,0,1003,1005,5,73,0,0,1004,1002,
        1,0,0,0,1004,1005,1,0,0,0,1005,1006,1,0,0,0,1006,1008,5,195,0,0,
        1007,1009,7,12,0,0,1008,1007,1,0,0,0,1008,1009,1,0,0,0,1009,67,1,
        0,0,0,1010,1015,7,13,0,0,1011,1012,5,203,0,0,1012,1014,5,215,0,0,
        1013,1011,1,0,0,0,1014,1017,1,0,0,0,1015,1013,1,0,0,0,1015,1016,
        1,0,0,0,1016,1019,1,0,0,0,1017,1015,1,0,0,0,1018,1020,3,66,33,0,
        1019,1018,1,0,0,0,1019,1020,1,0,0,0,1020,69,1,0,0,0,1021,1035,5,
        87,0,0,1022,1027,5,215,0,0,1023,1024,5,203,0,0,1024,1026,5,215,0,
        0,1025,1023,1,0,0,0,1026,1029,1,0,0,0,1027,1025,1,0,0,0,1027,1028,
        1,0,0,0,1028,1032,1,0,0,0,1029,1027,1,0,0,0,1030,1031,5,203,0,0,
        1031,1033,5,134,0,0,1032,1030,1,0,0,0,1032,1033,1,0,0,0,1033,1036,
        1,0,0,0,1034,1036,5,134,0,0,1035,1022,1,0,0,0,1035,1034,1,0,0,0,
        1036,71,1,0,0,0,1037,1038,7,14,0,0,1038,73,1,0,0,0,1039,1040,5,30,
        0,0,1040,75,1,0,0,0,1041,1042,5,212,0,0,1042,1043,5,204,0,0,1043,
        1054,5,212,0,0,1044,1045,5,212,0,0,1045,1046,5,204,0,0,1046,1054,
        5,211,0,0,1047,1048,5,211,0,0,1048,1049,5,204,0,0,1049,1054,5,211,
        0,0,1050,1051,5,213,0,0,1051,1052,5,204,0,0,1052,1054,5,213,0,0,
        1053,1041,1,0,0,0,1053,1044,1,0,0,0,1053,1047,1,0,0,0,1053,1050,
        1,0,0,0,1054,1056,1,0,0,0,1055,1057,5,34,0,0,1056,1055,1,0,0,0,1056,
        1057,1,0,0,0,1057,1062,1,0,0,0,1058,1059,5,209,0,0,1059,1060,3,132,
        66,0,1060,1061,5,210,0,0,1061,1063,1,0,0,0,1062,1058,1,0,0,0,1062,
        1063,1,0,0,0,1063,1065,1,0,0,0,1064,1066,7,15,0,0,1065,1064,1,0,
        0,0,1065,1066,1,0,0,0,1066,1073,1,0,0,0,1067,1068,5,207,0,0,1068,
        1069,5,215,0,0,1069,1070,5,209,0,0,1070,1071,5,211,0,0,1071,1072,
        5,210,0,0,1072,1074,5,208,0,0,1073,1067,1,0,0,0,1073,1074,1,0,0,
        0,1074,1078,1,0,0,0,1075,1076,5,199,0,0,1076,1077,5,215,0,0,1077,
        1079,5,201,0,0,1078,1075,1,0,0,0,1078,1079,1,0,0,0,1079,77,1,0,0,
        0,1080,1110,5,125,0,0,1081,1082,5,125,0,0,1082,1084,3,76,38,0,1083,
        1085,5,34,0,0,1084,1083,1,0,0,0,1084,1085,1,0,0,0,1085,1110,1,0,
        0,0,1086,1087,5,125,0,0,1087,1088,5,209,0,0,1088,1089,3,132,66,0,
        1089,1090,5,210,0,0,1090,1110,1,0,0,0,1091,1092,5,125,0,0,1092,1094,
        3,76,38,0,1093,1095,5,34,0,0,1094,1093,1,0,0,0,1094,1095,1,0,0,0,
        1095,1100,1,0,0,0,1096,1097,5,209,0,0,1097,1098,3,132,66,0,1098,
        1099,5,210,0,0,1099,1101,1,0,0,0,1100,1096,1,0,0,0,1100,1101,1,0,
        0,0,1101,1110,1,0,0,0,1102,1103,5,125,0,0,1103,1107,3,76,38,0,1104,
        1108,5,36,0,0,1105,1108,5,49,0,0,1106,1108,3,80,40,0,1107,1104,1,
        0,0,0,1107,1105,1,0,0,0,1107,1106,1,0,0,0,1107,1108,1,0,0,0,1108,
        1110,1,0,0,0,1109,1080,1,0,0,0,1109,1081,1,0,0,0,1109,1086,1,0,0,
        0,1109,1091,1,0,0,0,1109,1102,1,0,0,0,1110,79,1,0,0,0,1111,1112,
        5,207,0,0,1112,1116,3,138,69,0,1113,1114,5,209,0,0,1114,1115,5,211,
        0,0,1115,1117,5,210,0,0,1116,1113,1,0,0,0,1116,1117,1,0,0,0,1117,
        1118,1,0,0,0,1118,1119,5,208,0,0,1119,1130,1,0,0,0,1120,1121,5,199,
        0,0,1121,1125,3,52,26,0,1122,1123,5,209,0,0,1123,1124,5,211,0,0,
        1124,1126,5,210,0,0,1125,1122,1,0,0,0,1125,1126,1,0,0,0,1126,1127,
        1,0,0,0,1127,1128,5,201,0,0,1128,1130,1,0,0,0,1129,1111,1,0,0,0,
        1129,1120,1,0,0,0,1130,81,1,0,0,0,1131,1132,7,16,0,0,1132,83,1,0,
        0,0,1133,1138,3,82,41,0,1134,1135,5,209,0,0,1135,1136,3,132,66,0,
        1136,1137,5,210,0,0,1137,1139,1,0,0,0,1138,1134,1,0,0,0,1138,1139,
        1,0,0,0,1139,85,1,0,0,0,1140,1141,5,78,0,0,1141,1142,5,97,0,0,1142,
        1143,5,203,0,0,1143,1144,5,215,0,0,1144,1145,5,219,0,0,1145,1146,
        5,204,0,0,1146,1159,5,219,0,0,1147,1148,5,78,0,0,1148,1149,5,25,
        0,0,1149,1150,3,20,10,0,1150,1151,3,88,44,0,1151,1159,1,0,0,0,1152,
        1153,5,78,0,0,1153,1154,3,52,26,0,1154,1155,5,219,0,0,1155,1156,
        5,204,0,0,1156,1157,5,219,0,0,1157,1159,1,0,0,0,1158,1140,1,0,0,
        0,1158,1147,1,0,0,0,1158,1152,1,0,0,0,1159,87,1,0,0,0,1160,1162,
        5,194,0,0,1161,1163,5,94,0,0,1162,1161,1,0,0,0,1162,1163,1,0,0,0,
        1163,1165,1,0,0,0,1164,1166,5,219,0,0,1165,1164,1,0,0,0,1165,1166,
        1,0,0,0,1166,1172,1,0,0,0,1167,1168,3,90,45,0,1168,1169,5,219,0,
        0,1169,1171,1,0,0,0,1170,1167,1,0,0,0,1171,1174,1,0,0,0,1172,1170,
        1,0,0,0,1172,1173,1,0,0,0,1173,1175,1,0,0,0,1174,1172,1,0,0,0,1175,
        1177,3,90,45,0,1176,1178,5,219,0,0,1177,1176,1,0,0,0,1177,1178,1,
        0,0,0,1178,1179,1,0,0,0,1179,1180,5,195,0,0,1180,89,1,0,0,0,1181,
        1184,5,215,0,0,1182,1183,5,62,0,0,1183,1185,5,211,0,0,1184,1182,
        1,0,0,0,1184,1185,1,0,0,0,1185,1190,1,0,0,0,1186,1187,5,215,0,0,
        1187,1188,5,62,0,0,1188,1190,3,52,26,0,1189,1181,1,0,0,0,1189,1186,
        1,0,0,0,1190,91,1,0,0,0,1191,1192,5,219,0,0,1192,93,1,0,0,0,1193,
        1194,7,17,0,0,1194,95,1,0,0,0,1195,1230,7,18,0,0,1196,1199,7,18,
        0,0,1197,1200,3,76,38,0,1198,1200,5,125,0,0,1199,1197,1,0,0,0,1199,
        1198,1,0,0,0,1200,1213,1,0,0,0,1201,1204,5,196,0,0,1202,1205,3,76,
        38,0,1203,1205,5,125,0,0,1204,1202,1,0,0,0,1204,1203,1,0,0,0,1205,
        1211,1,0,0,0,1206,1209,5,196,0,0,1207,1210,3,76,38,0,1208,1210,5,
        125,0,0,1209,1207,1,0,0,0,1209,1208,1,0,0,0,1210,1212,1,0,0,0,1211,
        1206,1,0,0,0,1211,1212,1,0,0,0,1212,1214,1,0,0,0,1213,1201,1,0,0,
        0,1213,1214,1,0,0,0,1214,1230,1,0,0,0,1215,1216,7,18,0,0,1216,1227,
        3,76,38,0,1217,1218,5,196,0,0,1218,1221,3,76,38,0,1219,1220,5,196,
        0,0,1220,1222,3,76,38,0,1221,1219,1,0,0,0,1221,1222,1,0,0,0,1222,
        1225,1,0,0,0,1223,1224,5,196,0,0,1224,1226,3,98,49,0,1225,1223,1,
        0,0,0,1225,1226,1,0,0,0,1226,1228,1,0,0,0,1227,1217,1,0,0,0,1227,
        1228,1,0,0,0,1228,1230,1,0,0,0,1229,1195,1,0,0,0,1229,1196,1,0,0,
        0,1229,1215,1,0,0,0,1230,97,1,0,0,0,1231,1232,5,149,0,0,1232,1233,
        5,211,0,0,1233,1234,5,205,0,0,1234,1235,5,201,0,0,1235,1236,5,211,
        0,0,1236,99,1,0,0,0,1237,1239,5,40,0,0,1238,1237,1,0,0,0,1238,1239,
        1,0,0,0,1239,1240,1,0,0,0,1240,1241,5,215,0,0,1241,1254,5,191,0,
        0,1242,1243,3,52,26,0,1243,1244,5,191,0,0,1244,1249,3,52,26,0,1245,
        1246,5,132,0,0,1246,1248,3,52,26,0,1247,1245,1,0,0,0,1248,1251,1,
        0,0,0,1249,1247,1,0,0,0,1249,1250,1,0,0,0,1250,1252,1,0,0,0,1251,
        1249,1,0,0,0,1252,1253,5,198,0,0,1253,1255,1,0,0,0,1254,1242,1,0,
        0,0,1255,1256,1,0,0,0,1256,1254,1,0,0,0,1256,1257,1,0,0,0,1257,101,
        1,0,0,0,1258,1262,5,129,0,0,1259,1263,5,8,0,0,1260,1263,3,76,38,
        0,1261,1263,3,58,29,0,1262,1259,1,0,0,0,1262,1260,1,0,0,0,1262,1261,
        1,0,0,0,1263,1266,1,0,0,0,1264,1266,5,179,0,0,1265,1258,1,0,0,0,
        1265,1264,1,0,0,0,1266,103,1,0,0,0,1267,1268,5,28,0,0,1268,1269,
        7,19,0,0,1269,105,1,0,0,0,1270,1283,5,35,0,0,1271,1272,5,148,0,0,
        1272,1273,5,194,0,0,1273,1278,3,220,110,0,1274,1275,5,196,0,0,1275,
        1277,3,220,110,0,1276,1274,1,0,0,0,1277,1280,1,0,0,0,1278,1276,1,
        0,0,0,1278,1279,1,0,0,0,1279,1281,1,0,0,0,1280,1278,1,0,0,0,1281,
        1282,5,195,0,0,1282,1284,1,0,0,0,1283,1271,1,0,0,0,1283,1284,1,0,
        0,0,1284,1301,1,0,0,0,1285,1298,5,153,0,0,1286,1287,5,148,0,0,1287,
        1288,5,194,0,0,1288,1293,3,22,11,0,1289,1290,5,196,0,0,1290,1292,
        3,22,11,0,1291,1289,1,0,0,0,1292,1295,1,0,0,0,1293,1291,1,0,0,0,
        1293,1294,1,0,0,0,1294,1296,1,0,0,0,1295,1293,1,0,0,0,1296,1297,
        5,195,0,0,1297,1299,1,0,0,0,1298,1286,1,0,0,0,1298,1299,1,0,0,0,
        1299,1301,1,0,0,0,1300,1270,1,0,0,0,1300,1285,1,0,0,0,1301,107,1,
        0,0,0,1302,1312,5,19,0,0,1303,1310,5,128,0,0,1304,1305,3,106,53,
        0,1305,1306,5,203,0,0,1306,1307,3,182,91,0,1307,1311,1,0,0,0,1308,
        1309,5,18,0,0,1309,1311,5,215,0,0,1310,1304,1,0,0,0,1310,1308,1,
        0,0,0,1311,1313,1,0,0,0,1312,1303,1,0,0,0,1312,1313,1,0,0,0,1313,
        1326,1,0,0,0,1314,1315,5,148,0,0,1315,1316,5,194,0,0,1316,1321,3,
        26,13,0,1317,1318,5,196,0,0,1318,1320,3,26,13,0,1319,1317,1,0,0,
        0,1320,1323,1,0,0,0,1321,1319,1,0,0,0,1321,1322,1,0,0,0,1322,1324,
        1,0,0,0,1323,1321,1,0,0,0,1324,1325,5,195,0,0,1325,1327,1,0,0,0,
        1326,1314,1,0,0,0,1326,1327,1,0,0,0,1327,109,1,0,0,0,1328,1329,5,
        201,0,0,1329,1330,3,220,110,0,1330,111,1,0,0,0,1331,1332,5,201,0,
        0,1332,1336,5,201,0,0,1333,1334,3,220,110,0,1334,1335,5,203,0,0,
        1335,1337,1,0,0,0,1336,1333,1,0,0,0,1336,1337,1,0,0,0,1337,1338,
        1,0,0,0,1338,1339,5,215,0,0,1339,113,1,0,0,0,1340,1342,5,61,0,0,
        1341,1340,1,0,0,0,1341,1342,1,0,0,0,1342,1343,1,0,0,0,1343,1353,
        5,140,0,0,1344,1353,5,155,0,0,1345,1353,5,13,0,0,1346,1348,5,61,
        0,0,1347,1346,1,0,0,0,1347,1348,1,0,0,0,1348,1349,1,0,0,0,1349,1353,
        5,118,0,0,1350,1353,5,119,0,0,1351,1353,5,116,0,0,1352,1341,1,0,
        0,0,1352,1344,1,0,0,0,1352,1345,1,0,0,0,1352,1347,1,0,0,0,1352,1350,
        1,0,0,0,1352,1351,1,0,0,0,1353,1355,1,0,0,0,1354,1356,3,116,58,0,
        1355,1354,1,0,0,0,1355,1356,1,0,0,0,1356,1358,1,0,0,0,1357,1359,
        3,120,60,0,1358,1357,1,0,0,0,1358,1359,1,0,0,0,1359,1361,1,0,0,0,
        1360,1362,3,122,61,0,1361,1360,1,0,0,0,1361,1362,1,0,0,0,1362,1366,
        1,0,0,0,1363,1364,5,103,0,0,1364,1365,5,20,0,0,1365,1367,5,215,0,
        0,1366,1363,1,0,0,0,1366,1367,1,0,0,0,1367,115,1,0,0,0,1368,1369,
        5,187,0,0,1369,1370,5,194,0,0,1370,1375,3,118,59,0,1371,1372,5,196,
        0,0,1372,1374,3,118,59,0,1373,1371,1,0,0,0,1374,1377,1,0,0,0,1375,
        1373,1,0,0,0,1375,1376,1,0,0,0,1376,1378,1,0,0,0,1377,1375,1,0,0,
        0,1378,1379,5,195,0,0,1379,117,1,0,0,0,1380,1386,5,152,0,0,1381,
        1386,5,12,0,0,1382,1383,5,215,0,0,1383,1384,5,203,0,0,1384,1386,
        5,215,0,0,1385,1380,1,0,0,0,1385,1381,1,0,0,0,1385,1382,1,0,0,0,
        1386,119,1,0,0,0,1387,1388,5,182,0,0,1388,1393,5,215,0,0,1389,1390,
        5,203,0,0,1390,1392,5,215,0,0,1391,1389,1,0,0,0,1392,1395,1,0,0,
        0,1393,1391,1,0,0,0,1393,1394,1,0,0,0,1394,121,1,0,0,0,1395,1393,
        1,0,0,0,1396,1397,5,188,0,0,1397,1398,5,135,0,0,1398,1399,5,201,
        0,0,1399,1400,5,213,0,0,1400,123,1,0,0,0,1401,1402,5,103,0,0,1402,
        1403,5,77,0,0,1403,1404,5,207,0,0,1404,1405,5,215,0,0,1405,1406,
        5,197,0,0,1406,1407,5,215,0,0,1407,1408,5,198,0,0,1408,1409,5,208,
        0,0,1409,125,1,0,0,0,1410,1412,5,176,0,0,1411,1410,1,0,0,0,1411,
        1412,1,0,0,0,1412,1413,1,0,0,0,1413,1417,5,215,0,0,1414,1415,5,209,
        0,0,1415,1416,5,215,0,0,1416,1418,5,210,0,0,1417,1414,1,0,0,0,1417,
        1418,1,0,0,0,1418,1422,1,0,0,0,1419,1420,5,194,0,0,1420,1421,5,1,
        0,0,1421,1423,5,195,0,0,1422,1419,1,0,0,0,1422,1423,1,0,0,0,1423,
        1426,1,0,0,0,1424,1425,5,71,0,0,1425,1427,3,132,66,0,1426,1424,1,
        0,0,0,1426,1427,1,0,0,0,1427,1428,1,0,0,0,1428,1442,5,191,0,0,1429,
        1434,3,164,82,0,1430,1431,5,209,0,0,1431,1432,3,132,66,0,1432,1433,
        5,210,0,0,1433,1435,1,0,0,0,1434,1430,1,0,0,0,1434,1435,1,0,0,0,
        1435,1443,1,0,0,0,1436,1443,3,130,65,0,1437,1443,3,196,98,0,1438,
        1439,5,209,0,0,1439,1440,3,132,66,0,1440,1441,5,210,0,0,1441,1443,
        1,0,0,0,1442,1429,1,0,0,0,1442,1436,1,0,0,0,1442,1437,1,0,0,0,1442,
        1438,1,0,0,0,1442,1443,1,0,0,0,1443,1444,1,0,0,0,1444,1445,5,198,
        0,0,1445,127,1,0,0,0,1446,1451,3,82,41,0,1447,1448,7,20,0,0,1448,
        1450,3,82,41,0,1449,1447,1,0,0,0,1450,1453,1,0,0,0,1451,1449,1,0,
        0,0,1451,1452,1,0,0,0,1452,1454,1,0,0,0,1453,1451,1,0,0,0,1454,1455,
        5,209,0,0,1455,1456,3,132,66,0,1456,1457,5,210,0,0,1457,129,1,0,
        0,0,1458,1464,5,194,0,0,1459,1465,3,132,66,0,1460,1465,5,215,0,0,
        1461,1462,5,97,0,0,1462,1463,5,203,0,0,1463,1465,5,215,0,0,1464,
        1459,1,0,0,0,1464,1460,1,0,0,0,1464,1461,1,0,0,0,1465,1476,1,0,0,
        0,1466,1472,7,20,0,0,1467,1473,3,132,66,0,1468,1469,5,97,0,0,1469,
        1470,5,203,0,0,1470,1473,5,215,0,0,1471,1473,5,215,0,0,1472,1467,
        1,0,0,0,1472,1468,1,0,0,0,1472,1471,1,0,0,0,1473,1475,1,0,0,0,1474,
        1466,1,0,0,0,1475,1478,1,0,0,0,1476,1474,1,0,0,0,1476,1477,1,0,0,
        0,1477,1479,1,0,0,0,1478,1476,1,0,0,0,1479,1480,5,195,0,0,1480,131,
        1,0,0,0,1481,1486,5,215,0,0,1482,1483,5,203,0,0,1483,1485,5,215,
        0,0,1484,1482,1,0,0,0,1485,1488,1,0,0,0,1486,1484,1,0,0,0,1486,1487,
        1,0,0,0,1487,1493,1,0,0,0,1488,1486,1,0,0,0,1489,1490,5,97,0,0,1490,
        1491,5,203,0,0,1491,1493,5,215,0,0,1492,1481,1,0,0,0,1492,1489,1,
        0,0,0,1493,133,1,0,0,0,1494,1495,7,21,0,0,1495,1496,5,26,0,0,1496,
        1498,5,215,0,0,1497,1499,5,73,0,0,1498,1497,1,0,0,0,1498,1499,1,
        0,0,0,1499,1502,1,0,0,0,1500,1501,5,71,0,0,1501,1503,3,136,68,0,
        1502,1500,1,0,0,0,1502,1503,1,0,0,0,1503,1504,1,0,0,0,1504,1505,
        5,164,0,0,1505,1521,3,8,4,0,1506,1507,5,127,0,0,1507,1508,5,128,
        0,0,1508,1509,5,215,0,0,1509,1510,5,197,0,0,1510,1515,5,215,0,0,
        1511,1512,5,196,0,0,1512,1514,5,215,0,0,1513,1511,1,0,0,0,1514,1517,
        1,0,0,0,1515,1513,1,0,0,0,1515,1516,1,0,0,0,1516,1519,1,0,0,0,1517,
        1515,1,0,0,0,1518,1520,5,198,0,0,1519,1518,1,0,0,0,1519,1520,1,0,
        0,0,1520,1522,1,0,0,0,1521,1506,1,0,0,0,1522,1523,1,0,0,0,1523,1521,
        1,0,0,0,1523,1524,1,0,0,0,1524,135,1,0,0,0,1525,1526,5,215,0,0,1526,
        1529,5,203,0,0,1527,1528,5,215,0,0,1528,1530,5,203,0,0,1529,1527,
        1,0,0,0,1529,1530,1,0,0,0,1530,1532,1,0,0,0,1531,1525,1,0,0,0,1531,
        1532,1,0,0,0,1532,1533,1,0,0,0,1533,1534,5,215,0,0,1534,137,1,0,
        0,0,1535,1536,3,136,68,0,1536,1537,5,203,0,0,1537,1539,1,0,0,0,1538,
        1535,1,0,0,0,1538,1539,1,0,0,0,1539,1540,1,0,0,0,1540,1541,5,215,
        0,0,1541,139,1,0,0,0,1542,1543,5,136,0,0,1543,1547,5,215,0,0,1544,
        1545,5,194,0,0,1545,1546,7,3,0,0,1546,1548,5,195,0,0,1547,1544,1,
        0,0,0,1547,1548,1,0,0,0,1548,1549,1,0,0,0,1549,1556,5,197,0,0,1550,
        1557,3,26,13,0,1551,1554,5,110,0,0,1552,1553,5,128,0,0,1553,1555,
        3,138,69,0,1554,1552,1,0,0,0,1554,1555,1,0,0,0,1555,1557,1,0,0,0,
        1556,1550,1,0,0,0,1556,1551,1,0,0,0,1557,1558,1,0,0,0,1558,1559,
        5,198,0,0,1559,141,1,0,0,0,1560,1561,5,136,0,0,1561,1563,5,215,0,
        0,1562,1564,7,3,0,0,1563,1562,1,0,0,0,1563,1564,1,0,0,0,1564,1565,
        1,0,0,0,1565,1566,5,197,0,0,1566,1567,3,26,13,0,1567,1568,5,198,
        0,0,1568,143,1,0,0,0,1569,1578,3,146,73,0,1570,1578,3,148,74,0,1571,
        1578,3,150,75,0,1572,1578,3,152,76,0,1573,1578,3,160,80,0,1574,1575,
        3,164,82,0,1575,1576,5,198,0,0,1576,1578,1,0,0,0,1577,1569,1,0,0,
        0,1577,1570,1,0,0,0,1577,1571,1,0,0,0,1577,1572,1,0,0,0,1577,1573,
        1,0,0,0,1577,1574,1,0,0,0,1578,145,1,0,0,0,1579,1580,5,109,0,0,1580,
        1583,5,38,0,0,1581,1582,5,215,0,0,1582,1584,5,197,0,0,1583,1581,
        1,0,0,0,1583,1584,1,0,0,0,1584,1585,1,0,0,0,1585,1586,3,164,82,0,
        1586,1587,5,198,0,0,1587,147,1,0,0,0,1588,1591,5,38,0,0,1589,1590,
        5,215,0,0,1590,1592,5,197,0,0,1591,1589,1,0,0,0,1591,1592,1,0,0,
        0,1592,1593,1,0,0,0,1593,1594,7,22,0,0,1594,1595,3,84,42,0,1595,
        1596,5,111,0,0,1596,1597,3,164,82,0,1597,1598,5,198,0,0,1598,149,
        1,0,0,0,1599,1600,5,69,0,0,1600,1603,5,38,0,0,1601,1602,5,215,0,
        0,1602,1604,5,197,0,0,1603,1601,1,0,0,0,1603,1604,1,0,0,0,1604,1605,
        1,0,0,0,1605,1606,3,182,91,0,1606,1607,5,147,0,0,1607,1608,5,93,
        0,0,1608,1609,3,220,110,0,1609,1610,5,197,0,0,1610,1611,3,182,91,
        0,1611,1612,5,198,0,0,1612,151,1,0,0,0,1613,1616,5,175,0,0,1614,
        1615,5,215,0,0,1615,1617,5,197,0,0,1616,1614,1,0,0,0,1616,1617,1,
        0,0,0,1617,1621,1,0,0,0,1618,1619,5,194,0,0,1619,1620,7,23,0,0,1620,
        1622,5,195,0,0,1621,1618,1,0,0,0,1621,1622,1,0,0,0,1622,1625,1,0,
        0,0,1623,1624,5,215,0,0,1624,1626,5,197,0,0,1625,1623,1,0,0,0,1625,
        1626,1,0,0,0,1626,1629,1,0,0,0,1627,1630,3,154,77,0,1628,1630,3,
        158,79,0,1629,1627,1,0,0,0,1629,1628,1,0,0,0,1630,1631,1,0,0,0,1631,
        1629,1,0,0,0,1631,1632,1,0,0,0,1632,1633,1,0,0,0,1633,1634,5,198,
        0,0,1634,153,1,0,0,0,1635,1640,3,156,78,0,1636,1637,5,196,0,0,1637,
        1639,3,156,78,0,1638,1636,1,0,0,0,1639,1642,1,0,0,0,1640,1638,1,
        0,0,0,1640,1641,1,0,0,0,1641,155,1,0,0,0,1642,1640,1,0,0,0,1643,
        1644,3,180,90,0,1644,157,1,0,0,0,1645,1649,5,175,0,0,1646,1647,5,
        194,0,0,1647,1648,7,23,0,0,1648,1650,5,195,0,0,1649,1646,1,0,0,0,
        1649,1650,1,0,0,0,1650,1653,1,0,0,0,1651,1652,5,215,0,0,1652,1654,
        5,197,0,0,1653,1651,1,0,0,0,1653,1654,1,0,0,0,1654,1655,1,0,0,0,
        1655,1661,5,215,0,0,1656,1657,5,205,0,0,1657,1658,5,201,0,0,1658,
        1660,5,215,0,0,1659,1656,1,0,0,0,1660,1663,1,0,0,0,1661,1659,1,0,
        0,0,1661,1662,1,0,0,0,1662,1673,1,0,0,0,1663,1661,1,0,0,0,1664,1665,
        5,197,0,0,1665,1670,5,215,0,0,1666,1667,5,196,0,0,1667,1669,5,215,
        0,0,1668,1666,1,0,0,0,1669,1672,1,0,0,0,1670,1668,1,0,0,0,1670,1671,
        1,0,0,0,1671,1674,1,0,0,0,1672,1670,1,0,0,0,1673,1664,1,0,0,0,1673,
        1674,1,0,0,0,1674,1675,1,0,0,0,1675,1676,5,198,0,0,1676,159,1,0,
        0,0,1677,1678,5,150,0,0,1678,1682,5,38,0,0,1679,1680,5,194,0,0,1680,
        1681,7,23,0,0,1681,1683,5,195,0,0,1682,1679,1,0,0,0,1682,1683,1,
        0,0,0,1683,1704,1,0,0,0,1684,1685,5,215,0,0,1685,1686,5,197,0,0,
        1686,1687,5,186,0,0,1687,1688,3,164,82,0,1688,1689,5,197,0,0,1689,
        1690,3,164,82,0,1690,1705,1,0,0,0,1691,1692,5,186,0,0,1692,1693,
        3,164,82,0,1693,1694,5,197,0,0,1694,1696,1,0,0,0,1695,1691,1,0,0,
        0,1695,1696,1,0,0,0,1696,1701,1,0,0,0,1697,1698,5,215,0,0,1698,1702,
        5,197,0,0,1699,1700,5,97,0,0,1700,1702,5,197,0,0,1701,1697,1,0,0,
        0,1701,1699,1,0,0,0,1701,1702,1,0,0,0,1702,1703,1,0,0,0,1703,1705,
        3,164,82,0,1704,1684,1,0,0,0,1704,1695,1,0,0,0,1705,1706,1,0,0,0,
        1706,1707,5,198,0,0,1707,161,1,0,0,0,1708,1709,5,39,0,0,1709,1710,
        5,128,0,0,1710,1711,3,34,17,0,1711,1715,5,191,0,0,1712,1714,3,144,
        72,0,1713,1712,1,0,0,0,1714,1717,1,0,0,0,1715,1713,1,0,0,0,1715,
        1716,1,0,0,0,1716,1718,1,0,0,0,1717,1715,1,0,0,0,1718,1719,5,64,
        0,0,1719,1720,5,198,0,0,1720,163,1,0,0,0,1721,1722,3,166,83,0,1722,
        165,1,0,0,0,1723,1727,3,168,84,0,1724,1725,5,191,0,0,1725,1726,5,
        201,0,0,1726,1728,3,168,84,0,1727,1724,1,0,0,0,1727,1728,1,0,0,0,
        1728,167,1,0,0,0,1729,1734,3,170,85,0,1730,1731,7,24,0,0,1731,1733,
        3,170,85,0,1732,1730,1,0,0,0,1733,1736,1,0,0,0,1734,1732,1,0,0,0,
        1734,1735,1,0,0,0,1735,169,1,0,0,0,1736,1734,1,0,0,0,1737,1742,3,
        172,86,0,1738,1739,7,25,0,0,1739,1741,3,172,86,0,1740,1738,1,0,0,
        0,1741,1744,1,0,0,0,1742,1740,1,0,0,0,1742,1743,1,0,0,0,1743,171,
        1,0,0,0,1744,1742,1,0,0,0,1745,1749,3,174,87,0,1746,1747,3,176,88,
        0,1747,1748,3,174,87,0,1748,1750,1,0,0,0,1749,1746,1,0,0,0,1749,
        1750,1,0,0,0,1750,173,1,0,0,0,1751,1769,3,178,89,0,1752,1754,5,123,
        0,0,1753,1752,1,0,0,0,1753,1754,1,0,0,0,1754,1755,1,0,0,0,1755,1756,
        5,194,0,0,1756,1757,3,164,82,0,1757,1758,5,195,0,0,1758,1769,1,0,
        0,0,1759,1760,5,54,0,0,1760,1761,5,194,0,0,1761,1762,3,178,89,0,
        1762,1763,5,195,0,0,1763,1769,1,0,0,0,1764,1765,5,194,0,0,1765,1766,
        5,26,0,0,1766,1767,5,195,0,0,1767,1769,3,178,89,0,1768,1751,1,0,
        0,0,1768,1753,1,0,0,0,1768,1759,1,0,0,0,1768,1764,1,0,0,0,1769,175,
        1,0,0,0,1770,1771,5,191,0,0,1771,1780,5,191,0,0,1772,1780,5,192,
        0,0,1773,1774,5,199,0,0,1774,1780,5,201,0,0,1775,1780,5,200,0,0,
        1776,1780,5,202,0,0,1777,1780,5,199,0,0,1778,1780,5,201,0,0,1779,
        1770,1,0,0,0,1779,1772,1,0,0,0,1779,1773,1,0,0,0,1779,1775,1,0,0,
        0,1779,1776,1,0,0,0,1779,1777,1,0,0,0,1779,1778,1,0,0,0,1780,177,
        1,0,0,0,1781,1823,3,180,90,0,1782,1786,3,216,108,0,1783,1784,5,95,
        0,0,1784,1786,3,220,110,0,1785,1782,1,0,0,0,1785,1783,1,0,0,0,1786,
        1789,1,0,0,0,1787,1788,5,128,0,0,1788,1790,3,180,90,0,1789,1787,
        1,0,0,0,1789,1790,1,0,0,0,1790,1823,1,0,0,0,1791,1823,3,190,95,0,
        1792,1793,5,97,0,0,1793,1794,5,203,0,0,1794,1807,7,26,0,0,1795,1804,
        5,194,0,0,1796,1801,3,164,82,0,1797,1798,5,196,0,0,1798,1800,3,164,
        82,0,1799,1797,1,0,0,0,1800,1803,1,0,0,0,1801,1799,1,0,0,0,1801,
        1802,1,0,0,0,1802,1805,1,0,0,0,1803,1801,1,0,0,0,1804,1796,1,0,0,
        0,1804,1805,1,0,0,0,1805,1806,1,0,0,0,1806,1808,5,195,0,0,1807,1795,
        1,0,0,0,1807,1808,1,0,0,0,1808,1823,1,0,0,0,1809,1812,5,136,0,0,
        1810,1811,5,215,0,0,1811,1813,5,203,0,0,1812,1810,1,0,0,0,1812,1813,
        1,0,0,0,1813,1814,1,0,0,0,1814,1823,5,215,0,0,1815,1818,5,6,0,0,
        1816,1817,5,128,0,0,1817,1819,3,180,90,0,1818,1816,1,0,0,0,1818,
        1819,1,0,0,0,1819,1823,1,0,0,0,1820,1823,3,56,28,0,1821,1823,5,212,
        0,0,1822,1781,1,0,0,0,1822,1785,1,0,0,0,1822,1791,1,0,0,0,1822,1792,
        1,0,0,0,1822,1809,1,0,0,0,1822,1815,1,0,0,0,1822,1820,1,0,0,0,1822,
        1821,1,0,0,0,1823,179,1,0,0,0,1824,1830,3,184,92,0,1825,1826,5,205,
        0,0,1826,1827,5,201,0,0,1827,1829,3,184,92,0,1828,1825,1,0,0,0,1829,
        1832,1,0,0,0,1830,1828,1,0,0,0,1830,1831,1,0,0,0,1831,181,1,0,0,
        0,1832,1830,1,0,0,0,1833,1834,3,180,90,0,1834,183,1,0,0,0,1835,1854,
        5,160,0,0,1836,1854,5,161,0,0,1837,1854,5,159,0,0,1838,1854,5,137,
        0,0,1839,1843,5,215,0,0,1840,1841,5,209,0,0,1841,1842,5,215,0,0,
        1842,1844,5,210,0,0,1843,1840,1,0,0,0,1843,1844,1,0,0,0,1844,1854,
        1,0,0,0,1845,1846,5,215,0,0,1846,1854,5,197,0,0,1847,1854,3,186,
        93,0,1848,1854,3,188,94,0,1849,1850,5,215,0,0,1850,1851,5,191,0,
        0,1851,1852,5,191,0,0,1852,1854,5,219,0,0,1853,1835,1,0,0,0,1853,
        1836,1,0,0,0,1853,1837,1,0,0,0,1853,1838,1,0,0,0,1853,1839,1,0,0,
        0,1853,1845,1,0,0,0,1853,1847,1,0,0,0,1853,1848,1,0,0,0,1853,1849,
        1,0,0,0,1854,185,1,0,0,0,1855,1857,5,21,0,0,1856,1855,1,0,0,0,1856,
        1857,1,0,0,0,1857,1858,1,0,0,0,1858,1859,5,215,0,0,1859,187,1,0,
        0,0,1860,1864,5,215,0,0,1861,1862,5,209,0,0,1862,1863,7,27,0,0,1863,
        1865,5,210,0,0,1864,1861,1,0,0,0,1864,1865,1,0,0,0,1865,1868,1,0,
        0,0,1866,1868,5,3,0,0,1867,1860,1,0,0,0,1867,1866,1,0,0,0,1868,189,
        1,0,0,0,1869,1870,5,215,0,0,1870,1872,5,203,0,0,1871,1869,1,0,0,
        0,1871,1872,1,0,0,0,1872,1875,1,0,0,0,1873,1874,5,215,0,0,1874,1876,
        5,203,0,0,1875,1873,1,0,0,0,1875,1876,1,0,0,0,1876,1877,1,0,0,0,
        1877,1878,5,215,0,0,1878,1879,5,194,0,0,1879,1884,3,192,96,0,1880,
        1881,5,196,0,0,1881,1883,3,192,96,0,1882,1880,1,0,0,0,1883,1886,
        1,0,0,0,1884,1882,1,0,0,0,1884,1885,1,0,0,0,1885,1887,1,0,0,0,1886,
        1884,1,0,0,0,1887,1888,5,195,0,0,1888,191,1,0,0,0,1889,1899,3,164,
        82,0,1890,1896,5,6,0,0,1891,1892,5,194,0,0,1892,1897,3,32,16,0,1893,
        1894,3,220,110,0,1894,1895,5,195,0,0,1895,1897,1,0,0,0,1896,1891,
        1,0,0,0,1896,1893,1,0,0,0,1896,1897,1,0,0,0,1897,1899,1,0,0,0,1898,
        1889,1,0,0,0,1898,1890,1,0,0,0,1899,193,1,0,0,0,1900,1901,5,81,0,
        0,1901,1902,5,215,0,0,1902,1903,5,194,0,0,1903,1908,3,198,99,0,1904,
        1905,5,198,0,0,1905,1907,3,198,99,0,1906,1904,1,0,0,0,1907,1910,
        1,0,0,0,1908,1906,1,0,0,0,1908,1909,1,0,0,0,1909,1911,1,0,0,0,1910,
        1908,1,0,0,0,1911,1912,5,195,0,0,1912,1916,5,197,0,0,1913,1917,5,
        30,0,0,1914,1917,3,26,13,0,1915,1917,5,215,0,0,1916,1913,1,0,0,0,
        1916,1914,1,0,0,0,1916,1915,1,0,0,0,1917,1918,1,0,0,0,1918,1919,
        5,198,0,0,1919,195,1,0,0,0,1920,1922,5,176,0,0,1921,1920,1,0,0,0,
        1921,1922,1,0,0,0,1922,1923,1,0,0,0,1923,1927,5,215,0,0,1924,1925,
        5,209,0,0,1925,1926,5,215,0,0,1926,1928,5,210,0,0,1927,1924,1,0,
        0,0,1927,1928,1,0,0,0,1928,1931,1,0,0,0,1929,1930,5,71,0,0,1930,
        1932,3,132,66,0,1931,1929,1,0,0,0,1931,1932,1,0,0,0,1932,1944,1,
        0,0,0,1933,1934,5,191,0,0,1934,1935,5,81,0,0,1935,1936,5,220,0,0,
        1936,1937,5,209,0,0,1937,1938,3,132,66,0,1938,1939,5,210,0,0,1939,
        1941,1,0,0,0,1940,1933,1,0,0,0,1940,1941,1,0,0,0,1941,1942,1,0,0,
        0,1942,1944,5,198,0,0,1943,1921,1,0,0,0,1943,1940,1,0,0,0,1944,197,
        1,0,0,0,1945,1946,5,215,0,0,1946,1947,5,197,0,0,1947,1948,3,200,
        100,0,1948,199,1,0,0,0,1949,1959,3,26,13,0,1950,1951,7,28,0,0,1951,
        1954,5,128,0,0,1952,1955,3,32,16,0,1953,1955,3,204,102,0,1954,1952,
        1,0,0,0,1954,1953,1,0,0,0,1955,1959,1,0,0,0,1956,1959,5,67,0,0,1957,
        1959,5,66,0,0,1958,1949,1,0,0,0,1958,1950,1,0,0,0,1958,1956,1,0,
        0,0,1958,1957,1,0,0,0,1959,201,1,0,0,0,1960,1961,5,184,0,0,1961,
        1963,5,215,0,0,1962,1964,7,6,0,0,1963,1962,1,0,0,0,1963,1964,1,0,
        0,0,1964,1968,1,0,0,0,1965,1969,3,206,103,0,1966,1967,5,71,0,0,1967,
        1969,3,204,102,0,1968,1965,1,0,0,0,1968,1966,1,0,0,0,1968,1969,1,
        0,0,0,1969,1973,1,0,0,0,1970,1972,3,222,111,0,1971,1970,1,0,0,0,
        1972,1975,1,0,0,0,1973,1971,1,0,0,0,1973,1974,1,0,0,0,1974,1979,
        1,0,0,0,1975,1973,1,0,0,0,1976,1978,3,224,112,0,1977,1976,1,0,0,
        0,1978,1981,1,0,0,0,1979,1977,1,0,0,0,1979,1980,1,0,0,0,1980,1982,
        1,0,0,0,1981,1979,1,0,0,0,1982,1984,5,191,0,0,1983,1985,3,226,113,
        0,1984,1983,1,0,0,0,1984,1985,1,0,0,0,1985,1989,1,0,0,0,1986,1988,
        3,144,72,0,1987,1986,1,0,0,0,1988,1991,1,0,0,0,1989,1987,1,0,0,0,
        1989,1990,1,0,0,0,1990,1992,1,0,0,0,1991,1989,1,0,0,0,1992,1993,
        5,64,0,0,1993,1994,5,215,0,0,1994,1995,5,198,0,0,1995,203,1,0,0,
        0,1996,1997,5,215,0,0,1997,2000,5,203,0,0,1998,1999,5,215,0,0,1999,
        2001,5,203,0,0,2000,1998,1,0,0,0,2000,2001,1,0,0,0,2001,2003,1,0,
        0,0,2002,1996,1,0,0,0,2002,2003,1,0,0,0,2003,2004,1,0,0,0,2004,2005,
        5,215,0,0,2005,205,1,0,0,0,2006,2012,3,208,104,0,2007,2012,3,210,
        105,0,2008,2012,3,212,106,0,2009,2012,3,214,107,0,2010,2012,3,216,
        108,0,2011,2006,1,0,0,0,2011,2007,1,0,0,0,2011,2008,1,0,0,0,2011,
        2009,1,0,0,0,2011,2010,1,0,0,0,2012,207,1,0,0,0,2013,2014,5,142,
        0,0,2014,2015,3,218,109,0,2015,2016,5,198,0,0,2016,209,1,0,0,0,2017,
        2018,5,101,0,0,2018,2029,3,218,109,0,2019,2020,5,196,0,0,2020,2025,
        3,218,109,0,2021,2022,5,194,0,0,2022,2023,5,132,0,0,2023,2024,5,
        124,0,0,2024,2026,5,195,0,0,2025,2021,1,0,0,0,2025,2026,1,0,0,0,
        2026,2028,1,0,0,0,2027,2019,1,0,0,0,2028,2031,1,0,0,0,2029,2027,
        1,0,0,0,2029,2030,1,0,0,0,2030,2032,1,0,0,0,2031,2029,1,0,0,0,2032,
        2033,5,198,0,0,2033,211,1,0,0,0,2034,2035,5,174,0,0,2035,2040,3,
        218,109,0,2036,2037,5,196,0,0,2037,2039,3,218,109,0,2038,2036,1,
        0,0,0,2039,2042,1,0,0,0,2040,2038,1,0,0,0,2040,2041,1,0,0,0,2041,
        2043,1,0,0,0,2042,2040,1,0,0,0,2043,2044,5,198,0,0,2044,213,1,0,
        0,0,2045,2046,5,5,0,0,2046,2053,3,218,109,0,2047,2054,5,6,0,0,2048,
        2049,5,68,0,0,2049,2050,5,194,0,0,2050,2051,3,156,78,0,2051,2052,
        5,195,0,0,2052,2054,1,0,0,0,2053,2047,1,0,0,0,2053,2048,1,0,0,0,
        2054,2055,1,0,0,0,2055,2056,5,198,0,0,2056,215,1,0,0,0,2057,2059,
        5,13,0,0,2058,2057,1,0,0,0,2058,2059,1,0,0,0,2059,2060,1,0,0,0,2060,
        2061,5,96,0,0,2061,2062,3,218,109,0,2062,2063,5,205,0,0,2063,2064,
        5,201,0,0,2064,2070,5,215,0,0,2065,2066,5,205,0,0,2066,2067,5,201,
        0,0,2067,2069,5,215,0,0,2068,2065,1,0,0,0,2069,2072,1,0,0,0,2070,
        2068,1,0,0,0,2070,2071,1,0,0,0,2071,2073,1,0,0,0,2072,2070,1,0,0,
        0,2073,2074,5,198,0,0,2074,217,1,0,0,0,2075,2076,5,215,0,0,2076,
        2078,5,164,0,0,2077,2075,1,0,0,0,2077,2078,1,0,0,0,2078,2079,1,0,
        0,0,2079,2080,3,220,110,0,2080,219,1,0,0,0,2081,2082,5,215,0,0,2082,
        2085,5,203,0,0,2083,2084,5,215,0,0,2084,2086,5,203,0,0,2085,2083,
        1,0,0,0,2085,2086,1,0,0,0,2086,2088,1,0,0,0,2087,2081,1,0,0,0,2087,
        2088,1,0,0,0,2088,2089,1,0,0,0,2089,2090,7,29,0,0,2090,221,1,0,0,
        0,2091,2092,5,23,0,0,2092,2093,5,215,0,0,2093,2094,5,70,0,0,2094,
        2095,5,31,0,0,2095,2100,3,218,109,0,2096,2097,5,196,0,0,2097,2099,
        3,218,109,0,2098,2096,1,0,0,0,2099,2102,1,0,0,0,2100,2098,1,0,0,
        0,2100,2101,1,0,0,0,2101,223,1,0,0,0,2102,2100,1,0,0,0,2103,2104,
        5,186,0,0,2104,2105,3,164,82,0,2105,2106,5,198,0,0,2106,225,1,0,
        0,0,2107,2109,5,19,0,0,2108,2107,1,0,0,0,2108,2109,1,0,0,0,2109,
        2141,1,0,0,0,2110,2111,5,6,0,0,2111,2112,5,128,0,0,2112,2113,5,215,
        0,0,2113,2121,5,198,0,0,2114,2115,5,215,0,0,2115,2116,5,15,0,0,2116,
        2117,3,164,82,0,2117,2118,5,198,0,0,2118,2120,1,0,0,0,2119,2114,
        1,0,0,0,2120,2123,1,0,0,0,2121,2119,1,0,0,0,2121,2122,1,0,0,0,2122,
        2142,1,0,0,0,2123,2121,1,0,0,0,2124,2125,5,215,0,0,2125,2126,5,15,
        0,0,2126,2127,3,164,82,0,2127,2128,5,198,0,0,2128,2130,1,0,0,0,2129,
        2124,1,0,0,0,2130,2131,1,0,0,0,2131,2129,1,0,0,0,2131,2132,1,0,0,
        0,2132,2142,1,0,0,0,2133,2142,3,24,12,0,2134,2136,7,6,0,0,2135,2134,
        1,0,0,0,2135,2136,1,0,0,0,2136,2137,1,0,0,0,2137,2138,5,15,0,0,2138,
        2139,3,164,82,0,2139,2140,5,198,0,0,2140,2142,1,0,0,0,2141,2110,
        1,0,0,0,2141,2129,1,0,0,0,2141,2133,1,0,0,0,2141,2135,1,0,0,0,2142,
        227,1,0,0,0,2143,2144,5,85,0,0,2144,2146,5,215,0,0,2145,2147,7,2,
        0,0,2146,2145,1,0,0,0,2146,2147,1,0,0,0,2147,2150,1,0,0,0,2148,2149,
        5,71,0,0,2149,2151,3,230,115,0,2150,2148,1,0,0,0,2150,2151,1,0,0,
        0,2151,2155,1,0,0,0,2152,2153,5,24,0,0,2153,2154,5,130,0,0,2154,
        2156,3,220,110,0,2155,2152,1,0,0,0,2155,2156,1,0,0,0,2156,2157,1,
        0,0,0,2157,2161,5,191,0,0,2158,2160,3,224,112,0,2159,2158,1,0,0,
        0,2160,2163,1,0,0,0,2161,2159,1,0,0,0,2161,2162,1,0,0,0,2162,2167,
        1,0,0,0,2163,2161,1,0,0,0,2164,2166,3,232,116,0,2165,2164,1,0,0,
        0,2166,2169,1,0,0,0,2167,2165,1,0,0,0,2167,2168,1,0,0,0,2168,2170,
        1,0,0,0,2169,2167,1,0,0,0,2170,2171,5,64,0,0,2171,2172,5,215,0,0,
        2172,2173,5,198,0,0,2173,229,1,0,0,0,2174,2175,5,215,0,0,2175,2178,
        5,203,0,0,2176,2177,5,215,0,0,2177,2179,5,203,0,0,2178,2176,1,0,
        0,0,2178,2179,1,0,0,0,2179,2181,1,0,0,0,2180,2174,1,0,0,0,2180,2181,
        1,0,0,0,2181,2182,1,0,0,0,2182,2183,5,215,0,0,2183,231,1,0,0,0,2184,
        2186,5,215,0,0,2185,2187,7,3,0,0,2186,2185,1,0,0,0,2186,2187,1,0,
        0,0,2187,2190,1,0,0,0,2188,2189,5,128,0,0,2189,2191,3,16,8,0,2190,
        2188,1,0,0,0,2190,2191,1,0,0,0,2191,2192,1,0,0,0,2192,2193,5,197,
        0,0,2193,2198,3,234,117,0,2194,2195,5,196,0,0,2195,2197,3,234,117,
        0,2196,2194,1,0,0,0,2197,2200,1,0,0,0,2198,2196,1,0,0,0,2198,2199,
        1,0,0,0,2199,2201,1,0,0,0,2200,2198,1,0,0,0,2201,2202,5,198,0,0,
        2202,233,1,0,0,0,2203,2205,5,186,0,0,2204,2203,1,0,0,0,2204,2205,
        1,0,0,0,2205,2206,1,0,0,0,2206,2208,3,164,82,0,2207,2204,1,0,0,0,
        2207,2208,1,0,0,0,2208,2209,1,0,0,0,2209,2210,5,194,0,0,2210,2215,
        3,236,118,0,2211,2212,5,198,0,0,2212,2214,3,236,118,0,2213,2211,
        1,0,0,0,2214,2217,1,0,0,0,2215,2213,1,0,0,0,2215,2216,1,0,0,0,2216,
        2218,1,0,0,0,2217,2215,1,0,0,0,2218,2219,5,195,0,0,2219,235,1,0,
        0,0,2220,2221,5,215,0,0,2221,2240,5,15,0,0,2222,2223,5,207,0,0,2223,
        2224,3,138,69,0,2224,2225,5,208,0,0,2225,2241,1,0,0,0,2226,2241,
        3,178,89,0,2227,2228,5,2,0,0,2228,2229,3,182,91,0,2229,2230,5,194,
        0,0,2230,2235,3,238,119,0,2231,2232,5,196,0,0,2232,2234,3,238,119,
        0,2233,2231,1,0,0,0,2234,2237,1,0,0,0,2235,2233,1,0,0,0,2235,2236,
        1,0,0,0,2236,2238,1,0,0,0,2237,2235,1,0,0,0,2238,2239,5,195,0,0,
        2239,2241,1,0,0,0,2240,2222,1,0,0,0,2240,2226,1,0,0,0,2240,2227,
        1,0,0,0,2241,237,1,0,0,0,2242,2243,5,207,0,0,2243,2244,3,138,69,
        0,2244,2245,5,208,0,0,2245,2248,1,0,0,0,2246,2248,3,56,28,0,2247,
        2242,1,0,0,0,2247,2246,1,0,0,0,2248,2249,1,0,0,0,2249,2250,5,185,
        0,0,2250,2251,5,93,0,0,2251,2252,3,240,120,0,2252,239,1,0,0,0,2253,
        2256,3,70,35,0,2254,2255,5,204,0,0,2255,2257,3,70,35,0,2256,2254,
        1,0,0,0,2256,2257,1,0,0,0,2257,241,1,0,0,0,311,246,251,254,257,264,
        271,273,281,289,293,298,303,309,323,325,333,340,344,348,358,361,
        364,374,380,383,392,397,406,411,416,434,438,449,453,465,469,472,
        475,486,490,494,510,518,521,524,529,534,537,542,544,546,555,563,
        566,570,573,576,582,587,590,597,600,605,611,617,624,628,632,638,
        645,651,660,665,669,674,683,688,692,701,706,710,715,719,724,732,
        735,740,747,750,757,762,767,775,777,788,791,794,805,808,815,820,
        827,833,837,844,846,851,857,861,865,881,886,888,901,904,909,916,
        924,927,933,948,957,962,967,971,982,987,999,1004,1008,1015,1019,
        1027,1032,1035,1053,1056,1062,1065,1073,1078,1084,1094,1100,1107,
        1109,1116,1125,1129,1138,1158,1162,1165,1172,1177,1184,1189,1199,
        1204,1209,1211,1213,1221,1225,1227,1229,1238,1249,1256,1262,1265,
        1278,1283,1293,1298,1300,1310,1312,1321,1326,1336,1341,1347,1352,
        1355,1358,1361,1366,1375,1385,1393,1411,1417,1422,1426,1434,1442,
        1451,1464,1472,1476,1486,1492,1498,1502,1515,1519,1523,1529,1531,
        1538,1547,1554,1556,1563,1577,1583,1591,1603,1616,1621,1625,1629,
        1631,1640,1649,1653,1661,1670,1673,1682,1695,1701,1704,1715,1727,
        1734,1742,1749,1753,1768,1779,1785,1789,1801,1804,1807,1812,1818,
        1822,1830,1843,1853,1856,1864,1867,1871,1875,1884,1896,1898,1908,
        1916,1921,1927,1931,1940,1943,1954,1958,1963,1968,1973,1979,1984,
        1989,2000,2002,2011,2025,2029,2040,2053,2058,2070,2077,2085,2087,
        2100,2108,2121,2131,2135,2141,2146,2150,2155,2161,2167,2178,2180,
        2186,2190,2198,2204,2207,2215,2235,2240,2247,2256
    ]

class InterlisParserPy ( Parser ):

    grammarFileName = "InterlisParserPy.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'ABSTRACT'", "'ACCORDING'", "'AGGREGATES'", 
                     "'AGGREGATION'", "'AGGREGATION OF'", "'ALL'", "'AND'", 
                     "'ANY'", "'ANYCLASS'", "'ANYSTRUCTURE'", "'ANYOID'", 
                     "'ARCS'", "'AREA'", "'AS'", "':='", "'ASSOCIATION'", 
                     "'AT'", "'@'", "'ATTRIBUTE'", "'ATTRIBUTES'", "'\\'", 
                     "'BAG'", "'BASE'", "'BASED'", "'BASED ON'", "'BASKET'", 
                     "'BINARY'", "'BLACKBOX'", "'BLANK'", "'BOOLEAN'", "'BY'", 
                     "'CARDINALITY'", "'CHARSET'", "'CIRCULAR'", "'CLASS'", 
                     "'CLOCKWISE'", "'CODE'", "'CONSTRAINT'", "'CONSTRAINTS'", 
                     "'CONTEXT'", "'CONTINUE'", "'CONTINUOUS'", "'CONTOUR'", 
                     "'CONTRACT'", "'CONTRACTED'", "'COORD'", "'COORD2'", 
                     "'COORD3'", "'COUNTERCLOCKWISE'", "'DATE'", "'DATETIME'", 
                     "'DEFAULT'", "'DEFERRED'", "'DEFINED'", "'DEGREES'", 
                     "'DEPENDS'", "'DERIVATIVES'", "'DERIVED'", "'DIM1'", 
                     "'DIM2'", "'DIRECTED'", "'/'", "'DOMAIN'", "'END'", 
                     "'ENUM'", "'ENUMTREEVAL'", "'ENUMVAL'", "'EQUAL'", 
                     "'EXISTENCE'", "'EXTENDED'", "'EXTENDS'", "'EXTERNAL'", 
                     "'FINAL'", "'FIRST'", "'FIX'", "'FONT'", "'FORM'", 
                     "'FORMAT'", "'FREE'", "'FROM'", "'FUNCTION'", "'GENERIC'", 
                     "'GENERICS'", "'GRADS'", "'GRAPHIC'", "'HALIGNMENT'", 
                     "'#'", "'HIDING'", "'I16'", "'I32'", "'IDENT'", "'IMPORTS'", 
                     "'IN'", "'INHERITANCE'", "'INSPECTION'", "'INSPECTION OF'", 
                     "'INTERLIS'", "'INTERLIS1'", "'ISSUED'", "'JOIN'", 
                     "'JOIN OF'", "'LAST'", "'LINE'", "'LINEATTR'", "'LINESIZE'", 
                     "'LIST'", "'LNBASE'", "'LOCAL'", "'MANDATORY'", "'METAOBJECT'", 
                     "'%'", "'MODEL'", "'MTEXT'", "'**'", "'*'", "'MULTIAREA'", 
                     "'MULTICOORD'", "'MULTIPOLYLINE'", "'MULTISURFACE'", 
                     "'NAME'", "'NO'", "'NOINCREMENTALTRANSFER'", "'NOT'", 
                     "'NULL'", "'NUMERIC'", "'OBJECT'", "'OBJECTS'", "'OF'", 
                     "'OID'", "'ON'", "'OPTIONAL'", "'OR'", "'ORDERED'", 
                     "'OTHERS'", "'OVERLAPS'", "'PARAMETER'", "'PARENT'", 
                     "'PERIPHERY'", "'PI'", "'POLYLINE'", "'PROJECTION'", 
                     "'PROJECTION OF'", "'RADIANS'", "'REFERENCE'", "'REFSYS'", 
                     "'REFSYSTEM'", "'REQUIRED'", "'RESTRICTION'", "'ROTATION'", 
                     "'SET'", "'SIGN'", "'STRAIGHTS'", "'STRUCTURE'", "'SUBDIVISION'", 
                     "'SURFACE'", "'SYMBOLOGY'", "'TABLE'", "'TEXT'", "'THATAREA'", 
                     "'THIS'", "'THISAREA'", "'TID'", "'TIDSIZE'", "'~'", 
                     "'TIMEOFDAY'", "'TO'", "'TOPIC'", "'TRANSFER'", "'TRANSIENT'", 
                     "'TRANSLATION'", "'TYPE'", "'UNDEFINED'", "'UNION'", 
                     "'UNION_OF'", "'UNIQUE'", "'UNIT'", "'UNQUALIFIED'", 
                     "'URI'", "'UUIDOID'", "'VALIGNMENT'", "'VERSION'", 
                     "'VERTEX'", "'VERTEXINFO'", "'VIEW'", "'WHEN'", "'WHERE'", 
                     "'WITH'", "'WITHOUT'", "'XML'", "'XMLNS'", "'='", "'!='", 
                     "<INVALID>", "'('", "')'", "','", "':'", "';'", "'<'", 
                     "'<='", "'>'", "'>='", "'.'", "'..'", "'-'", "'+'", 
                     "'{'", "'}'", "'['", "']'" ]

    symbolicNames = [ "<INVALID>", "ABSTRACT", "ACCORDING", "AGGREGATES", 
                      "AGGREGATION", "AGGREGATION_OF", "ALL", "AND", "ANY", 
                      "ANYCLASS", "ANYSTRUCTURE", "ANYOID", "ARCS", "AREA", 
                      "AS", "ASSIGN", "ASSOCIATION", "AT", "AT_SYMBOL", 
                      "ATTRIBUTE", "ATTRIBUTES", "BACKSLASH", "BAG", "BASE", 
                      "BASED", "BASED_ON", "BASKET", "BINARY", "BLACKBOX", 
                      "BLANK", "BOOLEAN", "BY", "CARDINALITY", "CHARSET", 
                      "CIRCULAR", "CLASS", "CLOCKWISE", "CODE", "CONSTRAINT", 
                      "CONSTRAINTS", "CONTEXT", "CONTINUE", "CONTINUOUS", 
                      "CONTOUR", "CONTRACT", "CONTRACTED", "COORD", "COORD2", 
                      "COORD3", "COUNTERCLOCKWISE", "DATE", "DATETIME", 
                      "DEFAULT", "DEFERRED", "DEFINED", "DEGREES", "DEPENDS", 
                      "DERIVATIVES", "DERIVED", "DIM1", "DIM2", "DIRECTED", 
                      "DIV", "DOMAIN", "END", "ENUM", "ENUMTREEVAL", "ENUMVAL", 
                      "EQUAL", "EXISTENCE", "EXTENDED", "EXTENDS", "EXTERNAL", 
                      "FINAL", "FIRST", "FIX", "FONT", "FORM", "FORMAT", 
                      "FREE", "FROM", "FUNCTION", "GENERIC", "GENERICS", 
                      "GRADS", "GRAPHIC", "HALIGNMENT", "HASH", "HIDING", 
                      "I16", "I32", "IDENT", "IMPORTS", "IN", "INHERITANCE", 
                      "INSPECTION", "INSPECTION_OF", "INTERLIS", "INTERLIS1", 
                      "ISSUED", "JOIN", "JOIN_OF", "LAST", "LINE", "LINEATTR", 
                      "LINESIZE", "LIST", "LNBASE", "LOCAL", "MANDATORY", 
                      "METAOBJECT", "MOD", "MODEL", "MTEXT", "POW", "MUL", 
                      "MULTIAREA", "MULTICOORD", "MULTIPOLYLINE", "MULTISURFACE", 
                      "NAME", "NO", "NOINCREMENTALTRANSFER", "NOT", "NULL", 
                      "NUMERIC", "OBJECT", "OBJECTS", "OF", "OID", "ON", 
                      "OPTIONAL", "OR", "ORDERED", "OTHERS", "OVERLAPS", 
                      "PARAMETER", "PARENT", "PERIPHERY", "PI", "POLYLINE", 
                      "PROJECTION", "PROJECTION_OF", "RADIANS", "REFERENCE", 
                      "REFSYS", "REFSYSTEM", "REQUIRED", "RESTRICTION", 
                      "ROTATION", "SET", "SIGN", "STRAIGHTS", "STRUCTURE", 
                      "SUBDIVISION", "SURFACE", "SYMBOLOGY", "TABLE", "TEXT", 
                      "THATAREA", "THIS", "THISAREA", "TID", "TIDSIZE", 
                      "TILDE", "TIMEOFDAY", "TO", "TOPIC", "TRANSFER", "TRANSIENT", 
                      "TRANSLATION", "TYPE", "UNDEFINED", "UNION", "UNION_OF", 
                      "UNIQUE", "UNIT", "UNQUALIFIED", "URI", "UUIDOID", 
                      "VALIGNMENT", "VERSION", "VERTEX", "VERTEXINFO", "VIEW", 
                      "WHEN", "WHERE", "WITH", "WITHOUT", "XML", "XMLNS", 
                      "EQ", "NOT_EQ", "Scaling", "LPAR", "RPAR", "COMMA", 
                      "COLON", "SEMI", "LT", "LTEQ", "GT", "GTEQ", "DOT", 
                      "DOTDOT", "MINUS", "PLUS", "LCBR", "RCBR", "LSBR", 
                      "RSBR", "PosNumber", "Number", "Dec", "Float", "Name", 
                      "Letter", "Digit", "HexDigit", "STRING", "Explanation", 
                      "SingleLineComment", "BlockComment", "WS" ]

    RULE_interlis2def = 0
    RULE_modeldef = 1
    RULE_topicDef = 2
    RULE_definitions = 3
    RULE_topicRef = 4
    RULE_genericRef = 5
    RULE_classDef = 6
    RULE_structureDef = 7
    RULE_classRef = 8
    RULE_classOrStructureDef = 9
    RULE_structureRef = 10
    RULE_classOrStructureRef = 11
    RULE_attributeDef = 12
    RULE_attrTypeDef = 13
    RULE_attrType = 14
    RULE_referenceAttr = 15
    RULE_restrictedClassOrAssRef = 16
    RULE_classOrAssociationRef = 17
    RULE_restrictedStructureRef = 18
    RULE_restrictedClassOrStructureRef = 19
    RULE_associationDef = 20
    RULE_associationRef = 21
    RULE_roleDef = 22
    RULE_cardinality = 23
    RULE_domainDef = 24
    RULE_iliType = 25
    RULE_domainRef = 26
    RULE_baseType = 27
    RULE_constant = 28
    RULE_textType = 29
    RULE_textConst = 30
    RULE_enumerationType = 31
    RULE_enumTreeValueType = 32
    RULE_enumeration = 33
    RULE_enumElement = 34
    RULE_enumerationConst = 35
    RULE_alignmentType = 36
    RULE_booleanType = 37
    RULE_numeric = 38
    RULE_numericType = 39
    RULE_refSys = 40
    RULE_decConst = 41
    RULE_numericConst = 42
    RULE_formattedType = 43
    RULE_formatDef = 44
    RULE_baseAttrRef = 45
    RULE_formattedConst = 46
    RULE_dateTimeType = 47
    RULE_coordinateType = 48
    RULE_rotationDef = 49
    RULE_contextDef = 50
    RULE_oIDType = 51
    RULE_blackboxType = 52
    RULE_classType = 53
    RULE_attributeType = 54
    RULE_classConst = 55
    RULE_attributePathConst = 56
    RULE_lineType = 57
    RULE_lineForm = 58
    RULE_lineFormType = 59
    RULE_controlPoints = 60
    RULE_intersectionDef = 61
    RULE_lineFormTypeDef = 62
    RULE_unitDef = 63
    RULE_derivedUnit = 64
    RULE_composedUnit = 65
    RULE_unitRef = 66
    RULE_metaDataBasketDef = 67
    RULE_metaDataBasketRef = 68
    RULE_metaObjectRef = 69
    RULE_parameterDef = 70
    RULE_runTimeParameterDef = 71
    RULE_constraintDef = 72
    RULE_mandatoryConstraint = 73
    RULE_plausibilityConstraint = 74
    RULE_existenceConstraint = 75
    RULE_uniquenessConstraint = 76
    RULE_globalUniqueness = 77
    RULE_uniqueEl = 78
    RULE_localUniqueness = 79
    RULE_setConstraint = 80
    RULE_constraintsDef = 81
    RULE_expression = 82
    RULE_term = 83
    RULE_term0 = 84
    RULE_term1 = 85
    RULE_term2 = 86
    RULE_predicate = 87
    RULE_relation = 88
    RULE_factor = 89
    RULE_objectOrAttributePath = 90
    RULE_attributePath = 91
    RULE_pathEl = 92
    RULE_associationPath = 93
    RULE_attributeRef = 94
    RULE_functionCall = 95
    RULE_argument = 96
    RULE_functionDecl = 97
    RULE_functionDef = 98
    RULE_argumentDef = 99
    RULE_argumentType = 100
    RULE_viewDef = 101
    RULE_viewRef = 102
    RULE_formationDef = 103
    RULE_projection = 104
    RULE_join = 105
    RULE_union = 106
    RULE_aggregation = 107
    RULE_inspection = 108
    RULE_renamedViewableRef = 109
    RULE_viewableRef = 110
    RULE_baseExtensionDef = 111
    RULE_selection = 112
    RULE_viewAttributes = 113
    RULE_graphicDef = 114
    RULE_graphicRef = 115
    RULE_drawingRule = 116
    RULE_condSignParamAssignment = 117
    RULE_signParamAssignment = 118
    RULE_enumAssignment = 119
    RULE_enumRange = 120

    ruleNames =  [ "interlis2def", "modeldef", "topicDef", "definitions", 
                   "topicRef", "genericRef", "classDef", "structureDef", 
                   "classRef", "classOrStructureDef", "structureRef", "classOrStructureRef", 
                   "attributeDef", "attrTypeDef", "attrType", "referenceAttr", 
                   "restrictedClassOrAssRef", "classOrAssociationRef", "restrictedStructureRef", 
                   "restrictedClassOrStructureRef", "associationDef", "associationRef", 
                   "roleDef", "cardinality", "domainDef", "iliType", "domainRef", 
                   "baseType", "constant", "textType", "textConst", "enumerationType", 
                   "enumTreeValueType", "enumeration", "enumElement", "enumerationConst", 
                   "alignmentType", "booleanType", "numeric", "numericType", 
                   "refSys", "decConst", "numericConst", "formattedType", 
                   "formatDef", "baseAttrRef", "formattedConst", "dateTimeType", 
                   "coordinateType", "rotationDef", "contextDef", "oIDType", 
                   "blackboxType", "classType", "attributeType", "classConst", 
                   "attributePathConst", "lineType", "lineForm", "lineFormType", 
                   "controlPoints", "intersectionDef", "lineFormTypeDef", 
                   "unitDef", "derivedUnit", "composedUnit", "unitRef", 
                   "metaDataBasketDef", "metaDataBasketRef", "metaObjectRef", 
                   "parameterDef", "runTimeParameterDef", "constraintDef", 
                   "mandatoryConstraint", "plausibilityConstraint", "existenceConstraint", 
                   "uniquenessConstraint", "globalUniqueness", "uniqueEl", 
                   "localUniqueness", "setConstraint", "constraintsDef", 
                   "expression", "term", "term0", "term1", "term2", "predicate", 
                   "relation", "factor", "objectOrAttributePath", "attributePath", 
                   "pathEl", "associationPath", "attributeRef", "functionCall", 
                   "argument", "functionDecl", "functionDef", "argumentDef", 
                   "argumentType", "viewDef", "viewRef", "formationDef", 
                   "projection", "join", "union", "aggregation", "inspection", 
                   "renamedViewableRef", "viewableRef", "baseExtensionDef", 
                   "selection", "viewAttributes", "graphicDef", "graphicRef", 
                   "drawingRule", "condSignParamAssignment", "signParamAssignment", 
                   "enumAssignment", "enumRange" ]

    EOF = Token.EOF
    ABSTRACT=1
    ACCORDING=2
    AGGREGATES=3
    AGGREGATION=4
    AGGREGATION_OF=5
    ALL=6
    AND=7
    ANY=8
    ANYCLASS=9
    ANYSTRUCTURE=10
    ANYOID=11
    ARCS=12
    AREA=13
    AS=14
    ASSIGN=15
    ASSOCIATION=16
    AT=17
    AT_SYMBOL=18
    ATTRIBUTE=19
    ATTRIBUTES=20
    BACKSLASH=21
    BAG=22
    BASE=23
    BASED=24
    BASED_ON=25
    BASKET=26
    BINARY=27
    BLACKBOX=28
    BLANK=29
    BOOLEAN=30
    BY=31
    CARDINALITY=32
    CHARSET=33
    CIRCULAR=34
    CLASS=35
    CLOCKWISE=36
    CODE=37
    CONSTRAINT=38
    CONSTRAINTS=39
    CONTEXT=40
    CONTINUE=41
    CONTINUOUS=42
    CONTOUR=43
    CONTRACT=44
    CONTRACTED=45
    COORD=46
    COORD2=47
    COORD3=48
    COUNTERCLOCKWISE=49
    DATE=50
    DATETIME=51
    DEFAULT=52
    DEFERRED=53
    DEFINED=54
    DEGREES=55
    DEPENDS=56
    DERIVATIVES=57
    DERIVED=58
    DIM1=59
    DIM2=60
    DIRECTED=61
    DIV=62
    DOMAIN=63
    END=64
    ENUM=65
    ENUMTREEVAL=66
    ENUMVAL=67
    EQUAL=68
    EXISTENCE=69
    EXTENDED=70
    EXTENDS=71
    EXTERNAL=72
    FINAL=73
    FIRST=74
    FIX=75
    FONT=76
    FORM=77
    FORMAT=78
    FREE=79
    FROM=80
    FUNCTION=81
    GENERIC=82
    GENERICS=83
    GRADS=84
    GRAPHIC=85
    HALIGNMENT=86
    HASH=87
    HIDING=88
    I16=89
    I32=90
    IDENT=91
    IMPORTS=92
    IN=93
    INHERITANCE=94
    INSPECTION=95
    INSPECTION_OF=96
    INTERLIS=97
    INTERLIS1=98
    ISSUED=99
    JOIN=100
    JOIN_OF=101
    LAST=102
    LINE=103
    LINEATTR=104
    LINESIZE=105
    LIST=106
    LNBASE=107
    LOCAL=108
    MANDATORY=109
    METAOBJECT=110
    MOD=111
    MODEL=112
    MTEXT=113
    POW=114
    MUL=115
    MULTIAREA=116
    MULTICOORD=117
    MULTIPOLYLINE=118
    MULTISURFACE=119
    NAME=120
    NO=121
    NOINCREMENTALTRANSFER=122
    NOT=123
    NULL=124
    NUMERIC=125
    OBJECT=126
    OBJECTS=127
    OF=128
    OID=129
    ON=130
    OPTIONAL=131
    OR=132
    ORDERED=133
    OTHERS=134
    OVERLAPS=135
    PARAMETER=136
    PARENT=137
    PERIPHERY=138
    PI=139
    POLYLINE=140
    PROJECTION=141
    PROJECTION_OF=142
    RADIANS=143
    REFERENCE=144
    REFSYS=145
    REFSYSTEM=146
    REQUIRED=147
    RESTRICTION=148
    ROTATION=149
    SET=150
    SIGN=151
    STRAIGHTS=152
    STRUCTURE=153
    SUBDIVISION=154
    SURFACE=155
    SYMBOLOGY=156
    TABLE=157
    TEXT=158
    THATAREA=159
    THIS=160
    THISAREA=161
    TID=162
    TIDSIZE=163
    TILDE=164
    TIMEOFDAY=165
    TO=166
    TOPIC=167
    TRANSFER=168
    TRANSIENT=169
    TRANSLATION=170
    TYPE=171
    UNDEFINED=172
    UNION=173
    UNION_OF=174
    UNIQUE=175
    UNIT=176
    UNQUALIFIED=177
    URI=178
    UUIDOID=179
    VALIGNMENT=180
    VERSION=181
    VERTEX=182
    VERTEXINFO=183
    VIEW=184
    WHEN=185
    WHERE=186
    WITH=187
    WITHOUT=188
    XML=189
    XMLNS=190
    EQ=191
    NOT_EQ=192
    Scaling=193
    LPAR=194
    RPAR=195
    COMMA=196
    COLON=197
    SEMI=198
    LT=199
    LTEQ=200
    GT=201
    GTEQ=202
    DOT=203
    DOTDOT=204
    MINUS=205
    PLUS=206
    LCBR=207
    RCBR=208
    LSBR=209
    RSBR=210
    PosNumber=211
    Number=212
    Dec=213
    Float=214
    Name=215
    Letter=216
    Digit=217
    HexDigit=218
    STRING=219
    Explanation=220
    SingleLineComment=221
    BlockComment=222
    WS=223

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Interlis2defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def Dec(self):
            return self.getToken(InterlisParserPy.Dec, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def TRANSFER(self):
            return self.getToken(InterlisParserPy.TRANSFER, 0)

        def INTERLIS1(self):
            return self.getToken(InterlisParserPy.INTERLIS1, 0)

        def modeldef(self):
            return self.getTypedRuleContext(InterlisParserPy.ModeldefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_interlis2def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterlis2def" ):
                listener.enterInterlis2def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterlis2def" ):
                listener.exitInterlis2def(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterlis2def" ):
                return visitor.visitInterlis2def(self)
            else:
                return visitor.visitChildren(self)




    def interlis2def(self):

        localctx = InterlisParserPy.Interlis2defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_interlis2def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97]:
                self.state = 242
                self.match(InterlisParserPy.INTERLIS)
                self.state = 243
                self.match(InterlisParserPy.Dec)
                self.state = 244
                self.match(InterlisParserPy.SEMI)
                self.state = 246
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==45 or ((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 576478361669337089) != 0):
                    self.state = 245
                    self.modeldef()


                pass
            elif token in [168]:
                self.state = 248
                self.match(InterlisParserPy.TRANSFER)
                self.state = 249
                self.match(InterlisParserPy.INTERLIS1)
                self.state = 250
                self.match(InterlisParserPy.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModeldefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODEL(self):
            return self.getToken(InterlisParserPy.MODEL, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def CONTRACTED(self):
            return self.getToken(InterlisParserPy.CONTRACTED, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def AT(self):
            return self.getToken(InterlisParserPy.AT, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.STRING)
            else:
                return self.getToken(InterlisParserPy.STRING, i)

        def VERSION(self):
            return self.getToken(InterlisParserPy.VERSION, 0)

        def TRANSLATION(self):
            return self.getToken(InterlisParserPy.TRANSLATION, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def CONTRACT(self):
            return self.getToken(InterlisParserPy.CONTRACT, 0)

        def ISSUED(self):
            return self.getToken(InterlisParserPy.ISSUED, 0)

        def BY(self):
            return self.getToken(InterlisParserPy.BY, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def IMPORTS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.IMPORTS)
            else:
                return self.getToken(InterlisParserPy.IMPORTS, i)

        def metaDataBasketDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.MetaDataBasketDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.MetaDataBasketDefContext,i)


        def unitDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.UnitDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.UnitDefContext,i)


        def functionDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.FunctionDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.FunctionDefContext,i)


        def functionDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.FunctionDeclContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.FunctionDeclContext,i)


        def lineFormTypeDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.LineFormTypeDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.LineFormTypeDefContext,i)


        def domainDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.DomainDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.DomainDefContext,i)


        def contextDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ContextDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ContextDefContext,i)


        def runTimeParameterDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.RunTimeParameterDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.RunTimeParameterDefContext,i)


        def classDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ClassDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ClassDefContext,i)


        def structureDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.StructureDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.StructureDefContext,i)


        def topicDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.TopicDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.TopicDefContext,i)


        def TYPE(self):
            return self.getToken(InterlisParserPy.TYPE, 0)

        def REFSYSTEM(self):
            return self.getToken(InterlisParserPy.REFSYSTEM, 0)

        def SYMBOLOGY(self):
            return self.getToken(InterlisParserPy.SYMBOLOGY, 0)

        def INTERLIS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.INTERLIS)
            else:
                return self.getToken(InterlisParserPy.INTERLIS, i)

        def Explanation(self):
            return self.getToken(InterlisParserPy.Explanation, 0)

        def UNQUALIFIED(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.UNQUALIFIED)
            else:
                return self.getToken(InterlisParserPy.UNQUALIFIED, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_modeldef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModeldef" ):
                listener.enterModeldef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModeldef" ):
                listener.exitModeldef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModeldef" ):
                return visitor.visitModeldef(self)
            else:
                return visitor.visitChildren(self)




    def modeldef(self):

        localctx = InterlisParserPy.ModeldefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_modeldef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==45:
                self.state = 253
                self.match(InterlisParserPy.CONTRACTED)


            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 33555457) != 0):
                self.state = 256
                _la = self._input.LA(1)
                if not(((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 33555457) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 259
            self.match(InterlisParserPy.MODEL)
            self.state = 260
            self.match(InterlisParserPy.Name)
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 261
                self.match(InterlisParserPy.LPAR)
                self.state = 262
                self.match(InterlisParserPy.Name)
                self.state = 263
                self.match(InterlisParserPy.RPAR)


            self.state = 273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 266
                self.match(InterlisParserPy.AT)
                self.state = 267
                self.match(InterlisParserPy.STRING)
                self.state = 268
                self.match(InterlisParserPy.VERSION)
                self.state = 269
                self.match(InterlisParserPy.STRING)
                self.state = 271
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==220:
                    self.state = 270
                    self.match(InterlisParserPy.Explanation)




            self.state = 281
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==170:
                self.state = 275
                self.match(InterlisParserPy.TRANSLATION)
                self.state = 276
                self.match(InterlisParserPy.OF)
                self.state = 277
                self.match(InterlisParserPy.Name)
                self.state = 278
                self.match(InterlisParserPy.LSBR)
                self.state = 279
                self.match(InterlisParserPy.STRING)
                self.state = 280
                self.match(InterlisParserPy.RSBR)


            self.state = 283
            self.match(InterlisParserPy.EQ)
            self.state = 289
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==44:
                self.state = 284
                self.match(InterlisParserPy.CONTRACT)
                self.state = 285
                self.match(InterlisParserPy.ISSUED)
                self.state = 286
                self.match(InterlisParserPy.BY)
                self.state = 287
                self.match(InterlisParserPy.Name)
                self.state = 288
                self.match(InterlisParserPy.SEMI)


            self.state = 309
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==92:
                self.state = 291
                self.match(InterlisParserPy.IMPORTS)
                self.state = 293
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==177:
                    self.state = 292
                    self.match(InterlisParserPy.UNQUALIFIED)


                self.state = 295
                _la = self._input.LA(1)
                if not(_la==97 or _la==215):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 303
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 296
                    self.match(InterlisParserPy.COMMA)
                    self.state = 298
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==177:
                        self.state = 297
                        self.match(InterlisParserPy.UNQUALIFIED)


                    self.state = 300
                    _la = self._input.LA(1)
                    if not(_la==97 or _la==215):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 305
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 306
                self.match(InterlisParserPy.SEMI)
                self.state = 311
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 35)) & ~0x3f) == 0 and ((1 << (_la - 35)) & 70369012613153) != 0) or ((((_la - 103)) & ~0x3f) == 0 and ((1 << (_la - 103)) & 1416179566510081) != 0) or ((((_la - 167)) & ~0x3f) == 0 and ((1 << (_la - 167)) & 281477141107201) != 0):
                self.state = 323
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                if la_ == 1:
                    self.state = 312
                    self.metaDataBasketDef()
                    pass

                elif la_ == 2:
                    self.state = 313
                    self.unitDef()
                    pass

                elif la_ == 3:
                    self.state = 314
                    self.functionDef()
                    pass

                elif la_ == 4:
                    self.state = 315
                    self.functionDecl()
                    pass

                elif la_ == 5:
                    self.state = 316
                    self.lineFormTypeDef()
                    pass

                elif la_ == 6:
                    self.state = 317
                    self.domainDef()
                    pass

                elif la_ == 7:
                    self.state = 318
                    self.contextDef()
                    pass

                elif la_ == 8:
                    self.state = 319
                    self.runTimeParameterDef()
                    pass

                elif la_ == 9:
                    self.state = 320
                    self.classDef()
                    pass

                elif la_ == 10:
                    self.state = 321
                    self.structureDef()
                    pass

                elif la_ == 11:
                    self.state = 322
                    self.topicDef()
                    pass


                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 328
            self.match(InterlisParserPy.END)
            self.state = 329
            self.match(InterlisParserPy.Name)
            self.state = 330
            self.match(InterlisParserPy.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopicDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOPIC(self):
            return self.getToken(InterlisParserPy.TOPIC, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def VIEW(self):
            return self.getToken(InterlisParserPy.VIEW, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def topicRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.TopicRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.TopicRefContext,i)


        def OID(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OID)
            else:
                return self.getToken(InterlisParserPy.OID, i)

        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.AS)
            else:
                return self.getToken(InterlisParserPy.AS, i)

        def DEPENDS(self):
            return self.getToken(InterlisParserPy.DEPENDS, 0)

        def ON(self):
            return self.getToken(InterlisParserPy.ON, 0)

        def DEFERRED(self):
            return self.getToken(InterlisParserPy.DEFERRED, 0)

        def GENERICS(self):
            return self.getToken(InterlisParserPy.GENERICS, 0)

        def genericRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.GenericRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.GenericRefContext,i)


        def definitions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.DefinitionsContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.DefinitionsContext,i)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def UUIDOID(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.UUIDOID)
            else:
                return self.getToken(InterlisParserPy.UUIDOID, i)

        def INTERLIS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.INTERLIS)
            else:
                return self.getToken(InterlisParserPy.INTERLIS, i)

        def ANYOID(self):
            return self.getToken(InterlisParserPy.ANYOID, 0)

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_topicDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopicDef" ):
                listener.enterTopicDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopicDef" ):
                listener.exitTopicDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopicDef" ):
                return visitor.visitTopicDef(self)
            else:
                return visitor.visitChildren(self)




    def topicDef(self):

        localctx = InterlisParserPy.TopicDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_topicDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==184:
                self.state = 332
                self.match(InterlisParserPy.VIEW)


            self.state = 335
            self.match(InterlisParserPy.TOPIC)
            self.state = 336
            self.match(InterlisParserPy.Name)
            self.state = 340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 337
                self.match(InterlisParserPy.LPAR)
                self.state = 338
                _la = self._input.LA(1)
                if not(_la==1 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 339
                self.match(InterlisParserPy.RPAR)


            self.state = 344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 342
                self.match(InterlisParserPy.EXTENDS)
                self.state = 343
                self.topicRef()


            self.state = 346
            self.match(InterlisParserPy.EQ)
            self.state = 364
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 348
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 347
                    self.match(InterlisParserPy.BASKET)


                self.state = 350
                self.match(InterlisParserPy.OID)
                self.state = 351
                self.match(InterlisParserPy.AS)
                self.state = 361
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
                if la_ == 1:
                    self.state = 352
                    self.match(InterlisParserPy.Name)
                    pass

                elif la_ == 2:
                    self.state = 353
                    self.match(InterlisParserPy.Name)
                    self.state = 354
                    self.match(InterlisParserPy.DOT)
                    self.state = 355
                    self.match(InterlisParserPy.Name)
                    pass

                elif la_ == 3:
                    self.state = 358
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==97:
                        self.state = 356
                        self.match(InterlisParserPy.INTERLIS)
                        self.state = 357
                        self.match(InterlisParserPy.DOT)


                    self.state = 360
                    self.match(InterlisParserPy.UUIDOID)
                    pass


                self.state = 363
                self.match(InterlisParserPy.SEMI)


            self.state = 383
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==129:
                self.state = 366
                self.match(InterlisParserPy.OID)
                self.state = 367
                self.match(InterlisParserPy.AS)
                self.state = 380
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 368
                    self.match(InterlisParserPy.Name)
                    pass

                elif la_ == 2:
                    self.state = 369
                    self.match(InterlisParserPy.Name)
                    self.state = 370
                    self.match(InterlisParserPy.DOT)
                    self.state = 371
                    self.match(InterlisParserPy.Name)
                    pass

                elif la_ == 3:
                    self.state = 374
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==97:
                        self.state = 372
                        self.match(InterlisParserPy.INTERLIS)
                        self.state = 373
                        self.match(InterlisParserPy.DOT)


                    self.state = 376
                    self.match(InterlisParserPy.UUIDOID)
                    pass

                elif la_ == 4:
                    self.state = 377
                    self.match(InterlisParserPy.INTERLIS)
                    self.state = 378
                    self.match(InterlisParserPy.DOT)
                    self.state = 379
                    self.match(InterlisParserPy.ANYOID)
                    pass


                self.state = 382
                self.match(InterlisParserPy.SEMI)


            self.state = 397
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==56:
                self.state = 385
                self.match(InterlisParserPy.DEPENDS)
                self.state = 386
                self.match(InterlisParserPy.ON)
                self.state = 387
                self.topicRef()
                self.state = 392
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 388
                    self.match(InterlisParserPy.COMMA)
                    self.state = 389
                    self.topicRef()
                    self.state = 394
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 395
                self.match(InterlisParserPy.SEMI)


            self.state = 411
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==53:
                self.state = 399
                self.match(InterlisParserPy.DEFERRED)
                self.state = 400
                self.match(InterlisParserPy.GENERICS)
                self.state = 401
                self.genericRef()
                self.state = 406
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 402
                    self.match(InterlisParserPy.COMMA)
                    self.state = 403
                    self.genericRef()
                    self.state = 408
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 409
                self.match(InterlisParserPy.SEMI)


            self.state = 416
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -9223370353227530240) != 0) or _la==85 or _la==146 or ((((_la - 151)) & ~0x3f) == 0 and ((1 << (_la - 151)) & 141845891907589) != 0) or _la==215:
                self.state = 413
                self.definitions()
                self.state = 418
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 419
            self.match(InterlisParserPy.END)
            self.state = 420
            self.match(InterlisParserPy.Name)
            self.state = 421
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metaDataBasketDef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaDataBasketDefContext,0)


        def unitDef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitDefContext,0)


        def functionDef(self):
            return self.getTypedRuleContext(InterlisParserPy.FunctionDefContext,0)


        def domainDef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainDefContext,0)


        def contextDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ContextDefContext,0)


        def classDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassDefContext,0)


        def structureDef(self):
            return self.getTypedRuleContext(InterlisParserPy.StructureDefContext,0)


        def associationDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AssociationDefContext,0)


        def constraintsDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ConstraintsDefContext,0)


        def viewDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewDefContext,0)


        def graphicDef(self):
            return self.getTypedRuleContext(InterlisParserPy.GraphicDefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_definitions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitions" ):
                listener.enterDefinitions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitions" ):
                listener.exitDefinitions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitions" ):
                return visitor.visitDefinitions(self)
            else:
                return visitor.visitChildren(self)




    def definitions(self):

        localctx = InterlisParserPy.DefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_definitions)
        try:
            self.state = 434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 423
                self.metaDataBasketDef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 424
                self.unitDef()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 425
                self.functionDef()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 426
                self.domainDef()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 427
                self.contextDef()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 428
                self.classDef()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 429
                self.structureDef()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 430
                self.associationDef()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 431
                self.constraintsDef()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 432
                self.viewDef()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 433
                self.graphicDef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopicRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_topicRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopicRef" ):
                listener.enterTopicRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopicRef" ):
                listener.exitTopicRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopicRef" ):
                return visitor.visitTopicRef(self)
            else:
                return visitor.visitChildren(self)




    def topicRef(self):

        localctx = InterlisParserPy.TopicRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_topicRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 436
                self.match(InterlisParserPy.Name)
                self.state = 437
                self.match(InterlisParserPy.DOT)


            self.state = 440
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def domainRef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_genericRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericRef" ):
                listener.enterGenericRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericRef" ):
                listener.exitGenericRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericRef" ):
                return visitor.visitGenericRef(self)
            else:
                return visitor.visitChildren(self)




    def genericRef(self):

        localctx = InterlisParserPy.GenericRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_genericRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            self.domainRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(InterlisParserPy.CLASS, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def classOrStructureRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassOrStructureRefContext,0)


        def classOrStructureDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassOrStructureDefContext,0)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def OID(self):
            return self.getToken(InterlisParserPy.OID, 0)

        def AS(self):
            return self.getToken(InterlisParserPy.AS, 0)

        def NO(self):
            return self.getToken(InterlisParserPy.NO, 0)

        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def UUIDOID(self):
            return self.getToken(InterlisParserPy.UUIDOID, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_classDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDef" ):
                listener.enterClassDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDef" ):
                listener.exitClassDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassDef" ):
                return visitor.visitClassDef(self)
            else:
                return visitor.visitChildren(self)




    def classDef(self):

        localctx = InterlisParserPy.ClassDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_classDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.match(InterlisParserPy.CLASS)
            self.state = 445
            self.match(InterlisParserPy.Name)
            self.state = 449
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 446
                self.match(InterlisParserPy.LPAR)
                self.state = 447
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 448
                self.match(InterlisParserPy.RPAR)


            self.state = 453
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 451
                self.match(InterlisParserPy.EXTENDS)
                self.state = 452
                self.classOrStructureRef()


            self.state = 455
            self.match(InterlisParserPy.EQ)
            self.state = 472
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==121 or _la==129:
                self.state = 469
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [129]:
                    self.state = 456
                    self.match(InterlisParserPy.OID)
                    self.state = 457
                    self.match(InterlisParserPy.AS)
                    self.state = 465
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                    if la_ == 1:
                        self.state = 458
                        self.match(InterlisParserPy.Name)
                        pass

                    elif la_ == 2:
                        self.state = 459
                        self.match(InterlisParserPy.Name)
                        self.state = 460
                        self.match(InterlisParserPy.DOT)
                        self.state = 461
                        self.match(InterlisParserPy.Name)
                        pass

                    elif la_ == 3:
                        self.state = 462
                        self.match(InterlisParserPy.INTERLIS)
                        self.state = 463
                        self.match(InterlisParserPy.DOT)
                        self.state = 464
                        _la = self._input.LA(1)
                        if not(_la==179 or _la==215):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass


                    pass
                elif token in [121]:
                    self.state = 467
                    self.match(InterlisParserPy.NO)
                    self.state = 468
                    self.match(InterlisParserPy.OID)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 471
                self.match(InterlisParserPy.SEMI)


            self.state = 475
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18019071436529736) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 18015773369040897) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & 288230994686001163) != 0) or ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 285697) != 0):
                self.state = 474
                self.classOrStructureDef()


            self.state = 477
            self.match(InterlisParserPy.END)
            self.state = 478
            self.match(InterlisParserPy.Name)
            self.state = 479
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructureDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRUCTURE(self):
            return self.getToken(InterlisParserPy.STRUCTURE, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def structureRef(self):
            return self.getTypedRuleContext(InterlisParserPy.StructureRefContext,0)


        def classOrStructureDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassOrStructureDefContext,0)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_structureDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructureDef" ):
                listener.enterStructureDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructureDef" ):
                listener.exitStructureDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructureDef" ):
                return visitor.visitStructureDef(self)
            else:
                return visitor.visitChildren(self)




    def structureDef(self):

        localctx = InterlisParserPy.StructureDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_structureDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            self.match(InterlisParserPy.STRUCTURE)
            self.state = 482
            self.match(InterlisParserPy.Name)
            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 483
                self.match(InterlisParserPy.LPAR)
                self.state = 484
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 485
                self.match(InterlisParserPy.RPAR)


            self.state = 490
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 488
                self.match(InterlisParserPy.EXTENDS)
                self.state = 489
                self.structureRef()


            self.state = 492
            self.match(InterlisParserPy.EQ)
            self.state = 494
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18019071436529736) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 18015773369040897) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & 288230994686001163) != 0) or ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 285697) != 0):
                self.state = 493
                self.classOrStructureDef()


            self.state = 496
            self.match(InterlisParserPy.END)
            self.state = 497
            self.match(InterlisParserPy.Name)
            self.state = 498
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def REFSYSTEM(self):
            return self.getToken(InterlisParserPy.REFSYSTEM, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_classRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassRef" ):
                listener.enterClassRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassRef" ):
                listener.exitClassRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassRef" ):
                return visitor.visitClassRef(self)
            else:
                return visitor.visitChildren(self)




    def classRef(self):

        localctx = InterlisParserPy.ClassRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_classRef)
        self._la = 0 # Token type
        try:
            self.state = 521
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 500
                self.match(InterlisParserPy.INTERLIS)
                self.state = 501
                self.match(InterlisParserPy.DOT)
                self.state = 502
                self.match(InterlisParserPy.REFSYSTEM)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 503
                self.match(InterlisParserPy.INTERLIS)
                self.state = 504
                self.match(InterlisParserPy.DOT)
                self.state = 505
                self.match(InterlisParserPy.Name)
                self.state = 510
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==203:
                    self.state = 506
                    self.match(InterlisParserPy.DOT)
                    self.state = 507
                    self.match(InterlisParserPy.Name)
                    self.state = 512
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 513
                self.match(InterlisParserPy.Name)
                self.state = 518
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==203:
                    self.state = 514
                    self.match(InterlisParserPy.DOT)
                    self.state = 515
                    self.match(InterlisParserPy.Name)
                    self.state = 520
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassOrStructureDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTRIBUTE(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.ATTRIBUTE)
            else:
                return self.getToken(InterlisParserPy.ATTRIBUTE, i)

        def attributeDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.AttributeDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.AttributeDefContext,i)


        def constraintDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ConstraintDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ConstraintDefContext,i)


        def PARAMETER(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.PARAMETER)
            else:
                return self.getToken(InterlisParserPy.PARAMETER, i)

        def parameterDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ParameterDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ParameterDefContext,i)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_classOrStructureDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassOrStructureDef" ):
                listener.enterClassOrStructureDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassOrStructureDef" ):
                listener.exitClassOrStructureDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassOrStructureDef" ):
                return visitor.visitClassOrStructureDef(self)
            else:
                return visitor.visitChildren(self)




    def classOrStructureDef(self):

        localctx = InterlisParserPy.ClassOrStructureDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_classOrStructureDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 544 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 544
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                if la_ == 1:
                    self.state = 524
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==19:
                        self.state = 523
                        self.match(InterlisParserPy.ATTRIBUTE)


                    self.state = 527 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 526
                            self.attributeDef()

                        else:
                            raise NoViableAltException(self)
                        self.state = 529 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

                    pass

                elif la_ == 2:
                    self.state = 532 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 531
                            self.constraintDef()

                        else:
                            raise NoViableAltException(self)
                        self.state = 534 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,46,self._ctx)

                    pass

                elif la_ == 3:
                    self.state = 537
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                    if la_ == 1:
                        self.state = 536
                        self.match(InterlisParserPy.PARAMETER)


                    self.state = 540 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 539
                            self.parameterDef()

                        else:
                            raise NoViableAltException(self)
                        self.state = 542 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

                    pass


                self.state = 546 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 18019071436529736) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 18015773369040897) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & 288230994686001163) != 0) or ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 285697) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructureRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def BOOLEAN(self):
            return self.getToken(InterlisParserPy.BOOLEAN, 0)

        def UUIDOID(self):
            return self.getToken(InterlisParserPy.UUIDOID, 0)

        def URI(self):
            return self.getToken(InterlisParserPy.URI, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_structureRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructureRef" ):
                listener.enterStructureRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructureRef" ):
                listener.exitStructureRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructureRef" ):
                return visitor.visitStructureRef(self)
            else:
                return visitor.visitChildren(self)




    def structureRef(self):

        localctx = InterlisParserPy.StructureRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_structureRef)
        self._la = 0 # Token type
        try:
            self.state = 566
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97]:
                self.enterOuterAlt(localctx, 1)
                self.state = 548
                self.match(InterlisParserPy.INTERLIS)
                self.state = 549
                self.match(InterlisParserPy.DOT)
                self.state = 550
                _la = self._input.LA(1)
                if not(_la==30 or ((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 137438953475) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 555
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==203:
                    self.state = 551
                    self.match(InterlisParserPy.DOT)
                    self.state = 552
                    self.match(InterlisParserPy.Name)
                    self.state = 557
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 2)
                self.state = 558
                self.match(InterlisParserPy.Name)
                self.state = 563
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==203:
                    self.state = 559
                    self.match(InterlisParserPy.DOT)
                    self.state = 560
                    self.match(InterlisParserPy.Name)
                    self.state = 565
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassOrStructureRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassRefContext,0)


        def structureRef(self):
            return self.getTypedRuleContext(InterlisParserPy.StructureRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_classOrStructureRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassOrStructureRef" ):
                listener.enterClassOrStructureRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassOrStructureRef" ):
                listener.exitClassOrStructureRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassOrStructureRef" ):
                return visitor.visitClassOrStructureRef(self)
            else:
                return visitor.visitChildren(self)




    def classOrStructureRef(self):

        localctx = InterlisParserPy.ClassOrStructureRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_classOrStructureRef)
        try:
            self.state = 570
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 568
                self.classRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 569
                self.structureRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def attrTypeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,0)


        def lineType(self):
            return self.getTypedRuleContext(InterlisParserPy.LineTypeContext,0)


        def CONTINUOUS(self):
            return self.getToken(InterlisParserPy.CONTINUOUS, 0)

        def SUBDIVISION(self):
            return self.getToken(InterlisParserPy.SUBDIVISION, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.FactorContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.FactorContext,i)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def TRANSIENT(self):
            return self.getToken(InterlisParserPy.TRANSIENT, 0)

        def ASSIGN(self):
            return self.getToken(InterlisParserPy.ASSIGN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_attributeDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeDef" ):
                listener.enterAttributeDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeDef" ):
                listener.exitAttributeDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeDef" ):
                return visitor.visitAttributeDef(self)
            else:
                return visitor.visitChildren(self)




    def attributeDef(self):

        localctx = InterlisParserPy.AttributeDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_attributeDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 572
                self.match(InterlisParserPy.CONTINUOUS)


            self.state = 576
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==154:
                self.state = 575
                self.match(InterlisParserPy.SUBDIVISION)


            self.state = 578
            self.match(InterlisParserPy.Name)
            self.state = 582
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 579
                self.match(InterlisParserPy.LPAR)
                self.state = 580
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73 or _la==169):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 581
                self.match(InterlisParserPy.RPAR)


            self.state = 584
            self.match(InterlisParserPy.COLON)
            self.state = 587
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.state = 585
                self.attrTypeDef()
                pass

            elif la_ == 2:
                self.state = 586
                self.lineType()
                pass


            self.state = 600
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2138184) != 0) or ((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & 6192449488684801) != 0) or ((((_la - 159)) & ~0x3f) == 0 and ((1 << (_la - 159)) & 1256508694082887687) != 0):
                self.state = 590
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==15:
                    self.state = 589
                    self.match(InterlisParserPy.ASSIGN)


                self.state = 592
                self.factor()
                self.state = 597
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 593
                    self.match(InterlisParserPy.COMMA)
                    self.state = 594
                    self.factor()
                    self.state = 599
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 602
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttrTypeDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrType(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeContext,0)


        def enumeration(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumerationContext,0)


        def MANDATORY(self):
            return self.getToken(InterlisParserPy.MANDATORY, 0)

        def numeric(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericContext,0)


        def NUMERIC(self):
            return self.getToken(InterlisParserPy.NUMERIC, 0)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def unitRef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,0)


        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def CIRCULAR(self):
            return self.getToken(InterlisParserPy.CIRCULAR, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def restrictedStructureRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RestrictedStructureRefContext,0)


        def BAG(self):
            return self.getToken(InterlisParserPy.BAG, 0)

        def LIST(self):
            return self.getToken(InterlisParserPy.LIST, 0)

        def cardinality(self):
            return self.getTypedRuleContext(InterlisParserPy.CardinalityContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_attrTypeDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrTypeDef" ):
                listener.enterAttrTypeDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrTypeDef" ):
                listener.exitAttrTypeDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrTypeDef" ):
                return visitor.visitAttrTypeDef(self)
            else:
                return visitor.visitChildren(self)




    def attrTypeDef(self):

        localctx = InterlisParserPy.AttrTypeDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_attrTypeDef)
        self._la = 0 # Token type
        try:
            self.state = 632
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6, 10, 13, 19, 28, 30, 35, 46, 50, 51, 61, 65, 78, 86, 97, 109, 113, 116, 117, 118, 119, 120, 125, 129, 140, 144, 153, 155, 158, 165, 178, 179, 180, 194, 211, 212, 213, 215, 219]:
                self.enterOuterAlt(localctx, 1)
                self.state = 605
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==109:
                    self.state = 604
                    self.match(InterlisParserPy.MANDATORY)


                self.state = 624
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 607
                    self.attrType()
                    pass

                elif la_ == 2:
                    self.state = 608
                    self.enumeration()
                    pass

                elif la_ == 3:
                    self.state = 609
                    self.numeric()
                    self.state = 611
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==34:
                        self.state = 610
                        self.match(InterlisParserPy.CIRCULAR)


                    self.state = 617
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==209:
                        self.state = 613
                        self.match(InterlisParserPy.LSBR)
                        self.state = 614
                        self.unitRef()
                        self.state = 615
                        self.match(InterlisParserPy.RSBR)


                    pass

                elif la_ == 4:
                    self.state = 619
                    self.match(InterlisParserPy.NUMERIC)

                    self.state = 620
                    self.match(InterlisParserPy.LSBR)
                    self.state = 621
                    self.unitRef()
                    self.state = 622
                    self.match(InterlisParserPy.RSBR)
                    pass


                pass
            elif token in [22, 106]:
                self.enterOuterAlt(localctx, 2)
                self.state = 626
                _la = self._input.LA(1)
                if not(_la==22 or _la==106):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 628
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==207:
                    self.state = 627
                    self.cardinality()


                self.state = 630
                self.match(InterlisParserPy.OF)
                self.state = 631
                self.restrictedStructureRef()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttrTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def iliType(self):
            return self.getTypedRuleContext(InterlisParserPy.IliTypeContext,0)


        def domainRef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,0)


        def referenceAttr(self):
            return self.getTypedRuleContext(InterlisParserPy.ReferenceAttrContext,0)


        def restrictedStructureRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RestrictedStructureRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_attrType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrType" ):
                listener.enterAttrType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrType" ):
                listener.exitAttrType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrType" ):
                return visitor.visitAttrType(self)
            else:
                return visitor.visitChildren(self)




    def attrType(self):

        localctx = InterlisParserPy.AttrTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_attrType)
        try:
            self.state = 638
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 634
                self.iliType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 635
                self.domainRef()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 636
                self.referenceAttr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 637
                self.restrictedStructureRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReferenceAttrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REFERENCE(self):
            return self.getToken(InterlisParserPy.REFERENCE, 0)

        def TO(self):
            return self.getToken(InterlisParserPy.TO, 0)

        def restrictedClassOrAssRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RestrictedClassOrAssRefContext,0)


        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def EXTERNAL(self):
            return self.getToken(InterlisParserPy.EXTERNAL, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_referenceAttr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReferenceAttr" ):
                listener.enterReferenceAttr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReferenceAttr" ):
                listener.exitReferenceAttr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReferenceAttr" ):
                return visitor.visitReferenceAttr(self)
            else:
                return visitor.visitChildren(self)




    def referenceAttr(self):

        localctx = InterlisParserPy.ReferenceAttrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_referenceAttr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 640
            self.match(InterlisParserPy.REFERENCE)
            self.state = 641
            self.match(InterlisParserPy.TO)
            self.state = 645
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 642
                self.match(InterlisParserPy.LPAR)
                self.state = 643
                self.match(InterlisParserPy.EXTERNAL)
                self.state = 644
                self.match(InterlisParserPy.RPAR)


            self.state = 647
            self.restrictedClassOrAssRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestrictedClassOrAssRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classOrAssociationRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ClassOrAssociationRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ClassOrAssociationRefContext,i)


        def ANYCLASS(self):
            return self.getToken(InterlisParserPy.ANYCLASS, 0)

        def RESTRICTION(self):
            return self.getToken(InterlisParserPy.RESTRICTION, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_restrictedClassOrAssRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestrictedClassOrAssRef" ):
                listener.enterRestrictedClassOrAssRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestrictedClassOrAssRef" ):
                listener.exitRestrictedClassOrAssRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRestrictedClassOrAssRef" ):
                return visitor.visitRestrictedClassOrAssRef(self)
            else:
                return visitor.visitChildren(self)




    def restrictedClassOrAssRef(self):

        localctx = InterlisParserPy.RestrictedClassOrAssRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_restrictedClassOrAssRef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 651
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97, 215]:
                self.state = 649
                self.classOrAssociationRef()
                pass
            elif token in [9]:
                self.state = 650
                self.match(InterlisParserPy.ANYCLASS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 665
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==148:
                self.state = 653
                self.match(InterlisParserPy.RESTRICTION)
                self.state = 654
                self.match(InterlisParserPy.LPAR)

                self.state = 655
                self.classOrAssociationRef()
                self.state = 660
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==198:
                    self.state = 656
                    self.match(InterlisParserPy.SEMI)
                    self.state = 657
                    self.classOrAssociationRef()
                    self.state = 662
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 663
                self.match(InterlisParserPy.RPAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassOrAssociationRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassRefContext,0)


        def associationRef(self):
            return self.getTypedRuleContext(InterlisParserPy.AssociationRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_classOrAssociationRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassOrAssociationRef" ):
                listener.enterClassOrAssociationRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassOrAssociationRef" ):
                listener.exitClassOrAssociationRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassOrAssociationRef" ):
                return visitor.visitClassOrAssociationRef(self)
            else:
                return visitor.visitChildren(self)




    def classOrAssociationRef(self):

        localctx = InterlisParserPy.ClassOrAssociationRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_classOrAssociationRef)
        try:
            self.state = 669
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 667
                self.classRef()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 668
                self.associationRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestrictedStructureRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structureRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.StructureRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.StructureRefContext,i)


        def iliType(self):
            return self.getTypedRuleContext(InterlisParserPy.IliTypeContext,0)


        def ANYSTRUCTURE(self):
            return self.getToken(InterlisParserPy.ANYSTRUCTURE, 0)

        def RESTRICTION(self):
            return self.getToken(InterlisParserPy.RESTRICTION, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_restrictedStructureRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestrictedStructureRef" ):
                listener.enterRestrictedStructureRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestrictedStructureRef" ):
                listener.exitRestrictedStructureRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRestrictedStructureRef" ):
                return visitor.visitRestrictedStructureRef(self)
            else:
                return visitor.visitChildren(self)




    def restrictedStructureRef(self):

        localctx = InterlisParserPy.RestrictedStructureRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_restrictedStructureRef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 674
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97, 215]:
                self.state = 671
                self.structureRef()
                pass
            elif token in [6, 13, 19, 28, 30, 35, 46, 50, 51, 61, 65, 78, 86, 113, 116, 117, 118, 119, 120, 125, 129, 140, 153, 155, 158, 165, 178, 179, 180, 219]:
                self.state = 672
                self.iliType()
                pass
            elif token in [10]:
                self.state = 673
                self.match(InterlisParserPy.ANYSTRUCTURE)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 688
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==148:
                self.state = 676
                self.match(InterlisParserPy.RESTRICTION)
                self.state = 677
                self.match(InterlisParserPy.LPAR)
                self.state = 678
                self.structureRef()
                self.state = 683
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 679
                    self.match(InterlisParserPy.COMMA)
                    self.state = 680
                    self.structureRef()
                    self.state = 685
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 686
                self.match(InterlisParserPy.RPAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestrictedClassOrStructureRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classOrStructureRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ClassOrStructureRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ClassOrStructureRefContext,i)


        def ANYSTRUCTURE(self):
            return self.getToken(InterlisParserPy.ANYSTRUCTURE, 0)

        def RESTRICTION(self):
            return self.getToken(InterlisParserPy.RESTRICTION, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_restrictedClassOrStructureRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRestrictedClassOrStructureRef" ):
                listener.enterRestrictedClassOrStructureRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRestrictedClassOrStructureRef" ):
                listener.exitRestrictedClassOrStructureRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRestrictedClassOrStructureRef" ):
                return visitor.visitRestrictedClassOrStructureRef(self)
            else:
                return visitor.visitChildren(self)




    def restrictedClassOrStructureRef(self):

        localctx = InterlisParserPy.RestrictedClassOrStructureRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_restrictedClassOrStructureRef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [97, 215]:
                self.state = 690
                self.classOrStructureRef()
                pass
            elif token in [10]:
                self.state = 691
                self.match(InterlisParserPy.ANYSTRUCTURE)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 706
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==148:
                self.state = 694
                self.match(InterlisParserPy.RESTRICTION)
                self.state = 695
                self.match(InterlisParserPy.LPAR)
                self.state = 696
                self.classOrStructureRef()
                self.state = 701
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==198:
                    self.state = 697
                    self.match(InterlisParserPy.SEMI)
                    self.state = 698
                    self.classOrStructureRef()
                    self.state = 703
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 704
                self.match(InterlisParserPy.RPAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssociationDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSOCIATION(self):
            return self.getToken(InterlisParserPy.ASSOCIATION, 0)

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EQ)
            else:
                return self.getToken(InterlisParserPy.EQ, i)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def associationRef(self):
            return self.getTypedRuleContext(InterlisParserPy.AssociationRefContext,0)


        def DERIVED(self):
            return self.getToken(InterlisParserPy.DERIVED, 0)

        def FROM(self):
            return self.getToken(InterlisParserPy.FROM, 0)

        def roleDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.RoleDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.RoleDefContext,i)


        def ATTRIBUTE(self):
            return self.getToken(InterlisParserPy.ATTRIBUTE, 0)

        def CARDINALITY(self):
            return self.getToken(InterlisParserPy.CARDINALITY, 0)

        def cardinality(self):
            return self.getTypedRuleContext(InterlisParserPy.CardinalityContext,0)


        def constraintDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ConstraintDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ConstraintDefContext,i)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def OID(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OID)
            else:
                return self.getToken(InterlisParserPy.OID, i)

        def AS(self):
            return self.getToken(InterlisParserPy.AS, 0)

        def NO(self):
            return self.getToken(InterlisParserPy.NO, 0)

        def attributeDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.AttributeDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.AttributeDefContext,i)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_associationDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociationDef" ):
                listener.enterAssociationDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociationDef" ):
                listener.exitAssociationDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociationDef" ):
                return visitor.visitAssociationDef(self)
            else:
                return visitor.visitChildren(self)




    def associationDef(self):

        localctx = InterlisParserPy.AssociationDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_associationDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            self.match(InterlisParserPy.ASSOCIATION)
            self.state = 710
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215:
                self.state = 709
                self.match(InterlisParserPy.Name)


            self.state = 715
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 712
                self.match(InterlisParserPy.LPAR)
                self.state = 713
                _la = self._input.LA(1)
                if not(_la==1 or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 576460752303423497) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 714
                self.match(InterlisParserPy.RPAR)


            self.state = 719
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 717
                self.match(InterlisParserPy.EXTENDS)
                self.state = 718
                self.associationRef()


            self.state = 724
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==58:
                self.state = 721
                self.match(InterlisParserPy.DERIVED)
                self.state = 722
                self.match(InterlisParserPy.FROM)
                self.state = 723
                self.match(InterlisParserPy.Name)


            self.state = 726
            self.match(InterlisParserPy.EQ)
            self.state = 735
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==121 or _la==129:
                self.state = 732
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [129]:
                    self.state = 727
                    self.match(InterlisParserPy.OID)
                    self.state = 728
                    self.match(InterlisParserPy.AS)
                    self.state = 729
                    self.match(InterlisParserPy.Name)
                    pass
                elif token in [121]:
                    self.state = 730
                    self.match(InterlisParserPy.NO)
                    self.state = 731
                    self.match(InterlisParserPy.OID)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 734
                self.match(InterlisParserPy.SEMI)


            self.state = 740
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 737
                    self.roleDef() 
                self.state = 742
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

            self.state = 750
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 743
                self.match(InterlisParserPy.ATTRIBUTE)
                self.state = 747
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,87,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 744
                        self.attributeDef() 
                    self.state = 749
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,87,self._ctx)



            self.state = 757
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==32:
                self.state = 752
                self.match(InterlisParserPy.CARDINALITY)
                self.state = 753
                self.match(InterlisParserPy.EQ)
                self.state = 754
                self.cardinality()
                self.state = 755
                self.match(InterlisParserPy.SEMI)


            self.state = 762
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 18014673389494344) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 18015773369040897) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & 288230994685739019) != 0) or ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 285697) != 0):
                self.state = 759
                self.constraintDef()
                self.state = 764
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 765
            self.match(InterlisParserPy.END)
            self.state = 767
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215:
                self.state = 766
                self.match(InterlisParserPy.Name)


            self.state = 769
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssociationRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_associationRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociationRef" ):
                listener.enterAssociationRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociationRef" ):
                listener.exitAssociationRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociationRef" ):
                return visitor.visitAssociationRef(self)
            else:
                return visitor.visitChildren(self)




    def associationRef(self):

        localctx = InterlisParserPy.AssociationRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_associationRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 771
                self.match(InterlisParserPy.Name)
                self.state = 772
                self.match(InterlisParserPy.DOT)
                self.state = 775
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
                if la_ == 1:
                    self.state = 773
                    self.match(InterlisParserPy.Name)
                    self.state = 774
                    self.match(InterlisParserPy.DOT)




            self.state = 779
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def restrictedClassOrAssRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.RestrictedClassOrAssRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.RestrictedClassOrAssRefContext,i)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MINUS)
            else:
                return self.getToken(InterlisParserPy.MINUS, i)

        def LT(self):
            return self.getToken(InterlisParserPy.LT, 0)

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def HASH(self):
            return self.getToken(InterlisParserPy.HASH, 0)

        def cardinality(self):
            return self.getTypedRuleContext(InterlisParserPy.CardinalityContext,0)


        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OR)
            else:
                return self.getToken(InterlisParserPy.OR, i)

        def ASSIGN(self):
            return self.getToken(InterlisParserPy.ASSIGN, 0)

        def STRING(self):
            return self.getToken(InterlisParserPy.STRING, 0)

        def ABSTRACT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.ABSTRACT)
            else:
                return self.getToken(InterlisParserPy.ABSTRACT, i)

        def EXTENDED(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EXTENDED)
            else:
                return self.getToken(InterlisParserPy.EXTENDED, i)

        def FINAL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.FINAL)
            else:
                return self.getToken(InterlisParserPy.FINAL, i)

        def HIDING(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.HIDING)
            else:
                return self.getToken(InterlisParserPy.HIDING, i)

        def ORDERED(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.ORDERED)
            else:
                return self.getToken(InterlisParserPy.ORDERED, i)

        def EXTERNAL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EXTERNAL)
            else:
                return self.getToken(InterlisParserPy.EXTERNAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def attrTypeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,0)


        def enumeration(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumerationContext,0)


        def numeric(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericContext,0)


        def constraintDef(self):
            return self.getTypedRuleContext(InterlisParserPy.ConstraintDefContext,0)


        def MANDATORY(self):
            return self.getToken(InterlisParserPy.MANDATORY, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_roleDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleDef" ):
                listener.enterRoleDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleDef" ):
                listener.exitRoleDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoleDef" ):
                return visitor.visitRoleDef(self)
            else:
                return visitor.visitChildren(self)




    def roleDef(self):

        localctx = InterlisParserPy.RoleDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_roleDef)
        self._la = 0 # Token type
        try:
            self.state = 837
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 781
                self.match(InterlisParserPy.Name)
                self.state = 794
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==194:
                    self.state = 782
                    self.match(InterlisParserPy.LPAR)
                    self.state = 791
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==1 or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & -9223372036854513651) != 0):
                        self.state = 783
                        _la = self._input.LA(1)
                        if not(_la==1 or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & -9223372036854513651) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 788
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==196:
                            self.state = 784
                            self.match(InterlisParserPy.COMMA)
                            self.state = 785
                            _la = self._input.LA(1)
                            if not(_la==1 or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & -9223372036854513651) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 790
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 793
                    self.match(InterlisParserPy.RPAR)


                self.state = 805
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 796
                    self.match(InterlisParserPy.MINUS)
                    self.state = 797
                    self.match(InterlisParserPy.MINUS)

                elif la_ == 2:
                    self.state = 798
                    self.match(InterlisParserPy.MINUS)
                    self.state = 799
                    self.match(InterlisParserPy.LT)
                    self.state = 800
                    self.match(InterlisParserPy.GT)

                elif la_ == 3:
                    self.state = 801
                    self.match(InterlisParserPy.MINUS)
                    self.state = 802
                    self.match(InterlisParserPy.LT)
                    self.state = 803
                    self.match(InterlisParserPy.HASH)
                    self.state = 804
                    self.match(InterlisParserPy.GT)


                self.state = 808
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==207:
                    self.state = 807
                    self.cardinality()


                self.state = 810
                self.restrictedClassOrAssRef()
                self.state = 815
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==132:
                    self.state = 811
                    self.match(InterlisParserPy.OR)
                    self.state = 812
                    self.restrictedClassOrAssRef()
                    self.state = 817
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 820
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==15:
                    self.state = 818
                    self.match(InterlisParserPy.ASSIGN)
                    self.state = 819
                    self.match(InterlisParserPy.STRING)


                self.state = 822
                self.match(InterlisParserPy.SEMI)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 824
                self.match(InterlisParserPy.Name)
                self.state = 825
                self.match(InterlisParserPy.COLON)
                self.state = 827
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
                if la_ == 1:
                    self.state = 826
                    self.match(InterlisParserPy.MANDATORY)


                self.state = 833
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
                if la_ == 1:
                    self.state = 829
                    self.attrTypeDef()
                    pass

                elif la_ == 2:
                    self.state = 830
                    self.enumeration()
                    pass

                elif la_ == 3:
                    self.state = 831
                    self.numeric()
                    pass

                elif la_ == 4:
                    self.state = 832
                    self.constraintDef()
                    pass


                self.state = 835
                self.match(InterlisParserPy.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def MUL(self):
            return self.getToken(InterlisParserPy.MUL, 0)

        def PosNumber(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.PosNumber)
            else:
                return self.getToken(InterlisParserPy.PosNumber, i)

        def DOTDOT(self):
            return self.getToken(InterlisParserPy.DOTDOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_cardinality

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinality" ):
                listener.enterCardinality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinality" ):
                listener.exitCardinality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinality" ):
                return visitor.visitCardinality(self)
            else:
                return visitor.visitChildren(self)




    def cardinality(self):

        localctx = InterlisParserPy.CardinalityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_cardinality)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 839
            self.match(InterlisParserPy.LCBR)
            self.state = 846
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [115]:
                self.state = 840
                self.match(InterlisParserPy.MUL)
                pass
            elif token in [211]:
                self.state = 841
                self.match(InterlisParserPy.PosNumber)
                self.state = 844
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==204:
                    self.state = 842
                    self.match(InterlisParserPy.DOTDOT)
                    self.state = 843
                    _la = self._input.LA(1)
                    if not(_la==115 or _la==211):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 848
            self.match(InterlisParserPy.RCBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomainDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOMAIN(self):
            return self.getToken(InterlisParserPy.DOMAIN, 0)

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EQ)
            else:
                return self.getToken(InterlisParserPy.EQ, i)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def UUIDOID(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.UUIDOID)
            else:
                return self.getToken(InterlisParserPy.UUIDOID, i)

        def LPAR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.LPAR)
            else:
                return self.getToken(InterlisParserPy.LPAR, i)

        def RPAR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.RPAR)
            else:
                return self.getToken(InterlisParserPy.RPAR, i)

        def EXTENDS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EXTENDS)
            else:
                return self.getToken(InterlisParserPy.EXTENDS, i)

        def domainRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.DomainRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,i)


        def CONSTRAINTS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.CONSTRAINTS)
            else:
                return self.getToken(InterlisParserPy.CONSTRAINTS, i)

        def ABSTRACT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.ABSTRACT)
            else:
                return self.getToken(InterlisParserPy.ABSTRACT, i)

        def FINAL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.FINAL)
            else:
                return self.getToken(InterlisParserPy.FINAL, i)

        def GENERIC(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.GENERIC)
            else:
                return self.getToken(InterlisParserPy.GENERIC, i)

        def iliType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.IliTypeContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.IliTypeContext,i)


        def numeric(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.NumericContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.NumericContext,i)


        def enumeration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.EnumerationContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.EnumerationContext,i)


        def CLASS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.CLASS)
            else:
                return self.getToken(InterlisParserPy.CLASS, i)

        def MANDATORY(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MANDATORY)
            else:
                return self.getToken(InterlisParserPy.MANDATORY, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COLON)
            else:
                return self.getToken(InterlisParserPy.COLON, i)

        def constraintDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ConstraintDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ConstraintDefContext,i)


        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.STRING)
            else:
                return self.getToken(InterlisParserPy.STRING, i)

        def DOTDOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOTDOT)
            else:
                return self.getToken(InterlisParserPy.DOTDOT, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def RESTRICTION(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.RESTRICTION)
            else:
                return self.getToken(InterlisParserPy.RESTRICTION, i)

        def classOrAssociationRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ClassOrAssociationRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ClassOrAssociationRefContext,i)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_domainDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomainDef" ):
                listener.enterDomainDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomainDef" ):
                listener.exitDomainDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomainDef" ):
                return visitor.visitDomainDef(self)
            else:
                return visitor.visitChildren(self)




    def domainDef(self):

        localctx = InterlisParserPy.DomainDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_domainDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 851
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==63:
                self.state = 850
                self.match(InterlisParserPy.DOMAIN)


            self.state = 907 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 853
                    _la = self._input.LA(1)
                    if not(_la==179 or _la==215):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 857
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==194:
                        self.state = 854
                        self.match(InterlisParserPy.LPAR)
                        self.state = 855
                        _la = self._input.LA(1)
                        if not(_la==1 or _la==73 or _la==82):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 856
                        self.match(InterlisParserPy.RPAR)


                    self.state = 861
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==71:
                        self.state = 859
                        self.match(InterlisParserPy.EXTENDS)
                        self.state = 860
                        self.domainRef()


                    self.state = 863
                    self.match(InterlisParserPy.EQ)

                    self.state = 865
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==109:
                        self.state = 864
                        self.match(InterlisParserPy.MANDATORY)


                    self.state = 888
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                    if la_ == 1:
                        self.state = 867
                        self.iliType()
                        pass

                    elif la_ == 2:
                        self.state = 868
                        self.numeric()
                        pass

                    elif la_ == 3:
                        self.state = 869
                        self.enumeration()
                        pass

                    elif la_ == 4:
                        self.state = 870
                        self.match(InterlisParserPy.STRING)
                        self.state = 871
                        self.match(InterlisParserPy.DOTDOT)
                        self.state = 872
                        self.match(InterlisParserPy.STRING)
                        pass

                    elif la_ == 5:
                        self.state = 873
                        self.match(InterlisParserPy.CLASS)
                        self.state = 886
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==148:
                            self.state = 874
                            self.match(InterlisParserPy.RESTRICTION)
                            self.state = 875
                            self.match(InterlisParserPy.LPAR)
                            self.state = 876
                            self.classOrAssociationRef()
                            self.state = 881
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            while _la==198:
                                self.state = 877
                                self.match(InterlisParserPy.SEMI)
                                self.state = 878
                                self.classOrAssociationRef()
                                self.state = 883
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)

                            self.state = 884
                            self.match(InterlisParserPy.RPAR)


                        pass


                    self.state = 904
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==39:
                        self.state = 890
                        self.match(InterlisParserPy.CONSTRAINTS)

                        self.state = 891
                        self.match(InterlisParserPy.Name)
                        self.state = 892
                        self.match(InterlisParserPy.COLON)
                        self.state = 893
                        self.constraintDef()
                        self.state = 901
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==196:
                            self.state = 895
                            self.match(InterlisParserPy.COMMA)
                            self.state = 896
                            self.match(InterlisParserPy.Name)
                            self.state = 897
                            self.match(InterlisParserPy.COLON)
                            self.state = 898
                            self.constraintDef()
                            self.state = 903
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 906
                    self.match(InterlisParserPy.SEMI)

                else:
                    raise NoViableAltException(self)
                self.state = 909 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,115,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IliTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def baseType(self):
            return self.getTypedRuleContext(InterlisParserPy.BaseTypeContext,0)


        def lineType(self):
            return self.getTypedRuleContext(InterlisParserPy.LineTypeContext,0)


        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.STRING)
            else:
                return self.getToken(InterlisParserPy.STRING, i)

        def DOTDOT(self):
            return self.getToken(InterlisParserPy.DOTDOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_iliType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIliType" ):
                listener.enterIliType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIliType" ):
                listener.exitIliType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIliType" ):
                return visitor.visitIliType(self)
            else:
                return visitor.visitChildren(self)




    def iliType(self):

        localctx = InterlisParserPy.IliTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_iliType)
        try:
            self.state = 916
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6, 19, 28, 30, 35, 46, 50, 51, 65, 78, 86, 113, 117, 120, 125, 129, 153, 158, 165, 178, 179, 180]:
                self.enterOuterAlt(localctx, 1)
                self.state = 911
                self.baseType()
                pass
            elif token in [13, 61, 116, 118, 119, 140, 155]:
                self.enterOuterAlt(localctx, 2)
                self.state = 912
                self.lineType()
                pass
            elif token in [219]:
                self.enterOuterAlt(localctx, 3)
                self.state = 913
                self.match(InterlisParserPy.STRING)
                self.state = 914
                self.match(InterlisParserPy.DOTDOT)
                self.state = 915
                self.match(InterlisParserPy.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomainRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_domainRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomainRef" ):
                listener.enterDomainRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomainRef" ):
                listener.exitDomainRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomainRef" ):
                return visitor.visitDomainRef(self)
            else:
                return visitor.visitChildren(self)




    def domainRef(self):

        localctx = InterlisParserPy.DomainRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_domainRef)
        try:
            self.state = 933
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [215]:
                self.enterOuterAlt(localctx, 1)
                self.state = 927
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 918
                    self.match(InterlisParserPy.Name)
                    self.state = 919
                    self.match(InterlisParserPy.DOT)
                    self.state = 924
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,117,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 920
                            self.match(InterlisParserPy.Name)
                            self.state = 921
                            self.match(InterlisParserPy.DOT) 
                        self.state = 926
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,117,self._ctx)



                self.state = 929
                self.match(InterlisParserPy.Name)
                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 2)
                self.state = 930
                self.match(InterlisParserPy.INTERLIS)
                self.state = 931
                self.match(InterlisParserPy.DOT)
                self.state = 932
                self.match(InterlisParserPy.Name)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def textType(self):
            return self.getTypedRuleContext(InterlisParserPy.TextTypeContext,0)


        def enumerationType(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumerationTypeContext,0)


        def enumTreeValueType(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumTreeValueTypeContext,0)


        def alignmentType(self):
            return self.getTypedRuleContext(InterlisParserPy.AlignmentTypeContext,0)


        def booleanType(self):
            return self.getTypedRuleContext(InterlisParserPy.BooleanTypeContext,0)


        def numericType(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericTypeContext,0)


        def formattedType(self):
            return self.getTypedRuleContext(InterlisParserPy.FormattedTypeContext,0)


        def dateTimeType(self):
            return self.getTypedRuleContext(InterlisParserPy.DateTimeTypeContext,0)


        def coordinateType(self):
            return self.getTypedRuleContext(InterlisParserPy.CoordinateTypeContext,0)


        def oIDType(self):
            return self.getTypedRuleContext(InterlisParserPy.OIDTypeContext,0)


        def blackboxType(self):
            return self.getTypedRuleContext(InterlisParserPy.BlackboxTypeContext,0)


        def classType(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassTypeContext,0)


        def attributeType(self):
            return self.getTypedRuleContext(InterlisParserPy.AttributeTypeContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_baseType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBaseType" ):
                listener.enterBaseType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBaseType" ):
                listener.exitBaseType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBaseType" ):
                return visitor.visitBaseType(self)
            else:
                return visitor.visitChildren(self)




    def baseType(self):

        localctx = InterlisParserPy.BaseTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_baseType)
        try:
            self.state = 948
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [113, 120, 158, 178]:
                self.enterOuterAlt(localctx, 1)
                self.state = 935
                self.textType()
                pass
            elif token in [65]:
                self.enterOuterAlt(localctx, 2)
                self.state = 936
                self.enumerationType()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 937
                self.enumTreeValueType()
                pass
            elif token in [86, 180]:
                self.enterOuterAlt(localctx, 4)
                self.state = 938
                self.alignmentType()
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 5)
                self.state = 939
                self.booleanType()
                pass
            elif token in [125]:
                self.enterOuterAlt(localctx, 6)
                self.state = 940
                self.numericType()
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 7)
                self.state = 941
                self.formattedType()
                pass
            elif token in [50, 51, 165]:
                self.enterOuterAlt(localctx, 8)
                self.state = 942
                self.dateTimeType()
                pass
            elif token in [46, 117]:
                self.enterOuterAlt(localctx, 9)
                self.state = 943
                self.coordinateType()
                pass
            elif token in [129, 179]:
                self.enterOuterAlt(localctx, 10)
                self.state = 944
                self.oIDType()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 11)
                self.state = 945
                self.blackboxType()
                pass
            elif token in [35, 153]:
                self.enterOuterAlt(localctx, 12)
                self.state = 946
                self.classType()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 13)
                self.state = 947
                self.attributeType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNDEFINED(self):
            return self.getToken(InterlisParserPy.UNDEFINED, 0)

        def numericConst(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericConstContext,0)


        def textConst(self):
            return self.getTypedRuleContext(InterlisParserPy.TextConstContext,0)


        def formattedConst(self):
            return self.getTypedRuleContext(InterlisParserPy.FormattedConstContext,0)


        def enumerationConst(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumerationConstContext,0)


        def classConst(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassConstContext,0)


        def attributePathConst(self):
            return self.getTypedRuleContext(InterlisParserPy.AttributePathConstContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = InterlisParserPy.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_constant)
        try:
            self.state = 957
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 950
                self.match(InterlisParserPy.UNDEFINED)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 951
                self.numericConst()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 952
                self.textConst()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 953
                self.formattedConst()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 954
                self.enumerationConst()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 955
                self.classConst()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 956
                self.attributePathConst()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MTEXT(self):
            return self.getToken(InterlisParserPy.MTEXT, 0)

        def MUL(self):
            return self.getToken(InterlisParserPy.MUL, 0)

        def PosNumber(self):
            return self.getToken(InterlisParserPy.PosNumber, 0)

        def TEXT(self):
            return self.getToken(InterlisParserPy.TEXT, 0)

        def NAME(self):
            return self.getToken(InterlisParserPy.NAME, 0)

        def URI(self):
            return self.getToken(InterlisParserPy.URI, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_textType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextType" ):
                listener.enterTextType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextType" ):
                listener.exitTextType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextType" ):
                return visitor.visitTextType(self)
            else:
                return visitor.visitChildren(self)




    def textType(self):

        localctx = InterlisParserPy.TextTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_textType)
        self._la = 0 # Token type
        try:
            self.state = 971
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [113]:
                self.enterOuterAlt(localctx, 1)
                self.state = 959
                self.match(InterlisParserPy.MTEXT)
                self.state = 962
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==115:
                    self.state = 960
                    self.match(InterlisParserPy.MUL)
                    self.state = 961
                    self.match(InterlisParserPy.PosNumber)


                pass
            elif token in [158]:
                self.enterOuterAlt(localctx, 2)
                self.state = 964
                self.match(InterlisParserPy.TEXT)
                self.state = 967
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==115:
                    self.state = 965
                    self.match(InterlisParserPy.MUL)
                    self.state = 966
                    self.match(InterlisParserPy.PosNumber)


                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 3)
                self.state = 969
                self.match(InterlisParserPy.NAME)
                pass
            elif token in [178]:
                self.enterOuterAlt(localctx, 4)
                self.state = 970
                self.match(InterlisParserPy.URI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TextConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(InterlisParserPy.STRING, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_textConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTextConst" ):
                listener.enterTextConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTextConst" ):
                listener.exitTextConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTextConst" ):
                return visitor.visitTextConst(self)
            else:
                return visitor.visitChildren(self)




    def textConst(self):

        localctx = InterlisParserPy.TextConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_textConst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 973
            self.match(InterlisParserPy.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumerationTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(InterlisParserPy.ENUM, 0)

        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def enumElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.EnumElementContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.EnumElementContext,i)


        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def ORDERED(self):
            return self.getToken(InterlisParserPy.ORDERED, 0)

        def CIRCULAR(self):
            return self.getToken(InterlisParserPy.CIRCULAR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumerationType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumerationType" ):
                listener.enterEnumerationType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumerationType" ):
                listener.exitEnumerationType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumerationType" ):
                return visitor.visitEnumerationType(self)
            else:
                return visitor.visitChildren(self)




    def enumerationType(self):

        localctx = InterlisParserPy.EnumerationTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_enumerationType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 975
            self.match(InterlisParserPy.ENUM)
            self.state = 976
            self.match(InterlisParserPy.LCBR)
            self.state = 977
            self.enumElement()
            self.state = 982
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 978
                self.match(InterlisParserPy.COMMA)
                self.state = 979
                self.enumElement()
                self.state = 984
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 985
            self.match(InterlisParserPy.RCBR)
            self.state = 987
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34 or _la==133:
                self.state = 986
                _la = self._input.LA(1)
                if not(_la==34 or _la==133):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumTreeValueTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(InterlisParserPy.ALL, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def domainRef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumTreeValueType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumTreeValueType" ):
                listener.enterEnumTreeValueType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumTreeValueType" ):
                listener.exitEnumTreeValueType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumTreeValueType" ):
                return visitor.visitEnumTreeValueType(self)
            else:
                return visitor.visitChildren(self)




    def enumTreeValueType(self):

        localctx = InterlisParserPy.EnumTreeValueTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_enumTreeValueType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 989
            self.match(InterlisParserPy.ALL)
            self.state = 990
            self.match(InterlisParserPy.OF)
            self.state = 991
            self.domainRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumerationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def enumElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.EnumElementContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.EnumElementContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def ORDERED(self):
            return self.getToken(InterlisParserPy.ORDERED, 0)

        def CIRCULAR(self):
            return self.getToken(InterlisParserPy.CIRCULAR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumeration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeration" ):
                listener.enterEnumeration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeration" ):
                listener.exitEnumeration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeration" ):
                return visitor.visitEnumeration(self)
            else:
                return visitor.visitChildren(self)




    def enumeration(self):

        localctx = InterlisParserPy.EnumerationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_enumeration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 993
            self.match(InterlisParserPy.LPAR)
            self.state = 994
            self.enumElement()
            self.state = 999
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 995
                self.match(InterlisParserPy.COMMA)
                self.state = 996
                self.enumElement()
                self.state = 1001
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1004
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==197:
                self.state = 1002
                self.match(InterlisParserPy.COLON)
                self.state = 1003
                self.match(InterlisParserPy.FINAL)


            self.state = 1006
            self.match(InterlisParserPy.RPAR)
            self.state = 1008
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34 or _la==133:
                self.state = 1007
                _la = self._input.LA(1)
                if not(_la==34 or _la==133):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def LOCAL(self):
            return self.getToken(InterlisParserPy.LOCAL, 0)

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def enumeration(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumerationContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumElement" ):
                listener.enterEnumElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumElement" ):
                listener.exitEnumElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumElement" ):
                return visitor.visitEnumElement(self)
            else:
                return visitor.visitChildren(self)




    def enumElement(self):

        localctx = InterlisParserPy.EnumElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_enumElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            _la = self._input.LA(1)
            if not(_la==26 or _la==108 or _la==215):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1015
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==203:
                self.state = 1011
                self.match(InterlisParserPy.DOT)
                self.state = 1012
                self.match(InterlisParserPy.Name)
                self.state = 1017
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1019
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 1018
                self.enumeration()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumerationConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASH(self):
            return self.getToken(InterlisParserPy.HASH, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def OTHERS(self):
            return self.getToken(InterlisParserPy.OTHERS, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumerationConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumerationConst" ):
                listener.enterEnumerationConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumerationConst" ):
                listener.exitEnumerationConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumerationConst" ):
                return visitor.visitEnumerationConst(self)
            else:
                return visitor.visitChildren(self)




    def enumerationConst(self):

        localctx = InterlisParserPy.EnumerationConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_enumerationConst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            self.match(InterlisParserPy.HASH)
            self.state = 1035
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [215]:
                self.state = 1022
                self.match(InterlisParserPy.Name)
                self.state = 1027
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,132,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1023
                        self.match(InterlisParserPy.DOT)
                        self.state = 1024
                        self.match(InterlisParserPy.Name) 
                    self.state = 1029
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,132,self._ctx)

                self.state = 1032
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==203:
                    self.state = 1030
                    self.match(InterlisParserPy.DOT)
                    self.state = 1031
                    self.match(InterlisParserPy.OTHERS)


                pass
            elif token in [134]:
                self.state = 1034
                self.match(InterlisParserPy.OTHERS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlignmentTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HALIGNMENT(self):
            return self.getToken(InterlisParserPy.HALIGNMENT, 0)

        def VALIGNMENT(self):
            return self.getToken(InterlisParserPy.VALIGNMENT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_alignmentType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlignmentType" ):
                listener.enterAlignmentType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlignmentType" ):
                listener.exitAlignmentType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlignmentType" ):
                return visitor.visitAlignmentType(self)
            else:
                return visitor.visitChildren(self)




    def alignmentType(self):

        localctx = InterlisParserPy.AlignmentTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_alignmentType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1037
            _la = self._input.LA(1)
            if not(_la==86 or _la==180):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(InterlisParserPy.BOOLEAN, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_booleanType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanType" ):
                listener.enterBooleanType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanType" ):
                listener.exitBooleanType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanType" ):
                return visitor.visitBooleanType(self)
            else:
                return visitor.visitChildren(self)




    def booleanType(self):

        localctx = InterlisParserPy.BooleanTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_booleanType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1039
            self.match(InterlisParserPy.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Number)
            else:
                return self.getToken(InterlisParserPy.Number, i)

        def DOTDOT(self):
            return self.getToken(InterlisParserPy.DOTDOT, 0)

        def PosNumber(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.PosNumber)
            else:
                return self.getToken(InterlisParserPy.PosNumber, i)

        def Dec(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Dec)
            else:
                return self.getToken(InterlisParserPy.Dec, i)

        def CIRCULAR(self):
            return self.getToken(InterlisParserPy.CIRCULAR, 0)

        def LSBR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.LSBR)
            else:
                return self.getToken(InterlisParserPy.LSBR, i)

        def unitRef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,0)


        def RSBR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.RSBR)
            else:
                return self.getToken(InterlisParserPy.RSBR, i)

        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def LT(self):
            return self.getToken(InterlisParserPy.LT, 0)

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def CLOCKWISE(self):
            return self.getToken(InterlisParserPy.CLOCKWISE, 0)

        def COUNTERCLOCKWISE(self):
            return self.getToken(InterlisParserPy.COUNTERCLOCKWISE, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_numeric

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric" ):
                listener.enterNumeric(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric" ):
                listener.exitNumeric(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric" ):
                return visitor.visitNumeric(self)
            else:
                return visitor.visitChildren(self)




    def numeric(self):

        localctx = InterlisParserPy.NumericContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_numeric)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1053
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
            if la_ == 1:
                self.state = 1041
                self.match(InterlisParserPy.Number)
                self.state = 1042
                self.match(InterlisParserPy.DOTDOT)
                self.state = 1043
                self.match(InterlisParserPy.Number)
                pass

            elif la_ == 2:
                self.state = 1044
                self.match(InterlisParserPy.Number)
                self.state = 1045
                self.match(InterlisParserPy.DOTDOT)
                self.state = 1046
                self.match(InterlisParserPy.PosNumber)
                pass

            elif la_ == 3:
                self.state = 1047
                self.match(InterlisParserPy.PosNumber)
                self.state = 1048
                self.match(InterlisParserPy.DOTDOT)
                self.state = 1049
                self.match(InterlisParserPy.PosNumber)
                pass

            elif la_ == 4:
                self.state = 1050
                self.match(InterlisParserPy.Dec)
                self.state = 1051
                self.match(InterlisParserPy.DOTDOT)
                self.state = 1052
                self.match(InterlisParserPy.Dec)
                pass


            self.state = 1056
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 1055
                self.match(InterlisParserPy.CIRCULAR)


            self.state = 1062
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.state = 1058
                self.match(InterlisParserPy.LSBR)
                self.state = 1059
                self.unitRef()
                self.state = 1060
                self.match(InterlisParserPy.RSBR)


            self.state = 1065
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                self.state = 1064
                _la = self._input.LA(1)
                if not(_la==36 or _la==49):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1073
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
            if la_ == 1:
                self.state = 1067
                self.match(InterlisParserPy.LCBR)
                self.state = 1068
                self.match(InterlisParserPy.Name)
                self.state = 1069
                self.match(InterlisParserPy.LSBR)
                self.state = 1070
                self.match(InterlisParserPy.PosNumber)
                self.state = 1071
                self.match(InterlisParserPy.RSBR)
                self.state = 1072
                self.match(InterlisParserPy.RCBR)


            self.state = 1078
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
            if la_ == 1:
                self.state = 1075
                self.match(InterlisParserPy.LT)
                self.state = 1076
                self.match(InterlisParserPy.Name)
                self.state = 1077
                self.match(InterlisParserPy.GT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC(self):
            return self.getToken(InterlisParserPy.NUMERIC, 0)

        def numeric(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericContext,0)


        def CIRCULAR(self):
            return self.getToken(InterlisParserPy.CIRCULAR, 0)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def unitRef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,0)


        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def CLOCKWISE(self):
            return self.getToken(InterlisParserPy.CLOCKWISE, 0)

        def COUNTERCLOCKWISE(self):
            return self.getToken(InterlisParserPy.COUNTERCLOCKWISE, 0)

        def refSys(self):
            return self.getTypedRuleContext(InterlisParserPy.RefSysContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_numericType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericType" ):
                listener.enterNumericType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericType" ):
                listener.exitNumericType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericType" ):
                return visitor.visitNumericType(self)
            else:
                return visitor.visitChildren(self)




    def numericType(self):

        localctx = InterlisParserPy.NumericTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_numericType)
        self._la = 0 # Token type
        try:
            self.state = 1109
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1080
                self.match(InterlisParserPy.NUMERIC)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1081
                self.match(InterlisParserPy.NUMERIC)
                self.state = 1082
                self.numeric()
                self.state = 1084
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==34:
                    self.state = 1083
                    self.match(InterlisParserPy.CIRCULAR)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1086
                self.match(InterlisParserPy.NUMERIC)

                self.state = 1087
                self.match(InterlisParserPy.LSBR)
                self.state = 1088
                self.unitRef()
                self.state = 1089
                self.match(InterlisParserPy.RSBR)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1091
                self.match(InterlisParserPy.NUMERIC)
                self.state = 1092
                self.numeric()
                self.state = 1094
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==34:
                    self.state = 1093
                    self.match(InterlisParserPy.CIRCULAR)


                self.state = 1100
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 1096
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1097
                    self.unitRef()
                    self.state = 1098
                    self.match(InterlisParserPy.RSBR)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1102
                self.match(InterlisParserPy.NUMERIC)
                self.state = 1103
                self.numeric()
                self.state = 1107
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [36]:
                    self.state = 1104
                    self.match(InterlisParserPy.CLOCKWISE)
                    pass
                elif token in [49]:
                    self.state = 1105
                    self.match(InterlisParserPy.COUNTERCLOCKWISE)
                    pass
                elif token in [199, 207]:
                    self.state = 1106
                    self.refSys()
                    pass
                elif token in [3, 6, 13, 15, 21, 39, 87, 95, 96, 97, 107, 136, 137, 139, 148, 159, 160, 161, 172, 195, 196, 198, 201, 211, 212, 213, 215, 219]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RefSysContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def metaObjectRef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaObjectRefContext,0)


        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def PosNumber(self):
            return self.getToken(InterlisParserPy.PosNumber, 0)

        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def LT(self):
            return self.getToken(InterlisParserPy.LT, 0)

        def domainRef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,0)


        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_refSys

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRefSys" ):
                listener.enterRefSys(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRefSys" ):
                listener.exitRefSys(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRefSys" ):
                return visitor.visitRefSys(self)
            else:
                return visitor.visitChildren(self)




    def refSys(self):

        localctx = InterlisParserPy.RefSysContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_refSys)
        self._la = 0 # Token type
        try:
            self.state = 1129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [207]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1111
                self.match(InterlisParserPy.LCBR)
                self.state = 1112
                self.metaObjectRef()
                self.state = 1116
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 1113
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1114
                    self.match(InterlisParserPy.PosNumber)
                    self.state = 1115
                    self.match(InterlisParserPy.RSBR)


                self.state = 1118
                self.match(InterlisParserPy.RCBR)
                pass
            elif token in [199]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1120
                self.match(InterlisParserPy.LT)
                self.state = 1121
                self.domainRef()
                self.state = 1125
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 1122
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1123
                    self.match(InterlisParserPy.PosNumber)
                    self.state = 1124
                    self.match(InterlisParserPy.RSBR)


                self.state = 1127
                self.match(InterlisParserPy.GT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dec(self):
            return self.getToken(InterlisParserPy.Dec, 0)

        def PI(self):
            return self.getToken(InterlisParserPy.PI, 0)

        def LNBASE(self):
            return self.getToken(InterlisParserPy.LNBASE, 0)

        def PosNumber(self):
            return self.getToken(InterlisParserPy.PosNumber, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_decConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecConst" ):
                listener.enterDecConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecConst" ):
                listener.exitDecConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecConst" ):
                return visitor.visitDecConst(self)
            else:
                return visitor.visitChildren(self)




    def decConst(self):

        localctx = InterlisParserPy.DecConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_decConst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1131
            _la = self._input.LA(1)
            if not(_la==107 or _la==139 or _la==211 or _la==213):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decConst(self):
            return self.getTypedRuleContext(InterlisParserPy.DecConstContext,0)


        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def unitRef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,0)


        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_numericConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericConst" ):
                listener.enterNumericConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericConst" ):
                listener.exitNumericConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericConst" ):
                return visitor.visitNumericConst(self)
            else:
                return visitor.visitChildren(self)




    def numericConst(self):

        localctx = InterlisParserPy.NumericConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_numericConst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1133
            self.decConst()
            self.state = 1138
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.state = 1134
                self.match(InterlisParserPy.LSBR)
                self.state = 1135
                self.unitRef()
                self.state = 1136
                self.match(InterlisParserPy.RSBR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormattedTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORMAT(self):
            return self.getToken(InterlisParserPy.FORMAT, 0)

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.STRING)
            else:
                return self.getToken(InterlisParserPy.STRING, i)

        def DOTDOT(self):
            return self.getToken(InterlisParserPy.DOTDOT, 0)

        def BASED_ON(self):
            return self.getToken(InterlisParserPy.BASED_ON, 0)

        def structureRef(self):
            return self.getTypedRuleContext(InterlisParserPy.StructureRefContext,0)


        def formatDef(self):
            return self.getTypedRuleContext(InterlisParserPy.FormatDefContext,0)


        def domainRef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_formattedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormattedType" ):
                listener.enterFormattedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormattedType" ):
                listener.exitFormattedType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormattedType" ):
                return visitor.visitFormattedType(self)
            else:
                return visitor.visitChildren(self)




    def formattedType(self):

        localctx = InterlisParserPy.FormattedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_formattedType)
        try:
            self.state = 1158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1140
                self.match(InterlisParserPy.FORMAT)
                self.state = 1141
                self.match(InterlisParserPy.INTERLIS)
                self.state = 1142
                self.match(InterlisParserPy.DOT)
                self.state = 1143
                self.match(InterlisParserPy.Name)
                self.state = 1144
                self.match(InterlisParserPy.STRING)
                self.state = 1145
                self.match(InterlisParserPy.DOTDOT)
                self.state = 1146
                self.match(InterlisParserPy.STRING)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1147
                self.match(InterlisParserPy.FORMAT)
                self.state = 1148
                self.match(InterlisParserPy.BASED_ON)
                self.state = 1149
                self.structureRef()
                self.state = 1150
                self.formatDef()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1152
                self.match(InterlisParserPy.FORMAT)
                self.state = 1153
                self.domainRef()
                self.state = 1154
                self.match(InterlisParserPy.STRING)
                self.state = 1155
                self.match(InterlisParserPy.DOTDOT)
                self.state = 1156
                self.match(InterlisParserPy.STRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormatDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def baseAttrRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.BaseAttrRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.BaseAttrRefContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def INHERITANCE(self):
            return self.getToken(InterlisParserPy.INHERITANCE, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.STRING)
            else:
                return self.getToken(InterlisParserPy.STRING, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_formatDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormatDef" ):
                listener.enterFormatDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormatDef" ):
                listener.exitFormatDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormatDef" ):
                return visitor.visitFormatDef(self)
            else:
                return visitor.visitChildren(self)




    def formatDef(self):

        localctx = InterlisParserPy.FormatDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_formatDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1160
            self.match(InterlisParserPy.LPAR)
            self.state = 1162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==94:
                self.state = 1161
                self.match(InterlisParserPy.INHERITANCE)


            self.state = 1165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==219:
                self.state = 1164
                self.match(InterlisParserPy.STRING)


            self.state = 1172
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,153,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1167
                    self.baseAttrRef()
                    self.state = 1168
                    self.match(InterlisParserPy.STRING) 
                self.state = 1174
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,153,self._ctx)

            self.state = 1175
            self.baseAttrRef()
            self.state = 1177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==219:
                self.state = 1176
                self.match(InterlisParserPy.STRING)


            self.state = 1179
            self.match(InterlisParserPy.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseAttrRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def DIV(self):
            return self.getToken(InterlisParserPy.DIV, 0)

        def PosNumber(self):
            return self.getToken(InterlisParserPy.PosNumber, 0)

        def domainRef(self):
            return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_baseAttrRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBaseAttrRef" ):
                listener.enterBaseAttrRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBaseAttrRef" ):
                listener.exitBaseAttrRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBaseAttrRef" ):
                return visitor.visitBaseAttrRef(self)
            else:
                return visitor.visitChildren(self)




    def baseAttrRef(self):

        localctx = InterlisParserPy.BaseAttrRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_baseAttrRef)
        self._la = 0 # Token type
        try:
            self.state = 1189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1181
                self.match(InterlisParserPy.Name)
                self.state = 1184
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==62:
                    self.state = 1182
                    self.match(InterlisParserPy.DIV)
                    self.state = 1183
                    self.match(InterlisParserPy.PosNumber)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1186
                self.match(InterlisParserPy.Name)
                self.state = 1187
                self.match(InterlisParserPy.DIV)
                self.state = 1188
                self.domainRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormattedConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(InterlisParserPy.STRING, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_formattedConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormattedConst" ):
                listener.enterFormattedConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormattedConst" ):
                listener.exitFormattedConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormattedConst" ):
                return visitor.visitFormattedConst(self)
            else:
                return visitor.visitChildren(self)




    def formattedConst(self):

        localctx = InterlisParserPy.FormattedConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_formattedConst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1191
            self.match(InterlisParserPy.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateTimeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(InterlisParserPy.DATE, 0)

        def TIMEOFDAY(self):
            return self.getToken(InterlisParserPy.TIMEOFDAY, 0)

        def DATETIME(self):
            return self.getToken(InterlisParserPy.DATETIME, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_dateTimeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateTimeType" ):
                listener.enterDateTimeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateTimeType" ):
                listener.exitDateTimeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateTimeType" ):
                return visitor.visitDateTimeType(self)
            else:
                return visitor.visitChildren(self)




    def dateTimeType(self):

        localctx = InterlisParserPy.DateTimeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_dateTimeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1193
            _la = self._input.LA(1)
            if not(_la==50 or _la==51 or _la==165):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CoordinateTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COORD(self):
            return self.getToken(InterlisParserPy.COORD, 0)

        def MULTICOORD(self):
            return self.getToken(InterlisParserPy.MULTICOORD, 0)

        def numeric(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.NumericContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.NumericContext,i)


        def NUMERIC(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.NUMERIC)
            else:
                return self.getToken(InterlisParserPy.NUMERIC, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def rotationDef(self):
            return self.getTypedRuleContext(InterlisParserPy.RotationDefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_coordinateType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoordinateType" ):
                listener.enterCoordinateType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoordinateType" ):
                listener.exitCoordinateType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCoordinateType" ):
                return visitor.visitCoordinateType(self)
            else:
                return visitor.visitChildren(self)




    def coordinateType(self):

        localctx = InterlisParserPy.CoordinateTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_coordinateType)
        self._la = 0 # Token type
        try:
            self.state = 1229
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1195
                _la = self._input.LA(1)
                if not(_la==46 or _la==117):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1196
                _la = self._input.LA(1)
                if not(_la==46 or _la==117):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1199
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [211, 212, 213]:
                    self.state = 1197
                    self.numeric()
                    pass
                elif token in [125]:
                    self.state = 1198
                    self.match(InterlisParserPy.NUMERIC)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1213
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
                if la_ == 1:
                    self.state = 1201
                    self.match(InterlisParserPy.COMMA)
                    self.state = 1204
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [211, 212, 213]:
                        self.state = 1202
                        self.numeric()
                        pass
                    elif token in [125]:
                        self.state = 1203
                        self.match(InterlisParserPy.NUMERIC)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 1211
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
                    if la_ == 1:
                        self.state = 1206
                        self.match(InterlisParserPy.COMMA)
                        self.state = 1209
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [211, 212, 213]:
                            self.state = 1207
                            self.numeric()
                            pass
                        elif token in [125]:
                            self.state = 1208
                            self.match(InterlisParserPy.NUMERIC)
                            pass
                        else:
                            raise NoViableAltException(self)





                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1215
                _la = self._input.LA(1)
                if not(_la==46 or _la==117):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1216
                self.numeric()
                self.state = 1227
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
                if la_ == 1:
                    self.state = 1217
                    self.match(InterlisParserPy.COMMA)
                    self.state = 1218
                    self.numeric()
                    self.state = 1221
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
                    if la_ == 1:
                        self.state = 1219
                        self.match(InterlisParserPy.COMMA)
                        self.state = 1220
                        self.numeric()


                    self.state = 1225
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
                    if la_ == 1:
                        self.state = 1223
                        self.match(InterlisParserPy.COMMA)
                        self.state = 1224
                        self.rotationDef()




                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RotationDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROTATION(self):
            return self.getToken(InterlisParserPy.ROTATION, 0)

        def PosNumber(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.PosNumber)
            else:
                return self.getToken(InterlisParserPy.PosNumber, i)

        def MINUS(self):
            return self.getToken(InterlisParserPy.MINUS, 0)

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_rotationDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRotationDef" ):
                listener.enterRotationDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRotationDef" ):
                listener.exitRotationDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRotationDef" ):
                return visitor.visitRotationDef(self)
            else:
                return visitor.visitChildren(self)




    def rotationDef(self):

        localctx = InterlisParserPy.RotationDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_rotationDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1231
            self.match(InterlisParserPy.ROTATION)
            self.state = 1232
            self.match(InterlisParserPy.PosNumber)
            self.state = 1233
            self.match(InterlisParserPy.MINUS)
            self.state = 1234
            self.match(InterlisParserPy.GT)
            self.state = 1235
            self.match(InterlisParserPy.PosNumber)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContextDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EQ)
            else:
                return self.getToken(InterlisParserPy.EQ, i)

        def CONTEXT(self):
            return self.getToken(InterlisParserPy.CONTEXT, 0)

        def domainRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.DomainRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.DomainRefContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OR)
            else:
                return self.getToken(InterlisParserPy.OR, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_contextDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextDef" ):
                listener.enterContextDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextDef" ):
                listener.exitContextDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContextDef" ):
                return visitor.visitContextDef(self)
            else:
                return visitor.visitChildren(self)




    def contextDef(self):

        localctx = InterlisParserPy.ContextDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_contextDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 1237
                self.match(InterlisParserPy.CONTEXT)


            self.state = 1240
            self.match(InterlisParserPy.Name)
            self.state = 1241
            self.match(InterlisParserPy.EQ)
            self.state = 1254 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1242
                    self.domainRef()
                    self.state = 1243
                    self.match(InterlisParserPy.EQ)
                    self.state = 1244
                    self.domainRef()
                    self.state = 1249
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==132:
                        self.state = 1245
                        self.match(InterlisParserPy.OR)
                        self.state = 1246
                        self.domainRef()
                        self.state = 1251
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1252
                    self.match(InterlisParserPy.SEMI)

                else:
                    raise NoViableAltException(self)
                self.state = 1256 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,168,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OIDTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OID(self):
            return self.getToken(InterlisParserPy.OID, 0)

        def ANY(self):
            return self.getToken(InterlisParserPy.ANY, 0)

        def numeric(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericContext,0)


        def textType(self):
            return self.getTypedRuleContext(InterlisParserPy.TextTypeContext,0)


        def UUIDOID(self):
            return self.getToken(InterlisParserPy.UUIDOID, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_oIDType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOIDType" ):
                listener.enterOIDType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOIDType" ):
                listener.exitOIDType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOIDType" ):
                return visitor.visitOIDType(self)
            else:
                return visitor.visitChildren(self)




    def oIDType(self):

        localctx = InterlisParserPy.OIDTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_oIDType)
        try:
            self.state = 1265
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [129]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1258
                self.match(InterlisParserPy.OID)
                self.state = 1262
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [8]:
                    self.state = 1259
                    self.match(InterlisParserPy.ANY)
                    pass
                elif token in [211, 212, 213]:
                    self.state = 1260
                    self.numeric()
                    pass
                elif token in [113, 120, 158, 178]:
                    self.state = 1261
                    self.textType()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [179]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1264
                self.match(InterlisParserPy.UUIDOID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlackboxTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLACKBOX(self):
            return self.getToken(InterlisParserPy.BLACKBOX, 0)

        def XML(self):
            return self.getToken(InterlisParserPy.XML, 0)

        def BINARY(self):
            return self.getToken(InterlisParserPy.BINARY, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_blackboxType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlackboxType" ):
                listener.enterBlackboxType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlackboxType" ):
                listener.exitBlackboxType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlackboxType" ):
                return visitor.visitBlackboxType(self)
            else:
                return visitor.visitChildren(self)




    def blackboxType(self):

        localctx = InterlisParserPy.BlackboxTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_blackboxType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1267
            self.match(InterlisParserPy.BLACKBOX)
            self.state = 1268
            _la = self._input.LA(1)
            if not(_la==27 or _la==189):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(InterlisParserPy.CLASS, 0)

        def RESTRICTION(self):
            return self.getToken(InterlisParserPy.RESTRICTION, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def viewableRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ViewableRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def STRUCTURE(self):
            return self.getToken(InterlisParserPy.STRUCTURE, 0)

        def classOrStructureRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ClassOrStructureRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ClassOrStructureRefContext,i)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_classType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassType" ):
                listener.enterClassType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassType" ):
                listener.exitClassType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassType" ):
                return visitor.visitClassType(self)
            else:
                return visitor.visitChildren(self)




    def classType(self):

        localctx = InterlisParserPy.ClassTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_classType)
        self._la = 0 # Token type
        try:
            self.state = 1300
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [35]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1270
                self.match(InterlisParserPy.CLASS)
                self.state = 1283
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
                if la_ == 1:
                    self.state = 1271
                    self.match(InterlisParserPy.RESTRICTION)
                    self.state = 1272
                    self.match(InterlisParserPy.LPAR)
                    self.state = 1273
                    self.viewableRef()
                    self.state = 1278
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==196:
                        self.state = 1274
                        self.match(InterlisParserPy.COMMA)
                        self.state = 1275
                        self.viewableRef()
                        self.state = 1280
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1281
                    self.match(InterlisParserPy.RPAR)


                pass
            elif token in [153]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1285
                self.match(InterlisParserPy.STRUCTURE)
                self.state = 1298
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
                if la_ == 1:
                    self.state = 1286
                    self.match(InterlisParserPy.RESTRICTION)
                    self.state = 1287
                    self.match(InterlisParserPy.LPAR)
                    self.state = 1288
                    self.classOrStructureRef()
                    self.state = 1293
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==196:
                        self.state = 1289
                        self.match(InterlisParserPy.COMMA)
                        self.state = 1290
                        self.classOrStructureRef()
                        self.state = 1295
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1296
                    self.match(InterlisParserPy.RPAR)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTRIBUTE(self):
            return self.getToken(InterlisParserPy.ATTRIBUTE, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def RESTRICTION(self):
            return self.getToken(InterlisParserPy.RESTRICTION, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def attrTypeDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.AttrTypeDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def classType(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassTypeContext,0)


        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def attributePath(self):
            return self.getTypedRuleContext(InterlisParserPy.AttributePathContext,0)


        def AT_SYMBOL(self):
            return self.getToken(InterlisParserPy.AT_SYMBOL, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_attributeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeType" ):
                listener.enterAttributeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeType" ):
                listener.exitAttributeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeType" ):
                return visitor.visitAttributeType(self)
            else:
                return visitor.visitChildren(self)




    def attributeType(self):

        localctx = InterlisParserPy.AttributeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_attributeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1302
            self.match(InterlisParserPy.ATTRIBUTE)
            self.state = 1312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==128:
                self.state = 1303
                self.match(InterlisParserPy.OF)
                self.state = 1310
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [35, 153]:
                    self.state = 1304
                    self.classType()
                    self.state = 1305
                    self.match(InterlisParserPy.DOT)
                    self.state = 1306
                    self.attributePath()
                    pass
                elif token in [18]:
                    self.state = 1308
                    self.match(InterlisParserPy.AT_SYMBOL)
                    self.state = 1309
                    self.match(InterlisParserPy.Name)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 1326
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                self.state = 1314
                self.match(InterlisParserPy.RESTRICTION)
                self.state = 1315
                self.match(InterlisParserPy.LPAR)
                self.state = 1316
                self.attrTypeDef()
                self.state = 1321
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 1317
                    self.match(InterlisParserPy.COMMA)
                    self.state = 1318
                    self.attrTypeDef()
                    self.state = 1323
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1324
                self.match(InterlisParserPy.RPAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_classConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassConst" ):
                listener.enterClassConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassConst" ):
                listener.exitClassConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassConst" ):
                return visitor.visitClassConst(self)
            else:
                return visitor.visitChildren(self)




    def classConst(self):

        localctx = InterlisParserPy.ClassConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_classConst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1328
            self.match(InterlisParserPy.GT)
            self.state = 1329
            self.viewableRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributePathConstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.GT)
            else:
                return self.getToken(InterlisParserPy.GT, i)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_attributePathConst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributePathConst" ):
                listener.enterAttributePathConst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributePathConst" ):
                listener.exitAttributePathConst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributePathConst" ):
                return visitor.visitAttributePathConst(self)
            else:
                return visitor.visitChildren(self)




    def attributePathConst(self):

        localctx = InterlisParserPy.AttributePathConstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_attributePathConst)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1331
            self.match(InterlisParserPy.GT)
            self.state = 1332
            self.match(InterlisParserPy.GT)
            self.state = 1336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.state = 1333
                self.viewableRef()
                self.state = 1334
                self.match(InterlisParserPy.DOT)


            self.state = 1338
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POLYLINE(self):
            return self.getToken(InterlisParserPy.POLYLINE, 0)

        def SURFACE(self):
            return self.getToken(InterlisParserPy.SURFACE, 0)

        def AREA(self):
            return self.getToken(InterlisParserPy.AREA, 0)

        def MULTIPOLYLINE(self):
            return self.getToken(InterlisParserPy.MULTIPOLYLINE, 0)

        def MULTISURFACE(self):
            return self.getToken(InterlisParserPy.MULTISURFACE, 0)

        def MULTIAREA(self):
            return self.getToken(InterlisParserPy.MULTIAREA, 0)

        def lineForm(self):
            return self.getTypedRuleContext(InterlisParserPy.LineFormContext,0)


        def controlPoints(self):
            return self.getTypedRuleContext(InterlisParserPy.ControlPointsContext,0)


        def intersectionDef(self):
            return self.getTypedRuleContext(InterlisParserPy.IntersectionDefContext,0)


        def LINE(self):
            return self.getToken(InterlisParserPy.LINE, 0)

        def ATTRIBUTES(self):
            return self.getToken(InterlisParserPy.ATTRIBUTES, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def DIRECTED(self):
            return self.getToken(InterlisParserPy.DIRECTED, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_lineType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineType" ):
                listener.enterLineType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineType" ):
                listener.exitLineType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineType" ):
                return visitor.visitLineType(self)
            else:
                return visitor.visitChildren(self)




    def lineType(self):

        localctx = InterlisParserPy.LineTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_lineType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1352
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                self.state = 1341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==61:
                    self.state = 1340
                    self.match(InterlisParserPy.DIRECTED)


                self.state = 1343
                self.match(InterlisParserPy.POLYLINE)
                pass

            elif la_ == 2:
                self.state = 1344
                self.match(InterlisParserPy.SURFACE)
                pass

            elif la_ == 3:
                self.state = 1345
                self.match(InterlisParserPy.AREA)
                pass

            elif la_ == 4:
                self.state = 1347
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==61:
                    self.state = 1346
                    self.match(InterlisParserPy.DIRECTED)


                self.state = 1349
                self.match(InterlisParserPy.MULTIPOLYLINE)
                pass

            elif la_ == 5:
                self.state = 1350
                self.match(InterlisParserPy.MULTISURFACE)
                pass

            elif la_ == 6:
                self.state = 1351
                self.match(InterlisParserPy.MULTIAREA)
                pass


            self.state = 1355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==187:
                self.state = 1354
                self.lineForm()


            self.state = 1358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==182:
                self.state = 1357
                self.controlPoints()


            self.state = 1361
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==188:
                self.state = 1360
                self.intersectionDef()


            self.state = 1366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==103:
                self.state = 1363
                self.match(InterlisParserPy.LINE)
                self.state = 1364
                self.match(InterlisParserPy.ATTRIBUTES)
                self.state = 1365
                self.match(InterlisParserPy.Name)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineFormContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(InterlisParserPy.WITH, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def lineFormType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.LineFormTypeContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.LineFormTypeContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_lineForm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineForm" ):
                listener.enterLineForm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineForm" ):
                listener.exitLineForm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineForm" ):
                return visitor.visitLineForm(self)
            else:
                return visitor.visitChildren(self)




    def lineForm(self):

        localctx = InterlisParserPy.LineFormContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_lineForm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1368
            self.match(InterlisParserPy.WITH)
            self.state = 1369
            self.match(InterlisParserPy.LPAR)
            self.state = 1370
            self.lineFormType()
            self.state = 1375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 1371
                self.match(InterlisParserPy.COMMA)
                self.state = 1372
                self.lineFormType()
                self.state = 1377
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1378
            self.match(InterlisParserPy.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineFormTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRAIGHTS(self):
            return self.getToken(InterlisParserPy.STRAIGHTS, 0)

        def ARCS(self):
            return self.getToken(InterlisParserPy.ARCS, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_lineFormType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineFormType" ):
                listener.enterLineFormType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineFormType" ):
                listener.exitLineFormType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineFormType" ):
                return visitor.visitLineFormType(self)
            else:
                return visitor.visitChildren(self)




    def lineFormType(self):

        localctx = InterlisParserPy.LineFormTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_lineFormType)
        try:
            self.state = 1385
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [152]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1380
                self.match(InterlisParserPy.STRAIGHTS)
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1381
                self.match(InterlisParserPy.ARCS)
                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1382
                self.match(InterlisParserPy.Name)
                self.state = 1383
                self.match(InterlisParserPy.DOT)
                self.state = 1384
                self.match(InterlisParserPy.Name)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ControlPointsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERTEX(self):
            return self.getToken(InterlisParserPy.VERTEX, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_controlPoints

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControlPoints" ):
                listener.enterControlPoints(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControlPoints" ):
                listener.exitControlPoints(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitControlPoints" ):
                return visitor.visitControlPoints(self)
            else:
                return visitor.visitChildren(self)




    def controlPoints(self):

        localctx = InterlisParserPy.ControlPointsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_controlPoints)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1387
            self.match(InterlisParserPy.VERTEX)
            self.state = 1388
            self.match(InterlisParserPy.Name)
            self.state = 1393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==203:
                self.state = 1389
                self.match(InterlisParserPy.DOT)
                self.state = 1390
                self.match(InterlisParserPy.Name)
                self.state = 1395
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntersectionDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITHOUT(self):
            return self.getToken(InterlisParserPy.WITHOUT, 0)

        def OVERLAPS(self):
            return self.getToken(InterlisParserPy.OVERLAPS, 0)

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def Dec(self):
            return self.getToken(InterlisParserPy.Dec, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_intersectionDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersectionDef" ):
                listener.enterIntersectionDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersectionDef" ):
                listener.exitIntersectionDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntersectionDef" ):
                return visitor.visitIntersectionDef(self)
            else:
                return visitor.visitChildren(self)




    def intersectionDef(self):

        localctx = InterlisParserPy.IntersectionDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_intersectionDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1396
            self.match(InterlisParserPy.WITHOUT)
            self.state = 1397
            self.match(InterlisParserPy.OVERLAPS)
            self.state = 1398
            self.match(InterlisParserPy.GT)
            self.state = 1399
            self.match(InterlisParserPy.Dec)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineFormTypeDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINE(self):
            return self.getToken(InterlisParserPy.LINE, 0)

        def FORM(self):
            return self.getToken(InterlisParserPy.FORM, 0)

        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_lineFormTypeDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineFormTypeDef" ):
                listener.enterLineFormTypeDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineFormTypeDef" ):
                listener.exitLineFormTypeDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineFormTypeDef" ):
                return visitor.visitLineFormTypeDef(self)
            else:
                return visitor.visitChildren(self)




    def lineFormTypeDef(self):

        localctx = InterlisParserPy.LineFormTypeDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_lineFormTypeDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1401
            self.match(InterlisParserPy.LINE)
            self.state = 1402
            self.match(InterlisParserPy.FORM)
            self.state = 1403
            self.match(InterlisParserPy.LCBR)
            self.state = 1404
            self.match(InterlisParserPy.Name)
            self.state = 1405
            self.match(InterlisParserPy.COLON)
            self.state = 1406
            self.match(InterlisParserPy.Name)
            self.state = 1407
            self.match(InterlisParserPy.SEMI)
            self.state = 1408
            self.match(InterlisParserPy.RCBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def UNIT(self):
            return self.getToken(InterlisParserPy.UNIT, 0)

        def LSBR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.LSBR)
            else:
                return self.getToken(InterlisParserPy.LSBR, i)

        def RSBR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.RSBR)
            else:
                return self.getToken(InterlisParserPy.RSBR, i)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def unitRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.UnitRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,i)


        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def composedUnit(self):
            return self.getTypedRuleContext(InterlisParserPy.ComposedUnitContext,0)


        def functionDef(self):
            return self.getTypedRuleContext(InterlisParserPy.FunctionDefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_unitDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitDef" ):
                listener.enterUnitDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitDef" ):
                listener.exitUnitDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitDef" ):
                return visitor.visitUnitDef(self)
            else:
                return visitor.visitChildren(self)




    def unitDef(self):

        localctx = InterlisParserPy.UnitDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_unitDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1411
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==176:
                self.state = 1410
                self.match(InterlisParserPy.UNIT)


            self.state = 1413
            self.match(InterlisParserPy.Name)
            self.state = 1417
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==209:
                self.state = 1414
                self.match(InterlisParserPy.LSBR)
                self.state = 1415
                self.match(InterlisParserPy.Name)
                self.state = 1416
                self.match(InterlisParserPy.RSBR)


            self.state = 1422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 1419
                self.match(InterlisParserPy.LPAR)
                self.state = 1420
                self.match(InterlisParserPy.ABSTRACT)
                self.state = 1421
                self.match(InterlisParserPy.RPAR)


            self.state = 1426
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 1424
                self.match(InterlisParserPy.EXTENDS)
                self.state = 1425
                self.unitRef()


            self.state = 1428
            self.match(InterlisParserPy.EQ)
            self.state = 1442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
            if la_ == 1:
                self.state = 1429
                self.expression()
                self.state = 1434
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 1430
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1431
                    self.unitRef()
                    self.state = 1432
                    self.match(InterlisParserPy.RSBR)



            elif la_ == 2:
                self.state = 1436
                self.composedUnit()

            elif la_ == 3:
                self.state = 1437
                self.functionDef()

            elif la_ == 4:
                self.state = 1438
                self.match(InterlisParserPy.LSBR)
                self.state = 1439
                self.unitRef()
                self.state = 1440
                self.match(InterlisParserPy.RSBR)


            self.state = 1444
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DerivedUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decConst(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.DecConstContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.DecConstContext,i)


        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def unitRef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,0)


        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def MUL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MUL)
            else:
                return self.getToken(InterlisParserPy.MUL, i)

        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DIV)
            else:
                return self.getToken(InterlisParserPy.DIV, i)

        def POW(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.POW)
            else:
                return self.getToken(InterlisParserPy.POW, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_derivedUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDerivedUnit" ):
                listener.enterDerivedUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDerivedUnit" ):
                listener.exitDerivedUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDerivedUnit" ):
                return visitor.visitDerivedUnit(self)
            else:
                return visitor.visitChildren(self)




    def derivedUnit(self):

        localctx = InterlisParserPy.DerivedUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_derivedUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1446
            self.decConst()
            self.state = 1451
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 13510798882111489) != 0):
                self.state = 1447
                _la = self._input.LA(1)
                if not(((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 13510798882111489) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1448
                self.decConst()
                self.state = 1453
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1454
            self.match(InterlisParserPy.LSBR)
            self.state = 1455
            self.unitRef()
            self.state = 1456
            self.match(InterlisParserPy.RSBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComposedUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def unitRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.UnitRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,i)


        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def INTERLIS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.INTERLIS)
            else:
                return self.getToken(InterlisParserPy.INTERLIS, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def MUL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MUL)
            else:
                return self.getToken(InterlisParserPy.MUL, i)

        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DIV)
            else:
                return self.getToken(InterlisParserPy.DIV, i)

        def POW(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.POW)
            else:
                return self.getToken(InterlisParserPy.POW, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_composedUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposedUnit" ):
                listener.enterComposedUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposedUnit" ):
                listener.exitComposedUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComposedUnit" ):
                return visitor.visitComposedUnit(self)
            else:
                return visitor.visitChildren(self)




    def composedUnit(self):

        localctx = InterlisParserPy.ComposedUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_composedUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1458
            self.match(InterlisParserPy.LPAR)
            self.state = 1464
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
            if la_ == 1:
                self.state = 1459
                self.unitRef()
                pass

            elif la_ == 2:
                self.state = 1460
                self.match(InterlisParserPy.Name)
                pass

            elif la_ == 3:
                self.state = 1461
                self.match(InterlisParserPy.INTERLIS)
                self.state = 1462
                self.match(InterlisParserPy.DOT)
                self.state = 1463
                self.match(InterlisParserPy.Name)
                pass


            self.state = 1476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 13510798882111489) != 0):
                self.state = 1466
                _la = self._input.LA(1)
                if not(((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & 13510798882111489) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1472
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
                if la_ == 1:
                    self.state = 1467
                    self.unitRef()
                    pass

                elif la_ == 2:
                    self.state = 1468
                    self.match(InterlisParserPy.INTERLIS)
                    self.state = 1469
                    self.match(InterlisParserPy.DOT)
                    self.state = 1470
                    self.match(InterlisParserPy.Name)
                    pass

                elif la_ == 3:
                    self.state = 1471
                    self.match(InterlisParserPy.Name)
                    pass


                self.state = 1478
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1479
            self.match(InterlisParserPy.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_unitRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitRef" ):
                listener.enterUnitRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitRef" ):
                listener.exitUnitRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitRef" ):
                return visitor.visitUnitRef(self)
            else:
                return visitor.visitChildren(self)




    def unitRef(self):

        localctx = InterlisParserPy.UnitRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_unitRef)
        self._la = 0 # Token type
        try:
            self.state = 1492
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [215]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1481
                self.match(InterlisParserPy.Name)
                self.state = 1486
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==203:
                    self.state = 1482
                    self.match(InterlisParserPy.DOT)
                    self.state = 1483
                    self.match(InterlisParserPy.Name)
                    self.state = 1488
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1489
                self.match(InterlisParserPy.INTERLIS)
                self.state = 1490
                self.match(InterlisParserPy.DOT)
                self.state = 1491
                self.match(InterlisParserPy.Name)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaDataBasketDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def TILDE(self):
            return self.getToken(InterlisParserPy.TILDE, 0)

        def topicRef(self):
            return self.getTypedRuleContext(InterlisParserPy.TopicRefContext,0)


        def SIGN(self):
            return self.getToken(InterlisParserPy.SIGN, 0)

        def REFSYSTEM(self):
            return self.getToken(InterlisParserPy.REFSYSTEM, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def metaDataBasketRef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaDataBasketRefContext,0)


        def OBJECTS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OBJECTS)
            else:
                return self.getToken(InterlisParserPy.OBJECTS, i)

        def OF(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OF)
            else:
                return self.getToken(InterlisParserPy.OF, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COLON)
            else:
                return self.getToken(InterlisParserPy.COLON, i)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_metaDataBasketDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaDataBasketDef" ):
                listener.enterMetaDataBasketDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaDataBasketDef" ):
                listener.exitMetaDataBasketDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaDataBasketDef" ):
                return visitor.visitMetaDataBasketDef(self)
            else:
                return visitor.visitChildren(self)




    def metaDataBasketDef(self):

        localctx = InterlisParserPy.MetaDataBasketDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_metaDataBasketDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1494
            _la = self._input.LA(1)
            if not(_la==146 or _la==151):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1495
            self.match(InterlisParserPy.BASKET)
            self.state = 1496
            self.match(InterlisParserPy.Name)
            self.state = 1498
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==73:
                self.state = 1497
                self.match(InterlisParserPy.FINAL)


            self.state = 1502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 1500
                self.match(InterlisParserPy.EXTENDS)
                self.state = 1501
                self.metaDataBasketRef()


            self.state = 1504
            self.match(InterlisParserPy.TILDE)
            self.state = 1505
            self.topicRef()
            self.state = 1521 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1506
                self.match(InterlisParserPy.OBJECTS)
                self.state = 1507
                self.match(InterlisParserPy.OF)
                self.state = 1508
                self.match(InterlisParserPy.Name)
                self.state = 1509
                self.match(InterlisParserPy.COLON)

                self.state = 1510
                self.match(InterlisParserPy.Name)
                self.state = 1515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 1511
                    self.match(InterlisParserPy.COMMA)
                    self.state = 1512
                    self.match(InterlisParserPy.Name)
                    self.state = 1517
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1519
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
                if la_ == 1:
                    self.state = 1518
                    self.match(InterlisParserPy.SEMI)


                self.state = 1523 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==127):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaDataBasketRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_metaDataBasketRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaDataBasketRef" ):
                listener.enterMetaDataBasketRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaDataBasketRef" ):
                listener.exitMetaDataBasketRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaDataBasketRef" ):
                return visitor.visitMetaDataBasketRef(self)
            else:
                return visitor.visitChildren(self)




    def metaDataBasketRef(self):

        localctx = InterlisParserPy.MetaDataBasketRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_metaDataBasketRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1531
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
            if la_ == 1:
                self.state = 1525
                self.match(InterlisParserPy.Name)
                self.state = 1526
                self.match(InterlisParserPy.DOT)
                self.state = 1529
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
                if la_ == 1:
                    self.state = 1527
                    self.match(InterlisParserPy.Name)
                    self.state = 1528
                    self.match(InterlisParserPy.DOT)




            self.state = 1533
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaObjectRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def metaDataBasketRef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaDataBasketRefContext,0)


        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_metaObjectRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaObjectRef" ):
                listener.enterMetaObjectRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaObjectRef" ):
                listener.exitMetaObjectRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaObjectRef" ):
                return visitor.visitMetaObjectRef(self)
            else:
                return visitor.visitChildren(self)




    def metaObjectRef(self):

        localctx = InterlisParserPy.MetaObjectRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_metaObjectRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1538
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                self.state = 1535
                self.metaDataBasketRef()
                self.state = 1536
                self.match(InterlisParserPy.DOT)


            self.state = 1540
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(InterlisParserPy.PARAMETER, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def attrTypeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,0)


        def METAOBJECT(self):
            return self.getToken(InterlisParserPy.METAOBJECT, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def metaObjectRef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaObjectRefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_parameterDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDef" ):
                listener.enterParameterDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDef" ):
                listener.exitParameterDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDef" ):
                return visitor.visitParameterDef(self)
            else:
                return visitor.visitChildren(self)




    def parameterDef(self):

        localctx = InterlisParserPy.ParameterDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_parameterDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1542
            self.match(InterlisParserPy.PARAMETER)
            self.state = 1543
            self.match(InterlisParserPy.Name)
            self.state = 1547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 1544
                self.match(InterlisParserPy.LPAR)
                self.state = 1545
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1546
                self.match(InterlisParserPy.RPAR)


            self.state = 1549
            self.match(InterlisParserPy.COLON)
            self.state = 1556
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6, 10, 13, 19, 22, 28, 30, 35, 46, 50, 51, 61, 65, 78, 86, 97, 106, 109, 113, 116, 117, 118, 119, 120, 125, 129, 140, 144, 153, 155, 158, 165, 178, 179, 180, 194, 211, 212, 213, 215, 219]:
                self.state = 1550
                self.attrTypeDef()
                pass
            elif token in [110]:
                self.state = 1551
                self.match(InterlisParserPy.METAOBJECT)
                self.state = 1554
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==128:
                    self.state = 1552
                    self.match(InterlisParserPy.OF)
                    self.state = 1553
                    self.metaObjectRef()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 1558
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RunTimeParameterDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(InterlisParserPy.PARAMETER, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def attrTypeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_runTimeParameterDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRunTimeParameterDef" ):
                listener.enterRunTimeParameterDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRunTimeParameterDef" ):
                listener.exitRunTimeParameterDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRunTimeParameterDef" ):
                return visitor.visitRunTimeParameterDef(self)
            else:
                return visitor.visitChildren(self)




    def runTimeParameterDef(self):

        localctx = InterlisParserPy.RunTimeParameterDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_runTimeParameterDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1560
            self.match(InterlisParserPy.PARAMETER)
            self.state = 1561
            self.match(InterlisParserPy.Name)
            self.state = 1563
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==70 or _la==73:
                self.state = 1562
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1565
            self.match(InterlisParserPy.COLON)
            self.state = 1566
            self.attrTypeDef()
            self.state = 1567
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mandatoryConstraint(self):
            return self.getTypedRuleContext(InterlisParserPy.MandatoryConstraintContext,0)


        def plausibilityConstraint(self):
            return self.getTypedRuleContext(InterlisParserPy.PlausibilityConstraintContext,0)


        def existenceConstraint(self):
            return self.getTypedRuleContext(InterlisParserPy.ExistenceConstraintContext,0)


        def uniquenessConstraint(self):
            return self.getTypedRuleContext(InterlisParserPy.UniquenessConstraintContext,0)


        def setConstraint(self):
            return self.getTypedRuleContext(InterlisParserPy.SetConstraintContext,0)


        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_constraintDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintDef" ):
                listener.enterConstraintDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintDef" ):
                listener.exitConstraintDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintDef" ):
                return visitor.visitConstraintDef(self)
            else:
                return visitor.visitChildren(self)




    def constraintDef(self):

        localctx = InterlisParserPy.ConstraintDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_constraintDef)
        try:
            self.state = 1577
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [109]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1569
                self.mandatoryConstraint()
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1570
                self.plausibilityConstraint()
                pass
            elif token in [69]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1571
                self.existenceConstraint()
                pass
            elif token in [175]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1572
                self.uniquenessConstraint()
                pass
            elif token in [150]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1573
                self.setConstraint()
                pass
            elif token in [3, 6, 13, 21, 54, 87, 95, 96, 97, 107, 123, 136, 137, 139, 159, 160, 161, 172, 194, 201, 211, 212, 213, 215, 219]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1574
                self.expression()
                self.state = 1575
                self.match(InterlisParserPy.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MandatoryConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MANDATORY(self):
            return self.getToken(InterlisParserPy.MANDATORY, 0)

        def CONSTRAINT(self):
            return self.getToken(InterlisParserPy.CONSTRAINT, 0)

        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_mandatoryConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMandatoryConstraint" ):
                listener.enterMandatoryConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMandatoryConstraint" ):
                listener.exitMandatoryConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMandatoryConstraint" ):
                return visitor.visitMandatoryConstraint(self)
            else:
                return visitor.visitChildren(self)




    def mandatoryConstraint(self):

        localctx = InterlisParserPy.MandatoryConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_mandatoryConstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1579
            self.match(InterlisParserPy.MANDATORY)
            self.state = 1580
            self.match(InterlisParserPy.CONSTRAINT)
            self.state = 1583
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
            if la_ == 1:
                self.state = 1581
                self.match(InterlisParserPy.Name)
                self.state = 1582
                self.match(InterlisParserPy.COLON)


            self.state = 1585
            self.expression()
            self.state = 1586
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlausibilityConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRAINT(self):
            return self.getToken(InterlisParserPy.CONSTRAINT, 0)

        def numericConst(self):
            return self.getTypedRuleContext(InterlisParserPy.NumericConstContext,0)


        def MOD(self):
            return self.getToken(InterlisParserPy.MOD, 0)

        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def LTEQ(self):
            return self.getToken(InterlisParserPy.LTEQ, 0)

        def GTEQ(self):
            return self.getToken(InterlisParserPy.GTEQ, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_plausibilityConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlausibilityConstraint" ):
                listener.enterPlausibilityConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlausibilityConstraint" ):
                listener.exitPlausibilityConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlausibilityConstraint" ):
                return visitor.visitPlausibilityConstraint(self)
            else:
                return visitor.visitChildren(self)




    def plausibilityConstraint(self):

        localctx = InterlisParserPy.PlausibilityConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_plausibilityConstraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1588
            self.match(InterlisParserPy.CONSTRAINT)
            self.state = 1591
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==215:
                self.state = 1589
                self.match(InterlisParserPy.Name)
                self.state = 1590
                self.match(InterlisParserPy.COLON)


            self.state = 1593
            _la = self._input.LA(1)
            if not(_la==200 or _la==202):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1594
            self.numericConst()
            self.state = 1595
            self.match(InterlisParserPy.MOD)
            self.state = 1596
            self.expression()
            self.state = 1597
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExistenceConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXISTENCE(self):
            return self.getToken(InterlisParserPy.EXISTENCE, 0)

        def CONSTRAINT(self):
            return self.getToken(InterlisParserPy.CONSTRAINT, 0)

        def attributePath(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.AttributePathContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.AttributePathContext,i)


        def REQUIRED(self):
            return self.getToken(InterlisParserPy.REQUIRED, 0)

        def IN(self):
            return self.getToken(InterlisParserPy.IN, 0)

        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COLON)
            else:
                return self.getToken(InterlisParserPy.COLON, i)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_existenceConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExistenceConstraint" ):
                listener.enterExistenceConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExistenceConstraint" ):
                listener.exitExistenceConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExistenceConstraint" ):
                return visitor.visitExistenceConstraint(self)
            else:
                return visitor.visitChildren(self)




    def existenceConstraint(self):

        localctx = InterlisParserPy.ExistenceConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_existenceConstraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1599
            self.match(InterlisParserPy.EXISTENCE)
            self.state = 1600
            self.match(InterlisParserPy.CONSTRAINT)
            self.state = 1603
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,218,self._ctx)
            if la_ == 1:
                self.state = 1601
                self.match(InterlisParserPy.Name)
                self.state = 1602
                self.match(InterlisParserPy.COLON)


            self.state = 1605
            self.attributePath()
            self.state = 1606
            self.match(InterlisParserPy.REQUIRED)
            self.state = 1607
            self.match(InterlisParserPy.IN)
            self.state = 1608
            self.viewableRef()
            self.state = 1609
            self.match(InterlisParserPy.COLON)
            self.state = 1610
            self.attributePath()
            self.state = 1611
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniquenessConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIQUE(self):
            return self.getToken(InterlisParserPy.UNIQUE, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COLON)
            else:
                return self.getToken(InterlisParserPy.COLON, i)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def globalUniqueness(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.GlobalUniquenessContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.GlobalUniquenessContext,i)


        def localUniqueness(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.LocalUniquenessContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.LocalUniquenessContext,i)


        def LOCAL(self):
            return self.getToken(InterlisParserPy.LOCAL, 0)

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_uniquenessConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniquenessConstraint" ):
                listener.enterUniquenessConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniquenessConstraint" ):
                listener.exitUniquenessConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniquenessConstraint" ):
                return visitor.visitUniquenessConstraint(self)
            else:
                return visitor.visitChildren(self)




    def uniquenessConstraint(self):

        localctx = InterlisParserPy.UniquenessConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_uniquenessConstraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1613
            self.match(InterlisParserPy.UNIQUE)
            self.state = 1616
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,219,self._ctx)
            if la_ == 1:
                self.state = 1614
                self.match(InterlisParserPy.Name)
                self.state = 1615
                self.match(InterlisParserPy.COLON)


            self.state = 1621
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 1618
                self.match(InterlisParserPy.LPAR)
                self.state = 1619
                _la = self._input.LA(1)
                if not(_la==26 or _la==108):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1620
                self.match(InterlisParserPy.RPAR)


            self.state = 1625
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,221,self._ctx)
            if la_ == 1:
                self.state = 1623
                self.match(InterlisParserPy.Name)
                self.state = 1624
                self.match(InterlisParserPy.COLON)


            self.state = 1629 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1629
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 21, 137, 159, 160, 161, 215]:
                    self.state = 1627
                    self.globalUniqueness()
                    pass
                elif token in [175]:
                    self.state = 1628
                    self.localUniqueness()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1631 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==3 or _la==21 or ((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & 274907267073) != 0) or _la==215):
                    break

            self.state = 1633
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GlobalUniquenessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uniqueEl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.UniqueElContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.UniqueElContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_globalUniqueness

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGlobalUniqueness" ):
                listener.enterGlobalUniqueness(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGlobalUniqueness" ):
                listener.exitGlobalUniqueness(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGlobalUniqueness" ):
                return visitor.visitGlobalUniqueness(self)
            else:
                return visitor.visitChildren(self)




    def globalUniqueness(self):

        localctx = InterlisParserPy.GlobalUniquenessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_globalUniqueness)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1635
            self.uniqueEl()
            self.state = 1640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 1636
                self.match(InterlisParserPy.COMMA)
                self.state = 1637
                self.uniqueEl()
                self.state = 1642
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniqueElContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectOrAttributePath(self):
            return self.getTypedRuleContext(InterlisParserPy.ObjectOrAttributePathContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_uniqueEl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniqueEl" ):
                listener.enterUniqueEl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniqueEl" ):
                listener.exitUniqueEl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniqueEl" ):
                return visitor.visitUniqueEl(self)
            else:
                return visitor.visitChildren(self)




    def uniqueEl(self):

        localctx = InterlisParserPy.UniqueElContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_uniqueEl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1643
            self.objectOrAttributePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalUniquenessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIQUE(self):
            return self.getToken(InterlisParserPy.UNIQUE, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COLON)
            else:
                return self.getToken(InterlisParserPy.COLON, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MINUS)
            else:
                return self.getToken(InterlisParserPy.MINUS, i)

        def GT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.GT)
            else:
                return self.getToken(InterlisParserPy.GT, i)

        def LOCAL(self):
            return self.getToken(InterlisParserPy.LOCAL, 0)

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_localUniqueness

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalUniqueness" ):
                listener.enterLocalUniqueness(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalUniqueness" ):
                listener.exitLocalUniqueness(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocalUniqueness" ):
                return visitor.visitLocalUniqueness(self)
            else:
                return visitor.visitChildren(self)




    def localUniqueness(self):

        localctx = InterlisParserPy.LocalUniquenessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_localUniqueness)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1645
            self.match(InterlisParserPy.UNIQUE)
            self.state = 1649
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==194:
                self.state = 1646
                self.match(InterlisParserPy.LPAR)
                self.state = 1647
                _la = self._input.LA(1)
                if not(_la==26 or _la==108):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1648
                self.match(InterlisParserPy.RPAR)


            self.state = 1653
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,226,self._ctx)
            if la_ == 1:
                self.state = 1651
                self.match(InterlisParserPy.Name)
                self.state = 1652
                self.match(InterlisParserPy.COLON)


            self.state = 1655
            self.match(InterlisParserPy.Name)
            self.state = 1661
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==205:
                self.state = 1656
                self.match(InterlisParserPy.MINUS)
                self.state = 1657
                self.match(InterlisParserPy.GT)
                self.state = 1658
                self.match(InterlisParserPy.Name)
                self.state = 1663
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1673
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==197:
                self.state = 1664
                self.match(InterlisParserPy.COLON)
                self.state = 1665
                self.match(InterlisParserPy.Name)
                self.state = 1670
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 1666
                    self.match(InterlisParserPy.COMMA)
                    self.state = 1667
                    self.match(InterlisParserPy.Name)
                    self.state = 1672
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1675
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(InterlisParserPy.SET, 0)

        def CONSTRAINT(self):
            return self.getToken(InterlisParserPy.CONSTRAINT, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COLON)
            else:
                return self.getToken(InterlisParserPy.COLON, i)

        def WHERE(self):
            return self.getToken(InterlisParserPy.WHERE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ExpressionContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,i)


        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def LOCAL(self):
            return self.getToken(InterlisParserPy.LOCAL, 0)

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_setConstraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetConstraint" ):
                listener.enterSetConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetConstraint" ):
                listener.exitSetConstraint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetConstraint" ):
                return visitor.visitSetConstraint(self)
            else:
                return visitor.visitChildren(self)




    def setConstraint(self):

        localctx = InterlisParserPy.SetConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_setConstraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1677
            self.match(InterlisParserPy.SET)
            self.state = 1678
            self.match(InterlisParserPy.CONSTRAINT)
            self.state = 1682
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                self.state = 1679
                self.match(InterlisParserPy.LPAR)
                self.state = 1680
                _la = self._input.LA(1)
                if not(_la==26 or _la==108):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1681
                self.match(InterlisParserPy.RPAR)


            self.state = 1704
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
            if la_ == 1:
                self.state = 1684
                self.match(InterlisParserPy.Name)
                self.state = 1685
                self.match(InterlisParserPy.COLON)
                self.state = 1686
                self.match(InterlisParserPy.WHERE)
                self.state = 1687
                self.expression()
                self.state = 1688
                self.match(InterlisParserPy.COLON)
                self.state = 1689
                self.expression()
                pass

            elif la_ == 2:
                self.state = 1695
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==186:
                    self.state = 1691
                    self.match(InterlisParserPy.WHERE)
                    self.state = 1692
                    self.expression()
                    self.state = 1693
                    self.match(InterlisParserPy.COLON)


                self.state = 1701
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,232,self._ctx)
                if la_ == 1:
                    self.state = 1697
                    self.match(InterlisParserPy.Name)
                    self.state = 1698
                    self.match(InterlisParserPy.COLON)

                elif la_ == 2:
                    self.state = 1699
                    self.match(InterlisParserPy.INTERLIS)
                    self.state = 1700
                    self.match(InterlisParserPy.COLON)


                self.state = 1703
                self.expression()
                pass


            self.state = 1706
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintsDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRAINTS(self):
            return self.getToken(InterlisParserPy.CONSTRAINTS, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def classOrAssociationRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassOrAssociationRefContext,0)


        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def constraintDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ConstraintDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ConstraintDefContext,i)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_constraintsDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraintsDef" ):
                listener.enterConstraintsDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraintsDef" ):
                listener.exitConstraintsDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstraintsDef" ):
                return visitor.visitConstraintsDef(self)
            else:
                return visitor.visitChildren(self)




    def constraintsDef(self):

        localctx = InterlisParserPy.ConstraintsDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_constraintsDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1708
            self.match(InterlisParserPy.CONSTRAINTS)
            self.state = 1709
            self.match(InterlisParserPy.OF)
            self.state = 1710
            self.classOrAssociationRef()
            self.state = 1711
            self.match(InterlisParserPy.EQ)
            self.state = 1715
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 18014673389494344) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 18015773369040897) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & 288230994685739019) != 0) or ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 285697) != 0):
                self.state = 1712
                self.constraintDef()
                self.state = 1717
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1718
            self.match(InterlisParserPy.END)
            self.state = 1719
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(InterlisParserPy.TermContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = InterlisParserPy.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1721
            self.term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term0(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.Term0Context)
            else:
                return self.getTypedRuleContext(InterlisParserPy.Term0Context,i)


        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = InterlisParserPy.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1723
            self.term0()
            self.state = 1727
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==191:
                self.state = 1724
                self.match(InterlisParserPy.EQ)
                self.state = 1725
                self.match(InterlisParserPy.GT)
                self.state = 1726
                self.term0()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term0Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.Term1Context)
            else:
                return self.getTypedRuleContext(InterlisParserPy.Term1Context,i)


        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OR)
            else:
                return self.getToken(InterlisParserPy.OR, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.PLUS)
            else:
                return self.getToken(InterlisParserPy.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MINUS)
            else:
                return self.getToken(InterlisParserPy.MINUS, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_term0

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm0" ):
                listener.enterTerm0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm0" ):
                listener.exitTerm0(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm0" ):
                return visitor.visitTerm0(self)
            else:
                return visitor.visitChildren(self)




    def term0(self):

        localctx = InterlisParserPy.Term0Context(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_term0)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1729
            self.term1()
            self.state = 1734
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==132 or _la==205 or _la==206:
                self.state = 1730
                _la = self._input.LA(1)
                if not(_la==132 or _la==205 or _la==206):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1731
                self.term1()
                self.state = 1736
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term2(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.Term2Context)
            else:
                return self.getTypedRuleContext(InterlisParserPy.Term2Context,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.AND)
            else:
                return self.getToken(InterlisParserPy.AND, i)

        def MUL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MUL)
            else:
                return self.getToken(InterlisParserPy.MUL, i)

        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DIV)
            else:
                return self.getToken(InterlisParserPy.DIV, i)

        def POW(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.POW)
            else:
                return self.getToken(InterlisParserPy.POW, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_term1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm1" ):
                listener.enterTerm1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm1" ):
                listener.exitTerm1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm1" ):
                return visitor.visitTerm1(self)
            else:
                return visitor.visitChildren(self)




    def term1(self):

        localctx = InterlisParserPy.Term1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_term1)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1737
            self.term2()
            self.state = 1742
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==7 or _la==62 or _la==114 or _la==115:
                self.state = 1738
                _la = self._input.LA(1)
                if not(_la==7 or _la==62 or _la==114 or _la==115):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1739
                self.term2()
                self.state = 1744
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.PredicateContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.PredicateContext,i)


        def relation(self):
            return self.getTypedRuleContext(InterlisParserPy.RelationContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_term2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm2" ):
                listener.enterTerm2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm2" ):
                listener.exitTerm2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm2" ):
                return visitor.visitTerm2(self)
            else:
                return visitor.visitChildren(self)




    def term2(self):

        localctx = InterlisParserPy.Term2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_term2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1745
            self.predicate()
            self.state = 1749
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
            if la_ == 1:
                self.state = 1746
                self.relation()
                self.state = 1747
                self.predicate()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(InterlisParserPy.FactorContext,0)


        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def DEFINED(self):
            return self.getToken(InterlisParserPy.DEFINED, 0)

        def BASKET(self):
            return self.getToken(InterlisParserPy.BASKET, 0)

        def NOT(self):
            return self.getToken(InterlisParserPy.NOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = InterlisParserPy.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1768
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,240,self._ctx)
            if la_ == 1:
                self.state = 1751
                self.factor()
                pass

            elif la_ == 2:
                self.state = 1753
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==123:
                    self.state = 1752
                    self.match(InterlisParserPy.NOT)


                self.state = 1755
                self.match(InterlisParserPy.LPAR)
                self.state = 1756
                self.expression()
                self.state = 1757
                self.match(InterlisParserPy.RPAR)
                pass

            elif la_ == 3:
                self.state = 1759
                self.match(InterlisParserPy.DEFINED)
                self.state = 1760
                self.match(InterlisParserPy.LPAR)
                self.state = 1761
                self.factor()
                self.state = 1762
                self.match(InterlisParserPy.RPAR)
                pass

            elif la_ == 4:
                self.state = 1764
                self.match(InterlisParserPy.LPAR)
                self.state = 1765
                self.match(InterlisParserPy.BASKET)
                self.state = 1766
                self.match(InterlisParserPy.RPAR)
                self.state = 1767
                self.factor()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EQ)
            else:
                return self.getToken(InterlisParserPy.EQ, i)

        def NOT_EQ(self):
            return self.getToken(InterlisParserPy.NOT_EQ, 0)

        def LT(self):
            return self.getToken(InterlisParserPy.LT, 0)

        def GT(self):
            return self.getToken(InterlisParserPy.GT, 0)

        def LTEQ(self):
            return self.getToken(InterlisParserPy.LTEQ, 0)

        def GTEQ(self):
            return self.getToken(InterlisParserPy.GTEQ, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelation" ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = InterlisParserPy.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1779
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
            if la_ == 1:
                self.state = 1770
                self.match(InterlisParserPy.EQ)
                self.state = 1771
                self.match(InterlisParserPy.EQ)
                pass

            elif la_ == 2:
                self.state = 1772
                self.match(InterlisParserPy.NOT_EQ)
                pass

            elif la_ == 3:
                self.state = 1773
                self.match(InterlisParserPy.LT)
                self.state = 1774
                self.match(InterlisParserPy.GT)
                pass

            elif la_ == 4:
                self.state = 1775
                self.match(InterlisParserPy.LTEQ)
                pass

            elif la_ == 5:
                self.state = 1776
                self.match(InterlisParserPy.GTEQ)
                pass

            elif la_ == 6:
                self.state = 1777
                self.match(InterlisParserPy.LT)
                pass

            elif la_ == 7:
                self.state = 1778
                self.match(InterlisParserPy.GT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectOrAttributePath(self):
            return self.getTypedRuleContext(InterlisParserPy.ObjectOrAttributePathContext,0)


        def inspection(self):
            return self.getTypedRuleContext(InterlisParserPy.InspectionContext,0)


        def INSPECTION(self):
            return self.getToken(InterlisParserPy.INSPECTION, 0)

        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def functionCall(self):
            return self.getTypedRuleContext(InterlisParserPy.FunctionCallContext,0)


        def INTERLIS(self):
            return self.getToken(InterlisParserPy.INTERLIS, 0)

        def DOT(self):
            return self.getToken(InterlisParserPy.DOT, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def URI(self):
            return self.getToken(InterlisParserPy.URI, 0)

        def UUIDOID(self):
            return self.getToken(InterlisParserPy.UUIDOID, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ExpressionContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def PARAMETER(self):
            return self.getToken(InterlisParserPy.PARAMETER, 0)

        def ALL(self):
            return self.getToken(InterlisParserPy.ALL, 0)

        def constant(self):
            return self.getTypedRuleContext(InterlisParserPy.ConstantContext,0)


        def Number(self):
            return self.getToken(InterlisParserPy.Number, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = InterlisParserPy.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_factor)
        self._la = 0 # Token type
        try:
            self.state = 1822
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,249,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1781
                self.objectOrAttributePath()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1785
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 96]:
                    self.state = 1782
                    self.inspection()
                    pass
                elif token in [95]:
                    self.state = 1783
                    self.match(InterlisParserPy.INSPECTION)
                    self.state = 1784
                    self.viewableRef()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1789
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==128:
                    self.state = 1787
                    self.match(InterlisParserPy.OF)
                    self.state = 1788
                    self.objectOrAttributePath()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1791
                self.functionCall()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1792
                self.match(InterlisParserPy.INTERLIS)
                self.state = 1793
                self.match(InterlisParserPy.DOT)
                self.state = 1794
                _la = self._input.LA(1)
                if not(((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 137438953475) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1807
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,246,self._ctx)
                if la_ == 1:
                    self.state = 1795
                    self.match(InterlisParserPy.LPAR)
                    self.state = 1804
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18014398511587400) != 0) or ((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & 6192518208161537) != 0) or ((((_la - 159)) & ~0x3f) == 0 and ((1 << (_la - 159)) & 1256508728442626055) != 0):
                        self.state = 1796
                        self.expression()
                        self.state = 1801
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==196:
                            self.state = 1797
                            self.match(InterlisParserPy.COMMA)
                            self.state = 1798
                            self.expression()
                            self.state = 1803
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 1806
                    self.match(InterlisParserPy.RPAR)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1809
                self.match(InterlisParserPy.PARAMETER)
                self.state = 1812
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,247,self._ctx)
                if la_ == 1:
                    self.state = 1810
                    self.match(InterlisParserPy.Name)
                    self.state = 1811
                    self.match(InterlisParserPy.DOT)


                self.state = 1814
                self.match(InterlisParserPy.Name)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1815
                self.match(InterlisParserPy.ALL)
                self.state = 1818
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==128:
                    self.state = 1816
                    self.match(InterlisParserPy.OF)
                    self.state = 1817
                    self.objectOrAttributePath()


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1820
                self.constant()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1821
                self.match(InterlisParserPy.Number)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectOrAttributePathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pathEl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.PathElContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.PathElContext,i)


        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MINUS)
            else:
                return self.getToken(InterlisParserPy.MINUS, i)

        def GT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.GT)
            else:
                return self.getToken(InterlisParserPy.GT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_objectOrAttributePath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectOrAttributePath" ):
                listener.enterObjectOrAttributePath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectOrAttributePath" ):
                listener.exitObjectOrAttributePath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectOrAttributePath" ):
                return visitor.visitObjectOrAttributePath(self)
            else:
                return visitor.visitChildren(self)




    def objectOrAttributePath(self):

        localctx = InterlisParserPy.ObjectOrAttributePathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_objectOrAttributePath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1824
            self.pathEl()
            self.state = 1830
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,250,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1825
                    self.match(InterlisParserPy.MINUS)
                    self.state = 1826
                    self.match(InterlisParserPy.GT)
                    self.state = 1827
                    self.pathEl() 
                self.state = 1832
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,250,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributePathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectOrAttributePath(self):
            return self.getTypedRuleContext(InterlisParserPy.ObjectOrAttributePathContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_attributePath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributePath" ):
                listener.enterAttributePath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributePath" ):
                listener.exitAttributePath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributePath" ):
                return visitor.visitAttributePath(self)
            else:
                return visitor.visitChildren(self)




    def attributePath(self):

        localctx = InterlisParserPy.AttributePathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_attributePath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1833
            self.objectOrAttributePath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PathElContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THIS(self):
            return self.getToken(InterlisParserPy.THIS, 0)

        def THISAREA(self):
            return self.getToken(InterlisParserPy.THISAREA, 0)

        def THATAREA(self):
            return self.getToken(InterlisParserPy.THATAREA, 0)

        def PARENT(self):
            return self.getToken(InterlisParserPy.PARENT, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def associationPath(self):
            return self.getTypedRuleContext(InterlisParserPy.AssociationPathContext,0)


        def attributeRef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttributeRefContext,0)


        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.EQ)
            else:
                return self.getToken(InterlisParserPy.EQ, i)

        def STRING(self):
            return self.getToken(InterlisParserPy.STRING, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_pathEl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPathEl" ):
                listener.enterPathEl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPathEl" ):
                listener.exitPathEl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPathEl" ):
                return visitor.visitPathEl(self)
            else:
                return visitor.visitChildren(self)




    def pathEl(self):

        localctx = InterlisParserPy.PathElContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_pathEl)
        try:
            self.state = 1853
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,252,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1835
                self.match(InterlisParserPy.THIS)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1836
                self.match(InterlisParserPy.THISAREA)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1837
                self.match(InterlisParserPy.THATAREA)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1838
                self.match(InterlisParserPy.PARENT)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1839
                self.match(InterlisParserPy.Name)
                self.state = 1843
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
                if la_ == 1:
                    self.state = 1840
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1841
                    self.match(InterlisParserPy.Name)
                    self.state = 1842
                    self.match(InterlisParserPy.RSBR)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1845
                self.match(InterlisParserPy.Name)
                self.state = 1846
                self.match(InterlisParserPy.COLON)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1847
                self.associationPath()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1848
                self.attributeRef()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1849
                self.match(InterlisParserPy.Name)
                self.state = 1850
                self.match(InterlisParserPy.EQ)
                self.state = 1851
                self.match(InterlisParserPy.EQ)
                self.state = 1852
                self.match(InterlisParserPy.STRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssociationPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def BACKSLASH(self):
            return self.getToken(InterlisParserPy.BACKSLASH, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_associationPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssociationPath" ):
                listener.enterAssociationPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssociationPath" ):
                listener.exitAssociationPath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssociationPath" ):
                return visitor.visitAssociationPath(self)
            else:
                return visitor.visitChildren(self)




    def associationPath(self):

        localctx = InterlisParserPy.AssociationPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_associationPath)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1856
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 1855
                self.match(InterlisParserPy.BACKSLASH)


            self.state = 1858
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def FIRST(self):
            return self.getToken(InterlisParserPy.FIRST, 0)

        def LAST(self):
            return self.getToken(InterlisParserPy.LAST, 0)

        def Number(self):
            return self.getToken(InterlisParserPy.Number, 0)

        def AGGREGATES(self):
            return self.getToken(InterlisParserPy.AGGREGATES, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_attributeRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeRef" ):
                listener.enterAttributeRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeRef" ):
                listener.exitAttributeRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeRef" ):
                return visitor.visitAttributeRef(self)
            else:
                return visitor.visitChildren(self)




    def attributeRef(self):

        localctx = InterlisParserPy.AttributeRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_attributeRef)
        self._la = 0 # Token type
        try:
            self.state = 1867
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [215]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1860
                self.match(InterlisParserPy.Name)
                self.state = 1864
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
                if la_ == 1:
                    self.state = 1861
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1862
                    _la = self._input.LA(1)
                    if not(_la==74 or _la==102 or _la==212):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1863
                    self.match(InterlisParserPy.RSBR)


                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1866
                self.match(InterlisParserPy.AGGREGATES)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ArgumentContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ArgumentContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = InterlisParserPy.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1871
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,256,self._ctx)
            if la_ == 1:
                self.state = 1869
                self.match(InterlisParserPy.Name)
                self.state = 1870
                self.match(InterlisParserPy.DOT)


            self.state = 1875
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
            if la_ == 1:
                self.state = 1873
                self.match(InterlisParserPy.Name)
                self.state = 1874
                self.match(InterlisParserPy.DOT)


            self.state = 1877
            self.match(InterlisParserPy.Name)
            self.state = 1878
            self.match(InterlisParserPy.LPAR)
            self.state = 1879
            self.argument()
            self.state = 1884
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 1880
                self.match(InterlisParserPy.COMMA)
                self.state = 1881
                self.argument()
                self.state = 1886
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1887
            self.match(InterlisParserPy.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def ALL(self):
            return self.getToken(InterlisParserPy.ALL, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def restrictedClassOrAssRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RestrictedClassOrAssRefContext,0)


        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgument" ):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = InterlisParserPy.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_argument)
        try:
            self.state = 1898
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,260,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1889
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1890
                self.match(InterlisParserPy.ALL)
                self.state = 1896
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [194]:
                    self.state = 1891
                    self.match(InterlisParserPy.LPAR)
                    self.state = 1892
                    self.restrictedClassOrAssRef()
                    pass
                elif token in [215]:
                    self.state = 1893
                    self.viewableRef()
                    self.state = 1894
                    self.match(InterlisParserPy.RPAR)
                    pass
                elif token in [195, 196]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(InterlisParserPy.FUNCTION, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def argumentDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ArgumentDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ArgumentDefContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def BOOLEAN(self):
            return self.getToken(InterlisParserPy.BOOLEAN, 0)

        def attrTypeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_functionDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDecl" ):
                listener.enterFunctionDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDecl" ):
                listener.exitFunctionDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDecl" ):
                return visitor.visitFunctionDecl(self)
            else:
                return visitor.visitChildren(self)




    def functionDecl(self):

        localctx = InterlisParserPy.FunctionDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_functionDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1900
            self.match(InterlisParserPy.FUNCTION)
            self.state = 1901
            self.match(InterlisParserPy.Name)
            self.state = 1902
            self.match(InterlisParserPy.LPAR)
            self.state = 1903
            self.argumentDef()
            self.state = 1908
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==198:
                self.state = 1904
                self.match(InterlisParserPy.SEMI)
                self.state = 1905
                self.argumentDef()
                self.state = 1910
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1911
            self.match(InterlisParserPy.RPAR)
            self.state = 1912
            self.match(InterlisParserPy.COLON)
            self.state = 1916
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,262,self._ctx)
            if la_ == 1:
                self.state = 1913
                self.match(InterlisParserPy.BOOLEAN)
                pass

            elif la_ == 2:
                self.state = 1914
                self.attrTypeDef()
                pass

            elif la_ == 3:
                self.state = 1915
                self.match(InterlisParserPy.Name)
                pass


            self.state = 1918
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def UNIT(self):
            return self.getToken(InterlisParserPy.UNIT, 0)

        def LSBR(self):
            return self.getToken(InterlisParserPy.LSBR, 0)

        def RSBR(self):
            return self.getToken(InterlisParserPy.RSBR, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def unitRef(self):
            return self.getTypedRuleContext(InterlisParserPy.UnitRefContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def FUNCTION(self):
            return self.getToken(InterlisParserPy.FUNCTION, 0)

        def Explanation(self):
            return self.getToken(InterlisParserPy.Explanation, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_functionDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDef" ):
                listener.enterFunctionDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDef" ):
                listener.exitFunctionDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDef" ):
                return visitor.visitFunctionDef(self)
            else:
                return visitor.visitChildren(self)




    def functionDef(self):

        localctx = InterlisParserPy.FunctionDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_functionDef)
        self._la = 0 # Token type
        try:
            self.state = 1943
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [176, 215]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1921
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==176:
                    self.state = 1920
                    self.match(InterlisParserPy.UNIT)


                self.state = 1923
                self.match(InterlisParserPy.Name)
                self.state = 1927
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==209:
                    self.state = 1924
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1925
                    self.match(InterlisParserPy.Name)
                    self.state = 1926
                    self.match(InterlisParserPy.RSBR)


                self.state = 1931
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==71:
                    self.state = 1929
                    self.match(InterlisParserPy.EXTENDS)
                    self.state = 1930
                    self.unitRef()


                pass
            elif token in [191, 198]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1940
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==191:
                    self.state = 1933
                    self.match(InterlisParserPy.EQ)
                    self.state = 1934
                    self.match(InterlisParserPy.FUNCTION)
                    self.state = 1935
                    self.match(InterlisParserPy.Explanation)
                    self.state = 1936
                    self.match(InterlisParserPy.LSBR)
                    self.state = 1937
                    self.unitRef()
                    self.state = 1938
                    self.match(InterlisParserPy.RSBR)


                self.state = 1942
                self.match(InterlisParserPy.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def argumentType(self):
            return self.getTypedRuleContext(InterlisParserPy.ArgumentTypeContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_argumentDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentDef" ):
                listener.enterArgumentDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentDef" ):
                listener.exitArgumentDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentDef" ):
                return visitor.visitArgumentDef(self)
            else:
                return visitor.visitChildren(self)




    def argumentDef(self):

        localctx = InterlisParserPy.ArgumentDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_argumentDef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1945
            self.match(InterlisParserPy.Name)
            self.state = 1946
            self.match(InterlisParserPy.COLON)
            self.state = 1947
            self.argumentType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attrTypeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttrTypeDefContext,0)


        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def OBJECT(self):
            return self.getToken(InterlisParserPy.OBJECT, 0)

        def OBJECTS(self):
            return self.getToken(InterlisParserPy.OBJECTS, 0)

        def restrictedClassOrAssRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RestrictedClassOrAssRefContext,0)


        def viewRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewRefContext,0)


        def ENUMVAL(self):
            return self.getToken(InterlisParserPy.ENUMVAL, 0)

        def ENUMTREEVAL(self):
            return self.getToken(InterlisParserPy.ENUMTREEVAL, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_argumentType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentType" ):
                listener.enterArgumentType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentType" ):
                listener.exitArgumentType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentType" ):
                return visitor.visitArgumentType(self)
            else:
                return visitor.visitChildren(self)




    def argumentType(self):

        localctx = InterlisParserPy.ArgumentTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_argumentType)
        self._la = 0 # Token type
        try:
            self.state = 1958
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6, 10, 13, 19, 22, 28, 30, 35, 46, 50, 51, 61, 65, 78, 86, 97, 106, 109, 113, 116, 117, 118, 119, 120, 125, 129, 140, 144, 153, 155, 158, 165, 178, 179, 180, 194, 211, 212, 213, 215, 219]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1949
                self.attrTypeDef()
                pass
            elif token in [126, 127]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1950
                _la = self._input.LA(1)
                if not(_la==126 or _la==127):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1951
                self.match(InterlisParserPy.OF)
                self.state = 1954
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,268,self._ctx)
                if la_ == 1:
                    self.state = 1952
                    self.restrictedClassOrAssRef()
                    pass

                elif la_ == 2:
                    self.state = 1953
                    self.viewRef()
                    pass


                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1956
                self.match(InterlisParserPy.ENUMVAL)
                pass
            elif token in [66]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1957
                self.match(InterlisParserPy.ENUMTREEVAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VIEW(self):
            return self.getToken(InterlisParserPy.VIEW, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def formationDef(self):
            return self.getTypedRuleContext(InterlisParserPy.FormationDefContext,0)


        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def viewRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewRefContext,0)


        def baseExtensionDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.BaseExtensionDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.BaseExtensionDefContext,i)


        def selection(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.SelectionContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.SelectionContext,i)


        def viewAttributes(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewAttributesContext,0)


        def constraintDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ConstraintDefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ConstraintDefContext,i)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def TRANSIENT(self):
            return self.getToken(InterlisParserPy.TRANSIENT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_viewDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewDef" ):
                listener.enterViewDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewDef" ):
                listener.exitViewDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewDef" ):
                return visitor.visitViewDef(self)
            else:
                return visitor.visitChildren(self)




    def viewDef(self):

        localctx = InterlisParserPy.ViewDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_viewDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1960
            self.match(InterlisParserPy.VIEW)
            self.state = 1961
            self.match(InterlisParserPy.Name)
            self.state = 1963
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==70 or _la==73 or _la==169:
                self.state = 1962
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73 or _la==169):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1968
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 13, 96, 101, 142, 174]:
                self.state = 1965
                self.formationDef()
                pass
            elif token in [71]:
                self.state = 1966
                self.match(InterlisParserPy.EXTENDS)
                self.state = 1967
                self.viewRef()
                pass
            elif token in [23, 186, 191]:
                pass
            else:
                pass
            self.state = 1973
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==23:
                self.state = 1970
                self.baseExtensionDef()
                self.state = 1975
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1979
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==186:
                self.state = 1976
                self.selection()
                self.state = 1981
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1982
            self.match(InterlisParserPy.EQ)
            self.state = 1984
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,274,self._ctx)
            if la_ == 1:
                self.state = 1983
                self.viewAttributes()


            self.state = 1989
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 18014673389494344) != 0) or ((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 18015773369040897) != 0) or ((((_la - 136)) & ~0x3f) == 0 and ((1 << (_la - 136)) & 288230994685739019) != 0) or ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 285697) != 0):
                self.state = 1986
                self.constraintDef()
                self.state = 1991
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1992
            self.match(InterlisParserPy.END)
            self.state = 1993
            self.match(InterlisParserPy.Name)
            self.state = 1994
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_viewRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewRef" ):
                listener.enterViewRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewRef" ):
                listener.exitViewRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewRef" ):
                return visitor.visitViewRef(self)
            else:
                return visitor.visitChildren(self)




    def viewRef(self):

        localctx = InterlisParserPy.ViewRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_viewRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2002
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
            if la_ == 1:
                self.state = 1996
                self.match(InterlisParserPy.Name)
                self.state = 1997
                self.match(InterlisParserPy.DOT)
                self.state = 2000
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,276,self._ctx)
                if la_ == 1:
                    self.state = 1998
                    self.match(InterlisParserPy.Name)
                    self.state = 1999
                    self.match(InterlisParserPy.DOT)




            self.state = 2004
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormationDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def projection(self):
            return self.getTypedRuleContext(InterlisParserPy.ProjectionContext,0)


        def join(self):
            return self.getTypedRuleContext(InterlisParserPy.JoinContext,0)


        def union(self):
            return self.getTypedRuleContext(InterlisParserPy.UnionContext,0)


        def aggregation(self):
            return self.getTypedRuleContext(InterlisParserPy.AggregationContext,0)


        def inspection(self):
            return self.getTypedRuleContext(InterlisParserPy.InspectionContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_formationDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormationDef" ):
                listener.enterFormationDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormationDef" ):
                listener.exitFormationDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormationDef" ):
                return visitor.visitFormationDef(self)
            else:
                return visitor.visitChildren(self)




    def formationDef(self):

        localctx = InterlisParserPy.FormationDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_formationDef)
        try:
            self.state = 2011
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [142]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2006
                self.projection()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2007
                self.join()
                pass
            elif token in [174]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2008
                self.union()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2009
                self.aggregation()
                pass
            elif token in [13, 96]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2010
                self.inspection()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROJECTION_OF(self):
            return self.getToken(InterlisParserPy.PROJECTION_OF, 0)

        def renamedViewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RenamedViewableRefContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_projection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjection" ):
                listener.enterProjection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjection" ):
                listener.exitProjection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProjection" ):
                return visitor.visitProjection(self)
            else:
                return visitor.visitChildren(self)




    def projection(self):

        localctx = InterlisParserPy.ProjectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_projection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2013
            self.match(InterlisParserPy.PROJECTION_OF)
            self.state = 2014
            self.renamedViewableRef()
            self.state = 2015
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JOIN_OF(self):
            return self.getToken(InterlisParserPy.JOIN_OF, 0)

        def renamedViewableRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.RenamedViewableRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.RenamedViewableRefContext,i)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def LPAR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.LPAR)
            else:
                return self.getToken(InterlisParserPy.LPAR, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.OR)
            else:
                return self.getToken(InterlisParserPy.OR, i)

        def NULL(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.NULL)
            else:
                return self.getToken(InterlisParserPy.NULL, i)

        def RPAR(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.RPAR)
            else:
                return self.getToken(InterlisParserPy.RPAR, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_join

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoin" ):
                listener.enterJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoin" ):
                listener.exitJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoin" ):
                return visitor.visitJoin(self)
            else:
                return visitor.visitChildren(self)




    def join(self):

        localctx = InterlisParserPy.JoinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_join)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2017
            self.match(InterlisParserPy.JOIN_OF)
            self.state = 2018
            self.renamedViewableRef()
            self.state = 2029
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 2019
                self.match(InterlisParserPy.COMMA)
                self.state = 2020
                self.renamedViewableRef()
                self.state = 2025
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==194:
                    self.state = 2021
                    self.match(InterlisParserPy.LPAR)
                    self.state = 2022
                    self.match(InterlisParserPy.OR)
                    self.state = 2023
                    self.match(InterlisParserPy.NULL)
                    self.state = 2024
                    self.match(InterlisParserPy.RPAR)


                self.state = 2031
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2032
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION_OF(self):
            return self.getToken(InterlisParserPy.UNION_OF, 0)

        def renamedViewableRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.RenamedViewableRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.RenamedViewableRefContext,i)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_union

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnion" ):
                listener.enterUnion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnion" ):
                listener.exitUnion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnion" ):
                return visitor.visitUnion(self)
            else:
                return visitor.visitChildren(self)




    def union(self):

        localctx = InterlisParserPy.UnionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_union)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2034
            self.match(InterlisParserPy.UNION_OF)
            self.state = 2035
            self.renamedViewableRef()
            self.state = 2040
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 2036
                self.match(InterlisParserPy.COMMA)
                self.state = 2037
                self.renamedViewableRef()
                self.state = 2042
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2043
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AGGREGATION_OF(self):
            return self.getToken(InterlisParserPy.AGGREGATION_OF, 0)

        def renamedViewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RenamedViewableRefContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def ALL(self):
            return self.getToken(InterlisParserPy.ALL, 0)

        def EQUAL(self):
            return self.getToken(InterlisParserPy.EQUAL, 0)

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def uniqueEl(self):
            return self.getTypedRuleContext(InterlisParserPy.UniqueElContext,0)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_aggregation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregation" ):
                listener.enterAggregation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregation" ):
                listener.exitAggregation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregation" ):
                return visitor.visitAggregation(self)
            else:
                return visitor.visitChildren(self)




    def aggregation(self):

        localctx = InterlisParserPy.AggregationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_aggregation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2045
            self.match(InterlisParserPy.AGGREGATION_OF)
            self.state = 2046
            self.renamedViewableRef()
            self.state = 2053
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6]:
                self.state = 2047
                self.match(InterlisParserPy.ALL)
                pass
            elif token in [68]:
                self.state = 2048
                self.match(InterlisParserPy.EQUAL)
                self.state = 2049
                self.match(InterlisParserPy.LPAR)
                self.state = 2050
                self.uniqueEl()
                self.state = 2051
                self.match(InterlisParserPy.RPAR)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2055
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InspectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def INSPECTION_OF(self):
            return self.getToken(InterlisParserPy.INSPECTION_OF, 0)

        def renamedViewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.RenamedViewableRefContext,0)


        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.MINUS)
            else:
                return self.getToken(InterlisParserPy.MINUS, i)

        def GT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.GT)
            else:
                return self.getToken(InterlisParserPy.GT, i)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def AREA(self):
            return self.getToken(InterlisParserPy.AREA, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_inspection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInspection" ):
                listener.enterInspection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInspection" ):
                listener.exitInspection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInspection" ):
                return visitor.visitInspection(self)
            else:
                return visitor.visitChildren(self)




    def inspection(self):

        localctx = InterlisParserPy.InspectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_inspection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2058
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 2057
                self.match(InterlisParserPy.AREA)


            self.state = 2060
            self.match(InterlisParserPy.INSPECTION_OF)
            self.state = 2061
            self.renamedViewableRef()
            self.state = 2062
            self.match(InterlisParserPy.MINUS)
            self.state = 2063
            self.match(InterlisParserPy.GT)
            self.state = 2064
            self.match(InterlisParserPy.Name)
            self.state = 2070
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==205:
                self.state = 2065
                self.match(InterlisParserPy.MINUS)
                self.state = 2066
                self.match(InterlisParserPy.GT)
                self.state = 2067
                self.match(InterlisParserPy.Name)
                self.state = 2072
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2073
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RenamedViewableRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def TILDE(self):
            return self.getToken(InterlisParserPy.TILDE, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_renamedViewableRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRenamedViewableRef" ):
                listener.enterRenamedViewableRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRenamedViewableRef" ):
                listener.exitRenamedViewableRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenamedViewableRef" ):
                return visitor.visitRenamedViewableRef(self)
            else:
                return visitor.visitChildren(self)




    def renamedViewableRef(self):

        localctx = InterlisParserPy.RenamedViewableRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_renamedViewableRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2077
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,285,self._ctx)
            if la_ == 1:
                self.state = 2075
                self.match(InterlisParserPy.Name)
                self.state = 2076
                self.match(InterlisParserPy.TILDE)


            self.state = 2079
            self.viewableRef()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewableRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_viewableRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewableRef" ):
                listener.enterViewableRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewableRef" ):
                listener.exitViewableRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewableRef" ):
                return visitor.visitViewableRef(self)
            else:
                return visitor.visitChildren(self)




    def viewableRef(self):

        localctx = InterlisParserPy.ViewableRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_viewableRef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2087
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
            if la_ == 1:
                self.state = 2081
                self.match(InterlisParserPy.Name)
                self.state = 2082
                self.match(InterlisParserPy.DOT)
                self.state = 2085
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,286,self._ctx)
                if la_ == 1:
                    self.state = 2083
                    self.match(InterlisParserPy.Name)
                    self.state = 2084
                    self.match(InterlisParserPy.DOT)




            self.state = 2089
            _la = self._input.LA(1)
            if not(_la==215):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseExtensionDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BASE(self):
            return self.getToken(InterlisParserPy.BASE, 0)

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def BY(self):
            return self.getToken(InterlisParserPy.BY, 0)

        def renamedViewableRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.RenamedViewableRefContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.RenamedViewableRefContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_baseExtensionDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBaseExtensionDef" ):
                listener.enterBaseExtensionDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBaseExtensionDef" ):
                listener.exitBaseExtensionDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBaseExtensionDef" ):
                return visitor.visitBaseExtensionDef(self)
            else:
                return visitor.visitChildren(self)




    def baseExtensionDef(self):

        localctx = InterlisParserPy.BaseExtensionDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_baseExtensionDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2091
            self.match(InterlisParserPy.BASE)
            self.state = 2092
            self.match(InterlisParserPy.Name)
            self.state = 2093
            self.match(InterlisParserPy.EXTENDED)
            self.state = 2094
            self.match(InterlisParserPy.BY)
            self.state = 2095
            self.renamedViewableRef()
            self.state = 2100
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 2096
                self.match(InterlisParserPy.COMMA)
                self.state = 2097
                self.renamedViewableRef()
                self.state = 2102
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(InterlisParserPy.WHERE, 0)

        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_selection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelection" ):
                listener.enterSelection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelection" ):
                listener.exitSelection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelection" ):
                return visitor.visitSelection(self)
            else:
                return visitor.visitChildren(self)




    def selection(self):

        localctx = InterlisParserPy.SelectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_selection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2103
            self.match(InterlisParserPy.WHERE)
            self.state = 2104
            self.expression()
            self.state = 2105
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ViewAttributesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(InterlisParserPy.ALL, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def attributeDef(self):
            return self.getTypedRuleContext(InterlisParserPy.AttributeDefContext,0)


        def ASSIGN(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.ASSIGN)
            else:
                return self.getToken(InterlisParserPy.ASSIGN, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.ExpressionContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,i)


        def ATTRIBUTE(self):
            return self.getToken(InterlisParserPy.ATTRIBUTE, 0)

        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def TRANSIENT(self):
            return self.getToken(InterlisParserPy.TRANSIENT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_viewAttributes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewAttributes" ):
                listener.enterViewAttributes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewAttributes" ):
                listener.exitViewAttributes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitViewAttributes" ):
                return visitor.visitViewAttributes(self)
            else:
                return visitor.visitChildren(self)




    def viewAttributes(self):

        localctx = InterlisParserPy.ViewAttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_viewAttributes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 2107
                self.match(InterlisParserPy.ATTRIBUTE)


            self.state = 2141
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
            if la_ == 1:
                self.state = 2110
                self.match(InterlisParserPy.ALL)
                self.state = 2111
                self.match(InterlisParserPy.OF)
                self.state = 2112
                self.match(InterlisParserPy.Name)
                self.state = 2113
                self.match(InterlisParserPy.SEMI)
                self.state = 2121
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,290,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 2114
                        self.match(InterlisParserPy.Name)
                        self.state = 2115
                        self.match(InterlisParserPy.ASSIGN)
                        self.state = 2116
                        self.expression()
                        self.state = 2117
                        self.match(InterlisParserPy.SEMI) 
                    self.state = 2123
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,290,self._ctx)

                pass

            elif la_ == 2:
                self.state = 2129 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2124
                        self.match(InterlisParserPy.Name)
                        self.state = 2125
                        self.match(InterlisParserPy.ASSIGN)
                        self.state = 2126
                        self.expression()
                        self.state = 2127
                        self.match(InterlisParserPy.SEMI)

                    else:
                        raise NoViableAltException(self)
                    self.state = 2131 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,291,self._ctx)

                pass

            elif la_ == 3:
                self.state = 2133
                self.attributeDef()
                pass

            elif la_ == 4:
                self.state = 2135
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1 or _la==70 or _la==73 or _la==169:
                    self.state = 2134
                    _la = self._input.LA(1)
                    if not(_la==1 or _la==70 or _la==73 or _la==169):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2137
                self.match(InterlisParserPy.ASSIGN)
                self.state = 2138
                self.expression()
                self.state = 2139
                self.match(InterlisParserPy.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GraphicDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAPHIC(self):
            return self.getToken(InterlisParserPy.GRAPHIC, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def EQ(self):
            return self.getToken(InterlisParserPy.EQ, 0)

        def END(self):
            return self.getToken(InterlisParserPy.END, 0)

        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def EXTENDS(self):
            return self.getToken(InterlisParserPy.EXTENDS, 0)

        def graphicRef(self):
            return self.getTypedRuleContext(InterlisParserPy.GraphicRefContext,0)


        def BASED(self):
            return self.getToken(InterlisParserPy.BASED, 0)

        def ON(self):
            return self.getToken(InterlisParserPy.ON, 0)

        def viewableRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ViewableRefContext,0)


        def selection(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.SelectionContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.SelectionContext,i)


        def drawingRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.DrawingRuleContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.DrawingRuleContext,i)


        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_graphicDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGraphicDef" ):
                listener.enterGraphicDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGraphicDef" ):
                listener.exitGraphicDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGraphicDef" ):
                return visitor.visitGraphicDef(self)
            else:
                return visitor.visitChildren(self)




    def graphicDef(self):

        localctx = InterlisParserPy.GraphicDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_graphicDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2143
            self.match(InterlisParserPy.GRAPHIC)
            self.state = 2144
            self.match(InterlisParserPy.Name)
            self.state = 2146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==73:
                self.state = 2145
                _la = self._input.LA(1)
                if not(_la==1 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 2148
                self.match(InterlisParserPy.EXTENDS)
                self.state = 2149
                self.graphicRef()


            self.state = 2155
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==24:
                self.state = 2152
                self.match(InterlisParserPy.BASED)
                self.state = 2153
                self.match(InterlisParserPy.ON)
                self.state = 2154
                self.viewableRef()


            self.state = 2157
            self.match(InterlisParserPy.EQ)
            self.state = 2161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==186:
                self.state = 2158
                self.selection()
                self.state = 2163
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==215:
                self.state = 2164
                self.drawingRule()
                self.state = 2169
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2170
            self.match(InterlisParserPy.END)
            self.state = 2171
            self.match(InterlisParserPy.Name)
            self.state = 2172
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GraphicRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.Name)
            else:
                return self.getToken(InterlisParserPy.Name, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.DOT)
            else:
                return self.getToken(InterlisParserPy.DOT, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_graphicRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGraphicRef" ):
                listener.enterGraphicRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGraphicRef" ):
                listener.exitGraphicRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGraphicRef" ):
                return visitor.visitGraphicRef(self)
            else:
                return visitor.visitChildren(self)




    def graphicRef(self):

        localctx = InterlisParserPy.GraphicRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_graphicRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,300,self._ctx)
            if la_ == 1:
                self.state = 2174
                self.match(InterlisParserPy.Name)
                self.state = 2175
                self.match(InterlisParserPy.DOT)
                self.state = 2178
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,299,self._ctx)
                if la_ == 1:
                    self.state = 2176
                    self.match(InterlisParserPy.Name)
                    self.state = 2177
                    self.match(InterlisParserPy.DOT)




            self.state = 2182
            self.match(InterlisParserPy.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DrawingRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def COLON(self):
            return self.getToken(InterlisParserPy.COLON, 0)

        def condSignParamAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.CondSignParamAssignmentContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.CondSignParamAssignmentContext,i)


        def SEMI(self):
            return self.getToken(InterlisParserPy.SEMI, 0)

        def OF(self):
            return self.getToken(InterlisParserPy.OF, 0)

        def classRef(self):
            return self.getTypedRuleContext(InterlisParserPy.ClassRefContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def ABSTRACT(self):
            return self.getToken(InterlisParserPy.ABSTRACT, 0)

        def EXTENDED(self):
            return self.getToken(InterlisParserPy.EXTENDED, 0)

        def FINAL(self):
            return self.getToken(InterlisParserPy.FINAL, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_drawingRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrawingRule" ):
                listener.enterDrawingRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrawingRule" ):
                listener.exitDrawingRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDrawingRule" ):
                return visitor.visitDrawingRule(self)
            else:
                return visitor.visitChildren(self)




    def drawingRule(self):

        localctx = InterlisParserPy.DrawingRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_drawingRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2184
            self.match(InterlisParserPy.Name)
            self.state = 2186
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1 or _la==70 or _la==73:
                self.state = 2185
                _la = self._input.LA(1)
                if not(_la==1 or _la==70 or _la==73):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==128:
                self.state = 2188
                self.match(InterlisParserPy.OF)
                self.state = 2189
                self.classRef()


            self.state = 2192
            self.match(InterlisParserPy.COLON)
            self.state = 2193
            self.condSignParamAssignment()
            self.state = 2198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==196:
                self.state = 2194
                self.match(InterlisParserPy.COMMA)
                self.state = 2195
                self.condSignParamAssignment()
                self.state = 2200
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2201
            self.match(InterlisParserPy.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondSignParamAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def signParamAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.SignParamAssignmentContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.SignParamAssignmentContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def expression(self):
            return self.getTypedRuleContext(InterlisParserPy.ExpressionContext,0)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.SEMI)
            else:
                return self.getToken(InterlisParserPy.SEMI, i)

        def WHERE(self):
            return self.getToken(InterlisParserPy.WHERE, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_condSignParamAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondSignParamAssignment" ):
                listener.enterCondSignParamAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondSignParamAssignment" ):
                listener.exitCondSignParamAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondSignParamAssignment" ):
                return visitor.visitCondSignParamAssignment(self)
            else:
                return visitor.visitChildren(self)




    def condSignParamAssignment(self):

        localctx = InterlisParserPy.CondSignParamAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_condSignParamAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2207
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,305,self._ctx)
            if la_ == 1:
                self.state = 2204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==186:
                    self.state = 2203
                    self.match(InterlisParserPy.WHERE)


                self.state = 2206
                self.expression()


            self.state = 2209
            self.match(InterlisParserPy.LPAR)
            self.state = 2210
            self.signParamAssignment()
            self.state = 2215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==198:
                self.state = 2211
                self.match(InterlisParserPy.SEMI)
                self.state = 2212
                self.signParamAssignment()
                self.state = 2217
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2218
            self.match(InterlisParserPy.RPAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignParamAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Name(self):
            return self.getToken(InterlisParserPy.Name, 0)

        def ASSIGN(self):
            return self.getToken(InterlisParserPy.ASSIGN, 0)

        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def metaObjectRef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaObjectRefContext,0)


        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def factor(self):
            return self.getTypedRuleContext(InterlisParserPy.FactorContext,0)


        def ACCORDING(self):
            return self.getToken(InterlisParserPy.ACCORDING, 0)

        def attributePath(self):
            return self.getTypedRuleContext(InterlisParserPy.AttributePathContext,0)


        def LPAR(self):
            return self.getToken(InterlisParserPy.LPAR, 0)

        def enumAssignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.EnumAssignmentContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.EnumAssignmentContext,i)


        def RPAR(self):
            return self.getToken(InterlisParserPy.RPAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(InterlisParserPy.COMMA)
            else:
                return self.getToken(InterlisParserPy.COMMA, i)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_signParamAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignParamAssignment" ):
                listener.enterSignParamAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignParamAssignment" ):
                listener.exitSignParamAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSignParamAssignment" ):
                return visitor.visitSignParamAssignment(self)
            else:
                return visitor.visitChildren(self)




    def signParamAssignment(self):

        localctx = InterlisParserPy.SignParamAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_signParamAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2220
            self.match(InterlisParserPy.Name)
            self.state = 2221
            self.match(InterlisParserPy.ASSIGN)
            self.state = 2240
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [207]:
                self.state = 2222
                self.match(InterlisParserPy.LCBR)
                self.state = 2223
                self.metaObjectRef()
                self.state = 2224
                self.match(InterlisParserPy.RCBR)
                pass
            elif token in [3, 6, 13, 21, 87, 95, 96, 97, 107, 136, 137, 139, 159, 160, 161, 172, 201, 211, 212, 213, 215, 219]:
                self.state = 2226
                self.factor()
                pass
            elif token in [2]:
                self.state = 2227
                self.match(InterlisParserPy.ACCORDING)
                self.state = 2228
                self.attributePath()
                self.state = 2229
                self.match(InterlisParserPy.LPAR)
                self.state = 2230
                self.enumAssignment()
                self.state = 2235
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==196:
                    self.state = 2231
                    self.match(InterlisParserPy.COMMA)
                    self.state = 2232
                    self.enumAssignment()
                    self.state = 2237
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2238
                self.match(InterlisParserPy.RPAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(InterlisParserPy.WHEN, 0)

        def IN(self):
            return self.getToken(InterlisParserPy.IN, 0)

        def enumRange(self):
            return self.getTypedRuleContext(InterlisParserPy.EnumRangeContext,0)


        def LCBR(self):
            return self.getToken(InterlisParserPy.LCBR, 0)

        def metaObjectRef(self):
            return self.getTypedRuleContext(InterlisParserPy.MetaObjectRefContext,0)


        def RCBR(self):
            return self.getToken(InterlisParserPy.RCBR, 0)

        def constant(self):
            return self.getTypedRuleContext(InterlisParserPy.ConstantContext,0)


        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumAssignment" ):
                listener.enterEnumAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumAssignment" ):
                listener.exitEnumAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumAssignment" ):
                return visitor.visitEnumAssignment(self)
            else:
                return visitor.visitChildren(self)




    def enumAssignment(self):

        localctx = InterlisParserPy.EnumAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_enumAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2247
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [207]:
                self.state = 2242
                self.match(InterlisParserPy.LCBR)
                self.state = 2243
                self.metaObjectRef()
                self.state = 2244
                self.match(InterlisParserPy.RCBR)
                pass
            elif token in [87, 107, 139, 172, 201, 211, 213, 219]:
                self.state = 2246
                self.constant()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2249
            self.match(InterlisParserPy.WHEN)
            self.state = 2250
            self.match(InterlisParserPy.IN)
            self.state = 2251
            self.enumRange()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumRangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumerationConst(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(InterlisParserPy.EnumerationConstContext)
            else:
                return self.getTypedRuleContext(InterlisParserPy.EnumerationConstContext,i)


        def DOTDOT(self):
            return self.getToken(InterlisParserPy.DOTDOT, 0)

        def getRuleIndex(self):
            return InterlisParserPy.RULE_enumRange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumRange" ):
                listener.enterEnumRange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumRange" ):
                listener.exitEnumRange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumRange" ):
                return visitor.visitEnumRange(self)
            else:
                return visitor.visitChildren(self)




    def enumRange(self):

        localctx = InterlisParserPy.EnumRangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_enumRange)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2253
            self.enumerationConst()
            self.state = 2256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==204:
                self.state = 2254
                self.match(InterlisParserPy.DOTDOT)
                self.state = 2255
                self.enumerationConst()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





