"""
Vulnerability scanner for SparkForge.

This module provides automated vulnerability scanning capabilities including:
- Static code analysis
- Dependency vulnerability scanning
- Configuration security analysis
- Runtime security monitoring
"""

import json
import subprocess
import sys
import time
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional


@dataclass
class VulnerabilityReport:
    """Vulnerability report data structure."""

    vulnerability_id: str
    severity: str
    description: str
    file_path: str
    line_number: int
    cwe_id: Optional[str] = None
    cve_id: Optional[str] = None
    remediation: Optional[str] = None
    confidence: str = "medium"


@dataclass
class SecurityMetrics:
    """Security metrics data structure."""

    total_vulnerabilities: int
    high_severity: int
    medium_severity: int
    low_severity: int
    info_severity: int
    scan_timestamp: datetime
    scan_duration: float


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for SparkForge."""

    def __init__(self, project_root: Optional[Path] = None):
        self.project_root = project_root or Path.cwd()
        self.scan_results = []
        self.security_metrics = None

    def scan_all(self) -> Dict[str, Any]:
        """Run comprehensive vulnerability scan."""
        start_time = time.time()

        scan_results = {
            "static_analysis": self.scan_static_code(),
            "dependency_scan": self.scan_dependencies(),
            "configuration_scan": self.scan_configuration(),
            "secrets_scan": self.scan_secrets(),
            "license_scan": self.scan_licenses(),
            "supply_chain_scan": self.scan_supply_chain(),
        }

        end_time = time.time()
        self.security_metrics = SecurityMetrics(
            total_vulnerabilities=sum(
                len(result.get("vulnerabilities", []))
                for result in scan_results.values()
            ),
            high_severity=sum(
                len(
                    [
                        v
                        for v in result.get("vulnerabilities", [])
                        if v.get("severity") == "high"
                    ]
                )
                for result in scan_results.values()
            ),
            medium_severity=sum(
                len(
                    [
                        v
                        for v in result.get("vulnerabilities", [])
                        if v.get("severity") == "medium"
                    ]
                )
                for result in scan_results.values()
            ),
            low_severity=sum(
                len(
                    [
                        v
                        for v in result.get("vulnerabilities", [])
                        if v.get("severity") == "low"
                    ]
                )
                for result in scan_results.values()
            ),
            info_severity=sum(
                len(
                    [
                        v
                        for v in result.get("vulnerabilities", [])
                        if v.get("severity") == "info"
                    ]
                )
                for result in scan_results.values()
            ),
            scan_timestamp=datetime.now(),
            scan_duration=end_time - start_time,
        )

        return {
            "scan_results": scan_results,
            "security_metrics": self.security_metrics,
            "summary": self._generate_summary(),
        }

    def scan_static_code(self) -> Dict[str, Any]:
        """Scan static code for vulnerabilities using bandit."""
        try:
            # Run bandit security scan
            result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "bandit",
                    "-r",
                    str(self.project_root / "sparkforge"),
                    "-f",
                    "json",
                    "-ll",  # Low confidence, low severity
                ],
                capture_output=True,
                text=True,
                cwd=self.project_root,
            )

            if result.returncode != 0:
                return {"success": False, "error": result.stderr, "vulnerabilities": []}

            bandit_data = json.loads(result.stdout)
            vulnerabilities = []

            for issue in bandit_data.get("results", []):
                vulnerability = VulnerabilityReport(
                    vulnerability_id=issue.get("test_id", "unknown"),
                    severity=issue.get("issue_severity", "medium").lower(),
                    description=issue.get("issue_text", "No description"),
                    file_path=issue.get("filename", ""),
                    line_number=issue.get("line_number", 0),
                    cwe_id=issue.get("issue_cwe", {}).get("id"),
                    remediation=issue.get("issue_text", "No remediation provided"),
                    confidence=issue.get("issue_confidence", "medium").lower(),
                )
                vulnerabilities.append(vulnerability)

            return {
                "success": True,
                "vulnerabilities": [v.__dict__ for v in vulnerabilities],
                "metrics": bandit_data.get("metrics", {}),
                "scanner": "bandit",
                "version": self._get_bandit_version(),
            }

        except Exception as e:
            return {"success": False, "error": str(e), "vulnerabilities": []}

    def scan_dependencies(self) -> Dict[str, Any]:
        """Scan dependencies for known vulnerabilities."""
        try:
            # Run safety check
            safety_result = subprocess.run(
                [sys.executable, "-m", "safety", "check", "--json"],
                capture_output=True,
                text=True,
                cwd=self.project_root,
            )

            vulnerabilities = []
            if safety_result.stdout:
                try:
                    safety_data = json.loads(safety_result.stdout)
                    for vuln in safety_data:
                        vulnerability = VulnerabilityReport(
                            vulnerability_id=vuln.get("id", "unknown"),
                            severity=self._map_safety_severity(
                                vuln.get("severity", "medium")
                            ),
                            description=vuln.get("advisory", "No description"),
                            file_path="requirements.txt",
                            line_number=0,
                            cve_id=vuln.get("cve"),
                            remediation=f"Update {vuln.get('package')} to version {vuln.get('spec', 'latest')}",
                        )
                        vulnerabilities.append(vulnerability)
                except json.JSONDecodeError:
                    pass

            # Run pip-audit if available
            audit_vulnerabilities = []
            try:
                audit_result = subprocess.run(
                    [sys.executable, "-m", "pip", "audit", "--json"],
                    capture_output=True,
                    text=True,
                    cwd=self.project_root,
                )

                if audit_result.returncode == 0 and audit_result.stdout:
                    audit_data = json.loads(audit_result.stdout)
                    for vuln in audit_data.get("vulnerabilities", []):
                        vulnerability = VulnerabilityReport(
                            vulnerability_id=vuln.get("id", "unknown"),
                            severity="high",  # pip-audit typically reports high severity
                            description=vuln.get("description", "No description"),
                            file_path="requirements.txt",
                            line_number=0,
                            cve_id=vuln.get("id"),
                            remediation="Update package to fix vulnerability",
                        )
                        audit_vulnerabilities.append(vulnerability)
            except Exception:
                pass  # pip-audit not available

            all_vulnerabilities = vulnerabilities + audit_vulnerabilities

            return {
                "success": True,
                "vulnerabilities": [v.__dict__ for v in all_vulnerabilities],
                "scanner": "safety + pip-audit",
                "vulnerable_packages": len(
                    {v.package for v in all_vulnerabilities if hasattr(v, "package")}
                ),
            }

        except Exception as e:
            return {"success": False, "error": str(e), "vulnerabilities": []}

    def scan_configuration(self) -> Dict[str, Any]:
        """Scan configuration files for security issues."""
        vulnerabilities = []

        # Check for hardcoded secrets in configuration files
        config_files = [
            "pyproject.toml",
            "setup.py",
            "requirements.txt",
            "conf.py",
            "*.ini",
            "*.cfg",
            "*.yml",
            "*.yaml",
        ]

        for pattern in config_files:
            for config_file in self.project_root.glob(pattern):
                if config_file.is_file():
                    vulns = self._scan_config_file(config_file)
                    vulnerabilities.extend(vulns)

        # Check for insecure default configurations
        vulns = self._check_default_configurations()
        vulnerabilities.extend(vulns)

        return {
            "success": True,
            "vulnerabilities": [v.__dict__ for v in vulnerabilities],
            "scanner": "custom_config_scanner",
        }

    def _scan_config_file(self, config_file: Path) -> List[VulnerabilityReport]:
        """Scan individual configuration file for security issues."""
        vulnerabilities = []

        try:
            with open(config_file, encoding="utf-8") as f:
                content = f.read()

            # Check for hardcoded secrets
            secret_patterns = [
                ("password", "Hardcoded password detected"),
                ("secret", "Hardcoded secret detected"),
                ("key", "Hardcoded key detected"),
                ("token", "Hardcoded token detected"),
                ("api_key", "Hardcoded API key detected"),
                ("private_key", "Hardcoded private key detected"),
            ]

            for pattern, description in secret_patterns:
                if pattern in content.lower() and "=" in content:
                    # More sophisticated check for actual secrets
                    lines = content.split("\n")
                    for i, line in enumerate(lines):
                        if (
                            pattern in line.lower()
                            and "=" in line
                            and not any(
                                safe_word in line.lower()
                                for safe_word in [
                                    "example",
                                    "template",
                                    "placeholder",
                                    "your_",
                                ]
                            )
                        ):
                            vulnerability = VulnerabilityReport(
                                vulnerability_id="hardcoded_secret",
                                severity="high",
                                description=f"{description} in {config_file.name}",
                                file_path=str(config_file),
                                line_number=i + 1,
                                remediation="Use environment variables or secure configuration management",
                            )
                            vulnerabilities.append(vulnerability)

        except Exception:
            pass  # Skip files that can't be read

        return vulnerabilities

    def _check_default_configurations(self) -> List[VulnerabilityReport]:
        """Check for insecure default configurations."""
        vulnerabilities = []

        # Check pyproject.toml for insecure defaults
        pyproject_file = self.project_root / "pyproject.toml"
        if pyproject_file.exists():
            try:
                with open(pyproject_file) as f:
                    content = f.read()

                # Check for debug mode enabled
                if "debug = true" in content.lower():
                    vulnerability = VulnerabilityReport(
                        vulnerability_id="debug_mode_enabled",
                        severity="medium",
                        description="Debug mode enabled in production configuration",
                        file_path=str(pyproject_file),
                        line_number=content.lower().find("debug = true") + 1,
                        remediation="Disable debug mode in production",
                    )
                    vulnerabilities.append(vulnerability)

                # Check for insecure HTTP URLs
                if "http://" in content and "https://" not in content:
                    vulnerability = VulnerabilityReport(
                        vulnerability_id="insecure_http",
                        severity="medium",
                        description="Insecure HTTP URL detected",
                        file_path=str(pyproject_file),
                        line_number=content.find("http://") + 1,
                        remediation="Use HTTPS URLs instead of HTTP",
                    )
                    vulnerabilities.append(vulnerability)

            except Exception:
                pass

        return vulnerabilities

    def scan_secrets(self) -> Dict[str, Any]:
        """Scan for accidentally committed secrets."""
        vulnerabilities = []

        # Common secret patterns
        secret_patterns = [
            (r'password\s*=\s*["\'][^"\']+["\']', "Hardcoded password"),
            (r'secret\s*=\s*["\'][^"\']+["\']', "Hardcoded secret"),
            (r'api_key\s*=\s*["\'][^"\']+["\']', "Hardcoded API key"),
            (r'private_key\s*=\s*["\'][^"\']+["\']', "Hardcoded private key"),
            (r'token\s*=\s*["\'][^"\']+["\']', "Hardcoded token"),
            (r"sk_live_[a-zA-Z0-9]{24}", "Stripe live key"),
            (r"pk_live_[a-zA-Z0-9]{24}", "Stripe live publishable key"),
            (r"AKIA[0-9A-Z]{16}", "AWS access key"),
            (r"[0-9a-zA-Z+/]{40}", "Potential AWS secret key"),
            (r"-----BEGIN PRIVATE KEY-----", "Private key in code"),
            (r"-----BEGIN RSA PRIVATE KEY-----", "RSA private key in code"),
        ]

        # Scan Python files
        for py_file in self.project_root.rglob("*.py"):
            if py_file.is_file() and not any(
                part.startswith(".") for part in py_file.parts
            ):
                try:
                    with open(py_file, encoding="utf-8") as f:
                        content = f.read()

                    for pattern, description in secret_patterns:
                        import re

                        matches = re.finditer(pattern, content, re.IGNORECASE)
                        for match in matches:
                            # Check if it's not in a comment or test
                            line_start = content.rfind("\n", 0, match.start()) + 1
                            line_content = content[line_start : match.end()]

                            if not (
                                line_content.strip().startswith("#")
                                or "test" in py_file.name.lower()
                            ):
                                vulnerability = VulnerabilityReport(
                                    vulnerability_id="hardcoded_secret",
                                    severity="high",
                                    description=f"{description} in {py_file.name}",
                                    file_path=str(py_file),
                                    line_number=content[: match.start()].count("\n")
                                    + 1,
                                    remediation="Remove hardcoded secret and use environment variables",
                                )
                                vulnerabilities.append(vulnerability)

                except Exception:
                    pass  # Skip files that can't be read

        return {
            "success": True,
            "vulnerabilities": [v.__dict__ for v in vulnerabilities],
            "scanner": "custom_secrets_scanner",
        }

    def scan_licenses(self) -> Dict[str, Any]:
        """Scan for license compliance issues."""
        try:
            # Run pip-licenses to check licenses
            result = subprocess.run(
                [sys.executable, "-m", "pip-licenses", "--format=json"],
                capture_output=True,
                text=True,
                cwd=self.project_root,
            )

            if result.returncode != 0:
                return {
                    "success": False,
                    "error": "pip-licenses not available",
                    "vulnerabilities": [],
                }

            licenses_data = json.loads(result.stdout)

            # Check for problematic licenses
            problematic_licenses = [
                "GPL-2.0",
                "GPL-3.0",
                "AGPL-3.0",
                "Copyleft",
                "Commercial",
                "Proprietary",
                "Unknown",
            ]

            vulnerabilities = []
            for package in licenses_data:
                license_name = package.get("License", "Unknown")
                if any(
                    prob_license in license_name
                    for prob_license in problematic_licenses
                ):
                    vulnerability = VulnerabilityReport(
                        vulnerability_id="license_compliance",
                        severity="medium",
                        description=f"Potentially problematic license: {license_name}",
                        file_path="requirements.txt",
                        line_number=0,
                        remediation=f"Review license compatibility for {package.get('Name', 'package')}",
                    )
                    vulnerabilities.append(vulnerability)

            return {
                "success": True,
                "vulnerabilities": [v.__dict__ for v in vulnerabilities],
                "scanner": "pip-licenses",
                "total_packages": len(licenses_data),
            }

        except Exception as e:
            return {"success": False, "error": str(e), "vulnerabilities": []}

    def scan_supply_chain(self) -> Dict[str, Any]:
        """Scan for supply chain security issues."""
        vulnerabilities = []

        # Check for pinned dependencies
        requirements_file = self.project_root / "requirements.txt"
        if requirements_file.exists():
            try:
                with open(requirements_file) as f:
                    requirements = f.read()

                unpinned_deps = []
                for line in requirements.split("\n"):
                    line = line.strip()
                    if line and not line.startswith("#"):
                        if (
                            "==" not in line
                            and ">=" not in line
                            and "<=" not in line
                            and "~=" not in line
                        ):
                            unpinned_deps.append(line.split("==")[0])

                if unpinned_deps:
                    vulnerability = VulnerabilityReport(
                        vulnerability_id="unpinned_dependencies",
                        severity="medium",
                        description=f"Unpinned dependencies detected: {', '.join(unpinned_deps)}",
                        file_path=str(requirements_file),
                        line_number=0,
                        remediation="Pin all dependencies to specific versions",
                    )
                    vulnerabilities.append(vulnerability)

            except Exception:
                pass

        return {
            "success": True,
            "vulnerabilities": [v.__dict__ for v in vulnerabilities],
            "scanner": "supply_chain_scanner",
        }

    def _map_safety_severity(self, severity: str) -> str:
        """Map safety severity to standard severity levels."""
        severity_map = {
            "high": "high",
            "medium": "medium",
            "low": "low",
            "info": "info",
        }
        return severity_map.get(severity.lower(), "medium")

    def _get_bandit_version(self) -> str:
        """Get bandit version."""
        try:
            result = subprocess.run(
                [sys.executable, "-m", "bandit", "--version"],
                capture_output=True,
                text=True,
            )
            return result.stdout.strip()
        except Exception:
            return "unknown"

    def _generate_summary(self) -> Dict[str, Any]:
        """Generate security scan summary."""
        if not self.security_metrics:
            return {}

        return {
            "total_vulnerabilities": self.security_metrics.total_vulnerabilities,
            "severity_breakdown": {
                "high": self.security_metrics.high_severity,
                "medium": self.security_metrics.medium_severity,
                "low": self.security_metrics.low_severity,
                "info": self.security_metrics.info_severity,
            },
            "risk_score": self._calculate_risk_score(),
            "scan_duration": self.security_metrics.scan_duration,
            "scan_timestamp": self.security_metrics.scan_timestamp.isoformat(),
            "recommendations": self._generate_recommendations(),
        }

    def _calculate_risk_score(self) -> float:
        """Calculate overall risk score (0-100, higher is worse)."""
        if not self.security_metrics:
            return 0.0

        # Weighted risk calculation
        high_weight = 10
        medium_weight = 5
        low_weight = 2
        info_weight = 1

        total_weighted = (
            self.security_metrics.high_severity * high_weight
            + self.security_metrics.medium_severity * medium_weight
            + self.security_metrics.low_severity * low_weight
            + self.security_metrics.info_severity * info_weight
        )

        # Normalize to 0-100 scale (max reasonable score is 50)
        return min(100.0, (total_weighted / 50.0) * 100.0)

    def _generate_recommendations(self) -> List[str]:
        """Generate security recommendations based on scan results."""
        recommendations = []

        if not self.security_metrics:
            return recommendations

        if self.security_metrics.high_severity > 0:
            recommendations.append("Address high severity vulnerabilities immediately")

        if self.security_metrics.medium_severity > 5:
            recommendations.append("Review and fix medium severity vulnerabilities")

        if self.security_metrics.total_vulnerabilities > 20:
            recommendations.append(
                "Consider implementing automated security testing in CI/CD"
            )

        recommendations.extend(
            [
                "Regularly update dependencies to latest secure versions",
                "Implement security code review process",
                "Use dependency vulnerability scanning in CI/CD pipeline",
                "Consider using a secrets management solution",
                "Implement runtime security monitoring",
            ]
        )

        return recommendations

    def generate_report(self, output_file: Optional[Path] = None) -> Path:
        """Generate detailed security report."""
        scan_results = self.scan_all()

        if output_file is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = self.project_root / f"security_report_{timestamp}.json"

        with open(output_file, "w") as f:
            json.dump(scan_results, f, indent=2, default=str)

        return output_file


# CLI interface
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="SparkForge Vulnerability Scanner")
    parser.add_argument("--project-root", type=Path, help="Project root directory")
    parser.add_argument("--output", type=Path, help="Output file for report")
    parser.add_argument(
        "--format", choices=["json", "html"], default="json", help="Output format"
    )

    args = parser.parse_args()

    scanner = VulnerabilityScanner(args.project_root)
    report_file = scanner.generate_report(args.output)

    print(f"Security scan completed. Report saved to: {report_file}")

    # Print summary
    if scanner.security_metrics:
        print("\nSecurity Summary:")
        print(
            f"Total vulnerabilities: {scanner.security_metrics.total_vulnerabilities}"
        )
        print(f"High severity: {scanner.security_metrics.high_severity}")
        print(f"Medium severity: {scanner.security_metrics.medium_severity}")
        print(f"Low severity: {scanner.security_metrics.low_severity}")
        print(f"Risk score: {scanner._calculate_risk_score():.1f}/100")
