"""Process teleportation tomo datas generated by swep experiments instead of single shot results."""

import logging
from itertools import product
from typing import Literal, Union

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm

import labcodes.frog.tele_state as ts
import labcodes.frog.tele_gate as tg
from labcodes import fileio, plotter, state_disc, tomo

logger = logging.getLogger(__name__)


class qpt_tele_state:
    """For state teleportation qpt data.
    
    >>> lf = fileio.read_labrad('//XLD2-PC2/labRAD_data/crab.dir/230716.dir/230807_245_tele_fb.dir', 433)
    >>> qpt = qpt_tele_state(lf)
    >>> qpt.plot_chi()
    <Figure size 800x500 with 8 Axes>
    """
    TOMO_OPS = tuple('0xy')
    QPT_INITS = tuple('0xy1')
    def __init__(
        self,
        lf:fileio.LogFile,
        kind: Literal['fb', 'ps'] = None,
        ro_mat: np.matrix = ((1,0),(0,1)),
    ):
        self.lf = lf
        df = lf.df
        if 'run' not in df: df['run'] = 0  # For data with only one run.
        df = df.groupby('run').filter(lambda df: len(df) == 12)
        tomo_ops = [i.lower() for i in lf.conf['parameter']['-tomo_ops']]
        init_states = [i.lower() for i in lf.conf['parameter']['-init_states']]
        df['tomo_op'] = df['tomo_op'].replace(dict(enumerate(tomo_ops)))
        df['init_state'] = df['init_state'].replace(dict(enumerate(init_states)))
        self.df = df

        if kind is None:
            title = self.lf.name.title.lower()
            if '_ps' in title or '(ps)' in title:
                kind = 'ps'
            else:
                kind = 'fb'
        
        if kind == 'ps':
            self.rho_ideal = ts.rho_out_ideal_ps
            self.chi_ideal = ts.chi_ideal_ps
        elif kind == 'fb':
            self.rho_ideal = ts.rho_out_ideal_fb
            self.chi_ideal = ts.chi_ideal_fb
        else:
            raise ValueError(f'kind {kind} not recognized')
        
        self.ro_mat = np.asarray(ro_mat)
        self.selects = ('00', '01', '10', '11')
        self._rho = {select: {} for select in self.selects}
        self._chi = {select: {} for select in self.selects}
        try:
            self.constuct_all()
        except:
            logger.exception(f'failed to construct rho and chi for {self.lf.name}')

    @classmethod
    def from_ss_data(cls, folder:str, m:int, runs:int=1):
        records = []
        for run, i in tqdm(product(range(runs), range(12)), total=runs*12, desc='loading data'):
            lf = fileio.read_labrad(folder, m + i + run * 12)
            lf.df = lf.df.astype(int)
            probs = state_disc.probs_from_flags(
                [lf.df['q4_s1'], lf.df['q5_s1'], lf.df['q2_s1']],
                nlevels=2, n_qbs=3,
            )
            prob_labels = state_disc.prob_labels(nlevels=2, n_qbs=3)
            rec = {
                'init_state': cls.QPT_INITS.index(lf.conf['parameter']['-state'].lower()),
                'tomo_op': cls.TOMO_OPS.index(lf.conf['parameter']['-tomo_op'].lower()),
                'run': run,
            }
            rec.update({f'p{lb}': p for lb, p in zip(prob_labels, probs)})
            records.append(rec)
        df = pd.DataFrame.from_records(records)

        base_lf = fileio.read_labrad(folder, m)
        base_lf.df = df
        base_lf.conf['parameter']['-tomo_ops'] = cls.TOMO_OPS
        base_lf.conf['parameter']['-init_states'] = cls.QPT_INITS
        return cls(base_lf)

    def probs(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        init_state: Literal['0', 'x', 'y', '1'] = '0', 
        select: Literal['00', '01', '10', '11'] = '00',
        ro_mat: np.matrix = None,
    ) -> pd.DataFrame:
        if run == 'mean':
            vals = np.mean([self.probs(run, init_state, select).values 
                            for run in self.df['run'].unique()], axis=0)
            return pd.DataFrame(vals, index=self.probs().index, 
                                columns=self.probs().columns)
        elif run == 'ideal':
            raise ValueError('run="ideal" not supported for probs')
        
        probs = self.df.query(f'run == {run} & init_state == "{init_state}"')
        probs = probs.set_index('tomo_op').loc[self.TOMO_OPS, [f'p{select}0', f'p{select}1']]
        p_select = probs.sum(axis='columns').replace({0:np.inf})  # TODO: include this in result.
        probs = probs.divide(p_select, axis='index')
        if ro_mat is None:
            ro_mat = self.ro_mat
        else:
            ro_mat = np.asarray(ro_mat)
        probs = probs @ np.linalg.inv(ro_mat).T
        return probs

    def rho(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        init_state: Literal['0', 'x', 'y', '1'] = '0', 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run in self._rho[select]:
            if init_state in self._rho[select][run]:
                return self._rho[select][run][init_state]
            
        if run == 'mean':
            return np.mean([self.rho(run, init_state, select) 
                            for run in self.df['run'].unique()], axis=0)
        
        if run == 'ideal':
            return self.rho_ideal[select][init_state]
        
        probs = self.probs(run, init_state, select)
        return tomo.qst(probs.values)

    def chi(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = 0, 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run in self._chi[select]:
            return self._chi[select][run]
        
        if run == 'mean':
            return np.mean([self.chi(run, select) 
                            for run in self.df['run'].unique()], axis=0)
        
        if run == 'ideal':
            return self.chi_ideal[select]
        
        return tomo.qpt([self.rho(run, init, select) for init in self.QPT_INITS])
    
    def constuct_all(self) -> None:
        for run in self.df['run'].unique():
            if len(self.df.query(f'run == {run}')) != 12:
                logger.warning(f'run {run} does not have 12 tomo points')
                continue
            for select in self.selects:
                rho = {init: self.rho(run, init, select) for init in self.QPT_INITS}
                self._rho[select][run] = rho
                chi = self.chi(run, select)
                self._chi[select][run] = chi

    @property
    def Frho(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                for init in self.QPT_INITS:
                    rec[f'F{init}'] = tomo.fid_overlap(
                        self.rho(run, init, select),
                        self.rho_ideal[select][init.lower()],
                    )
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def Fchi(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                rec['Fchi'] = tomo.fid_overlap(self.chi(run, select),
                                               self.chi_ideal[select])
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def fname(self) -> fileio.LogName:
        fname = self.lf.name.copy()
        fchi_mean = self.Fchi['Fchi'].mean()
        fchi_std = self.Fchi.groupby('run')['Fchi'].mean().std()  # As previous.
        fname.title += f' Fchi_mean={fchi_mean:.2%}±{fchi_std:.2%},runs{self.df.run.max()+1}'
        return fname
    
    def dump_chi(self, fname: str = 'chi_exp.json', run='mean'):
        chi_mean = {select: self.chi(run, select) for select in self.selects}
        chi_mean['id'] = self.lf.name.id
        return fileio.data_to_json(chi_mean, fname)

    def plot_chi_4x2(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}

        fig = plt.figure(figsize=(10,5))
        fig.set_layout_engine('compressed')  # Setting tight_layout=False not working.
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r:plt.Axes = fig.add_subplot(2, 4, 2*i+1, projection='3d')
            ax_i:plt.Axes = fig.add_subplot(2, 4, 2*i+2, projection='3d')
            plotter.plot_complex_mat3d(mat, [ax_r, ax_i], cmin=-1, cmax=1)
            # Ok for run=='mean' because `fid` is linear.
            fid = tomo.fid_overlap(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}')
            for ax in ax_r, ax_i:
                ax.set_zlim(-0.5, 0.5)
                ax.set_zticks([0, 0.5])
                ax.collections[0].set_linewidth(0.2)
                ax.set_xticklabels('IXYZ')
                ax.set_yticklabels('IXYZ')
                ax.tick_params('both', pad=0, labelsize='small')
                for txt in ax.texts:
                    if abs(float(txt.get_text())) <= 5e-3: txt.remove()
                    txt.set_fontsize('x-small')
        cax = fig.add_axes([0.4, 0.48, 0.1, 0.01])
        fig.colorbar(ax_r.collections[0], cax=cax, orientation='horizontal')
        fig.suptitle(self.fname.as_plot_title(width=100))
        return fig
    
    def plot_chi(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}
        fig, axs = plt.subplots(ncols=4, nrows=2, figsize=(8, 5), sharex=True, sharey=True)
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r = axs.ravel()[2*i]
            ax_i = axs.ravel()[2*i+1]
            plotter.plot_mat(mat.real, .3, -.3, ax=ax_r, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
            plotter.plot_mat(mat.imag, .3, -.3, ax=ax_i, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
            fid = tomo.fid_overlap(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}')
        ax_r.set_xticks(range(4))
        ax_r.set_yticks(range(4))
        ax_r.set_xticklabels([])
        ax_r.set_yticklabels('IXYZ')
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        return fig
    
    def plot_rho(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        fig = plt.figure(figsize=(10, 5), layout='constrained')
        subfigs = fig.subfigures(ncols=4, nrows=1, wspace=0.02)
        for ic, select in enumerate(self.selects):
            subfig = subfigs[ic]
            fchi = tomo.fid_overlap(self.chi(run, select), self.chi_ideal[select])
            subfig.suptitle(f'select={select}, Fchi={fchi:.2%}')
            axs = subfig.subplots(ncols=2, nrows=4, sharex=True, sharey=True, gridspec_kw=dict(wspace=0))
            for ir, init in enumerate('0xy1'):
                ax_r = axs[ir, 0]
                ax_i = axs[ir, 1]
                mat = self.rho(run, init, select)
                plotter.plot_mat(mat.real, .5, -.5, ax=ax_r, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
                plotter.plot_mat(mat.imag, .5, -.5, ax=ax_i, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
                fid = tomo.fid_overlap(mat, self.rho_ideal[select][init])
                ax_r.set_ylabel(f'init={init},\nFrho={fid:.2%}')
            ax_r.set_xticks([])
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        return fig
    
    def plot_fidelity(self) -> plt.Figure:
        df = pd.concat(
            [self.Fchi.set_index(['run', 'select']), 
            self.Frho.set_index(['run', 'select'])],
            axis='columns',
        ).reset_index()

        fig, axs = plt.subplots(nrows=5, sharex=True, figsize=(6,6))
        def plot_panel(ax:plt.Axes, df:pd.DataFrame, yname:str):
            ax.plot('run', yname, data=df.query('select=="00"'), label='00')
            ax.plot('run', yname, data=df.query('select=="01"'), label='01')
            ax.plot('run', yname, data=df.query('select=="10"'), label='10')
            ax.plot('run', yname, data=df.query('select=="11"'), label='11')
            ymean = df[yname].mean()
            plotter.cursor(ax=ax, y=ymean, text=f'{ymean:.2%}', text_style=dict(ha='right'))
            ax.set_ylabel(yname)
        plot_panel(axs[0], df, 'Fchi')
        plot_panel(axs[1], df, 'F0')
        plot_panel(axs[2], df, 'Fx')
        plot_panel(axs[3], df, 'Fy')
        plot_panel(axs[4], df, 'F1')
        axs[1].legend(ncols=4, loc='center left')
        axs[-1].set_xlabel('run')
        fig.suptitle(self.fname.as_plot_title())
        return fig


class qpt_tele_gate:
    TOMO_OPS = ('00','0x','0y','x0','xx','xy','y0','yx','yy')
    QPT_INITS = ('00','0x','0y','01','x0','xx','xy','x1','y0','yx','yy','y1','10','1x','1y','11')
    """For gate teleportation qpt data."""
    def __init__(
        self,
        lf:fileio.LogFile,
        kind: Literal['fb', 'ps'] = None,
        ro_mat: np.matrix = ((1, 0, 0, 0),(0, 1, 0, 0),(0, 0, 1, 0),(0, 0, 0, 1)),
        parallel: bool = False,
    ):
        self.lf = lf
        df = lf.df.copy()
        if 'run' not in df: df['run'] = 0  # For data with only one run.
        df = df.groupby('run').filter(lambda df: len(df) == 144)
        tomo_ops = [i.lower() for i in lf.conf['parameter']['-tomo_ops']]
        init_states = [i.lower() for i in lf.conf['parameter']['-init_states']]
        df['tomo_op'] = df['tomo_op'].replace(dict(enumerate(tomo_ops)))
        df['init_state'] = df['init_state'].replace(dict(enumerate(init_states)))
        self.df = df

        if kind is None:
            title = self.lf.name.title.lower()
            if '_ps' in title or '(ps)' in title:
                kind = 'ps'
            else:
                kind = 'fb'
        
        if kind == 'ps':
            self.rho_ideal = tg.rho_out_ideal_ps
            self.chi_ideal = tg.chi_ideal_ps
        elif kind == 'fb':
            self.rho_ideal = tg.rho_out_ideal_fb
            self.chi_ideal = tg.chi_ideal_fb
        else:
            raise ValueError(f'kind {kind} not recognized')
        
        self.rho_in = "0xy1"
        self.ro_mat = np.asarray(ro_mat)
        self.selects = ('00', '01', '10', '11')
        self._rho = {select: {} for select in self.selects}
        self._chi = {select: {} for select in self.selects}
        try:
            if parallel:
                self.build_all_parallel()
            else:
                self.build_all()
        except:
            logger.exception(f'failed to construct rho and chi for {self.lf.name}')

    def probs(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = None, 
        init_state: str = '00', 
        select: Literal['00', '01', '10', '11'] = '00',
        ro_mat: np.matrix = None,
    ) -> pd.DataFrame:
        if run is None: run = self.df['run'].unique()[0]
        if run == 'mean':
            vals = np.mean([self.probs(run, init_state, select, ro_mat).values 
                            for run in self.df['run'].unique()], axis=0)
            return pd.DataFrame(vals, index=self.probs().index, 
                                columns=self.probs().columns)
        elif run == 'ideal':
            raise ValueError('run="ideal" not supported for probs')
        
        probs = self.df.query(f'run == {run} & init_state == "{init_state}"')
        probs = probs.set_index('tomo_op').loc[self.TOMO_OPS, [f'p0{select}0', f'p0{select}1', f'p1{select}0', f'p1{select}1']]
        p_select = probs.sum(axis='columns').replace({0:np.inf})  # TODO: include this in result.
        probs = probs.divide(p_select, axis='index')
        if ro_mat is None:
            ro_mat = self.ro_mat
        else:
            ro_mat = np.asarray(ro_mat)
        probs = probs @ np.linalg.inv(ro_mat).T
        return probs

    def rho(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = None,
        init_state: str = '00',
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run is None: run = self.df['run'].unique()[0]
        if run in self._rho[select]:
            if init_state in self._rho[select][run]:
                return self._rho[select][run][init_state]

        if run == 'mean':
            return np.mean([self.rho(run, init_state, select) 
                            for run in self.df['run'].unique()], axis=0)

        if run == 'ideal':
            return self.rho_ideal[select][init_state]

        probs = self.probs(run, init_state, select)
        return tomo.qst(probs.values)

    def chi(
        self, 
        run: Union[int, Literal['mean', 'ideal']] = None, 
        select: Literal['00', '01', '10', '11'] = '00',
    ) -> np.ndarray:
        if run is None: run = self.df['run'].unique()[0]
        if run in self._chi[select]:
            return self._chi[select][run]
        
        if run == 'mean':
            return np.mean([self.chi(run, select) 
                            for run in self.df['run'].unique()], axis=0)
        
        if run == 'ideal':
            return self.chi_ideal[select]
        
        return tomo.qpt([self.rho(run, init, select) for init in self.QPT_INITS],
                        self.rho_in)
    
    def build_all(self) -> None:
        for run in tqdm(self.df['run'].unique()):
            if len(self.df.query(f'run == {run}')) != 144:
                logger.warning(f'run {run} does not have 144 tomo points')
                continue
            for select in self.selects:
                rho = {init: self.rho(run, init, select) for init in self.QPT_INITS}
                self._rho[select][run] = rho
                chi = self.chi(run, select)
                self._chi[select][run] = chi

    def build_all_parallel(self) -> None:
        from joblib import Parallel, delayed
        def job(run, select) -> None:
            if len(self.df.query(f'run == {run}')) != 144:
                logger.warning(f'run {run} does not have 144 tomo points')
                return None, None
            
            rho = {init: self.rho(run, init, select) for init in self.QPT_INITS}
            self._rho[select][run] = rho
            chi = self.chi(run, select)
            self._chi[select][run] = chi
            return rho, chi

        results = Parallel(n_jobs=-3, verbose=3)(
            delayed(job)(run, select) 
            for run, select in product(self.df['run'].unique(), self.selects)
        )
        for (rho, chi), (run, select) in zip(results, product(self.df['run'].unique(), 
                                                              self.selects)):
            if rho is None: continue
            self._rho[select][run] = rho
            self._chi[select][run] = chi

    @property
    def Frho(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                for init in self.QPT_INITS:
                    rec[f'F{init}'] = tomo.fid_overlap(
                        self.rho(run, init, select),
                        self.rho_ideal[select][init.lower()],
                    )
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def Fchi(self) -> pd.DataFrame:
        records = []
        for run in self.df['run'].unique():
            for select in self.selects:
                rec = {'run': run, 'select': select}
                rec['Fchi'] = tomo.fid_overlap(self.chi(run, select),
                                               self.chi_ideal[select])
                records.append(rec)
        return pd.DataFrame.from_records(records)
    
    @property
    def fname(self) -> fileio.LogName:
        fname = self.lf.name.copy()
        fname.title = fname.title[12:]
        fchi_mean = self.Fchi['Fchi'].mean()
        fchi_std = self.Fchi.groupby('run')['Fchi'].mean().std()  # As previous.
        fname.title += f' Fchi_mean={fchi_mean:.2%}±{fchi_std:.2%},runs{self.df.run.max()+1}'
        return fname
    
    def dump_chi(self, fname: str = 'chi_exp.json', run='mean'):
        chi_mean = {select: self.chi(run, select) for select in self.selects}
        chi_mean['id'] = self.lf.name.id
        return fileio.data_to_json(chi_mean, fname)
    
    def plot_chi_4x2(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}

        fig = plt.figure(figsize=(10,4.5))
        fig.set_layout_engine('none')  # Setting tight_layout=False not working.
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r:plt.Axes = fig.add_subplot(2, 4, 2*i+1, projection='3d')
            ax_i:plt.Axes = fig.add_subplot(2, 4, 2*i+2, projection='3d')
            plotter.plot_complex_mat3d(mat, [ax_r, ax_i], cmin=-.25, cmax=.25, label=False)
            # Ok for run=='mean' because `fid` is linear.
            fid = tomo.fid_overlap(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}', y=0.92)
            for ax in ax_r, ax_i:
                ax.set_zlim(-0.25, 0.25)
                ax.set_zticks([0, 0.25])
                ax.collections[0].set_linewidth(0.2)
                ax.set_xticklabels([])
                ax.set_yticklabels([])
                ax.tick_params('z', pad=0, labelsize='x-small')

        cax = fig.add_axes([0.475, 0.5, 0.05, 0.01])
        fig.colorbar(ax_r.collections[0], cax=cax, orientation='horizontal', location='top',
                    ticks=[-.25, .25])
        fig.suptitle(self.fname.as_plot_title(width=100))
        fig.subplots_adjust(wspace=0, hspace=0)
        return fig
    
    def plot_truth_table(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        fig, axs = plt.subplots(ncols=4, figsize=(8, 3), sharex=True, sharey=True)
        fig.set_layout_engine('compressed')
        for ax, select in zip(axs, ['00', '01', '10', '11']):
            truth_table = np.vstack([
                self.probs(run=run, init_state=input, select=select).loc['00',:].values
                for input in ['00', '01', '10', '11']
            ])
            plotter.plot_mat(truth_table.T, ax=ax, zmax=1, zmin=0, cmap='Blues', 
                            omit_below=0.03, vary_size=True, fmt='{:.1%}'.format)
            ax.set_title('Select ' + select)
            ax.set_xlabel('Input')
            ax.set_xticks(np.arange(4))
            ax.set_xticklabels(['00', '01', '10', '11'])
            for txt in ax.texts:
                txt.set_fontsize('small')
        axs[0].set_ylabel('Output')
        axs[0].set_yticks(np.arange(4))
        axs[0].set_yticklabels(['00', '01', '10', '11'])
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        return fig
    
    def plot_chi(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        chi_dict = {select: self.chi(run, select) for select in self.selects}
        fmt = lambda x: f'{x*100:.1f}'
        fig, axs = plt.subplots(ncols=2, nrows=4, figsize=(8, 16), sharex=True, sharey=True)
        fig.set_layout_engine('compressed')
        for i, (select, mat) in enumerate(chi_dict.items()):
            ax_r = axs.ravel()[2*i]
            ax_i = axs.ravel()[2*i+1]
            plotter.plot_mat(mat.real, .2, -.2, ax=ax_r, vary_size=True, fmt=fmt, omit_below=5e-3)
            plotter.plot_mat(mat.imag, .2, -.2, ax=ax_i, vary_size=True, fmt=fmt, omit_below=5e-3)
            fid = tomo.fid_overlap(mat, self.chi_ideal[select])
            ax_r.set_title(f'select={select}, Fchi={fid:.2%}', fontdict=dict(fontsize='small'))
            ax_r.set_xlim(-.5, 15.5)
            ax_r.set_ylim(-.5, 15.5)
            ax_r.set_xticks(range(16))
            ax_r.set_yticks(range(16))
            ax_r.set_xticklabels([])
            ax_r.set_yticklabels([i+j for i,j in product('IXYZ', repeat=2)])
            ax_r.tick_params('both', labelsize='x-small', pad=0.1)
        for ax in axs.ravel():
            for txt in ax.texts:
                txt.set_fontsize('x-small')
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        return fig
    
    def plot_fidelity(self) -> plt.Figure:
        df = pd.concat(
            [self.Fchi.set_index(['run', 'select']), 
            self.Frho.set_index(['run', 'select'])],
            axis='columns',
        ).reset_index()

        def plot_panel(ax:plt.Axes, df:pd.DataFrame, yname:str):
            ax.plot('run', yname, data=df.query('select=="00"'), label='00')
            ax.plot('run', yname, data=df.query('select=="01"'), label='01')
            ax.plot('run', yname, data=df.query('select=="10"'), label='10')
            ax.plot('run', yname, data=df.query('select=="11"'), label='11')
            ymean = df[yname].mean()
            plotter.cursor(ax=ax, y=ymean, text=f'{ymean:.2%}', text_style=dict(ha='right'))

        fig = plt.figure(figsize=(8,6))
        fig.set_layout_engine('none')
        gs = fig.add_gridspec(5, 4, hspace=0.2, wspace=0.2)
        for i, init in enumerate(self.QPT_INITS):
            ax = fig.add_subplot(gs[i//4+1, i%4])
            plot_panel(ax, df, f'F{init}')
            ax.set_title(f'F{init}', fontdict=dict(fontsize='x-small'), y=0.9)
            ax.tick_params(axis='both', labelsize='x-small', pad=0.1)
            if i < 12:
                ax.set_xticklabels([])
            else:
                ax.set_xlabel('run', fontsize='x-small')
        ax0 = fig.add_subplot(gs[0,:], sharex=ax)
        plot_panel(ax0, df, 'Fchi')
        ax0.set_title('Fchi', fontdict=dict(fontsize='x-small'), y=0.9)
        ax0.set_xticklabels([])
        ax0.tick_params(axis='y', labelsize='x-small', pad=0.1)
        ax0.legend(loc='center left')
        fig.suptitle(self.fname.as_plot_title(width=100))
        return fig

    def plot_bell(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        fmt = lambda x: f'{x*100:.1f}'
        fig = plt.figure(figsize=(10, 5), layout='constrained')
        subfigs = fig.subfigures(ncols=4, nrows=1, hspace=0, wspace=0)
        for ic, select in enumerate(self.selects):
            subfig = subfigs[ic]
            fchi = tomo.fid_overlap(self.chi(run, select), self.chi_ideal[select])
            subfig.suptitle(f'select={select}, Fchi={fchi:.2%}')
            axs = subfig.subplots(ncols=2, nrows=4, sharex=True, sharey=True, 
                                  gridspec_kw=dict(wspace=0, hspace=0))
            for ir, init in enumerate(['y0', 'y1', 'x0', 'x1']):
                ax_r = axs[ir, 0]
                ax_i = axs[ir, 1]
                mat = self.rho(run, init, select)
                plotter.plot_mat(mat.real, .4, -.4, ax=ax_r, vary_size=True, fmt=fmt, omit_below=3e-2)
                plotter.plot_mat(mat.imag, .4, -.4, ax=ax_i, vary_size=True, fmt=fmt, omit_below=3e-2)
                fid = tomo.fid_overlap(mat, self.rho_ideal[select][init])
                ax_r.set_ylabel(f'init={init},\nFrho={fid:.2%}', fontdict=dict(fontsize='x-small'))
                ax_r.tick_params('both', labelsize='x-small', pad=0.1)
                ax_i.tick_params('both', labelsize='x-small', pad=0.1)
                for txt in ax_r.texts + ax_i.texts:
                    txt.set_fontsize('x-small')
            ax_r.set_xticks([])
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        return fig

    def plot_rho(self, run: Union[int, Literal['mean', 'ideal']] = 'mean') -> plt.Figure:
        logger.warning('large plot, very slow!')
        fig = plt.figure(figsize=(15,30), layout='constrained')
        subfigs = fig.subfigures(ncols=4, nrows=1, wspace=0.02)
        for ic, select in enumerate(self.selects):
            subfig = subfigs[ic]
            fchi = tomo.fid_overlap(self.chi(run, select), self.chi_ideal[select])
            subfig.suptitle(f'select={select}, Fchi={fchi:.2%}')
            axs = subfig.subplots(ncols=2, nrows=16, sharex=True, sharey=True, gridspec_kw=dict(wspace=0))
            for ir, init in enumerate(self.QPT_INITS):
                ax_r = axs[ir, 0]
                ax_i = axs[ir, 1]
                mat = self.rho(run, init, select)
                plotter.plot_mat(mat.real, .5, -.5, ax=ax_r, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
                plotter.plot_mat(mat.imag, .5, -.5, ax=ax_i, vary_size=True, fmt='{:.1%}'.format, omit_below=3e-3)
                fid = tomo.fid_overlap(mat, self.rho_ideal[select][init])
                ax_r.set_ylabel(f'init={init},\nFrho={fid:.2%}')
            ax_r.set_xticks([])
        fname = self.fname.copy()
        fname.title = fname.title + f' run={run}'
        fig.suptitle(fname.as_plot_title(width=100))
        return fig
