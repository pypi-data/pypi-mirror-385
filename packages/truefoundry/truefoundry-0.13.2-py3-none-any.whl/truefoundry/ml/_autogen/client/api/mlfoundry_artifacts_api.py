# coding: utf-8

"""
TrueFoundry ML API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

import re  # noqa: F401
import warnings
from typing import Optional

from truefoundry.ml._autogen.client.api_client import ApiClient
from truefoundry.ml._autogen.client.api_response import ApiResponse
from truefoundry.ml._autogen.client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)
from truefoundry.ml._autogen.client.models.apply_request_dto import ApplyRequestDto
from truefoundry.ml._autogen.client.models.apply_response_dto import ApplyResponseDto
from truefoundry.ml._autogen.client.models.artifact_response_dto import (
    ArtifactResponseDto,
)
from truefoundry.ml._autogen.client.models.artifact_type import ArtifactType
from truefoundry.ml._autogen.client.models.artifact_version_response_dto import (
    ArtifactVersionResponseDto,
)
from truefoundry.ml._autogen.client.models.authorize_user_for_model_request_dto import (
    AuthorizeUserForModelRequestDto,
)
from truefoundry.ml._autogen.client.models.authorize_user_for_model_version_request_dto import (
    AuthorizeUserForModelVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.create_artifact_request_dto import (
    CreateArtifactRequestDto,
)
from truefoundry.ml._autogen.client.models.create_artifact_response_dto import (
    CreateArtifactResponseDto,
)
from truefoundry.ml._autogen.client.models.create_artifact_version_request_dto import (
    CreateArtifactVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.create_artifact_version_response_dto import (
    CreateArtifactVersionResponseDto,
)
from truefoundry.ml._autogen.client.models.create_dataset_request_dto import (
    CreateDatasetRequestDto,
)
from truefoundry.ml._autogen.client.models.create_model_version_request_dto import (
    CreateModelVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.create_multi_part_upload_for_dataset_request_dto import (
    CreateMultiPartUploadForDatasetRequestDto,
)
from truefoundry.ml._autogen.client.models.create_multi_part_upload_for_dataset_response_dto import (
    CreateMultiPartUploadForDatasetResponseDto,
)
from truefoundry.ml._autogen.client.models.create_multi_part_upload_request_dto import (
    CreateMultiPartUploadRequestDto,
)
from truefoundry.ml._autogen.client.models.dataset_response_dto import (
    DatasetResponseDto,
)
from truefoundry.ml._autogen.client.models.delete_artifact_versions_request_dto import (
    DeleteArtifactVersionsRequestDto,
)
from truefoundry.ml._autogen.client.models.delete_dataset_request_dto import (
    DeleteDatasetRequestDto,
)
from truefoundry.ml._autogen.client.models.delete_files_for_dataset_request_dto import (
    DeleteFilesForDatasetRequestDto,
)
from truefoundry.ml._autogen.client.models.delete_model_version_request_dto import (
    DeleteModelVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.export_deployment_files_request_dto import (
    ExportDeploymentFilesRequestDto,
)
from truefoundry.ml._autogen.client.models.finalize_artifact_version_request_dto import (
    FinalizeArtifactVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.get_artifact_version_aliases_response_dto import (
    GetArtifactVersionAliasesResponseDto,
)
from truefoundry.ml._autogen.client.models.get_signed_url_for_dataset_write_request_dto import (
    GetSignedURLForDatasetWriteRequestDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_artifact_version_read_request_dto import (
    GetSignedURLsForArtifactVersionReadRequestDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_artifact_version_read_response_dto import (
    GetSignedURLsForArtifactVersionReadResponseDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_artifact_version_write_request_dto import (
    GetSignedURLsForArtifactVersionWriteRequestDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_artifact_version_write_response_dto import (
    GetSignedURLsForArtifactVersionWriteResponseDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_dataset_read_request_dto import (
    GetSignedURLsForDatasetReadRequestDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_dataset_read_response_dto import (
    GetSignedURLsForDatasetReadResponseDto,
)
from truefoundry.ml._autogen.client.models.get_signed_urls_for_dataset_write_response_dto import (
    GetSignedURLsForDatasetWriteResponseDto,
)
from truefoundry.ml._autogen.client.models.list_artifact_versions_request_dto import (
    ListArtifactVersionsRequestDto,
)
from truefoundry.ml._autogen.client.models.list_artifact_versions_response_dto import (
    ListArtifactVersionsResponseDto,
)
from truefoundry.ml._autogen.client.models.list_artifacts_request_dto import (
    ListArtifactsRequestDto,
)
from truefoundry.ml._autogen.client.models.list_artifacts_response_dto import (
    ListArtifactsResponseDto,
)
from truefoundry.ml._autogen.client.models.list_datasets_request_dto import (
    ListDatasetsRequestDto,
)
from truefoundry.ml._autogen.client.models.list_datasets_response_dto import (
    ListDatasetsResponseDto,
)
from truefoundry.ml._autogen.client.models.list_files_for_artifact_version_request_dto import (
    ListFilesForArtifactVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.list_files_for_artifact_versions_response_dto import (
    ListFilesForArtifactVersionsResponseDto,
)
from truefoundry.ml._autogen.client.models.list_files_for_dataset_request_dto import (
    ListFilesForDatasetRequestDto,
)
from truefoundry.ml._autogen.client.models.list_files_for_dataset_response_dto import (
    ListFilesForDatasetResponseDto,
)
from truefoundry.ml._autogen.client.models.list_model_version_response_dto import (
    ListModelVersionResponseDto,
)
from truefoundry.ml._autogen.client.models.list_model_versions_request_dto import (
    ListModelVersionsRequestDto,
)
from truefoundry.ml._autogen.client.models.list_models_request_dto import (
    ListModelsRequestDto,
)
from truefoundry.ml._autogen.client.models.list_models_response_dto import (
    ListModelsResponseDto,
)
from truefoundry.ml._autogen.client.models.model_response_dto import ModelResponseDto
from truefoundry.ml._autogen.client.models.model_version_response_dto import (
    ModelVersionResponseDto,
)
from truefoundry.ml._autogen.client.models.multi_part_upload_response_dto import (
    MultiPartUploadResponseDto,
)
from truefoundry.ml._autogen.client.models.notify_artifact_version_failure_dto import (
    NotifyArtifactVersionFailureDto,
)
from truefoundry.ml._autogen.client.models.resolve_agent_app_response_dto import (
    ResolveAgentAppResponseDto,
)
from truefoundry.ml._autogen.client.models.update_artifact_version_request_dto import (
    UpdateArtifactVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.update_dataset_request_dto import (
    UpdateDatasetRequestDto,
)
from truefoundry.ml._autogen.client.models.update_model_version_request_dto import (
    UpdateModelVersionRequestDto,
)
from truefoundry.ml._autogen.client.models.validate_external_storage_root_request_dto import (
    ValidateExternalStorageRootRequestDto,
)
from truefoundry.ml._autogen.client.models.validate_external_storage_root_response_dto import (
    ValidateExternalStorageRootResponseDto,
)
from truefoundry.pydantic_v1 import (
    StrictInt,
    StrictStr,
    validate_arguments,
)


class MlfoundryArtifactsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def apply_manifest_put(
        self, apply_request_dto: ApplyRequestDto, **kwargs
    ) -> ApplyResponseDto:  # noqa: E501
        """(Deprecated) Apply Manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.apply_manifest_put(apply_request_dto, async_req=True)
        >>> result = thread.get()

        :param apply_request_dto: (required)
        :type apply_request_dto: ApplyRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApplyResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the apply_manifest_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.apply_manifest_put_with_http_info(apply_request_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def apply_manifest_put_with_http_info(
        self, apply_request_dto: ApplyRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Apply Manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.apply_manifest_put_with_http_info(apply_request_dto, async_req=True)
        >>> result = thread.get()

        :param apply_request_dto: (required)
        :type apply_request_dto: ApplyRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApplyResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "PUT /api/2.0/mlflow/mlfoundry-artifacts/apply is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["apply_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_manifest_put" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["apply_request_dto"] is not None:
            _body_params = _params["apply_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ApplyResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/apply",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def authorize_user_for_model_post(
        self,
        authorize_user_for_model_request_dto: AuthorizeUserForModelRequestDto,
        **kwargs,
    ) -> object:  # noqa: E501
        """(Deprecated) Authorize User For Model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.authorize_user_for_model_post(authorize_user_for_model_request_dto, async_req=True)
        >>> result = thread.get()

        :param authorize_user_for_model_request_dto: (required)
        :type authorize_user_for_model_request_dto: AuthorizeUserForModelRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the authorize_user_for_model_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.authorize_user_for_model_post_with_http_info(
            authorize_user_for_model_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def authorize_user_for_model_post_with_http_info(
        self,
        authorize_user_for_model_request_dto: AuthorizeUserForModelRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Authorize User For Model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.authorize_user_for_model_post_with_http_info(authorize_user_for_model_request_dto, async_req=True)
        >>> result = thread.get()

        :param authorize_user_for_model_request_dto: (required)
        :type authorize_user_for_model_request_dto: AuthorizeUserForModelRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/models/authorize is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["authorize_user_for_model_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_user_for_model_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["authorize_user_for_model_request_dto"] is not None:
            _body_params = _params["authorize_user_for_model_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/models/authorize",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def authorize_user_for_model_version_post(
        self,
        authorize_user_for_model_version_request_dto: AuthorizeUserForModelVersionRequestDto,
        **kwargs,
    ) -> object:  # noqa: E501
        """(Deprecated) Authorize User For Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.authorize_user_for_model_version_post(authorize_user_for_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param authorize_user_for_model_version_request_dto: (required)
        :type authorize_user_for_model_version_request_dto: AuthorizeUserForModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the authorize_user_for_model_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.authorize_user_for_model_version_post_with_http_info(
            authorize_user_for_model_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def authorize_user_for_model_version_post_with_http_info(
        self,
        authorize_user_for_model_version_request_dto: AuthorizeUserForModelVersionRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Authorize User For Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.authorize_user_for_model_version_post_with_http_info(authorize_user_for_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param authorize_user_for_model_version_request_dto: (required)
        :type authorize_user_for_model_version_request_dto: AuthorizeUserForModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/model-versions/authorize is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["authorize_user_for_model_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize_user_for_model_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["authorize_user_for_model_version_request_dto"] is not None:
            _body_params = _params["authorize_user_for_model_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/authorize",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_artifact_post(
        self, create_artifact_request_dto: CreateArtifactRequestDto, **kwargs
    ) -> CreateArtifactResponseDto:  # noqa: E501
        """(Deprecated) Create Artifact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_artifact_post(create_artifact_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_artifact_request_dto: (required)
        :type create_artifact_request_dto: CreateArtifactRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateArtifactResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_artifact_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_artifact_post_with_http_info(
            create_artifact_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_artifact_post_with_http_info(
        self, create_artifact_request_dto: CreateArtifactRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Create Artifact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_artifact_post_with_http_info(create_artifact_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_artifact_request_dto: (required)
        :type create_artifact_request_dto: CreateArtifactRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateArtifactResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifacts/create is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["create_artifact_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_artifact_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_artifact_request_dto"] is not None:
            _body_params = _params["create_artifact_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "CreateArtifactResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifacts/create",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_artifact_version_post(
        self,
        create_artifact_version_request_dto: CreateArtifactVersionRequestDto,
        **kwargs,
    ) -> CreateArtifactVersionResponseDto:  # noqa: E501
        """(Deprecated) Create Artifact Version  # noqa: E501

        Create artifact version API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_artifact_version_post(create_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_artifact_version_request_dto: (required)
        :type create_artifact_version_request_dto: CreateArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateArtifactVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_artifact_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_artifact_version_post_with_http_info(
            create_artifact_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_artifact_version_post_with_http_info(
        self,
        create_artifact_version_request_dto: CreateArtifactVersionRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Create Artifact Version  # noqa: E501

        Create artifact version API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_artifact_version_post_with_http_info(create_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_artifact_version_request_dto: (required)
        :type create_artifact_version_request_dto: CreateArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateArtifactVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/create is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["create_artifact_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_artifact_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_artifact_version_request_dto"] is not None:
            _body_params = _params["create_artifact_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "CreateArtifactVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/create",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_dataset_post(
        self, create_dataset_request_dto: CreateDatasetRequestDto, **kwargs
    ) -> DatasetResponseDto:  # noqa: E501
        """(Deprecated) Create Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_dataset_post(create_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_dataset_request_dto: (required)
        :type create_dataset_request_dto: CreateDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DatasetResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_dataset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_dataset_post_with_http_info(
            create_dataset_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_dataset_post_with_http_info(
        self, create_dataset_request_dto: CreateDatasetRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Create Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_dataset_post_with_http_info(create_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_dataset_request_dto: (required)
        :type create_dataset_request_dto: CreateDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DatasetResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/create is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["create_dataset_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_dataset_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_dataset_request_dto"] is not None:
            _body_params = _params["create_dataset_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "DatasetResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/create",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_model_version_post(
        self, create_model_version_request_dto: CreateModelVersionRequestDto, **kwargs
    ) -> ModelVersionResponseDto:  # noqa: E501
        """(Deprecated) Create Model Version  # noqa: E501

        Create Models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_model_version_post(create_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_model_version_request_dto: (required)
        :type create_model_version_request_dto: CreateModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_model_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_model_version_post_with_http_info(
            create_model_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_model_version_post_with_http_info(
        self, create_model_version_request_dto: CreateModelVersionRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Create Model Version  # noqa: E501

        Create Models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_model_version_post_with_http_info(create_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_model_version_request_dto: (required)
        :type create_model_version_request_dto: CreateModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/model-versions/create is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["create_model_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_model_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_model_version_request_dto"] is not None:
            _body_params = _params["create_model_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/create",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_multi_part_upload_post(
        self,
        create_multi_part_upload_request_dto: CreateMultiPartUploadRequestDto,
        **kwargs,
    ) -> MultiPartUploadResponseDto:  # noqa: E501
        """(Deprecated) Create Multi Part Upload  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_multi_part_upload_post(create_multi_part_upload_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_multi_part_upload_request_dto: (required)
        :type create_multi_part_upload_request_dto: CreateMultiPartUploadRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MultiPartUploadResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_multi_part_upload_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_multi_part_upload_post_with_http_info(
            create_multi_part_upload_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_multi_part_upload_post_with_http_info(
        self,
        create_multi_part_upload_request_dto: CreateMultiPartUploadRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Create Multi Part Upload  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_multi_part_upload_post_with_http_info(create_multi_part_upload_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_multi_part_upload_request_dto: (required)
        :type create_multi_part_upload_request_dto: CreateMultiPartUploadRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MultiPartUploadResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/multi-part-upload/create is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["create_multi_part_upload_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multi_part_upload_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_multi_part_upload_request_dto"] is not None:
            _body_params = _params["create_multi_part_upload_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "MultiPartUploadResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/multi-part-upload/create",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_multipart_upload_for_dataset_post(
        self,
        create_multi_part_upload_for_dataset_request_dto: CreateMultiPartUploadForDatasetRequestDto,
        **kwargs,
    ) -> CreateMultiPartUploadForDatasetResponseDto:  # noqa: E501
        """(Deprecated) Create Multipart Upload For Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_multipart_upload_for_dataset_post(create_multi_part_upload_for_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_multi_part_upload_for_dataset_request_dto: (required)
        :type create_multi_part_upload_for_dataset_request_dto: CreateMultiPartUploadForDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateMultiPartUploadForDatasetResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_multipart_upload_for_dataset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_multipart_upload_for_dataset_post_with_http_info(
            create_multi_part_upload_for_dataset_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_multipart_upload_for_dataset_post_with_http_info(
        self,
        create_multi_part_upload_for_dataset_request_dto: CreateMultiPartUploadForDatasetRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Create Multipart Upload For Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_multipart_upload_for_dataset_post_with_http_info(create_multi_part_upload_for_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param create_multi_part_upload_for_dataset_request_dto: (required)
        :type create_multi_part_upload_for_dataset_request_dto: CreateMultiPartUploadForDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateMultiPartUploadForDatasetResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/multi-part-upload/create is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["create_multi_part_upload_for_dataset_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multipart_upload_for_dataset_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_multi_part_upload_for_dataset_request_dto"] is not None:
            _body_params = _params["create_multi_part_upload_for_dataset_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "CreateMultiPartUploadForDatasetResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/multi-part-upload/create",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_artifact_post(
        self, delete_model_version_request_dto: DeleteModelVersionRequestDto, **kwargs
    ) -> object:  # noqa: E501
        """(Deprecated) Delete Artifact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_artifact_post(delete_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_model_version_request_dto: (required)
        :type delete_model_version_request_dto: DeleteModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_artifact_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_artifact_post_with_http_info(
            delete_model_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_artifact_post_with_http_info(
        self, delete_model_version_request_dto: DeleteModelVersionRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Delete Artifact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_artifact_post_with_http_info(delete_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_model_version_request_dto: (required)
        :type delete_model_version_request_dto: DeleteModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact/delete is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["delete_model_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_artifact_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["delete_model_version_request_dto"] is not None:
            _body_params = _params["delete_model_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact/delete",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_artifact_version_post(
        self,
        delete_artifact_versions_request_dto: DeleteArtifactVersionsRequestDto,
        **kwargs,
    ) -> object:  # noqa: E501
        """(Deprecated) Delete Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_artifact_version_post(delete_artifact_versions_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_artifact_versions_request_dto: (required)
        :type delete_artifact_versions_request_dto: DeleteArtifactVersionsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_artifact_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_artifact_version_post_with_http_info(
            delete_artifact_versions_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_artifact_version_post_with_http_info(
        self,
        delete_artifact_versions_request_dto: DeleteArtifactVersionsRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Delete Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_artifact_version_post_with_http_info(delete_artifact_versions_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_artifact_versions_request_dto: (required)
        :type delete_artifact_versions_request_dto: DeleteArtifactVersionsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/delete is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["delete_artifact_versions_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_artifact_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["delete_artifact_versions_request_dto"] is not None:
            _body_params = _params["delete_artifact_versions_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/delete",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_dataset_post(
        self, delete_dataset_request_dto: DeleteDatasetRequestDto, **kwargs
    ) -> object:  # noqa: E501
        """(Deprecated) Delete Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_dataset_post(delete_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_dataset_request_dto: (required)
        :type delete_dataset_request_dto: DeleteDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_dataset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_dataset_post_with_http_info(
            delete_dataset_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_dataset_post_with_http_info(
        self, delete_dataset_request_dto: DeleteDatasetRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Delete Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_dataset_post_with_http_info(delete_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_dataset_request_dto: (required)
        :type delete_dataset_request_dto: DeleteDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/delete is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["delete_dataset_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dataset_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["delete_dataset_request_dto"] is not None:
            _body_params = _params["delete_dataset_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/delete",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_files_for_dataset_delete(
        self,
        delete_files_for_dataset_request_dto: DeleteFilesForDatasetRequestDto,
        **kwargs,
    ) -> object:  # noqa: E501
        """(Deprecated) Delete Files For Dataset  # noqa: E501

        Delete files from the dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_files_for_dataset_delete(delete_files_for_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_files_for_dataset_request_dto: (required)
        :type delete_files_for_dataset_request_dto: DeleteFilesForDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_files_for_dataset_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_files_for_dataset_delete_with_http_info(
            delete_files_for_dataset_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_files_for_dataset_delete_with_http_info(
        self,
        delete_files_for_dataset_request_dto: DeleteFilesForDatasetRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Delete Files For Dataset  # noqa: E501

        Delete files from the dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_files_for_dataset_delete_with_http_info(delete_files_for_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_files_for_dataset_request_dto: (required)
        :type delete_files_for_dataset_request_dto: DeleteFilesForDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "DELETE /api/2.0/mlflow/mlfoundry-artifacts/datasets/files/ is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["delete_files_for_dataset_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_files_for_dataset_delete" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["delete_files_for_dataset_request_dto"] is not None:
            _body_params = _params["delete_files_for_dataset_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/files/",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_model_version_post(
        self, delete_model_version_request_dto: DeleteModelVersionRequestDto, **kwargs
    ) -> object:  # noqa: E501
        """(Deprecated) Delete Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_model_version_post(delete_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_model_version_request_dto: (required)
        :type delete_model_version_request_dto: DeleteModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_model_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_model_version_post_with_http_info(
            delete_model_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def delete_model_version_post_with_http_info(
        self, delete_model_version_request_dto: DeleteModelVersionRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Delete Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_model_version_post_with_http_info(delete_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param delete_model_version_request_dto: (required)
        :type delete_model_version_request_dto: DeleteModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/model-versions/delete is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["delete_model_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["delete_model_version_request_dto"] is not None:
            _body_params = _params["delete_model_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/delete",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def export_deployment_files_by_fqn_post(
        self,
        export_deployment_files_request_dto: ExportDeploymentFilesRequestDto,
        **kwargs,
    ) -> object:  # noqa: E501
        """(Deprecated) Export Deployment Files By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_deployment_files_by_fqn_post(export_deployment_files_request_dto, async_req=True)
        >>> result = thread.get()

        :param export_deployment_files_request_dto: (required)
        :type export_deployment_files_request_dto: ExportDeploymentFilesRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the export_deployment_files_by_fqn_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.export_deployment_files_by_fqn_post_with_http_info(
            export_deployment_files_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def export_deployment_files_by_fqn_post_with_http_info(
        self,
        export_deployment_files_request_dto: ExportDeploymentFilesRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Export Deployment Files By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.export_deployment_files_by_fqn_post_with_http_info(export_deployment_files_request_dto, async_req=True)
        >>> result = thread.get()

        :param export_deployment_files_request_dto: (required)
        :type export_deployment_files_request_dto: ExportDeploymentFilesRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/model-versions/export-deployment-files-by-fqn is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["export_deployment_files_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_deployment_files_by_fqn_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["export_deployment_files_request_dto"] is not None:
            _body_params = _params["export_deployment_files_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json", "application/zip"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/export-deployment-files-by-fqn",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def finalize_artifact_version_post(
        self,
        finalize_artifact_version_request_dto: FinalizeArtifactVersionRequestDto,
        **kwargs,
    ) -> ArtifactVersionResponseDto:  # noqa: E501
        """(Deprecated) Finalize Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.finalize_artifact_version_post(finalize_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param finalize_artifact_version_request_dto: (required)
        :type finalize_artifact_version_request_dto: FinalizeArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the finalize_artifact_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.finalize_artifact_version_post_with_http_info(
            finalize_artifact_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def finalize_artifact_version_post_with_http_info(
        self,
        finalize_artifact_version_request_dto: FinalizeArtifactVersionRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Finalize Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.finalize_artifact_version_post_with_http_info(finalize_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param finalize_artifact_version_request_dto: (required)
        :type finalize_artifact_version_request_dto: FinalizeArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/finalize is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["finalize_artifact_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finalize_artifact_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["finalize_artifact_version_request_dto"] is not None:
            _body_params = _params["finalize_artifact_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/finalize",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_artifact_by_fqn_get(self, fqn: StrictStr, **kwargs) -> ArtifactResponseDto:  # noqa: E501
        """(Deprecated) Get Artifact By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_by_fqn_get(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_artifact_by_fqn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_artifact_by_fqn_get_with_http_info(fqn, **kwargs)  # noqa: E501

    @validate_arguments
    def get_artifact_by_fqn_get_with_http_info(
        self, fqn: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Artifact By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_by_fqn_get_with_http_info(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/artifacts/get-by-fqn is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["fqn"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_artifact_by_fqn_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("fqn") is not None:  # noqa: E501
            _query_params.append(("fqn", _params["fqn"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifacts/get-by-fqn",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_artifact_by_id_get(self, id: StrictStr, **kwargs) -> ArtifactResponseDto:  # noqa: E501
        """(Deprecated) Get Artifact By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_by_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_artifact_by_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_artifact_by_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_artifact_by_id_get_with_http_info(
        self, id: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Artifact By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_by_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/artifacts/get is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_artifact_by_id_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifacts/get",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_artifact_version_by_fqn_get(
        self, fqn: StrictStr, **kwargs
    ) -> ArtifactVersionResponseDto:  # noqa: E501
        """(Deprecated) Get Artifact Version By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_version_by_fqn_get(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_artifact_version_by_fqn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_artifact_version_by_fqn_get_with_http_info(fqn, **kwargs)  # noqa: E501

    @validate_arguments
    def get_artifact_version_by_fqn_get_with_http_info(
        self, fqn: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Artifact Version By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_version_by_fqn_get_with_http_info(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-by-fqn is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["fqn"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_artifact_version_by_fqn_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("fqn") is not None:  # noqa: E501
            _query_params.append(("fqn", _params["fqn"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-by-fqn",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_artifact_version_by_id_get(
        self, id: StrictStr, **kwargs
    ) -> ArtifactVersionResponseDto:  # noqa: E501
        """(Deprecated) Get Artifact Version By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_version_by_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_artifact_version_by_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_artifact_version_by_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_artifact_version_by_id_get_with_http_info(
        self, id: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Artifact Version By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_version_by_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_artifact_version_by_id_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_artifact_version_by_name_get(
        self,
        experiment_id: StrictInt,
        artifact_name: StrictStr,
        version: Optional[StrictInt] = None,
        artifact_type: Optional[ArtifactType] = None,
        **kwargs,
    ) -> ArtifactVersionResponseDto:  # noqa: E501
        """(Deprecated) Get Artifact Version By Name  # noqa: E501

        Get artifact version API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_version_by_name_get(experiment_id, artifact_name, version, artifact_type, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param artifact_name: (required)
        :type artifact_name: str
        :param version:
        :type version: int
        :param artifact_type:
        :type artifact_type: ArtifactType
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_artifact_version_by_name_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_artifact_version_by_name_get_with_http_info(
            experiment_id, artifact_name, version, artifact_type, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_artifact_version_by_name_get_with_http_info(
        self,
        experiment_id: StrictInt,
        artifact_name: StrictStr,
        version: Optional[StrictInt] = None,
        artifact_type: Optional[ArtifactType] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Artifact Version By Name  # noqa: E501

        Get artifact version API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_artifact_version_by_name_get_with_http_info(experiment_id, artifact_name, version, artifact_type, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param artifact_name: (required)
        :type artifact_name: str
        :param version:
        :type version: int
        :param artifact_type:
        :type artifact_type: ArtifactType
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-by-name is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["experiment_id", "artifact_name", "version", "artifact_type"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_artifact_version_by_name_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("experiment_id") is not None:  # noqa: E501
            _query_params.append(("experiment_id", _params["experiment_id"]))

        if _params.get("artifact_name") is not None:  # noqa: E501
            _query_params.append(("artifact_name", _params["artifact_name"]))

        if _params.get("version") is not None:  # noqa: E501
            _query_params.append(("version", _params["version"]))

        if _params.get("artifact_type") is not None:  # noqa: E501
            _query_params.append(("artifact_type", _params["artifact_type"].value))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-by-name",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_dataset_by_fqn_get(self, fqn: StrictStr, **kwargs) -> DatasetResponseDto:  # noqa: E501
        """(Deprecated) Get Dataset By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_dataset_by_fqn_get(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DatasetResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_dataset_by_fqn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_dataset_by_fqn_get_with_http_info(fqn, **kwargs)  # noqa: E501

    @validate_arguments
    def get_dataset_by_fqn_get_with_http_info(
        self, fqn: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Dataset By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_dataset_by_fqn_get_with_http_info(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DatasetResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/datasets/get-by-fqn is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["fqn"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_by_fqn_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("fqn") is not None:  # noqa: E501
            _query_params.append(("fqn", _params["fqn"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "DatasetResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/get-by-fqn",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_dataset_get(self, id: StrictStr, **kwargs) -> DatasetResponseDto:  # noqa: E501
        """(Deprecated) Get Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_dataset_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DatasetResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_dataset_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_dataset_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_dataset_get_with_http_info(self, id: StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_dataset_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DatasetResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/datasets/get is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "DatasetResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/get",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_model_by_fqn_get(self, fqn: StrictStr, **kwargs) -> ModelResponseDto:  # noqa: E501
        """(Deprecated) Get Model By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_by_fqn_get(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_model_by_fqn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_model_by_fqn_get_with_http_info(fqn, **kwargs)  # noqa: E501

    @validate_arguments
    def get_model_by_fqn_get_with_http_info(
        self, fqn: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Model By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_by_fqn_get_with_http_info(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/models/get-by-fqn is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["fqn"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_by_fqn_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("fqn") is not None:  # noqa: E501
            _query_params.append(("fqn", _params["fqn"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/models/get-by-fqn",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_model_by_name_get(
        self, experiment_id: StrictInt, name: StrictStr, **kwargs
    ) -> ModelResponseDto:  # noqa: E501
        """(Deprecated) Get Model By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_by_name_get(experiment_id, name, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param name: (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_model_by_name_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_model_by_name_get_with_http_info(experiment_id, name, **kwargs)  # noqa: E501

    @validate_arguments
    def get_model_by_name_get_with_http_info(
        self, experiment_id: StrictInt, name: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Model By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_by_name_get_with_http_info(experiment_id, name, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param name: (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/models/get-by-name is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["experiment_id", "name"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_by_name_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("experiment_id") is not None:  # noqa: E501
            _query_params.append(("experiment_id", _params["experiment_id"]))

        if _params.get("name") is not None:  # noqa: E501
            _query_params.append(("name", _params["name"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/models/get-by-name",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_model_get(self, id: StrictStr, **kwargs) -> ModelResponseDto:  # noqa: E501
        """(Deprecated) Get Model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_model_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_model_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_model_get_with_http_info(self, id: StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/models/get is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/models/get",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_model_version_by_fqn_get(
        self, fqn: StrictStr, **kwargs
    ) -> ModelVersionResponseDto:  # noqa: E501
        """(Deprecated) Get Model Version By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_version_by_fqn_get(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_model_version_by_fqn_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_model_version_by_fqn_get_with_http_info(fqn, **kwargs)  # noqa: E501

    @validate_arguments
    def get_model_version_by_fqn_get_with_http_info(
        self, fqn: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Model Version By Fqn  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_version_by_fqn_get_with_http_info(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/model-versions/get-by-fqn is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["fqn"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_version_by_fqn_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("fqn") is not None:  # noqa: E501
            _query_params.append(("fqn", _params["fqn"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/get-by-fqn",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_model_version_by_name_get(
        self,
        experiment_id: StrictInt,
        model_name: Optional[StrictStr] = None,
        version: Optional[StrictInt] = None,
        name: Optional[StrictStr] = None,
        **kwargs,
    ) -> ModelVersionResponseDto:  # noqa: E501
        """(Deprecated) Get Model Version By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_version_by_name_get(experiment_id, model_name, version, name, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param model_name:
        :type model_name: str
        :param version:
        :type version: int
        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_model_version_by_name_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_model_version_by_name_get_with_http_info(
            experiment_id, model_name, version, name, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_model_version_by_name_get_with_http_info(
        self,
        experiment_id: StrictInt,
        model_name: Optional[StrictStr] = None,
        version: Optional[StrictInt] = None,
        name: Optional[StrictStr] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Model Version By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_version_by_name_get_with_http_info(experiment_id, model_name, version, name, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param model_name:
        :type model_name: str
        :param version:
        :type version: int
        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/model-versions/get-by-name is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["experiment_id", "model_name", "version", "name"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_version_by_name_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("experiment_id") is not None:  # noqa: E501
            _query_params.append(("experiment_id", _params["experiment_id"]))

        if _params.get("model_name") is not None:  # noqa: E501
            _query_params.append(("model_name", _params["model_name"]))

        if _params.get("version") is not None:  # noqa: E501
            _query_params.append(("version", _params["version"]))

        if _params.get("name") is not None:  # noqa: E501
            _query_params.append(("name", _params["name"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/get-by-name",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_model_version_get(self, id: StrictStr, **kwargs) -> ModelVersionResponseDto:  # noqa: E501
        """(Deprecated) Get Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_version_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_model_version_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_model_version_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_model_version_get_with_http_info(
        self, id: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_model_version_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/model-versions/get is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_version_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/get",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_signed_urls_dataset_read_post(
        self,
        get_signed_urls_for_dataset_read_request_dto: GetSignedURLsForDatasetReadRequestDto,
        **kwargs,
    ) -> GetSignedURLsForDatasetReadResponseDto:  # noqa: E501
        """(Deprecated) Get Signed Urls Dataset Read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_dataset_read_post(get_signed_urls_for_dataset_read_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_urls_for_dataset_read_request_dto: (required)
        :type get_signed_urls_for_dataset_read_request_dto: GetSignedURLsForDatasetReadRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSignedURLsForDatasetReadResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_signed_urls_dataset_read_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_signed_urls_dataset_read_post_with_http_info(
            get_signed_urls_for_dataset_read_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_signed_urls_dataset_read_post_with_http_info(
        self,
        get_signed_urls_for_dataset_read_request_dto: GetSignedURLsForDatasetReadRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Signed Urls Dataset Read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_dataset_read_post_with_http_info(get_signed_urls_for_dataset_read_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_urls_for_dataset_read_request_dto: (required)
        :type get_signed_urls_for_dataset_read_request_dto: GetSignedURLsForDatasetReadRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSignedURLsForDatasetReadResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/get-signed-urls-for-read is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["get_signed_urls_for_dataset_read_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_signed_urls_dataset_read_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["get_signed_urls_for_dataset_read_request_dto"] is not None:
            _body_params = _params["get_signed_urls_for_dataset_read_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "GetSignedURLsForDatasetReadResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/get-signed-urls-for-read",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_signed_urls_for_dataset_write_post(
        self,
        get_signed_url_for_dataset_write_request_dto: GetSignedURLForDatasetWriteRequestDto,
        **kwargs,
    ) -> GetSignedURLsForDatasetWriteResponseDto:  # noqa: E501
        """(Deprecated) Get Signed Urls For Dataset Write  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_for_dataset_write_post(get_signed_url_for_dataset_write_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_url_for_dataset_write_request_dto: (required)
        :type get_signed_url_for_dataset_write_request_dto: GetSignedURLForDatasetWriteRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSignedURLsForDatasetWriteResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_signed_urls_for_dataset_write_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_signed_urls_for_dataset_write_post_with_http_info(
            get_signed_url_for_dataset_write_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_signed_urls_for_dataset_write_post_with_http_info(
        self,
        get_signed_url_for_dataset_write_request_dto: GetSignedURLForDatasetWriteRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Signed Urls For Dataset Write  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_for_dataset_write_post_with_http_info(get_signed_url_for_dataset_write_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_url_for_dataset_write_request_dto: (required)
        :type get_signed_url_for_dataset_write_request_dto: GetSignedURLForDatasetWriteRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSignedURLsForDatasetWriteResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/get-signed-urls-for-write is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["get_signed_url_for_dataset_write_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_signed_urls_for_dataset_write_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["get_signed_url_for_dataset_write_request_dto"] is not None:
            _body_params = _params["get_signed_url_for_dataset_write_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "GetSignedURLsForDatasetWriteResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/get-signed-urls-for-write",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_signed_urls_for_read_post(
        self,
        get_signed_urls_for_artifact_version_read_request_dto: GetSignedURLsForArtifactVersionReadRequestDto,
        **kwargs,
    ) -> GetSignedURLsForArtifactVersionReadResponseDto:  # noqa: E501
        """(Deprecated) Get Signed Urls For Read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_for_read_post(get_signed_urls_for_artifact_version_read_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_urls_for_artifact_version_read_request_dto: (required)
        :type get_signed_urls_for_artifact_version_read_request_dto: GetSignedURLsForArtifactVersionReadRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSignedURLsForArtifactVersionReadResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_signed_urls_for_read_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_signed_urls_for_read_post_with_http_info(
            get_signed_urls_for_artifact_version_read_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_signed_urls_for_read_post_with_http_info(
        self,
        get_signed_urls_for_artifact_version_read_request_dto: GetSignedURLsForArtifactVersionReadRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Signed Urls For Read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_for_read_post_with_http_info(get_signed_urls_for_artifact_version_read_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_urls_for_artifact_version_read_request_dto: (required)
        :type get_signed_urls_for_artifact_version_read_request_dto: GetSignedURLsForArtifactVersionReadRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSignedURLsForArtifactVersionReadResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-signed-urls-for-read is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["get_signed_urls_for_artifact_version_read_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_signed_urls_for_read_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["get_signed_urls_for_artifact_version_read_request_dto"] is not None:
            _body_params = _params[
                "get_signed_urls_for_artifact_version_read_request_dto"
            ]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "GetSignedURLsForArtifactVersionReadResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-signed-urls-for-read",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_signed_urls_for_write_post(
        self,
        get_signed_urls_for_artifact_version_write_request_dto: GetSignedURLsForArtifactVersionWriteRequestDto,
        **kwargs,
    ) -> GetSignedURLsForArtifactVersionWriteResponseDto:  # noqa: E501
        """(Deprecated) Get Signed Urls For Write  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_for_write_post(get_signed_urls_for_artifact_version_write_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_urls_for_artifact_version_write_request_dto: (required)
        :type get_signed_urls_for_artifact_version_write_request_dto: GetSignedURLsForArtifactVersionWriteRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSignedURLsForArtifactVersionWriteResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_signed_urls_for_write_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_signed_urls_for_write_post_with_http_info(
            get_signed_urls_for_artifact_version_write_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_signed_urls_for_write_post_with_http_info(
        self,
        get_signed_urls_for_artifact_version_write_request_dto: GetSignedURLsForArtifactVersionWriteRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Signed Urls For Write  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signed_urls_for_write_post_with_http_info(get_signed_urls_for_artifact_version_write_request_dto, async_req=True)
        >>> result = thread.get()

        :param get_signed_urls_for_artifact_version_write_request_dto: (required)
        :type get_signed_urls_for_artifact_version_write_request_dto: GetSignedURLsForArtifactVersionWriteRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSignedURLsForArtifactVersionWriteResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-signed-urls-for-write is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["get_signed_urls_for_artifact_version_write_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_signed_urls_for_write_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if (
            _params["get_signed_urls_for_artifact_version_write_request_dto"]
            is not None
        ):
            _body_params = _params[
                "get_signed_urls_for_artifact_version_write_request_dto"
            ]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "GetSignedURLsForArtifactVersionWriteResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/get-signed-urls-for-write",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_version_aliases_for_artifact_get(
        self, artifact_id: StrictStr, **kwargs
    ) -> GetArtifactVersionAliasesResponseDto:  # noqa: E501
        """(Deprecated) Get Version Aliases For Artifact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_version_aliases_for_artifact_get(artifact_id, async_req=True)
        >>> result = thread.get()

        :param artifact_id: (required)
        :type artifact_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetArtifactVersionAliasesResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_version_aliases_for_artifact_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_version_aliases_for_artifact_get_with_http_info(
            artifact_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_version_aliases_for_artifact_get_with_http_info(
        self, artifact_id: StrictStr, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Get Version Aliases For Artifact  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_version_aliases_for_artifact_get_with_http_info(artifact_id, async_req=True)
        >>> result = thread.get()

        :param artifact_id: (required)
        :type artifact_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetArtifactVersionAliasesResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/artifacts/get-version-aliases is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["artifact_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version_aliases_for_artifact_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("artifact_id") is not None:  # noqa: E501
            _query_params.append(("artifact_id", _params["artifact_id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "GetArtifactVersionAliasesResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifacts/get-version-aliases",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_artifact_versions_post(
        self,
        list_artifact_versions_request_dto: ListArtifactVersionsRequestDto,
        **kwargs,
    ) -> ListArtifactVersionsResponseDto:  # noqa: E501
        """(Deprecated) List Artifact Versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_artifact_versions_post(list_artifact_versions_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_artifact_versions_request_dto: (required)
        :type list_artifact_versions_request_dto: ListArtifactVersionsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListArtifactVersionsResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_artifact_versions_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_artifact_versions_post_with_http_info(
            list_artifact_versions_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_artifact_versions_post_with_http_info(
        self,
        list_artifact_versions_request_dto: ListArtifactVersionsRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Artifact Versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_artifact_versions_post_with_http_info(list_artifact_versions_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_artifact_versions_request_dto: (required)
        :type list_artifact_versions_request_dto: ListArtifactVersionsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListArtifactVersionsResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_artifact_versions_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_artifact_versions_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_artifact_versions_request_dto"] is not None:
            _body_params = _params["list_artifact_versions_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListArtifactVersionsResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_artifacts_post(
        self, list_artifacts_request_dto: ListArtifactsRequestDto, **kwargs
    ) -> ListArtifactsResponseDto:  # noqa: E501
        """(Deprecated) List Artifacts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_artifacts_post(list_artifacts_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_artifacts_request_dto: (required)
        :type list_artifacts_request_dto: ListArtifactsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListArtifactsResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_artifacts_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_artifacts_post_with_http_info(
            list_artifacts_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_artifacts_post_with_http_info(
        self, list_artifacts_request_dto: ListArtifactsRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Artifacts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_artifacts_post_with_http_info(list_artifacts_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_artifacts_request_dto: (required)
        :type list_artifacts_request_dto: ListArtifactsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListArtifactsResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifacts/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_artifacts_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_artifacts_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_artifacts_request_dto"] is not None:
            _body_params = _params["list_artifacts_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListArtifactsResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifacts/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_datasets_post(
        self, list_datasets_request_dto: ListDatasetsRequestDto, **kwargs
    ) -> ListDatasetsResponseDto:  # noqa: E501
        """(Deprecated) List Datasets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_datasets_post(list_datasets_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_datasets_request_dto: (required)
        :type list_datasets_request_dto: ListDatasetsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDatasetsResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_datasets_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_datasets_post_with_http_info(
            list_datasets_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_datasets_post_with_http_info(
        self, list_datasets_request_dto: ListDatasetsRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Datasets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_datasets_post_with_http_info(list_datasets_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_datasets_request_dto: (required)
        :type list_datasets_request_dto: ListDatasetsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDatasetsResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_datasets_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_datasets_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_datasets_request_dto"] is not None:
            _body_params = _params["list_datasets_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListDatasetsResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_files_for_artifact_version_post(
        self,
        list_files_for_artifact_version_request_dto: ListFilesForArtifactVersionRequestDto,
        **kwargs,
    ) -> ListFilesForArtifactVersionsResponseDto:  # noqa: E501
        """(Deprecated) List Files For Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_files_for_artifact_version_post(list_files_for_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_files_for_artifact_version_request_dto: (required)
        :type list_files_for_artifact_version_request_dto: ListFilesForArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListFilesForArtifactVersionsResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_files_for_artifact_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_files_for_artifact_version_post_with_http_info(
            list_files_for_artifact_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_files_for_artifact_version_post_with_http_info(
        self,
        list_files_for_artifact_version_request_dto: ListFilesForArtifactVersionRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Files For Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_files_for_artifact_version_post_with_http_info(list_files_for_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_files_for_artifact_version_request_dto: (required)
        :type list_files_for_artifact_version_request_dto: ListFilesForArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListFilesForArtifactVersionsResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/files/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_files_for_artifact_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files_for_artifact_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_files_for_artifact_version_request_dto"] is not None:
            _body_params = _params["list_files_for_artifact_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListFilesForArtifactVersionsResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/files/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_files_for_dataset_post(
        self,
        list_files_for_dataset_request_dto: ListFilesForDatasetRequestDto,
        **kwargs,
    ) -> ListFilesForDatasetResponseDto:  # noqa: E501
        """(Deprecated) List Files For Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_files_for_dataset_post(list_files_for_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_files_for_dataset_request_dto: (required)
        :type list_files_for_dataset_request_dto: ListFilesForDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListFilesForDatasetResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_files_for_dataset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_files_for_dataset_post_with_http_info(
            list_files_for_dataset_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_files_for_dataset_post_with_http_info(
        self,
        list_files_for_dataset_request_dto: ListFilesForDatasetRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Files For Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_files_for_dataset_post_with_http_info(list_files_for_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_files_for_dataset_request_dto: (required)
        :type list_files_for_dataset_request_dto: ListFilesForDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListFilesForDatasetResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/files/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_files_for_dataset_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_files_for_dataset_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_files_for_dataset_request_dto"] is not None:
            _body_params = _params["list_files_for_dataset_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListFilesForDatasetResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/files/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_model_versions_post(
        self, list_model_versions_request_dto: ListModelVersionsRequestDto, **kwargs
    ) -> ListModelVersionResponseDto:  # noqa: E501
        """(Deprecated) List Model Versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_model_versions_post(list_model_versions_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_model_versions_request_dto: (required)
        :type list_model_versions_request_dto: ListModelVersionsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListModelVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_model_versions_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_model_versions_post_with_http_info(
            list_model_versions_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def list_model_versions_post_with_http_info(
        self, list_model_versions_request_dto: ListModelVersionsRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Model Versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_model_versions_post_with_http_info(list_model_versions_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_model_versions_request_dto: (required)
        :type list_model_versions_request_dto: ListModelVersionsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListModelVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/model-versions/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_model_versions_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_model_versions_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_model_versions_request_dto"] is not None:
            _body_params = _params["list_model_versions_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListModelVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def list_models_post(
        self, list_models_request_dto: ListModelsRequestDto, **kwargs
    ) -> ListModelsResponseDto:  # noqa: E501
        """(Deprecated) List Models  # noqa: E501

        List Models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_models_post(list_models_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_models_request_dto: (required)
        :type list_models_request_dto: ListModelsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListModelsResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the list_models_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.list_models_post_with_http_info(list_models_request_dto, **kwargs)  # noqa: E501

    @validate_arguments
    def list_models_post_with_http_info(
        self, list_models_request_dto: ListModelsRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) List Models  # noqa: E501

        List Models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_models_post_with_http_info(list_models_request_dto, async_req=True)
        >>> result = thread.get()

        :param list_models_request_dto: (required)
        :type list_models_request_dto: ListModelsRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListModelsResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/models/list is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["list_models_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_models_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["list_models_request_dto"] is not None:
            _body_params = _params["list_models_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ListModelsResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/models/list",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def notify_failure_post(
        self,
        notify_artifact_version_failure_dto: NotifyArtifactVersionFailureDto,
        **kwargs,
    ) -> object:  # noqa: E501
        """(Deprecated) Notify Failure  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.notify_failure_post(notify_artifact_version_failure_dto, async_req=True)
        >>> result = thread.get()

        :param notify_artifact_version_failure_dto: (required)
        :type notify_artifact_version_failure_dto: NotifyArtifactVersionFailureDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the notify_failure_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.notify_failure_post_with_http_info(
            notify_artifact_version_failure_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def notify_failure_post_with_http_info(
        self,
        notify_artifact_version_failure_dto: NotifyArtifactVersionFailureDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Notify Failure  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.notify_failure_post_with_http_info(notify_artifact_version_failure_dto, async_req=True)
        >>> result = thread.get()

        :param notify_artifact_version_failure_dto: (required)
        :type notify_artifact_version_failure_dto: NotifyArtifactVersionFailureDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/notify-failure is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["notify_artifact_version_failure_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method notify_failure_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["notify_artifact_version_failure_dto"] is not None:
            _body_params = _params["notify_artifact_version_failure_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/notify-failure",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def resolve_agent_get(self, fqn: StrictStr, **kwargs) -> ResolveAgentAppResponseDto:  # noqa: E501
        """(Deprecated) Resolve Agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.resolve_agent_get(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResolveAgentAppResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the resolve_agent_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.resolve_agent_get_with_http_info(fqn, **kwargs)  # noqa: E501

    @validate_arguments
    def resolve_agent_get_with_http_info(self, fqn: StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) Resolve Agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.resolve_agent_get_with_http_info(fqn, async_req=True)
        >>> result = thread.get()

        :param fqn: (required)
        :type fqn: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResolveAgentAppResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "GET /api/2.0/mlflow/mlfoundry-artifacts/agent/resolve is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["fqn"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resolve_agent_get" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("fqn") is not None:  # noqa: E501
            _query_params.append(("fqn", _params["fqn"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ResolveAgentAppResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/agent/resolve",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_artifact_version_post(
        self,
        update_artifact_version_request_dto: UpdateArtifactVersionRequestDto,
        **kwargs,
    ) -> ArtifactVersionResponseDto:  # noqa: E501
        """(Deprecated) Update Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_artifact_version_post(update_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param update_artifact_version_request_dto: (required)
        :type update_artifact_version_request_dto: UpdateArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_artifact_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_artifact_version_post_with_http_info(
            update_artifact_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_artifact_version_post_with_http_info(
        self,
        update_artifact_version_request_dto: UpdateArtifactVersionRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Update Artifact Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_artifact_version_post_with_http_info(update_artifact_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param update_artifact_version_request_dto: (required)
        :type update_artifact_version_request_dto: UpdateArtifactVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/update is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["update_artifact_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_artifact_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["update_artifact_version_request_dto"] is not None:
            _body_params = _params["update_artifact_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ArtifactVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/update",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_dataset_post(
        self, update_dataset_request_dto: UpdateDatasetRequestDto, **kwargs
    ) -> DatasetResponseDto:  # noqa: E501
        """(Deprecated) Update Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_dataset_post(update_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param update_dataset_request_dto: (required)
        :type update_dataset_request_dto: UpdateDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DatasetResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_dataset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_dataset_post_with_http_info(
            update_dataset_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_dataset_post_with_http_info(
        self, update_dataset_request_dto: UpdateDatasetRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Update Dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_dataset_post_with_http_info(update_dataset_request_dto, async_req=True)
        >>> result = thread.get()

        :param update_dataset_request_dto: (required)
        :type update_dataset_request_dto: UpdateDatasetRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DatasetResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/datasets/update is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["update_dataset_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dataset_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["update_dataset_request_dto"] is not None:
            _body_params = _params["update_dataset_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "DatasetResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/datasets/update",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_model_version_post(
        self, update_model_version_request_dto: UpdateModelVersionRequestDto, **kwargs
    ) -> ModelVersionResponseDto:  # noqa: E501
        """(Deprecated) Update Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_model_version_post(update_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param update_model_version_request_dto: (required)
        :type update_model_version_request_dto: UpdateModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelVersionResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_model_version_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_model_version_post_with_http_info(
            update_model_version_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_model_version_post_with_http_info(
        self, update_model_version_request_dto: UpdateModelVersionRequestDto, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Update Model Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_model_version_post_with_http_info(update_model_version_request_dto, async_req=True)
        >>> result = thread.get()

        :param update_model_version_request_dto: (required)
        :type update_model_version_request_dto: UpdateModelVersionRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelVersionResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/model-versions/update is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["update_model_version_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_version_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["update_model_version_request_dto"] is not None:
            _body_params = _params["update_model_version_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ModelVersionResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/model-versions/update",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def validate_external_storage_root_path_post(
        self,
        validate_external_storage_root_request_dto: ValidateExternalStorageRootRequestDto,
        **kwargs,
    ) -> ValidateExternalStorageRootResponseDto:  # noqa: E501
        """(Deprecated) Validate External Storage Root Path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_external_storage_root_path_post(validate_external_storage_root_request_dto, async_req=True)
        >>> result = thread.get()

        :param validate_external_storage_root_request_dto: (required)
        :type validate_external_storage_root_request_dto: ValidateExternalStorageRootRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ValidateExternalStorageRootResponseDto
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the validate_external_storage_root_path_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.validate_external_storage_root_path_post_with_http_info(
            validate_external_storage_root_request_dto, **kwargs
        )  # noqa: E501

    @validate_arguments
    def validate_external_storage_root_path_post_with_http_info(
        self,
        validate_external_storage_root_request_dto: ValidateExternalStorageRootRequestDto,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """(Deprecated) Validate External Storage Root Path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_external_storage_root_path_post_with_http_info(validate_external_storage_root_request_dto, async_req=True)
        >>> result = thread.get()

        :param validate_external_storage_root_request_dto: (required)
        :type validate_external_storage_root_request_dto: ValidateExternalStorageRootRequestDto
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ValidateExternalStorageRootResponseDto, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn(
            "POST /api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/validate-storage-root is deprecated.",
            DeprecationWarning,
        )

        _params = locals()

        _all_params = ["validate_external_storage_root_request_dto"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_external_storage_root_path_post" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["validate_external_storage_root_request_dto"] is not None:
            _body_params = _params["validate_external_storage_root_request_dto"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKey"]  # noqa: E501

        _response_types_map = {
            "200": "ValidateExternalStorageRootResponseDto",
            "422": "HTTPValidationError",
        }

        return self.api_client.call_api(
            "/api/2.0/mlflow/mlfoundry-artifacts/artifact-versions/validate-storage-root",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
