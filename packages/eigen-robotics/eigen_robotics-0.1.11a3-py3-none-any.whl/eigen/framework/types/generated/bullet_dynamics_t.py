"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct



class bullet_dynamics_t(object):

    __slots__ = ["bodyUniqueId", "linkIndex", "mass", "lateralFriction", "spinningFriction", "rollingFriction", "restitution", "linearDamping", "angularDamping", "contactStiffness", "contactDamping", "frictionAnchor", "localInertiaDiagonal", "ccdSweptSphereRadius", "contactProcessingThreshold", "activationState", "jointDamping", "anisotropicFriction", "maxJointVelocity", "collisionMargin", "jointLowerLimit", "jointUpperLimit", "jointLimitForce", "physicsClientId"]

    __typenames__ = ["int32_t", "int32_t", "float", "float", "float", "float", "float", "float", "float", "float", "float", "int32_t", "generated.float_vector_t", "float", "float", "int32_t", "float", "float", "float", "float", "float", "float", "float", "int32_t"]

    __dimensions__ = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]

    def __init__(self):
        self.bodyUniqueId = 0
        """ LCM Type: int32_t """
        self.linkIndex = 0
        """
        Required: object unique id, as returned by loadURDF etc.
        LCM Type: int32_t
        """

        self.mass = 0.0
        """
        Required: link index or -1 for the base
        Optional fields
        LCM Type: float
        """

        self.lateralFriction = 0.0
        """
        Mass of the link (or base for linkIndex -1)
        LCM Type: float
        """

        self.spinningFriction = 0.0
        """
        Lateral (linear) contact friction
        LCM Type: float
        """

        self.rollingFriction = 0.0
        """
        Torsional friction around the contact normal
        LCM Type: float
        """

        self.restitution = 0.0
        """
        Torsional friction orthogonal to contact normal
        LCM Type: float
        """

        self.linearDamping = 0.0
        """
        Bounciness of contact (keep < 1, preferably closer to 0)
        LCM Type: float
        """

        self.angularDamping = 0.0
        """
        Linear damping of the link
        LCM Type: float
        """

        self.contactStiffness = 0.0
        """
        Angular damping of the link
        LCM Type: float
        """

        self.contactDamping = 0.0
        """
        Stiffness of the contact constraints
        LCM Type: float
        """

        self.frictionAnchor = 0
        """
        Damping of the contact constraints
        LCM Type: int32_t
        """

        self.localInertiaDiagonal = generated.float_vector_t()
        """
        Enable/disable friction anchor
        LCM Type: generated.float_vector_t
        """

        self.ccdSweptSphereRadius = 0.0
        """
        Diagonal elements of the inertia tensor
        LCM Type: float
        """

        self.contactProcessingThreshold = 0.0
        """
        Radius of the sphere for continuous collision detection
        LCM Type: float
        """

        self.activationState = 0
        """
        Threshold for processing contacts
        LCM Type: int32_t
        """

        self.jointDamping = 0.0
        """
        Activation state (e.g., sleeping, wake-up state)
        LCM Type: float
        """

        self.anisotropicFriction = 0.0
        """
        Joint damping coefficient
        LCM Type: float
        """

        self.maxJointVelocity = 0.0
        """
        Anisotropic friction coefficient
        LCM Type: float
        """

        self.collisionMargin = 0.0
        """
        Maximum joint velocity
        LCM Type: float
        """

        self.jointLowerLimit = 0.0
        """
        Collision margin
        LCM Type: float
        """

        self.jointUpperLimit = 0.0
        """
        Lower limit of a joint
        LCM Type: float
        """

        self.jointLimitForce = 0.0
        """
        Upper limit of a joint
        LCM Type: float
        """

        self.physicsClientId = 0
        """
        Maximum force applied to satisfy a joint limit
        LCM Type: int32_t
        """


    def encode(self):
        buf = BytesIO()
        buf.write(bullet_dynamics_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">iifffffffffi", self.bodyUniqueId, self.linkIndex, self.mass, self.lateralFriction, self.spinningFriction, self.rollingFriction, self.restitution, self.linearDamping, self.angularDamping, self.contactStiffness, self.contactDamping, self.frictionAnchor))
        assert self.localInertiaDiagonal._get_packed_fingerprint() == generated.float_vector_t._get_packed_fingerprint()
        self.localInertiaDiagonal._encode_one(buf)
        buf.write(struct.pack(">ffifffffffi", self.ccdSweptSphereRadius, self.contactProcessingThreshold, self.activationState, self.jointDamping, self.anisotropicFriction, self.maxJointVelocity, self.collisionMargin, self.jointLowerLimit, self.jointUpperLimit, self.jointLimitForce, self.physicsClientId))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != bullet_dynamics_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return bullet_dynamics_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = bullet_dynamics_t()
        self.bodyUniqueId, self.linkIndex, self.mass, self.lateralFriction, self.spinningFriction, self.rollingFriction, self.restitution, self.linearDamping, self.angularDamping, self.contactStiffness, self.contactDamping, self.frictionAnchor = struct.unpack(">iifffffffffi", buf.read(48))
        self.localInertiaDiagonal = generated.float_vector_t._decode_one(buf)
        self.ccdSweptSphereRadius, self.contactProcessingThreshold, self.activationState, self.jointDamping, self.anisotropicFriction, self.maxJointVelocity, self.collisionMargin, self.jointLowerLimit, self.jointUpperLimit, self.jointLimitForce, self.physicsClientId = struct.unpack(">ffifffffffi", buf.read(44))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if bullet_dynamics_t in parents: return 0
        newparents = parents + [bullet_dynamics_t]
        tmphash = (0xb3c94a72a1477368+ generated.float_vector_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if bullet_dynamics_t._packed_fingerprint is None:
            bullet_dynamics_t._packed_fingerprint = struct.pack(">Q", bullet_dynamics_t._get_hash_recursive([]))
        return bullet_dynamics_t._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", bullet_dynamics_t._get_packed_fingerprint())[0]

