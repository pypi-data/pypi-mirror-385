# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _area_scan_3d_camera
else:
    import _area_scan_3d_camera

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _area_scan_3d_camera.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _area_scan_3d_camera.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _area_scan_3d_camera.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _area_scan_3d_camera.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _area_scan_3d_camera.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _area_scan_3d_camera.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _area_scan_3d_camera.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _area_scan_3d_camera.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _area_scan_3d_camera.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _area_scan_3d_camera.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _area_scan_3d_camera.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _area_scan_3d_camera:
_area_scan_3d_camera.SwigPyIterator_swigregister(SwigPyIterator)
from . import shared
class Transformation(object):
    r"""Proxy of C++ WrappedTransformation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rotation = property(_area_scan_3d_camera.Transformation_rotation_get, _area_scan_3d_camera.Transformation_rotation_set, doc=r"""rotation : wrapped_matrix<(double,3)>""")
    translation = property(_area_scan_3d_camera.Transformation_translation_get, _area_scan_3d_camera.Transformation_translation_set, doc=r"""translation : wrapped_array<(double,3)>""")

    def __init__(self):
        r"""__init__(Transformation self) -> Transformation"""
        _area_scan_3d_camera.Transformation_swiginit(self, _area_scan_3d_camera.new_Transformation())
    __swig_destroy__ = _area_scan_3d_camera.delete_Transformation

# Register Transformation in _area_scan_3d_camera:
_area_scan_3d_camera.Transformation_swigregister(Transformation)
class FrameTransformation(object):
    r"""Proxy of C++ WrappedFrameTransformation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rotation = property(_area_scan_3d_camera.FrameTransformation_rotation_get, _area_scan_3d_camera.FrameTransformation_rotation_set, doc=r"""rotation : wrapped_matrix<(double,3)>""")
    translation = property(_area_scan_3d_camera.FrameTransformation_translation_get, _area_scan_3d_camera.FrameTransformation_translation_set, doc=r"""translation : wrapped_array<(double,3)>""")

    def __rotate__(self, theta, axis):
        r"""__rotate__(FrameTransformation self, double theta, int axis)"""
        return _area_scan_3d_camera.FrameTransformation___rotate__(self, theta, axis)

    def __translate__(self, translateX, translateY, translateZ):
        r"""__translate__(FrameTransformation self, double translateX, double translateY, double translateZ)"""
        return _area_scan_3d_camera.FrameTransformation___translate__(self, translateX, translateY, translateZ)

    def __is__valid__(self):
        r"""__is__valid__(FrameTransformation self) -> bool"""
        return _area_scan_3d_camera.FrameTransformation___is__valid__(self)

    def __init__(self):
        r"""__init__(FrameTransformation self) -> FrameTransformation"""
        _area_scan_3d_camera.FrameTransformation_swiginit(self, _area_scan_3d_camera.new_FrameTransformation())
    __swig_destroy__ = _area_scan_3d_camera.delete_FrameTransformation

# Register FrameTransformation in _area_scan_3d_camera:
_area_scan_3d_camera.FrameTransformation_swigregister(FrameTransformation)
class CameraIntrinsics(object):
    r"""Proxy of C++ WrappedCameraIntrinsics class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    texture = property(_area_scan_3d_camera.CameraIntrinsics_texture_get, _area_scan_3d_camera.CameraIntrinsics_texture_set, doc=r"""texture : mmind::eye::Intrinsics2DCamera""")
    depth = property(_area_scan_3d_camera.CameraIntrinsics_depth_get, _area_scan_3d_camera.CameraIntrinsics_depth_set, doc=r"""depth : mmind::eye::Intrinsics2DCamera""")
    depth_to_texture = property(_area_scan_3d_camera.CameraIntrinsics_depth_to_texture_get, _area_scan_3d_camera.CameraIntrinsics_depth_to_texture_set, doc=r"""depth_to_texture : WrappedTransformation""")

    def __init__(self):
        r"""__init__(CameraIntrinsics self) -> CameraIntrinsics"""
        _area_scan_3d_camera.CameraIntrinsics_swiginit(self, _area_scan_3d_camera.new_CameraIntrinsics())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraIntrinsics

# Register CameraIntrinsics in _area_scan_3d_camera:
_area_scan_3d_camera.CameraIntrinsics_swigregister(CameraIntrinsics)

def camera_intrinsics_to_wrapped(wrappedIntrinsics, intrinsics):
    r"""camera_intrinsics_to_wrapped(CameraIntrinsics wrappedIntrinsics, mmind::eye::CameraIntrinsics const & intrinsics)"""
    return _area_scan_3d_camera.camera_intrinsics_to_wrapped(wrappedIntrinsics, intrinsics)

def wrapped_to_camera_intrinsics(intrinsics, wrappedIntrinsics):
    r"""wrapped_to_camera_intrinsics(mmind::eye::CameraIntrinsics & intrinsics, CameraIntrinsics wrappedIntrinsics)"""
    return _area_scan_3d_camera.wrapped_to_camera_intrinsics(intrinsics, wrappedIntrinsics)

def wrapped_to_frame_transformation(frameTransformation, wrappedFrameTransformation):
    r"""wrapped_to_frame_transformation(FrameTransformation frameTransformation, FrameTransformation wrappedFrameTransformation)"""
    return _area_scan_3d_camera.wrapped_to_frame_transformation(frameTransformation, wrappedFrameTransformation)

def frame_transformation_towrapped(frameTransformation, wrappedFrameTransformation):
    r"""frame_transformation_towrapped(FrameTransformation frameTransformation, FrameTransformation wrappedFrameTransformation)"""
    return _area_scan_3d_camera.frame_transformation_towrapped(frameTransformation, wrappedFrameTransformation)
class CameraInfo(object):
    r"""Defines the camera information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    model = property(_area_scan_3d_camera.CameraInfo_model_get, _area_scan_3d_camera.CameraInfo_model_set, doc=r""" The device model, such as Mech-Eye NANO.""")
    device_name = property(_area_scan_3d_camera.CameraInfo_device_name_get, _area_scan_3d_camera.CameraInfo_device_name_set, doc=r""" The device name (UTF-8 encoded).""")
    serial_number = property(_area_scan_3d_camera.CameraInfo_serial_number_get, _area_scan_3d_camera.CameraInfo_serial_number_set, doc=r""" The serial number of the device.""")
    platform = property(_area_scan_3d_camera.CameraInfo_platform_get, _area_scan_3d_camera.CameraInfo_platform_set, doc=r""" The platform name of the device.""")
    hardware_version = property(_area_scan_3d_camera.CameraInfo_hardware_version_get, _area_scan_3d_camera.CameraInfo_hardware_version_set, doc=r""" The version of the hardware (pre-determined in the factory).""")
    firmware_version = property(_area_scan_3d_camera.CameraInfo_firmware_version_get, _area_scan_3d_camera.CameraInfo_firmware_version_set, doc=r""" The version of the firmware (upgradable).""")
    ip_address = property(_area_scan_3d_camera.CameraInfo_ip_address_get, _area_scan_3d_camera.CameraInfo_ip_address_set, doc=r""" The IP address of the device.""")
    subnet_mask = property(_area_scan_3d_camera.CameraInfo_subnet_mask_get, _area_scan_3d_camera.CameraInfo_subnet_mask_set, doc=r"""subnet_mask : std::string""")
    ip_assignment_method = property(_area_scan_3d_camera.CameraInfo_ip_assignment_method_get, _area_scan_3d_camera.CameraInfo_ip_assignment_method_set, doc=r"""ip_assignment_method : mmind::eye::IpAssignmentMethod""")
    port = property(_area_scan_3d_camera.CameraInfo_port_get, _area_scan_3d_camera.CameraInfo_port_set, doc=r"""port : uint16_t""")
    supported = property(_area_scan_3d_camera.CameraInfo_supported_get, _area_scan_3d_camera.CameraInfo_supported_set, doc=r"""supported : bool""")
    last_supported_version = property(_area_scan_3d_camera.CameraInfo_last_supported_version_get, _area_scan_3d_camera.CameraInfo_last_supported_version_set, doc=r""" The last supported version of the device.""")

    def __init__(self):
        r"""__init__(CameraInfo self) -> CameraInfo"""
        _area_scan_3d_camera.CameraInfo_swiginit(self, _area_scan_3d_camera.new_CameraInfo())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraInfo

# Register CameraInfo in _area_scan_3d_camera:
_area_scan_3d_camera.CameraInfo_swigregister(CameraInfo)
class DeviceTemperature(object):
    r"""Describes the device temperatures."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cpu_temperature = property(_area_scan_3d_camera.DeviceTemperature_cpu_temperature_get, _area_scan_3d_camera.DeviceTemperature_cpu_temperature_set, doc=r"""cpu_temperature : float""")
    projector_temperature = property(_area_scan_3d_camera.DeviceTemperature_projector_temperature_get, _area_scan_3d_camera.DeviceTemperature_projector_temperature_set, doc=r"""projector_temperature : float""")

    def __init__(self):
        r"""__init__(DeviceTemperature self) -> DeviceTemperature"""
        _area_scan_3d_camera.DeviceTemperature_swiginit(self, _area_scan_3d_camera.new_DeviceTemperature())
    __swig_destroy__ = _area_scan_3d_camera.delete_DeviceTemperature

# Register DeviceTemperature in _area_scan_3d_camera:
_area_scan_3d_camera.DeviceTemperature_swigregister(DeviceTemperature)
class CameraStatus(object):
    r"""Describes the camera's statuses."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    temperature = property(_area_scan_3d_camera.CameraStatus_temperature_get, _area_scan_3d_camera.CameraStatus_temperature_set, doc=r"""temperature : mmind::eye::DeviceTemperature""")

    def __init__(self):
        r"""__init__(CameraStatus self) -> CameraStatus"""
        _area_scan_3d_camera.CameraStatus_swiginit(self, _area_scan_3d_camera.new_CameraStatus())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraStatus

# Register CameraStatus in _area_scan_3d_camera:
_area_scan_3d_camera.CameraStatus_swigregister(CameraStatus)
class CameraMatrix(object):
    r"""Describes the camera intrinsic parameter matrix."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fx = property(_area_scan_3d_camera.CameraMatrix_fx_get, _area_scan_3d_camera.CameraMatrix_fx_set, doc=r"""fx : double""")
    fy = property(_area_scan_3d_camera.CameraMatrix_fy_get, _area_scan_3d_camera.CameraMatrix_fy_set, doc=r"""fy : double""")
    cx = property(_area_scan_3d_camera.CameraMatrix_cx_get, _area_scan_3d_camera.CameraMatrix_cx_set, doc=r"""cx : double""")
    cy = property(_area_scan_3d_camera.CameraMatrix_cy_get, _area_scan_3d_camera.CameraMatrix_cy_set, doc=r"""cy : double""")

    def __init__(self):
        r"""__init__(CameraMatrix self) -> CameraMatrix"""
        _area_scan_3d_camera.CameraMatrix_swiginit(self, _area_scan_3d_camera.new_CameraMatrix())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraMatrix

# Register CameraMatrix in _area_scan_3d_camera:
_area_scan_3d_camera.CameraMatrix_swigregister(CameraMatrix)
class CameraDistortion(object):
    r"""Describes the distortion parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    k1 = property(_area_scan_3d_camera.CameraDistortion_k1_get, _area_scan_3d_camera.CameraDistortion_k1_set, doc=r"""k1 : double""")
    k2 = property(_area_scan_3d_camera.CameraDistortion_k2_get, _area_scan_3d_camera.CameraDistortion_k2_set, doc=r"""k2 : double""")
    p1 = property(_area_scan_3d_camera.CameraDistortion_p1_get, _area_scan_3d_camera.CameraDistortion_p1_set, doc=r"""p1 : double""")
    p2 = property(_area_scan_3d_camera.CameraDistortion_p2_get, _area_scan_3d_camera.CameraDistortion_p2_set, doc=r"""p2 : double""")
    k3 = property(_area_scan_3d_camera.CameraDistortion_k3_get, _area_scan_3d_camera.CameraDistortion_k3_set, doc=r"""k3 : double""")

    def __init__(self):
        r"""__init__(CameraDistortion self) -> CameraDistortion"""
        _area_scan_3d_camera.CameraDistortion_swiginit(self, _area_scan_3d_camera.new_CameraDistortion())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraDistortion

# Register CameraDistortion in _area_scan_3d_camera:
_area_scan_3d_camera.CameraDistortion_swigregister(CameraDistortion)
class Intrinsics2DCamera(object):
    r"""
    Describes the intrinsic parameters of the 2D camera in the 3D camera based on the pinhole
    camera model, including the camera matrix and camera distortion parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    camera_distortion = property(_area_scan_3d_camera.Intrinsics2DCamera_camera_distortion_get, _area_scan_3d_camera.Intrinsics2DCamera_camera_distortion_set, doc=r"""camera_distortion : mmind::eye::CameraDistortion""")
    camera_matrix = property(_area_scan_3d_camera.Intrinsics2DCamera_camera_matrix_get, _area_scan_3d_camera.Intrinsics2DCamera_camera_matrix_set, doc=r"""camera_matrix : mmind::eye::CameraMatrix""")

    def __init__(self):
        r"""__init__(Intrinsics2DCamera self) -> Intrinsics2DCamera"""
        _area_scan_3d_camera.Intrinsics2DCamera_swiginit(self, _area_scan_3d_camera.new_Intrinsics2DCamera())
    __swig_destroy__ = _area_scan_3d_camera.delete_Intrinsics2DCamera

# Register Intrinsics2DCamera in _area_scan_3d_camera:
_area_scan_3d_camera.Intrinsics2DCamera_swigregister(Intrinsics2DCamera)
class CameraResolutions(object):
    r"""
    Defines the camera image resolutions, including the resolutions of the 2D image (texture)
    and depth map.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    texture = property(_area_scan_3d_camera.CameraResolutions_texture_get, _area_scan_3d_camera.CameraResolutions_texture_set, doc=r"""texture : mmind::eye::Size""")
    depth = property(_area_scan_3d_camera.CameraResolutions_depth_get, _area_scan_3d_camera.CameraResolutions_depth_set, doc=r"""depth : mmind::eye::Size""")

    def __init__(self):
        r"""__init__(CameraResolutions self) -> CameraResolutions"""
        _area_scan_3d_camera.CameraResolutions_swiginit(self, _area_scan_3d_camera.new_CameraResolutions())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraResolutions

# Register CameraResolutions in _area_scan_3d_camera:
_area_scan_3d_camera.CameraResolutions_swigregister(CameraResolutions)
ColorTypeOf2DCamera_Monochrome = _area_scan_3d_camera.ColorTypeOf2DCamera_Monochrome

ColorTypeOf2DCamera_Color = _area_scan_3d_camera.ColorTypeOf2DCamera_Color

ColorTypeOf2DCamera_Undefined = _area_scan_3d_camera.ColorTypeOf2DCamera_Undefined

class doubleArray3(object):
    r"""Proxy of C++ wrapped_array< double,3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_area_scan_3d_camera.doubleArray3_data_get, _area_scan_3d_camera.doubleArray3_data_set, doc=r"""data : a(3).double""")

    def __len__(self):
        r"""__len__(doubleArray3 self) -> size_t"""
        return _area_scan_3d_camera.doubleArray3___len__(self)

    def __getitem__(self, i):
        r"""__getitem__(doubleArray3 self, size_t i) -> double const &"""
        return _area_scan_3d_camera.doubleArray3___getitem__(self, i)

    def __setitem__(self, i, v):
        r"""__setitem__(doubleArray3 self, size_t i, double const & v)"""
        return _area_scan_3d_camera.doubleArray3___setitem__(self, i, v)

    def __init__(self):
        r"""__init__(doubleArray3 self) -> doubleArray3"""
        _area_scan_3d_camera.doubleArray3_swiginit(self, _area_scan_3d_camera.new_doubleArray3())
    __swig_destroy__ = _area_scan_3d_camera.delete_doubleArray3

# Register doubleArray3 in _area_scan_3d_camera:
_area_scan_3d_camera.doubleArray3_swigregister(doubleArray3)
class doubleMatrix3(object):
    r"""Proxy of C++ wrapped_matrix< double,3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_area_scan_3d_camera.doubleMatrix3_data_get, _area_scan_3d_camera.doubleMatrix3_data_set, doc=r"""data : a(3).a(3).double""")

    def __len__(self):
        r"""__len__(doubleMatrix3 self) -> size_t"""
        return _area_scan_3d_camera.doubleMatrix3___len__(self)

    def __getitem__(self, i):
        r"""__getitem__(doubleMatrix3 self, size_t i) -> doubleArray3"""
        return _area_scan_3d_camera.doubleMatrix3___getitem__(self, i)

    def __setitem__(self, i, v):
        r"""__setitem__(doubleMatrix3 self, size_t i, doubleArray3 v)"""
        return _area_scan_3d_camera.doubleMatrix3___setitem__(self, i, v)

    def __init__(self):
        r"""__init__(doubleMatrix3 self) -> doubleMatrix3"""
        _area_scan_3d_camera.doubleMatrix3_swiginit(self, _area_scan_3d_camera.new_doubleMatrix3())
    __swig_destroy__ = _area_scan_3d_camera.delete_doubleMatrix3

# Register doubleMatrix3 in _area_scan_3d_camera:
_area_scan_3d_camera.doubleMatrix3_swigregister(doubleMatrix3)
class Gray(object):
    r"""Represents a pixel in 'GrayScale2DImage' with grayscale channel information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gray = property(_area_scan_3d_camera.Gray_gray_get, _area_scan_3d_camera.Gray_gray_set, doc=r"""gray : uint8_t""")

    def __init__(self):
        r"""__init__(Gray self) -> Gray"""
        _area_scan_3d_camera.Gray_swiginit(self, _area_scan_3d_camera.new_Gray())
    __swig_destroy__ = _area_scan_3d_camera.delete_Gray

# Register Gray in _area_scan_3d_camera:
_area_scan_3d_camera.Gray_swigregister(Gray)
class ColorBGR(object):
    r"""Represents a pixel in 'Color2DImage' with blue, green, and red channel information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    b = property(_area_scan_3d_camera.ColorBGR_b_get, _area_scan_3d_camera.ColorBGR_b_set, doc=r"""b : uint8_t""")
    g = property(_area_scan_3d_camera.ColorBGR_g_get, _area_scan_3d_camera.ColorBGR_g_set, doc=r"""g : uint8_t""")
    r = property(_area_scan_3d_camera.ColorBGR_r_get, _area_scan_3d_camera.ColorBGR_r_set, doc=r"""r : uint8_t""")

    def __init__(self):
        r"""__init__(ColorBGR self) -> ColorBGR"""
        _area_scan_3d_camera.ColorBGR_swiginit(self, _area_scan_3d_camera.new_ColorBGR())
    __swig_destroy__ = _area_scan_3d_camera.delete_ColorBGR

# Register ColorBGR in _area_scan_3d_camera:
_area_scan_3d_camera.ColorBGR_swigregister(ColorBGR)
class Frame2D(object):
    r"""
    Represents the 2D capture result, which can be obtained by calling
    'Camera.capture2D'. The 2D data can be in the form of 'Gray' or 'ColorBGR' and is stored
    in a 2D array, with each element in the array representing an image pixel.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _area_scan_3d_camera.delete_Frame2D

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        |

        *Overload 2:*

        Constructor.
        """
        _area_scan_3d_camera.Frame2D_swiginit(self, _area_scan_3d_camera.new_Frame2D(*args))

    def image_size(self):
        r"""Gets the image size of 'Frame2D'."""
        return _area_scan_3d_camera.Frame2D_image_size(self)

    def is_empty(self):
        r"""Judges whether 'Frame2D' is empty."""
        return _area_scan_3d_camera.Frame2D_is_empty(self)

    def color_type(self):
        r"""Gets the color type of the 2D camera in the 3D camera."""
        return _area_scan_3d_camera.Frame2D_color_type(self)

    def frame_id(self):
        r"""The ID of the 'Frame2D' frame."""
        return _area_scan_3d_camera.Frame2D_frame_id(self)

    def clear(self):
        r"""Clears the data in 'Frame2D' and releases the associated resources."""
        return _area_scan_3d_camera.Frame2D_clear(self)

    def get_gray_scale_image(self):
        r"""
        Gets image data of the 'Frame2D' with the 'Gray' pixel format. If
        the 2D camera's color type (according to the return value of 'Frame2D.colorType)' is
        Frame2DColorType.Monochrome, this method gets the original data. If the color type is
        Frame2DColorType.Color, this method converts 'ColorBGR' values to 'Gray' values
        according to the following equation: Gray = 0.299 * Red + 0.587 * Green + 0.114 * Blue.
        :rtype: :py:class:`GrayScale2DImage`
        :return: See 'GrayScale2DImage' for details.
        """
        return _area_scan_3d_camera.Frame2D_get_gray_scale_image(self)

    def get_color_image(self):
        r"""
        Gets the image data of the 'Frame2D' with the 'ColorBGR' pixel format.
        If the 2D camera's color type (according to the return value of 'Frame2D.colorType)' is
        'Frame2DColorType.Color', this method gets the original data. If the color type is
        Frame2DColorType.Monochrome, this method converts the 'Gray' values to 'ColorBGR'
        values according to the following equation: Blue = Gray, Green = Gray, Red = Gray.
        :rtype: :py:class:`Color2DImage`
        :return: See 'Color2DImage' for details.
        """
        return _area_scan_3d_camera.Frame2D_get_color_image(self)

# Register Frame2D in _area_scan_3d_camera:
_area_scan_3d_camera.Frame2D_swigregister(Frame2D)
class GrayScale2DImage(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.GrayScale2DImage_swiginit(self, _area_scan_3d_camera.new_GrayScale2DImage())
    __swig_destroy__ = _area_scan_3d_camera.delete_GrayScale2DImage

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.GrayScale2DImage_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.GrayScale2DImage_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.GrayScale2DImage_is_empty(self)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.GrayScale2DImage_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint8 * w * h).from_address(int(data.this)), np.uint8)
        img = np.reshape(img, (h, w))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.GrayScale2DImage_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.GrayScale2DImage_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.GrayScale2DImage_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.GrayScale2DImage_release(self)

    def __getitem__(self, n):
        r"""__getitem__(GrayScale2DImage self, size_t n) -> Gray"""
        return _area_scan_3d_camera.GrayScale2DImage___getitem__(self, n)

# Register GrayScale2DImage in _area_scan_3d_camera:
_area_scan_3d_camera.GrayScale2DImage_swigregister(GrayScale2DImage)
class Color2DImage(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.Color2DImage_swiginit(self, _area_scan_3d_camera.new_Color2DImage())
    __swig_destroy__ = _area_scan_3d_camera.delete_Color2DImage

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.Color2DImage_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.Color2DImage_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.Color2DImage_is_empty(self)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.Color2DImage_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint8 * w * h * 3).from_address(int(data.this)), np.uint8)
        img = np.reshape(img, (h, w, 3))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.Color2DImage_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.Color2DImage_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.Color2DImage_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.Color2DImage_release(self)

    def __getitem__(self, n):
        r"""__getitem__(Color2DImage self, size_t n) -> ColorBGR"""
        return _area_scan_3d_camera.Color2DImage___getitem__(self, n)

# Register Color2DImage in _area_scan_3d_camera:
_area_scan_3d_camera.Color2DImage_swigregister(Color2DImage)
class PointZ(object):
    r"""Represents a point in 'DepthMap' with the depth (z-coordinate) information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    z = property(_area_scan_3d_camera.PointZ_z_get, _area_scan_3d_camera.PointZ_z_set, doc=r"""z : float""")

    def __init__(self):
        r"""__init__(PointZ self) -> PointZ"""
        _area_scan_3d_camera.PointZ_swiginit(self, _area_scan_3d_camera.new_PointZ())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointZ

# Register PointZ in _area_scan_3d_camera:
_area_scan_3d_camera.PointZ_swigregister(PointZ)
class NormalVector(object):
    r"""The pixel element struct with the normal vector coordinate (x, y, z) information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_area_scan_3d_camera.NormalVector_x_get, _area_scan_3d_camera.NormalVector_x_set, doc=r"""x : float""")
    y = property(_area_scan_3d_camera.NormalVector_y_get, _area_scan_3d_camera.NormalVector_y_set, doc=r"""y : float""")
    z = property(_area_scan_3d_camera.NormalVector_z_get, _area_scan_3d_camera.NormalVector_z_set, doc=r"""z : float""")
    curvature = property(_area_scan_3d_camera.NormalVector_curvature_get, _area_scan_3d_camera.NormalVector_curvature_set, doc=r"""curvature : float""")

    def __init__(self):
        r"""__init__(NormalVector self) -> NormalVector"""
        _area_scan_3d_camera.NormalVector_swiginit(self, _area_scan_3d_camera.new_NormalVector())
    __swig_destroy__ = _area_scan_3d_camera.delete_NormalVector

# Register NormalVector in _area_scan_3d_camera:
_area_scan_3d_camera.NormalVector_swigregister(NormalVector)
class PointXYZWithNormals(object):
    r"""
    The pixel element struct in 'UntexturedPointCloudWithNormals' with the coordinate (x,
    y, z) and normal vector coordinate (x, y, z, curvature) information.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    point = property(_area_scan_3d_camera.PointXYZWithNormals_point_get, _area_scan_3d_camera.PointXYZWithNormals_point_set, doc=r"""point : mmind::eye::PointXYZ""")
    normal = property(_area_scan_3d_camera.PointXYZWithNormals_normal_get, _area_scan_3d_camera.PointXYZWithNormals_normal_set, doc=r"""normal : mmind::eye::NormalVector""")

    def __init__(self):
        r"""__init__(PointXYZWithNormals self) -> PointXYZWithNormals"""
        _area_scan_3d_camera.PointXYZWithNormals_swiginit(self, _area_scan_3d_camera.new_PointXYZWithNormals())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointXYZWithNormals

# Register PointXYZWithNormals in _area_scan_3d_camera:
_area_scan_3d_camera.PointXYZWithNormals_swigregister(PointXYZWithNormals)
class Frame3D(object):
    r"""
    Represents the 3D capture result, which can be obtained by calling
    'Camera.capture3D'. The 3D data can be in the
    form of 'PointZ' or 'PointXYZ' and is stored in a 2D array, with each element in the array
    representing a point. The class also provides methods for saving the point cloud data to a local
    file.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _area_scan_3d_camera.delete_Frame3D

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        |

        *Overload 2:*

        Copy constructor.
        """
        _area_scan_3d_camera.Frame3D_swiginit(self, _area_scan_3d_camera.new_Frame3D(*args))

    def image_size(self):
        r"""Gets the image size of 'Frame3D'."""
        return _area_scan_3d_camera.Frame3D_image_size(self)

    def frame_id(self):
        r"""The ID of the 'Frame3D' frame."""
        return _area_scan_3d_camera.Frame3D_frame_id(self)

    def is_empty(self):
        r"""Judges whether 'Frame3D' is empty."""
        return _area_scan_3d_camera.Frame3D_is_empty(self)

    def clear(self):
        r"""Clears the data in 'Frame3D' and releases the associated resources."""
        return _area_scan_3d_camera.Frame3D_clear(self)

    def get_untextured_point_cloud(self):
        r"""
        Gets the organized 3D data map with a 'PointXYZ' pixel data format. Each point
        in 'PointCloud' contains the X, Y, and Z data represented in the camera coordinate
        system. The X, Y, and Z data default unit is in mm (You can change the unit by calling
        Camera.setPointCloudUnit before calling 'Camera.capture3D)', and invalid data is in nan.
        :rtype: :py:class:`PointCloud`
        :return: See 'PointCloud' for details.
        """
        return _area_scan_3d_camera.Frame3D_get_untextured_point_cloud(self)

    def get_untextured_point_cloud_with_normals(self):
        r"""
        Gets the organized 3D data map with a 'PointXYZWithNormals' pixel data format.
        Each point in 'PointCloudWithNormals' contains the X, Y, Z data represented in the camera
        coordinate system. The X, Y, and Z data default unit is in mm (You can change the unit by
        calling 'Camera.setPointCloudUnit' before calling 'Camera.capture3D)', and invalid data
        is in nan. Normal vectors are computed for each point. If the 'Frame3D' is obtained by
        'Camera.capture3DWithNormal', the normal vectors are computed at the camera side.
        :rtype: :py:class:`PointCloudWithNormals`
        :return: See 'PointCloudWithNormals' for details.
        """
        return _area_scan_3d_camera.Frame3D_get_untextured_point_cloud_with_normals(self)

    def get_depth_map(self):
        r"""
        Gets the organized 3D data with the 'PointZ' data format. Each point in
        'DepthMap' contains the depth (z-coordinate) data in the camera reference frame.
        If the application only requires the depth data, obtaining the 'DepthMap' is more
        efficient. The default unit of the depth data is millimeter (You can change the unit by
        calling 'Camera.setPointCloudUnit' before calling 'Camera.capture3D)', and the invalid
        data is represented by "nan".
        :rtype: :py:class:`DepthMap`
        :return: See 'DepthMap' for details.
        """
        return _area_scan_3d_camera.Frame3D_get_depth_map(self)

    def get_orthogonal_depth_map(self):
        r"""
        Obtains the 3D data with the 'PointZ' data format. The 3D data is
        projected under the orthographic projection camera model. Four parameters are provided to
        assist in converting depth pixel positions into coordinate values in the camera
        reference frame according to the following equation: X = col * xScale + xOffset, Y = row *
        yScale + yOffset.
        :param [out]: xScale The output parameter.
        :param [out]: yScale The output parameter.
        :param [out]: xOffset The output parameter.
        :param [out]: yOffset The output parameter.
        :rtype: :py:class:`DepthMap`
        :return: See 'DepthMap' for details.
        """
        return _area_scan_3d_camera.Frame3D_get_orthogonal_depth_map(self)

    def save_untextured_point_cloud(self, fileFormat, fileName, isOrganized=False):
        r"""
        Saves the untextured point cloud to a file of the input file format and filename.
        Each point contains x, y, and z fields. The default unit of the coordinate data is
        millimeter (You can change the unit by calling 'Camera.setPointCloudUnit' before calling
        'Camera.capture3D)'. Point cloud can be saved in organized or unorganized structure with
        ACSII mode.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame3D_save_untextured_point_cloud(self, fileFormat, fileName, isOrganized)

    def save_untextured_point_cloud_with_normals(self, fileFormat, fileName, isOrganized=False):
        r"""
        Saves the untextured point cloud to a file of the input file format and filename.
        Each point contains x, y, z, normalX, normalY, and normalZ fields. The default unit of the
        coordinate data is millimeter (You can change the unit by calling
        Camera.setPointCloudUnit before calling 'Camera.capture3D)'. Point cloud can be saved in
        organized or unorganized structure with ACSII mode.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame3D_save_untextured_point_cloud_with_normals(self, fileFormat, fileName, isOrganized)

    @staticmethod
    def save_point_cloud(*args):
        r"""
        Saves the untextured point cloud to a file of the input file format and filename.
        Each point contains x, y, and z fields. The default unit of the coordinate data is
        millimeter. Point cloud can be saved in organized or unorganized structure with ACSII mode.
        :param [in]: pointCloud The point cloud data to be saved. See 'PointCloud' for details.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :param [in]: pointCloudUnit The unit of the coordinate data.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame3D_save_point_cloud(*args)

    @staticmethod
    def save_point_cloud_with_normals(*args):
        r"""
        Saves the untextured point cloud to a file of the input file format and filename.
        Each point contains x, y, z, normalX, normalY, and normalZ fields. The default unit of the
        coordinate data is millimeter. Point cloud can be saved in organized or unorganized structure
        with ACSII mode.
        :param [in]: pointCloud The point cloud data to be saved. See 'PointCloudWithNormals' for
            details.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :param [in]: pointCloudUnit The unit of the coordinate data.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame3D_save_point_cloud_with_normals(*args)

# Register Frame3D in _area_scan_3d_camera:
_area_scan_3d_camera.Frame3D_swigregister(Frame3D)
class DepthMap(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.DepthMap_swiginit(self, _area_scan_3d_camera.new_DepthMap())
    __swig_destroy__ = _area_scan_3d_camera.delete_DepthMap

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.DepthMap_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.DepthMap_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.DepthMap_is_empty(self)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.DepthMap_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h).from_address(int(data.this)), np.float32)
        img = np.reshape(img, (h, w))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.DepthMap_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.DepthMap_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.DepthMap_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.DepthMap_release(self)

    def __getitem__(self, n):
        r"""__getitem__(DepthMap self, size_t n) -> PointZ"""
        return _area_scan_3d_camera.DepthMap___getitem__(self, n)

# Register DepthMap in _area_scan_3d_camera:
_area_scan_3d_camera.DepthMap_swigregister(DepthMap)
class UntexturedPointCloud(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.UntexturedPointCloud_swiginit(self, _area_scan_3d_camera.new_UntexturedPointCloud())
    __swig_destroy__ = _area_scan_3d_camera.delete_UntexturedPointCloud

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloud_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloud_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.UntexturedPointCloud_is_empty(self)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.UntexturedPointCloud_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 3).from_address(int(data.this)), np.float32)
        img = np.reshape(img, (h, w, 3))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.UntexturedPointCloud_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloud_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.UntexturedPointCloud_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloud_release(self)

    def __getitem__(self, n):
        r"""__getitem__(UntexturedPointCloud self, size_t n) -> PointXYZ"""
        return _area_scan_3d_camera.UntexturedPointCloud___getitem__(self, n)

# Register UntexturedPointCloud in _area_scan_3d_camera:
_area_scan_3d_camera.UntexturedPointCloud_swigregister(UntexturedPointCloud)
class UntexturedPointCloudWithNormals(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.UntexturedPointCloudWithNormals_swiginit(self, _area_scan_3d_camera.new_UntexturedPointCloudWithNormals())
    __swig_destroy__ = _area_scan_3d_camera.delete_UntexturedPointCloudWithNormals

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_is_empty(self)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.UntexturedPointCloudWithNormals_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 7).from_address(int(data.this)), np.float32)
        img = np.reshape(img, (h, w, 7))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals_release(self)

    def __getitem__(self, n):
        r"""__getitem__(UntexturedPointCloudWithNormals self, size_t n) -> PointXYZWithNormals"""
        return _area_scan_3d_camera.UntexturedPointCloudWithNormals___getitem__(self, n)

# Register UntexturedPointCloudWithNormals in _area_scan_3d_camera:
_area_scan_3d_camera.UntexturedPointCloudWithNormals_swigregister(UntexturedPointCloudWithNormals)
class PointXYZBGR(object):
    r"""
    Represents a point in 'TexturedPointCloud' with the coordinate (x, y, z) and texture
    (blue, green, red, and transparency) information.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(PointXYZBGR self) -> PointXYZBGR
        __init__(PointXYZBGR self, float x, float y, float z) -> PointXYZBGR
        __init__(PointXYZBGR self, uint8_t b, uint8_t g, uint8_t r, uint8_t a) -> PointXYZBGR
        __init__(PointXYZBGR self, float x, float y, float z, uint8_t b, uint8_t g, uint8_t r, uint8_t a=255) -> PointXYZBGR
        __init__(PointXYZBGR self, PointXYZBGR p) -> PointXYZBGR
        """
        _area_scan_3d_camera.PointXYZBGR_swiginit(self, _area_scan_3d_camera.new_PointXYZBGR(*args))
    x = property(_area_scan_3d_camera.PointXYZBGR_x_get, _area_scan_3d_camera.PointXYZBGR_x_set, doc=r""" X channel, default unit: mm, invalid data: nan.""")
    y = property(_area_scan_3d_camera.PointXYZBGR_y_get, _area_scan_3d_camera.PointXYZBGR_y_set, doc=r""" Y channel, default unit: mm, invalid data: nan.""")
    z = property(_area_scan_3d_camera.PointXYZBGR_z_get, _area_scan_3d_camera.PointXYZBGR_z_set, doc=r""" Z channel, default unit: mm, invalid data: nan.""")
    b = property(_area_scan_3d_camera.PointXYZBGR_b_get, _area_scan_3d_camera.PointXYZBGR_b_set, doc=r""" Blue channel.""")
    g = property(_area_scan_3d_camera.PointXYZBGR_g_get, _area_scan_3d_camera.PointXYZBGR_g_set, doc=r""" Green channel.""")
    r = property(_area_scan_3d_camera.PointXYZBGR_r_get, _area_scan_3d_camera.PointXYZBGR_r_set, doc=r""" Red channel.""")
    a = property(_area_scan_3d_camera.PointXYZBGR_a_get, _area_scan_3d_camera.PointXYZBGR_a_set, doc=r""" Transparency channel.""")
    rgb = property(_area_scan_3d_camera.PointXYZBGR_rgb_get, _area_scan_3d_camera.PointXYZBGR_rgb_set, doc=r"""rgb : float""")
    __swig_destroy__ = _area_scan_3d_camera.delete_PointXYZBGR

# Register PointXYZBGR in _area_scan_3d_camera:
_area_scan_3d_camera.PointXYZBGR_swigregister(PointXYZBGR)
class PointXYZBGRWithNormals(object):
    r"""
    The pixel element struct in 'TexturedPointCloudWithNormals' with the coordinate (x, y,
    z), texture (blue, green, red and transparency), and normal vector coordinate (x, y, z and
    curvature) information.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    color_point = property(_area_scan_3d_camera.PointXYZBGRWithNormals_color_point_get, _area_scan_3d_camera.PointXYZBGRWithNormals_color_point_set, doc=r"""color_point : mmind::eye::PointXYZBGR""")
    normal = property(_area_scan_3d_camera.PointXYZBGRWithNormals_normal_get, _area_scan_3d_camera.PointXYZBGRWithNormals_normal_set, doc=r"""normal : mmind::eye::NormalVector""")

    def __init__(self):
        r"""__init__(PointXYZBGRWithNormals self) -> PointXYZBGRWithNormals"""
        _area_scan_3d_camera.PointXYZBGRWithNormals_swiginit(self, _area_scan_3d_camera.new_PointXYZBGRWithNormals())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointXYZBGRWithNormals

# Register PointXYZBGRWithNormals in _area_scan_3d_camera:
_area_scan_3d_camera.PointXYZBGRWithNormals_swigregister(PointXYZBGRWithNormals)
class Frame2DAnd3D(object):
    r"""
    Represents the 2D and 3D capture results, which can be obtained by calling
    'Camera.capture2DAnd3D'. The 3D data can be in the
    form of 'PointZ' or 'PointXYZ' and is stored in a 2D array, with each element in the array
    representing a point. The class also provides methods for saving the point cloud data to a local
    file.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _area_scan_3d_camera.delete_Frame2DAnd3D

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        |

        *Overload 2:*

        Copy constructor.
        """
        _area_scan_3d_camera.Frame2DAnd3D_swiginit(self, _area_scan_3d_camera.new_Frame2DAnd3D(*args))

    def frame_2d(self):
        r"""Gets the 'Frame2D' data part."""
        return _area_scan_3d_camera.Frame2DAnd3D_frame_2d(self)

    def frame_3d(self):
        r"""Gets the 'Frame3D' data part."""
        return _area_scan_3d_camera.Frame2DAnd3D_frame_3d(self)

    def clear(self):
        r"""Clears the data in 'Frame2DAnd3D' and releases the associated resources."""
        return _area_scan_3d_camera.Frame2DAnd3D_clear(self)

    def get_textured_point_cloud(self):
        r"""
        Gets the 2D and 3D data aligned pixel-to-pixel with the 'PointXYZBGR' data format.
        Each point in 'TexturedPointCloud' contains the coordinate data in the
        camera reference frame and texture information. The default unit of the coordinates is
        millimeter (You can change the unit by calling 'Camera.setPointCloudUnit' before calling
        'Camera.capture2DAnd3D)', and the invalid data is represented by "nan".
        :rtype: :py:class:`TexturedPointCloud`
        :return: See 'TexturedPointCloud' for details.
        """
        return _area_scan_3d_camera.Frame2DAnd3D_get_textured_point_cloud(self)

    def get_textured_point_cloud_with_normals(self):
        r"""
        Gets the pixel-aligned 2D and 3D data with the 'PointXYZBGRWithNormals' pixel data
        format. Each point in 'TexturedPointCloudWithNormals' contains the X, Y, and Z data
        represented in the camera coordinate system and the texture information. X, Y, and Z data
        default unit is in mm (You can change the unit by calling 'Camera.setPointCloudUnit'
        before calling 'Camera.capture2DAnd3D)', and invalid data is in nan. Normal vectors are
        computed for each point. If the 'Frame2DAnd3D' is obtained by
        Camera.capture2DAnd3DWithNormal, the normal vectors are computed at the camera side.
        :rtype: :py:class:`TexturedPointCloudWithNormals`
        :return: See 'TexturedPointCloudWithNormals' for details.
        """
        return _area_scan_3d_camera.Frame2DAnd3D_get_textured_point_cloud_with_normals(self)

    def save_textured_point_cloud(self, fileFormat, fileName, isOrganized=False):
        r"""
        Saves the textured point cloud to a file of the input file format and filename.
        Each point contains x, y, z, blue, green, and red fields. The default unit of the coordinate
        data is millimeter (You can change the unit by calling 'Camera.setPointCloudUnit' before
        calling 'Camera.capture2DAnd3D)'. Point cloud can be saved in organized or unorganized
        structure with ACSII mode.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame2DAnd3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame2DAnd3D_save_textured_point_cloud(self, fileFormat, fileName, isOrganized)

    def save_textured_point_cloud_with_normals(self, fileFormat, fileName, isOrganized=False):
        r"""
        Saves the textured point cloud to a file of the input file format and filename.
        Each point contains x, y, z, blue, green, red, normalX, normalY, and normalZ fields. The
        default unit of the coordinate is millimeter (You can change the unit by calling
        Camera.setPointCloudUnit before calling 'Camera.capture2DAnd3D)'. Point cloud can be saved
        in organized or unorganized structure with ACSII mode.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame2DAnd3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame2DAnd3D_save_textured_point_cloud_with_normals(self, fileFormat, fileName, isOrganized)

    @staticmethod
    def save_point_cloud(*args):
        r"""
        Saves the textured point cloud to a file of the input file format and filename.
        Each point contains x, y, z, blue, green, and red fields. The default unit of the coordinate
        data is millimeter. Point cloud can be saved in organized or unorganized structure with ACSII
        mode.
        :param [in]: pointCloud The point cloud data to be saved. See 'TexturedPointCloud' for
            details.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :param [in]: pointCloudUnit The unit of the coordinate data.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame2DAnd3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame2DAnd3D_save_point_cloud(*args)

    @staticmethod
    def save_point_cloud_with_normals(*args):
        r"""
        Saves the textured point cloud to a file of the input file format and filename.
        Each point contains x, y, z, blue, green, red, normalX, normalY, and normalZ fields. The
        default unit of the coordinate data is millimeter. Point cloud can be saved in organized or
        unorganized structure with ACSII mode.
        :param [in]: pointCloud The point cloud data to be saved. See
            TexturedPointCloudWithNormals for details.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :param [in]: pointCloudUnit The unit of the coordinate data.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'Frame2DAnd3D' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _area_scan_3d_camera.Frame2DAnd3D_save_point_cloud_with_normals(*args)

# Register Frame2DAnd3D in _area_scan_3d_camera:
_area_scan_3d_camera.Frame2DAnd3D_swigregister(Frame2DAnd3D)
class TexturedPointCloud(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.TexturedPointCloud_swiginit(self, _area_scan_3d_camera.new_TexturedPointCloud())
    __swig_destroy__ = _area_scan_3d_camera.delete_TexturedPointCloud

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloud_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloud_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.TexturedPointCloud_is_empty(self)

    def vertices(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.TexturedPointCloud_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 4).from_address(int(data.this)), np.float32).copy()
        img = np.reshape(img, (h, w, 4))
        img = img[:, :, :3]
        return img.copy()

    def colors(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.TexturedPointCloud_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint8 * w * h * 16).from_address(int(data.this)), np.uint8).copy()
        img = np.reshape(img, (h, w, 16))
        img = img[:, :, 12:15]
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.TexturedPointCloud_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloud_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.TexturedPointCloud_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloud_release(self)

    def __getitem__(self, n):
        r"""__getitem__(TexturedPointCloud self, size_t n) -> PointXYZBGR"""
        return _area_scan_3d_camera.TexturedPointCloud___getitem__(self, n)

# Register TexturedPointCloud in _area_scan_3d_camera:
_area_scan_3d_camera.TexturedPointCloud_swigregister(TexturedPointCloud)
class TexturedPointCloudWithNormals(object):
    r"""Represents a 2D container of data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Constructor."""
        _area_scan_3d_camera.TexturedPointCloudWithNormals_swiginit(self, _area_scan_3d_camera.new_TexturedPointCloudWithNormals())
    __swig_destroy__ = _area_scan_3d_camera.delete_TexturedPointCloudWithNormals

    def width(self):
        r"""Returns the width of the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_width(self)

    def height(self):
        r"""Returns the height of the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_height(self)

    def is_empty(self):
        r"""Returns true if the Array2D object has no elements."""
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_is_empty(self)

    def vertices(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.TexturedPointCloudWithNormals_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 8).from_address(int(data.this)), np.float32).copy()
        img = np.reshape(img, (h, w, 8))
        img = img[:, :, :3]
        return img.copy()

    def colors(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.TexturedPointCloudWithNormals_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint8 * w * h * 32).from_address(int(data.this)), np.uint8).copy()
        img = np.reshape(img, (h, w, 32))
        img = img[:, :, 12:15]
        return img.copy()

    def normals(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _area_scan_3d_camera.TexturedPointCloudWithNormals_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 8).from_address(int(data.this)), np.float32).copy()
        img = np.reshape(img, (h, w, 8))
        img = img[:, :, 4:]
        return img.copy()



    def at(self, row, col):
        r"""
        Returns a reference to the element at the specified row and column in the Array2D
        object.
        :type row: int
        :param row: The index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: The index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_clone(self)

    def resize(self, width, height):
        r"""
        Changes the size of the Array2D object. It destroys the existing data and reallocates
        memory according to the new size, if the new size is different from the old size.
        :param [in]: width The new width of the Array2D object.
        :param [in]: height The new height of the Array2D object.
        """
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_resize(self, width, height)

    def release(self):
        r"""Deallocates the data in the Array2D object."""
        return _area_scan_3d_camera.TexturedPointCloudWithNormals_release(self)

    def __getitem__(self, n):
        r"""__getitem__(TexturedPointCloudWithNormals self, size_t n) -> PointXYZBGRWithNormals"""
        return _area_scan_3d_camera.TexturedPointCloudWithNormals___getitem__(self, n)

# Register TexturedPointCloudWithNormals in _area_scan_3d_camera:
_area_scan_3d_camera.TexturedPointCloudWithNormals_swigregister(TexturedPointCloudWithNormals)
class Camera(object):
    r"""
    Operates the camera.
    Use 'Camera.connect' to connect an available camera, and then call the corresponding methods
    to perform data acquisition, configure parameters, and so on.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _area_scan_3d_camera.delete_Camera

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        |

        *Overload 2:*

        Copy constructor.
        """
        _area_scan_3d_camera.Camera_swiginit(self, _area_scan_3d_camera.new_Camera(*args))

    @staticmethod
    def discover_cameras(timeoutMs=5000):
        r"""
        Discovers all available cameras and returns the list of
        information of all available cameras. If a camera is not successfully discovered, please
        check the network connection and indicator lights on the camera.
        :param [in]: timeoutMs The timeout period (in ms) for discovering cameras. If no cameras are
            discovered after the timeout period has passed, this method returns an empty list.
        :rtype: std::vector< mmind::eye::CameraInfo,std::allocator< mmind::eye::CameraInfo > >
        :return: The list of information of all available cameras.
        """
        return _area_scan_3d_camera.Camera_discover_cameras(timeoutMs)

    def connect(self, *args):
        r"""
        *Overload 1:*

        Connects to a camera using 'CameraInfo'.
        :param [in]: info The information of the camera to be connected. You can use
            Camera.discoverCameras to discover all available cameras.
        :param [in]: timeoutMs The timeout period (in ms) for connecting to a camera. If the camera
            connection does not succeed after the timeout period has passed, this method returns
            ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' IP address format error.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' IP address not corresponding to an available
             device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model or firmware
             version.

             'ErrorStatus::MMIND_STATUS_TIMEOUT_ERROR' Timeout error.


        |

        *Overload 2:*

        Connects to a camera using the IP address.
        :param [in]: ipAddress The IP address of the camera to be connected. The format of a valid IP
            address: 100.100.1.1.
        :param [in]: timeoutMs The timeout period (in ms) for connecting to a camera. If the camera
            connection does not succeed after the timeout period has passed, this method returns
            ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' IP address format error.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' IP address not corresponding to an available
             device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model or firmware
             version.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.


        |

        *Overload 3:*

        Connects to a camera using the IP address.
        :param [in]: ipAddress The IP address of the camera to be connected. The format of a valid IP
            address: 100.100.1.1.
        :param [in]: timeoutMs The timeout period (in ms) for connecting to a camera. If the camera
            connection does not succeed after the timeout period has passed, this method returns
            ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' IP address format error.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' IP address not corresponding to an available
             device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model or firmware
             version.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _area_scan_3d_camera.Camera_connect(self, *args)

    def disconnect(self):
        r"""Disconnects from the camera and releases the associated resources."""
        return _area_scan_3d_camera.Camera_disconnect(self)

    def set_heartbeat_interval(self, timeIntervalMs):
        r"""
        Sets the time interval at which the client sends periodic heartbeat messages to the
        camera side. The default time interval is 10s.
        :param [in]: timeIntervalMs The time interval for periodic sending heartbeat messages in
            milliseconds. The valid setting range is from 1s to 3600s.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_OUT_OF_RANGE_ERROR' Invalid parameter input.
        """
        return _area_scan_3d_camera.Camera_set_heartbeat_interval(self, timeIntervalMs)

    def get_camera_info(self, info):
        r"""
        Gets the basic information of the camera, such as the model, serial number,
        firmware version, and IP configuration.
        :param [out]: See 'CameraInfo' for details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.
        """
        return _area_scan_3d_camera.Camera_get_camera_info(self, info)

    def get_camera_status(self, status):
        r"""
        Gets various statuses of the camera.
        :param [out]: See 'CameraStatus' for details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.
        """
        return _area_scan_3d_camera.Camera_get_camera_status(self, status)

    def get_camera_resolutions(self, resolutions):
        r"""
        Gets the image resolutions of the camera. Two image resolutions are provided,
        2D image (texture) and depth map, which correspond to the 2D and 3D capture results
        Frame2D and 'Frame3D'.
        :param [out]: See 'CameraResolutions' for details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.
        """
        return _area_scan_3d_camera.Camera_get_camera_resolutions(self, resolutions)

    def current_user_set(self):
        r"""
        Gets the 'UserSet' currently in use.Through 'UserSet', you can access all
        available parameters of the camera related to 2D and 3D data acquisition. You can also use
        'UserSet' to directly set and get the parameter values instead of using 'Parameter'
        interface.
        :rtype: :py:class:`UserSet`
        :return: See 'UserSet' for details.
        """
        return _area_scan_3d_camera.Camera_current_user_set(self)

    def user_set_manager(self):
        r"""
        Gets the 'UserSetManager' of the camera. 'UserSetManager' provides various
        operations for managing all user sets saved in the camera, including adding and deleting user
        sets and selecting the user set to be used. It also provides the methods for saving all user
        sets to a JSON file and load all user sets from a JSON file.
        :rtype: :py:class:`UserSetManager`
        :return: See 'UserSetManager' for details.
        """
        return _area_scan_3d_camera.Camera_user_set_manager(self)

    def capture_3d(self, frame3D, timeoutMs=5000):
        r"""
        Projects structured light and captures a single 3D frame. 3D
        information is computed on the camera. The result is retrieved after the
        computation is completed.
        :param [out]: frame3D The capture result. See 'Frame3D' for details.
        :param [in]: timeoutMs The timeout period (in ms) for the capturing process. If no data is
            received within the timeout period, this method returns
            'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

        """
        return _area_scan_3d_camera.Camera_capture_3d(self, frame3D, timeoutMs)

    def capture_3d_with_normal(self, frame3D, timeoutMs=10000):
        r"""
        Projects structured light and captures a single 3D frame. 3D
        information and normal vector are computed on the camera. The result is
        retrieved after the computation is completed.
        :param [out]: frame3D The capture result. See 'Frame3D' for details.
        :param [in]: timeoutMs The timeout period (in ms) for the capturing process. If no data is
            received within the timeout period, this method returns
            'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _area_scan_3d_camera.Camera_capture_3d_with_normal(self, frame3D, timeoutMs)

    def capture_2d(self, frame2D, timeoutMs=5000):
        r"""
        Captures a single 2D frame using the 2D camera in the 3D camera. The result is
        retrieved after the capture is completed.
        :param [out]: frame2D The capture result. See 'Frame2D' for details.
        :param [in]: timeoutMs The timeout period (in ms) for the capturing process. If no data is
            received within the timeout period, this method returns
            'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _area_scan_3d_camera.Camera_capture_2d(self, frame2D, timeoutMs)

    def capture_2d_and_3d(self, frame2DAnd3D, timeoutMs=10000):
        r"""
        Simultaneously captures a single 2D frame and 3D frame. 3D
        information is computed on the camera. Both 2D and 3D capture results are
        retrieved after the capturing and computation processes are completed. Using this method, you
        can easily generate the textured point cloud from both 2D and 3D data.
        :param [out]: frame2DAnd3D The capture result containing 'Frame2D' and 'Frame3D'. See
            'Frame2DAnd3D' for details.
        :param [in]: timeoutMs The timeout period (in ms) for the capturing process. If no data is
            received within the timeout period, this method returns
            'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _area_scan_3d_camera.Camera_capture_2d_and_3d(self, frame2DAnd3D, timeoutMs)

    def capture_2d_and_3d_with_normal(self, frame2DAnd3D, timeoutMs=15000):
        r"""
        Simultaneously captures a single 2D frame and 3D frame. 3D
        information and normal vector are computed on the camera.
        Both 2D and 3D capture results are retrieved after the capturing and computation processes
        are completed. Using this method, you can easily generate the texture point cloud from both
        2D and 3D data.
        :param [out]: frame2DAnd3D The capture result containing 'Frame2D' and 'Frame3D'. See
            'Frame2DAnd3D' for details.
        :param [in]: timeoutMs The timeout period (in ms) for the capturing process. If no data is
            received within the timeout period, this method returns
            'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _area_scan_3d_camera.Camera_capture_2d_and_3d_with_normal(self, frame2DAnd3D, timeoutMs)

    def capture_stereo_2d(self, left, right, isRectified=False, timeoutMs=5000):
        r"""
        Captures the 2D images from both 2D cameras in the 3D camera. This method is
        only available for DEEP, DEEP-GL, LSR S, LSR S-GL, LSR L, LSR L-GL, PRO XS, and PRO XS-GL.
        Since: V2.2.1
        :param [out]: left The 2D image of the left 2D camera. See 'Frame2D' for details.
        :param [out]: right The 2D image of the right 2D camera. See 'Frame2D' for details.
        :param [in]: isRectified Whether to perform stereo rectification. After the rectification, The
            left image and the depth map are aligned pixel-to-pixel. If true, the rectified 2D images are
            returned. If false, the original images are returned.
        :param [in]: timeoutMs The timeout period (in ms) for the capturing process. If no data is
            received within the timeout period, this method returns
            ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model or firmware
             version.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

        Notes: Different camera models have different parameters for adjusting the exposure of
        these 2D images. For DEEP, DEEP-GL, LSR S, LSR S-GL, LSR L, and LSR L-GL,adjust
        DepthSourceExposureMode and 'DepthSourceExposureTime'. For the other models,
        adjust 'ExposureMode' and 'ExposureTime'.
        """
        return _area_scan_3d_camera.Camera_capture_stereo_2d(self, left, right, isRectified, timeoutMs)

    def set_point_cloud_unit(self, unit):
        r"""
        Sets the unit of the point cloud.
        :param [in]: unit The new 'CoordinateUnit' of the point cloud.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No frame data obtained. Some error may have
             occurred on the device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Unsupported camera model.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _area_scan_3d_camera.Camera_set_point_cloud_unit(self, unit)

    def save_virtual_device_file(self, fileName):
        r"""
        Saves the acquired data, 'Parameter' s, and 'CameraInfo' in an MRAW format file
        that can be loaded as a virtual device in Mech-Eye Viewer.

        :type fileName: string
        :param fileName: The name of the MRAW file to be saved. You can add a path before the name to
            specify the path for saving the file.
        Notes: Depending on the parameter settings and amount of data to be saved, it may take up to a
        few minutes to save the virtual device file. Please ensure that the file name is encoded in
        UTF-8 format.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Failed to create the virtual device file.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No data available for saving.
        """
        return _area_scan_3d_camera.Camera_save_virtual_device_file(self, fileName)

    def get_camera_intrinsics(self, wrappedIntrinsics):
        r"""get_camera_intrinsics(Camera self, CameraIntrinsics wrappedIntrinsics) -> ErrorStatus"""
        return _area_scan_3d_camera.Camera_get_camera_intrinsics(self, wrappedIntrinsics)

    def get_point_cloud_unit(self):
        r"""get_point_cloud_unit(Camera self) -> ErrorStatus"""
        return _area_scan_3d_camera.Camera_get_point_cloud_unit(self)

# Register Camera in _area_scan_3d_camera:
_area_scan_3d_camera.Camera_swigregister(Camera)
class VectorCameraInfo(object):
    r"""Proxy of C++ std::vector< mmind::eye::CameraInfo > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorCameraInfo self) -> SwigPyIterator"""
        return _area_scan_3d_camera.VectorCameraInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorCameraInfo self) -> bool"""
        return _area_scan_3d_camera.VectorCameraInfo___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorCameraInfo self) -> bool"""
        return _area_scan_3d_camera.VectorCameraInfo___bool__(self)

    def __len__(self):
        r"""__len__(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::size_type"""
        return _area_scan_3d_camera.VectorCameraInfo___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i, std::vector< mmind::eye::CameraInfo >::difference_type j) -> VectorCameraInfo"""
        return _area_scan_3d_camera.VectorCameraInfo___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i, std::vector< mmind::eye::CameraInfo >::difference_type j)
        __setslice__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i, std::vector< mmind::eye::CameraInfo >::difference_type j, VectorCameraInfo v)
        """
        return _area_scan_3d_camera.VectorCameraInfo___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i, std::vector< mmind::eye::CameraInfo >::difference_type j)"""
        return _area_scan_3d_camera.VectorCameraInfo___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i)
        __delitem__(VectorCameraInfo self, SWIGPY_SLICEOBJECT * slice)
        """
        return _area_scan_3d_camera.VectorCameraInfo___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorCameraInfo self, SWIGPY_SLICEOBJECT * slice) -> VectorCameraInfo
        __getitem__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i) -> CameraInfo
        """
        return _area_scan_3d_camera.VectorCameraInfo___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorCameraInfo self, SWIGPY_SLICEOBJECT * slice, VectorCameraInfo v)
        __setitem__(VectorCameraInfo self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::difference_type i, CameraInfo x)
        """
        return _area_scan_3d_camera.VectorCameraInfo___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorCameraInfo self) -> CameraInfo"""
        return _area_scan_3d_camera.VectorCameraInfo_pop(self)

    def append(self, x):
        r"""append(VectorCameraInfo self, CameraInfo x)"""
        return _area_scan_3d_camera.VectorCameraInfo_append(self, x)

    def empty(self):
        r"""empty(VectorCameraInfo self) -> bool"""
        return _area_scan_3d_camera.VectorCameraInfo_empty(self)

    def size(self):
        r"""size(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::size_type"""
        return _area_scan_3d_camera.VectorCameraInfo_size(self)

    def swap(self, v):
        r"""swap(VectorCameraInfo self, VectorCameraInfo v)"""
        return _area_scan_3d_camera.VectorCameraInfo_swap(self, v)

    def begin(self):
        r"""begin(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::iterator"""
        return _area_scan_3d_camera.VectorCameraInfo_begin(self)

    def end(self):
        r"""end(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::iterator"""
        return _area_scan_3d_camera.VectorCameraInfo_end(self)

    def rbegin(self):
        r"""rbegin(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::reverse_iterator"""
        return _area_scan_3d_camera.VectorCameraInfo_rbegin(self)

    def rend(self):
        r"""rend(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::reverse_iterator"""
        return _area_scan_3d_camera.VectorCameraInfo_rend(self)

    def clear(self):
        r"""clear(VectorCameraInfo self)"""
        return _area_scan_3d_camera.VectorCameraInfo_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::allocator_type"""
        return _area_scan_3d_camera.VectorCameraInfo_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorCameraInfo self)"""
        return _area_scan_3d_camera.VectorCameraInfo_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::iterator pos) -> std::vector< mmind::eye::CameraInfo >::iterator
        erase(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::iterator first, std::vector< mmind::eye::CameraInfo >::iterator last) -> std::vector< mmind::eye::CameraInfo >::iterator
        """
        return _area_scan_3d_camera.VectorCameraInfo_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorCameraInfo self) -> VectorCameraInfo
        __init__(VectorCameraInfo self, VectorCameraInfo other) -> VectorCameraInfo
        __init__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::size_type size) -> VectorCameraInfo
        __init__(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::size_type size, CameraInfo value) -> VectorCameraInfo
        """
        _area_scan_3d_camera.VectorCameraInfo_swiginit(self, _area_scan_3d_camera.new_VectorCameraInfo(*args))

    def push_back(self, x):
        r"""push_back(VectorCameraInfo self, CameraInfo x)"""
        return _area_scan_3d_camera.VectorCameraInfo_push_back(self, x)

    def front(self):
        r"""front(VectorCameraInfo self) -> CameraInfo"""
        return _area_scan_3d_camera.VectorCameraInfo_front(self)

    def back(self):
        r"""back(VectorCameraInfo self) -> CameraInfo"""
        return _area_scan_3d_camera.VectorCameraInfo_back(self)

    def assign(self, n, x):
        r"""assign(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::size_type n, CameraInfo x)"""
        return _area_scan_3d_camera.VectorCameraInfo_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::size_type new_size)
        resize(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::size_type new_size, CameraInfo x)
        """
        return _area_scan_3d_camera.VectorCameraInfo_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::iterator pos, CameraInfo x) -> std::vector< mmind::eye::CameraInfo >::iterator
        insert(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::iterator pos, std::vector< mmind::eye::CameraInfo >::size_type n, CameraInfo x)
        """
        return _area_scan_3d_camera.VectorCameraInfo_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorCameraInfo self, std::vector< mmind::eye::CameraInfo >::size_type n)"""
        return _area_scan_3d_camera.VectorCameraInfo_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorCameraInfo self) -> std::vector< mmind::eye::CameraInfo >::size_type"""
        return _area_scan_3d_camera.VectorCameraInfo_capacity(self)
    __swig_destroy__ = _area_scan_3d_camera.delete_VectorCameraInfo

# Register VectorCameraInfo in _area_scan_3d_camera:
_area_scan_3d_camera.VectorCameraInfo_swigregister(VectorCameraInfo)
class EventCallbackBase(object):
    r"""Proxy of C++ EventCallbackBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def run(self, event):
        r"""run(EventCallbackBase self, mmind::eye::CameraEvent::Event event)"""
        return _area_scan_3d_camera.EventCallbackBase_run(self, event)

    def process_event(self, eventData):
        r"""process_event(EventCallbackBase self, EventData eventData)"""
        return _area_scan_3d_camera.EventCallbackBase_process_event(self, eventData)

    def process_event_with_payload(self, eventData, extraPayload):
        r"""process_event_with_payload(EventCallbackBase self, EventData eventData, Payload extraPayload)"""
        return _area_scan_3d_camera.EventCallbackBase_process_event_with_payload(self, eventData, extraPayload)
    __swig_destroy__ = _area_scan_3d_camera.delete_EventCallbackBase

    def __init__(self):
        r"""__init__(EventCallbackBase self) -> EventCallbackBase"""
        if self.__class__ == EventCallbackBase:
            _self = None
        else:
            _self = self
        _area_scan_3d_camera.EventCallbackBase_swiginit(self, _area_scan_3d_camera.new_EventCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _area_scan_3d_camera.disown_EventCallbackBase(self)
        return weakref.proxy(self)

# Register EventCallbackBase in _area_scan_3d_camera:
_area_scan_3d_camera.EventCallbackBase_swigregister(EventCallbackBase)
class EventData(object):
    r"""Represents data associated with a camera event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    event_id = property(_area_scan_3d_camera.EventData_event_id_get, _area_scan_3d_camera.EventData_event_id_set, doc=r"""event_id : int""")
    event_name = property(_area_scan_3d_camera.EventData_event_name_get, _area_scan_3d_camera.EventData_event_name_set, doc=r"""event_name : std::string""")
    timestamp = property(_area_scan_3d_camera.EventData_timestamp_get, _area_scan_3d_camera.EventData_timestamp_set, doc=r"""timestamp : int64_t""")
    frame_id = property(_area_scan_3d_camera.EventData_frame_id_get, _area_scan_3d_camera.EventData_frame_id_set, doc=r"""frame_id : int64_t""")

    def __init__(self):
        r"""__init__(EventData self) -> EventData"""
        _area_scan_3d_camera.EventData_swiginit(self, _area_scan_3d_camera.new_EventData())
    __swig_destroy__ = _area_scan_3d_camera.delete_EventData

# Register EventData in _area_scan_3d_camera:
_area_scan_3d_camera.EventData_swigregister(EventData)
class CameraEvent(object):
    r"""
    The camera event related.
    Use 'CameraEvent.getSupportedEvents' to get supported events.
    Use 'CameraEvent.registerCameraEventCallback' to register an event of interest.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CAMERA_EVENT_NONE = _area_scan_3d_camera.CameraEvent_CAMERA_EVENT_NONE
    r""" The default value."""
    CAMERA_EVENT_DISCONNECTED = _area_scan_3d_camera.CameraEvent_CAMERA_EVENT_DISCONNECTED
    r""" The camera has disconnected."""
    CAMERA_EVENT_EXPOSURE_END = _area_scan_3d_camera.CameraEvent_CAMERA_EVENT_EXPOSURE_END
    r"""
    The camera has completed structured-light projection and exposure.
    Note: This event is sent after the structured-light projection has been
    completed. To ensure both 2D and 3D data have been acquired before the
    event is sent, check the following recommendations: If the flash
    exposure mode is used for acquiring the 2D data, and the
    scanning2d_setting::FlashAcquisitionMode parameter is set to "Fast",
    call
    'Camera::capture3D' before calling 'Camera::capture2D'.
    Otherwise, call 'Camera::capture2D' before calling
    Camera::capture3D. Alternatively, you can call
    Camera.capture2DAnd3D instead to avoid the timing issue.
    """
    CAMERA_EVENT_ALL = _area_scan_3d_camera.CameraEvent_CAMERA_EVENT_ALL
    r""" All camera events."""

    @staticmethod
    def get_supported_events(camera, eventInfos):
        r"""
        Get supported events by the camera

        :type camera: :py:class:`Camera`
        :param camera: The camera for which to get supported events.
        :type eventInfos: std::vector< mmind::eye::CameraEvent::EventInfo,std::allocator< mmind::eye::CameraEvent::EventInfo > >
        :param eventInfos: The information of the events supported.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.
        """
        return _area_scan_3d_camera.CameraEvent_get_supported_events(camera, eventInfos)

    def register_camera_event_callback(self, *args):
        r"""
        register_camera_event_callback(CameraEvent self, Camera camera, EventCallbackBase callback, unsigned int events) -> ErrorStatus

            :brief Registers a camera event of interest.
            :deprecated: this method is deprecated since version 2.4.0. Please use the following method instead: register_camera_event_callback(CameraEvent self, Camera camera, mmind::eye::CameraEvent::Event event, EventCallbackBase callback) -> ErrorStatus.
            :type camera: :py:class:`Camera`
            :param camera: The camera object to unregister the callback for.
            :type callback: :py:class:`EventCallbackBase`
            :param callback: User-derived version of :py:class:`EventCallbackBase` for handling camera events.
            :type event: int
            :param event: The camera event. See :py:enum:`CameraEvent.Event` for details.

            :rtype: :py:class:`ErrorStatus`
            :return:
                 'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

                 'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle, not connected to any
                       device.

                 'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected due to network issues.

                 'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Not supported camera model or firmware.

        register_camera_event_callback(CameraEvent self, Camera camera, uint16_t event, EventCallbackBase callback) -> ErrorStatus

            :brief Registers a callback to handle a camera event.
            This function registers a callback function to be invoked when a specified event occurs
            on the given camera object.

            :type camera: :py:class:`Camera`
            :param camera: The camera object to unregister the callback for.
            :type event: int
            :param event: The camera event. See `CameraEvent.get_supported_events` for details.
            :type callback: :py:class:`EventCallbackBase`
            :param callback: User-derived version of :py:class:`EventCallbackBase` for handling camera events.

            :rtype: :py:class:`ErrorStatus`
            :return:
                'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

                'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle, not connected to any
                     device.

                'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected due to network issues.

                'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Not supported camera model or firmware.

                'ErrorStatus.MMIND_STATUS_INVALID_CALLBACKFUNC' Callback function is null or has been
                                                                                     registered already.

                'ErrorStatus.MMIND_STATUS_MESSAGE_CHANNEL_ERROR' Failed to establish message channel
                                                                                     for reporting events.

        """
        return _area_scan_3d_camera.CameraEvent_register_camera_event_callback(self, *args)



    def unregister_camera_event_callback(self, camera, event):
        r"""unregister_camera_event_callback(CameraEvent self, Camera camera, uint16_t event) -> ErrorStatus"""
        return _area_scan_3d_camera.CameraEvent_unregister_camera_event_callback(self, camera, event)

    def __init__(self):
        r"""__init__(CameraEvent self) -> CameraEvent"""
        _area_scan_3d_camera.CameraEvent_swiginit(self, _area_scan_3d_camera.new_CameraEvent())
    __swig_destroy__ = _area_scan_3d_camera.delete_CameraEvent

# Register CameraEvent in _area_scan_3d_camera:
_area_scan_3d_camera.CameraEvent_swigregister(CameraEvent)
class EventInfo(object):
    r"""Describes the event information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    event_name = property(_area_scan_3d_camera.EventInfo_event_name_get, _area_scan_3d_camera.EventInfo_event_name_set, doc=r"""event_name : std::string""")
    event_id = property(_area_scan_3d_camera.EventInfo_event_id_get, _area_scan_3d_camera.EventInfo_event_id_set, doc=r"""event_id : uint16_t""")

    def __init__(self, *args):
        r"""
        __init__(EventInfo self) -> EventInfo
        __init__(EventInfo self, std::string const & eventName, uint16_t eventId) -> EventInfo
        """
        _area_scan_3d_camera.EventInfo_swiginit(self, _area_scan_3d_camera.new_EventInfo(*args))
    __swig_destroy__ = _area_scan_3d_camera.delete_EventInfo

# Register EventInfo in _area_scan_3d_camera:
_area_scan_3d_camera.EventInfo_swigregister(EventInfo)
class PayloadMember(object):
    r"""Describes the data member of the event's payload."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_area_scan_3d_camera.PayloadMember_name_get, _area_scan_3d_camera.PayloadMember_name_set, doc=r""" Member name""")
    Type__UInt32 = _area_scan_3d_camera.PayloadMember_Type__UInt32
    
    Type__Int32 = _area_scan_3d_camera.PayloadMember_Type__Int32
    
    Type__Int64 = _area_scan_3d_camera.PayloadMember_Type__Int64
    
    Type__Float = _area_scan_3d_camera.PayloadMember_Type__Float
    
    Type__Double = _area_scan_3d_camera.PayloadMember_Type__Double
    
    Type__Bool = _area_scan_3d_camera.PayloadMember_Type__Bool
    
    Type__String = _area_scan_3d_camera.PayloadMember_Type__String
    
    type = property(_area_scan_3d_camera.PayloadMember_type_get, _area_scan_3d_camera.PayloadMember_type_set, doc=r""" Member type""")
    value = property(_area_scan_3d_camera.PayloadMember_value_get, _area_scan_3d_camera.PayloadMember_value_set, doc=r""" Member value""")

    def __init__(self):
        r"""__init__(PayloadMember self) -> PayloadMember"""
        _area_scan_3d_camera.PayloadMember_swiginit(self, _area_scan_3d_camera.new_PayloadMember())
    __swig_destroy__ = _area_scan_3d_camera.delete_PayloadMember

# Register PayloadMember in _area_scan_3d_camera:
_area_scan_3d_camera.PayloadMember_swigregister(PayloadMember)
class MemberValue(object):
    r"""Proxy of C++ mmind::eye::CameraEvent::PayloadMember::MemberValue class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uint_32value = property(_area_scan_3d_camera.MemberValue_uint_32value_get, _area_scan_3d_camera.MemberValue_uint_32value_set, doc=r"""uint_32value : uint32_t""")
    int_32value = property(_area_scan_3d_camera.MemberValue_int_32value_get, _area_scan_3d_camera.MemberValue_int_32value_set, doc=r"""int_32value : int32_t""")
    int_64value = property(_area_scan_3d_camera.MemberValue_int_64value_get, _area_scan_3d_camera.MemberValue_int_64value_set, doc=r"""int_64value : int64_t""")
    float_value = property(_area_scan_3d_camera.MemberValue_float_value_get, _area_scan_3d_camera.MemberValue_float_value_set, doc=r"""float_value : float""")
    double_value = property(_area_scan_3d_camera.MemberValue_double_value_get, _area_scan_3d_camera.MemberValue_double_value_set, doc=r"""double_value : double""")
    bool_value = property(_area_scan_3d_camera.MemberValue_bool_value_get, _area_scan_3d_camera.MemberValue_bool_value_set, doc=r"""bool_value : bool""")
    string_value = property(_area_scan_3d_camera.MemberValue_string_value_get, _area_scan_3d_camera.MemberValue_string_value_set, doc=r"""string_value : std::string""")

    def __init__(self):
        r"""__init__(MemberValue self) -> MemberValue"""
        _area_scan_3d_camera.MemberValue_swiginit(self, _area_scan_3d_camera.new_MemberValue())
    __swig_destroy__ = _area_scan_3d_camera.delete_MemberValue

# Register MemberValue in _area_scan_3d_camera:
_area_scan_3d_camera.MemberValue_swigregister(MemberValue)
class Payload(object):
    r"""Proxy of C++ std::vector< mmind::eye::CameraEvent::PayloadMember > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(Payload self) -> SwigPyIterator"""
        return _area_scan_3d_camera.Payload_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(Payload self) -> bool"""
        return _area_scan_3d_camera.Payload___nonzero__(self)

    def __bool__(self):
        r"""__bool__(Payload self) -> bool"""
        return _area_scan_3d_camera.Payload___bool__(self)

    def __len__(self):
        r"""__len__(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type"""
        return _area_scan_3d_camera.Payload___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type j) -> Payload"""
        return _area_scan_3d_camera.Payload___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type j)
        __setslice__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type j, Payload v)
        """
        return _area_scan_3d_camera.Payload___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type j)"""
        return _area_scan_3d_camera.Payload___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i)
        __delitem__(Payload self, SWIGPY_SLICEOBJECT * slice)
        """
        return _area_scan_3d_camera.Payload___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(Payload self, SWIGPY_SLICEOBJECT * slice) -> Payload
        __getitem__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i) -> PayloadMember
        """
        return _area_scan_3d_camera.Payload___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(Payload self, SWIGPY_SLICEOBJECT * slice, Payload v)
        __setitem__(Payload self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::difference_type i, PayloadMember x)
        """
        return _area_scan_3d_camera.Payload___setitem__(self, *args)

    def pop(self):
        r"""pop(Payload self) -> PayloadMember"""
        return _area_scan_3d_camera.Payload_pop(self)

    def append(self, x):
        r"""append(Payload self, PayloadMember x)"""
        return _area_scan_3d_camera.Payload_append(self, x)

    def empty(self):
        r"""empty(Payload self) -> bool"""
        return _area_scan_3d_camera.Payload_empty(self)

    def size(self):
        r"""size(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type"""
        return _area_scan_3d_camera.Payload_size(self)

    def swap(self, v):
        r"""swap(Payload self, Payload v)"""
        return _area_scan_3d_camera.Payload_swap(self, v)

    def begin(self):
        r"""begin(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator"""
        return _area_scan_3d_camera.Payload_begin(self)

    def end(self):
        r"""end(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator"""
        return _area_scan_3d_camera.Payload_end(self)

    def rbegin(self):
        r"""rbegin(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::reverse_iterator"""
        return _area_scan_3d_camera.Payload_rbegin(self)

    def rend(self):
        r"""rend(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::reverse_iterator"""
        return _area_scan_3d_camera.Payload_rend(self)

    def clear(self):
        r"""clear(Payload self)"""
        return _area_scan_3d_camera.Payload_clear(self)

    def get_allocator(self):
        r"""get_allocator(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::allocator_type"""
        return _area_scan_3d_camera.Payload_get_allocator(self)

    def pop_back(self):
        r"""pop_back(Payload self)"""
        return _area_scan_3d_camera.Payload_pop_back(self)

    def erase(self, *args):
        r"""
        erase(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator pos) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator
        erase(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator first, std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator last) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator
        """
        return _area_scan_3d_camera.Payload_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Payload self) -> Payload
        __init__(Payload self, Payload other) -> Payload
        __init__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type size) -> Payload
        __init__(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type size, PayloadMember value) -> Payload
        """
        _area_scan_3d_camera.Payload_swiginit(self, _area_scan_3d_camera.new_Payload(*args))

    def push_back(self, x):
        r"""push_back(Payload self, PayloadMember x)"""
        return _area_scan_3d_camera.Payload_push_back(self, x)

    def front(self):
        r"""front(Payload self) -> PayloadMember"""
        return _area_scan_3d_camera.Payload_front(self)

    def back(self):
        r"""back(Payload self) -> PayloadMember"""
        return _area_scan_3d_camera.Payload_back(self)

    def assign(self, n, x):
        r"""assign(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type n, PayloadMember x)"""
        return _area_scan_3d_camera.Payload_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type new_size)
        resize(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type new_size, PayloadMember x)
        """
        return _area_scan_3d_camera.Payload_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator pos, PayloadMember x) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator
        insert(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::iterator pos, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type n, PayloadMember x)
        """
        return _area_scan_3d_camera.Payload_insert(self, *args)

    def reserve(self, n):
        r"""reserve(Payload self, std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type n)"""
        return _area_scan_3d_camera.Payload_reserve(self, n)

    def capacity(self):
        r"""capacity(Payload self) -> std::vector< mmind::eye::CameraEvent::PayloadMember >::size_type"""
        return _area_scan_3d_camera.Payload_capacity(self)
    __swig_destroy__ = _area_scan_3d_camera.delete_Payload

# Register Payload in _area_scan_3d_camera:
_area_scan_3d_camera.Payload_swigregister(Payload)
class EventInfos(object):
    r"""Proxy of C++ std::vector< mmind::eye::CameraEvent::EventInfo > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(EventInfos self) -> SwigPyIterator"""
        return _area_scan_3d_camera.EventInfos_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(EventInfos self) -> bool"""
        return _area_scan_3d_camera.EventInfos___nonzero__(self)

    def __bool__(self):
        r"""__bool__(EventInfos self) -> bool"""
        return _area_scan_3d_camera.EventInfos___bool__(self)

    def __len__(self):
        r"""__len__(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::size_type"""
        return _area_scan_3d_camera.EventInfos___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type j) -> EventInfos"""
        return _area_scan_3d_camera.EventInfos___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type j)
        __setslice__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type j, EventInfos v)
        """
        return _area_scan_3d_camera.EventInfos___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type j)"""
        return _area_scan_3d_camera.EventInfos___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i)
        __delitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice)
        """
        return _area_scan_3d_camera.EventInfos___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice) -> EventInfos
        __getitem__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i) -> EventInfo
        """
        return _area_scan_3d_camera.EventInfos___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice, EventInfos v)
        __setitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::difference_type i, EventInfo x)
        """
        return _area_scan_3d_camera.EventInfos___setitem__(self, *args)

    def pop(self):
        r"""pop(EventInfos self) -> EventInfo"""
        return _area_scan_3d_camera.EventInfos_pop(self)

    def append(self, x):
        r"""append(EventInfos self, EventInfo x)"""
        return _area_scan_3d_camera.EventInfos_append(self, x)

    def empty(self):
        r"""empty(EventInfos self) -> bool"""
        return _area_scan_3d_camera.EventInfos_empty(self)

    def size(self):
        r"""size(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::size_type"""
        return _area_scan_3d_camera.EventInfos_size(self)

    def swap(self, v):
        r"""swap(EventInfos self, EventInfos v)"""
        return _area_scan_3d_camera.EventInfos_swap(self, v)

    def begin(self):
        r"""begin(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::iterator"""
        return _area_scan_3d_camera.EventInfos_begin(self)

    def end(self):
        r"""end(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::iterator"""
        return _area_scan_3d_camera.EventInfos_end(self)

    def rbegin(self):
        r"""rbegin(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::reverse_iterator"""
        return _area_scan_3d_camera.EventInfos_rbegin(self)

    def rend(self):
        r"""rend(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::reverse_iterator"""
        return _area_scan_3d_camera.EventInfos_rend(self)

    def clear(self):
        r"""clear(EventInfos self)"""
        return _area_scan_3d_camera.EventInfos_clear(self)

    def get_allocator(self):
        r"""get_allocator(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::allocator_type"""
        return _area_scan_3d_camera.EventInfos_get_allocator(self)

    def pop_back(self):
        r"""pop_back(EventInfos self)"""
        return _area_scan_3d_camera.EventInfos_pop_back(self)

    def erase(self, *args):
        r"""
        erase(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::iterator pos) -> std::vector< mmind::eye::CameraEvent::EventInfo >::iterator
        erase(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::iterator first, std::vector< mmind::eye::CameraEvent::EventInfo >::iterator last) -> std::vector< mmind::eye::CameraEvent::EventInfo >::iterator
        """
        return _area_scan_3d_camera.EventInfos_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(EventInfos self) -> EventInfos
        __init__(EventInfos self, EventInfos other) -> EventInfos
        __init__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type size) -> EventInfos
        __init__(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type size, EventInfo value) -> EventInfos
        """
        _area_scan_3d_camera.EventInfos_swiginit(self, _area_scan_3d_camera.new_EventInfos(*args))

    def push_back(self, x):
        r"""push_back(EventInfos self, EventInfo x)"""
        return _area_scan_3d_camera.EventInfos_push_back(self, x)

    def front(self):
        r"""front(EventInfos self) -> EventInfo"""
        return _area_scan_3d_camera.EventInfos_front(self)

    def back(self):
        r"""back(EventInfos self) -> EventInfo"""
        return _area_scan_3d_camera.EventInfos_back(self)

    def assign(self, n, x):
        r"""assign(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type n, EventInfo x)"""
        return _area_scan_3d_camera.EventInfos_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type new_size)
        resize(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type new_size, EventInfo x)
        """
        return _area_scan_3d_camera.EventInfos_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::iterator pos, EventInfo x) -> std::vector< mmind::eye::CameraEvent::EventInfo >::iterator
        insert(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::iterator pos, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type n, EventInfo x)
        """
        return _area_scan_3d_camera.EventInfos_insert(self, *args)

    def reserve(self, n):
        r"""reserve(EventInfos self, std::vector< mmind::eye::CameraEvent::EventInfo >::size_type n)"""
        return _area_scan_3d_camera.EventInfos_reserve(self, n)

    def capacity(self):
        r"""capacity(EventInfos self) -> std::vector< mmind::eye::CameraEvent::EventInfo >::size_type"""
        return _area_scan_3d_camera.EventInfos_capacity(self)
    __swig_destroy__ = _area_scan_3d_camera.delete_EventInfos

# Register EventInfos in _area_scan_3d_camera:
_area_scan_3d_camera.EventInfos_swigregister(EventInfos)
class HandEyeCalibration(object):
    r"""Proxy of C++ mmind::eye::HandEyeCalibration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CameraMountingMode_EyeInHand = _area_scan_3d_camera.HandEyeCalibration_CameraMountingMode_EyeInHand
    r""" The camera is mounted in the robot's hand."""
    CameraMountingMode_EyeToHand = _area_scan_3d_camera.HandEyeCalibration_CameraMountingMode_EyeToHand
    r""" The camera is fixed mounted with respect to the robot's base."""
    CalibrationBoardModel_BDB_5 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_BDB_5
    
    CalibrationBoardModel_BDB_6 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_BDB_6
    
    CalibrationBoardModel_BDB_7 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_BDB_7
    
    CalibrationBoardModel_OCB_5 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_OCB_5
    
    CalibrationBoardModel_OCB_10 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_OCB_10
    
    CalibrationBoardModel_OCB_15 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_OCB_15
    
    CalibrationBoardModel_OCB_20 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_OCB_20
    
    CalibrationBoardModel_CGB_20 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_CGB_20
    
    CalibrationBoardModel_CGB_35 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_CGB_35
    
    CalibrationBoardModel_CGB_50 = _area_scan_3d_camera.HandEyeCalibration_CalibrationBoardModel_CGB_50
    

    def initialize_calibration(self, camera, mountingMode, boardModel):
        r"""
        Sets the board model and camera mounting mode for this calibration.
        :param [in]: camera The camera handle.
        :param [in]: mountingMode The camera mounting mode. See 'CameraMountingMode' for details.
        :param [in]: boardModel The calibration board model. See 'CalibrationBoardModel' for
            details.
        :rtype: :py:class:`ErrorStatus`
        :return: See 'ErrorStatus' for details.
        """
        return _area_scan_3d_camera.HandEyeCalibration_initialize_calibration(self, camera, mountingMode, boardModel)

    def add_pose_and_detect(self, camera, poseData, color2DImage, timeoutMs=10000):
        r"""
        Adds current pose of the robot, captures the image, and calculates necessary
        parameters prepared for calibration.
        :param [in]: camera The camera handle.
        :param [in]: poseData The current pose of the robot. See 'Transformation' for details.
        :param [out]: color2DImage The current 2D image with feature recognition result. See
            Color2DImage for details.
        :param [in]: timeoutMs The timeout for connecting a camera in ms unit. If the execution
            time of the connecting process is greater than the timeout, the function will immediately
            return 'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: See 'ErrorStatus' for details.
        """
        return _area_scan_3d_camera.HandEyeCalibration_add_pose_and_detect(self, camera, poseData, color2DImage, timeoutMs)

    def calculate_extrinsics(self, camera, cameraToBase):
        r"""
        Starts to calculate the result of hand-eye calibration.
        :param [in]: camera The camera handle.
        :param [out]: cameraToBase The result of hand-eye calibration. See 'Transformation' for
            details.
        :rtype: :py:class:`ErrorStatus`
        :return: See 'ErrorStatus' for details.
        """
        return _area_scan_3d_camera.HandEyeCalibration_calculate_extrinsics(self, camera, cameraToBase)

    def test_recognition(self, camera, testResult, timeoutMs=10000):
        r"""
        Only captures current image with feature recognition result for test.
        :param [in]: camera The camera handle.
        :param [out]: testResult The current 2D image with feature recognition result. See
            Color2DImage for details.
        :param [in]: timeoutMs The timeout for connecting a camera in ms unit. If the execution
            time of the connecting process is greater than the timeout, the function will immediately
            return 'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: See 'ErrorStatus' for details.
        """
        return _area_scan_3d_camera.HandEyeCalibration_test_recognition(self, camera, testResult, timeoutMs)

    def __init__(self):
        r"""__init__(HandEyeCalibration self) -> HandEyeCalibration"""
        _area_scan_3d_camera.HandEyeCalibration_swiginit(self, _area_scan_3d_camera.new_HandEyeCalibration())
    __swig_destroy__ = _area_scan_3d_camera.delete_HandEyeCalibration

# Register HandEyeCalibration in _area_scan_3d_camera:
_area_scan_3d_camera.HandEyeCalibration_swigregister(HandEyeCalibration)
class HandEyeTransformation(object):
    r"""
    Defines rigid body transformations, including translation vector and
    quaternion vector.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Transformation() -> HandEyeTransformation
        __init__(HandEyeTransformation self, double x, double y, double z, double qW, double qX, double qY, double qZ) -> HandEyeTransformation
        """
        _area_scan_3d_camera.HandEyeTransformation_swiginit(self, _area_scan_3d_camera.new_HandEyeTransformation(*args))

    def to_string(self):
        r"""to_string(HandEyeTransformation self) -> std::string"""
        return _area_scan_3d_camera.HandEyeTransformation_to_string(self)
    x = property(_area_scan_3d_camera.HandEyeTransformation_x_get, _area_scan_3d_camera.HandEyeTransformation_x_set, doc=r"""x : double""")
    y = property(_area_scan_3d_camera.HandEyeTransformation_y_get, _area_scan_3d_camera.HandEyeTransformation_y_set, doc=r"""y : double""")
    z = property(_area_scan_3d_camera.HandEyeTransformation_z_get, _area_scan_3d_camera.HandEyeTransformation_z_set, doc=r"""z : double""")
    q_w = property(_area_scan_3d_camera.HandEyeTransformation_q_w_get, _area_scan_3d_camera.HandEyeTransformation_q_w_set, doc=r"""q_w : double""")
    q_x = property(_area_scan_3d_camera.HandEyeTransformation_q_x_get, _area_scan_3d_camera.HandEyeTransformation_q_x_set, doc=r"""q_x : double""")
    q_y = property(_area_scan_3d_camera.HandEyeTransformation_q_y_get, _area_scan_3d_camera.HandEyeTransformation_q_y_set, doc=r"""q_y : double""")
    q_z = property(_area_scan_3d_camera.HandEyeTransformation_q_z_get, _area_scan_3d_camera.HandEyeTransformation_q_z_set, doc=r"""q_z : double""")
    __swig_destroy__ = _area_scan_3d_camera.delete_HandEyeTransformation

# Register HandEyeTransformation in _area_scan_3d_camera:
_area_scan_3d_camera.HandEyeTransformation_swigregister(HandEyeTransformation)
class LaserPowerLevel(object):
    r"""Proxy of C++ mmind::eye::laser_setting::PowerLevel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.LaserPowerLevel_name
    
    description = _area_scan_3d_camera.LaserPowerLevel_description
    
    type = _area_scan_3d_camera.LaserPowerLevel_type
    

    @staticmethod
    def step():
        r"""step() -> int"""
        return _area_scan_3d_camera.LaserPowerLevel_step()

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.LaserPowerLevel_range()
    unit = _area_scan_3d_camera.LaserPowerLevel_unit
    

    def __init__(self):
        r"""__init__(LaserPowerLevel self) -> LaserPowerLevel"""
        _area_scan_3d_camera.LaserPowerLevel_swiginit(self, _area_scan_3d_camera.new_LaserPowerLevel())
    __swig_destroy__ = _area_scan_3d_camera.delete_LaserPowerLevel

# Register LaserPowerLevel in _area_scan_3d_camera:
_area_scan_3d_camera.LaserPowerLevel_swigregister(LaserPowerLevel)
class LaserFringeCodingMode(object):
    r"""Proxy of C++ mmind::eye::laser_setting::FringeCodingMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.LaserFringeCodingMode_name
    
    description = _area_scan_3d_camera.LaserFringeCodingMode_description
    
    type = _area_scan_3d_camera.LaserFringeCodingMode_type
    
    Value_Fast = _area_scan_3d_camera.LaserFringeCodingMode_Value_Fast
    r"""
    Suitable for non-reflective objects, provides fast acquisition speed, but the
    depth data quality is lower.
    """
    Value_Accurate = _area_scan_3d_camera.LaserFringeCodingMode_Value_Accurate
    r"""
    Suitable for non-reflective objects, provides high-quality depth data, but
    the acquisition speed is slower.
    """
    Value_Reflective = _area_scan_3d_camera.LaserFringeCodingMode_Value_Reflective
    r"""
    Suitable for reflective objects, provides high-quality depth data, but the
    acquisition speed is slower.
    """

    def __init__(self):
        r"""__init__(LaserFringeCodingMode self) -> LaserFringeCodingMode"""
        _area_scan_3d_camera.LaserFringeCodingMode_swiginit(self, _area_scan_3d_camera.new_LaserFringeCodingMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_LaserFringeCodingMode

# Register LaserFringeCodingMode in _area_scan_3d_camera:
_area_scan_3d_camera.LaserFringeCodingMode_swigregister(LaserFringeCodingMode)
class ProcessingMode(object):
    r"""Proxy of C++ mmind::eye::laser_setting::ProcessingMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.ProcessingMode_name
    
    description = _area_scan_3d_camera.ProcessingMode_description
    
    type = _area_scan_3d_camera.ProcessingMode_type
    
    Value_Faster = _area_scan_3d_camera.ProcessingMode_Value_Faster
    r"""
    Provides faster processing speed, but the depth data might have missing points.
    Suitable for scenarios with relatively simple reflective conditions.
    """
    Value_MoreComplete = _area_scan_3d_camera.ProcessingMode_Value_MoreComplete
    r"""
    Provides more complete depth data, but the processing speed is slower.
    Suitable for scenarios with complex reflective conditions, such as a bin
    whose walls often cause interreflection.
    """

    def __init__(self):
        r"""__init__(ProcessingMode self) -> ProcessingMode"""
        _area_scan_3d_camera.ProcessingMode_swiginit(self, _area_scan_3d_camera.new_ProcessingMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_ProcessingMode

# Register ProcessingMode in _area_scan_3d_camera:
_area_scan_3d_camera.ProcessingMode_swigregister(ProcessingMode)
class LaserFrameRange(object):
    r"""Proxy of C++ mmind::eye::laser_setting::FrameRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.LaserFrameRange_name
    
    description = _area_scan_3d_camera.LaserFrameRange_description
    
    type = _area_scan_3d_camera.LaserFrameRange_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.LaserFrameRange_range()

    def __init__(self):
        r"""__init__(LaserFrameRange self) -> LaserFrameRange"""
        _area_scan_3d_camera.LaserFrameRange_swiginit(self, _area_scan_3d_camera.new_LaserFrameRange())
    __swig_destroy__ = _area_scan_3d_camera.delete_LaserFrameRange

# Register LaserFrameRange in _area_scan_3d_camera:
_area_scan_3d_camera.LaserFrameRange_swigregister(LaserFrameRange)
class LaserFramePartitionCount(object):
    r"""Proxy of C++ mmind::eye::laser_setting::FramePartitionCount class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.LaserFramePartitionCount_name
    
    description = _area_scan_3d_camera.LaserFramePartitionCount_description
    
    type = _area_scan_3d_camera.LaserFramePartitionCount_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.LaserFramePartitionCount_range()

    def __init__(self):
        r"""__init__(LaserFramePartitionCount self) -> LaserFramePartitionCount"""
        _area_scan_3d_camera.LaserFramePartitionCount_swiginit(self, _area_scan_3d_camera.new_LaserFramePartitionCount())
    __swig_destroy__ = _area_scan_3d_camera.delete_LaserFramePartitionCount

# Register LaserFramePartitionCount in _area_scan_3d_camera:
_area_scan_3d_camera.LaserFramePartitionCount_swigregister(LaserFramePartitionCount)
class PointCloudSurfaceSmoothing(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::SurfaceSmoothing class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.PointCloudSurfaceSmoothing_name
    
    description = _area_scan_3d_camera.PointCloudSurfaceSmoothing_description
    
    type = _area_scan_3d_camera.PointCloudSurfaceSmoothing_type
    
    Value_Off = _area_scan_3d_camera.PointCloudSurfaceSmoothing_Value_Off
    
    Value_Weak = _area_scan_3d_camera.PointCloudSurfaceSmoothing_Value_Weak
    
    Value_Normal = _area_scan_3d_camera.PointCloudSurfaceSmoothing_Value_Normal
    
    Value_Strong = _area_scan_3d_camera.PointCloudSurfaceSmoothing_Value_Strong
    

    def __init__(self):
        r"""__init__(PointCloudSurfaceSmoothing self) -> PointCloudSurfaceSmoothing"""
        _area_scan_3d_camera.PointCloudSurfaceSmoothing_swiginit(self, _area_scan_3d_camera.new_PointCloudSurfaceSmoothing())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointCloudSurfaceSmoothing

# Register PointCloudSurfaceSmoothing in _area_scan_3d_camera:
_area_scan_3d_camera.PointCloudSurfaceSmoothing_swigregister(PointCloudSurfaceSmoothing)
class PointCloudNoiseRemoval(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::NoiseRemoval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.PointCloudNoiseRemoval_name
    
    description = _area_scan_3d_camera.PointCloudNoiseRemoval_description
    
    type = _area_scan_3d_camera.PointCloudNoiseRemoval_type
    
    Value_Off = _area_scan_3d_camera.PointCloudNoiseRemoval_Value_Off
    
    Value_Weak = _area_scan_3d_camera.PointCloudNoiseRemoval_Value_Weak
    
    Value_Normal = _area_scan_3d_camera.PointCloudNoiseRemoval_Value_Normal
    
    Value_Strong = _area_scan_3d_camera.PointCloudNoiseRemoval_Value_Strong
    

    def __init__(self):
        r"""__init__(PointCloudNoiseRemoval self) -> PointCloudNoiseRemoval"""
        _area_scan_3d_camera.PointCloudNoiseRemoval_swiginit(self, _area_scan_3d_camera.new_PointCloudNoiseRemoval())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointCloudNoiseRemoval

# Register PointCloudNoiseRemoval in _area_scan_3d_camera:
_area_scan_3d_camera.PointCloudNoiseRemoval_swigregister(PointCloudNoiseRemoval)
class PointCloudOutlierRemoval(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::OutlierRemoval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.PointCloudOutlierRemoval_name
    
    description = _area_scan_3d_camera.PointCloudOutlierRemoval_description
    
    type = _area_scan_3d_camera.PointCloudOutlierRemoval_type
    
    Value_Off = _area_scan_3d_camera.PointCloudOutlierRemoval_Value_Off
    
    Value_Weak = _area_scan_3d_camera.PointCloudOutlierRemoval_Value_Weak
    
    Value_Normal = _area_scan_3d_camera.PointCloudOutlierRemoval_Value_Normal
    
    Value_Strong = _area_scan_3d_camera.PointCloudOutlierRemoval_Value_Strong
    

    def __init__(self):
        r"""__init__(PointCloudOutlierRemoval self) -> PointCloudOutlierRemoval"""
        _area_scan_3d_camera.PointCloudOutlierRemoval_swiginit(self, _area_scan_3d_camera.new_PointCloudOutlierRemoval())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointCloudOutlierRemoval

# Register PointCloudOutlierRemoval in _area_scan_3d_camera:
_area_scan_3d_camera.PointCloudOutlierRemoval_swigregister(PointCloudOutlierRemoval)
class GapFilling(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::GapFilling class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.GapFilling_name
    
    description = _area_scan_3d_camera.GapFilling_description
    
    type = _area_scan_3d_camera.GapFilling_type
    
    Value_Off = _area_scan_3d_camera.GapFilling_Value_Off
    
    Value_Weak = _area_scan_3d_camera.GapFilling_Value_Weak
    
    Value_Normal = _area_scan_3d_camera.GapFilling_Value_Normal
    
    Value_Strong = _area_scan_3d_camera.GapFilling_Value_Strong
    

    def __init__(self):
        r"""__init__(GapFilling self) -> GapFilling"""
        _area_scan_3d_camera.GapFilling_swiginit(self, _area_scan_3d_camera.new_GapFilling())
    __swig_destroy__ = _area_scan_3d_camera.delete_GapFilling

# Register GapFilling in _area_scan_3d_camera:
_area_scan_3d_camera.GapFilling_swigregister(GapFilling)
class PointCloudEdgePreservation(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::EdgePreservation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.PointCloudEdgePreservation_name
    
    description = _area_scan_3d_camera.PointCloudEdgePreservation_description
    
    type = _area_scan_3d_camera.PointCloudEdgePreservation_type
    
    Value_Sharp = _area_scan_3d_camera.PointCloudEdgePreservation_Value_Sharp
    
    Value_Normal = _area_scan_3d_camera.PointCloudEdgePreservation_Value_Normal
    
    Value_Smooth = _area_scan_3d_camera.PointCloudEdgePreservation_Value_Smooth
    

    def __init__(self):
        r"""__init__(PointCloudEdgePreservation self) -> PointCloudEdgePreservation"""
        _area_scan_3d_camera.PointCloudEdgePreservation_swiginit(self, _area_scan_3d_camera.new_PointCloudEdgePreservation())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointCloudEdgePreservation

# Register PointCloudEdgePreservation in _area_scan_3d_camera:
_area_scan_3d_camera.PointCloudEdgePreservation_swigregister(PointCloudEdgePreservation)
class EnableDistortionCorrection(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::EnableDistortionCorrection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.EnableDistortionCorrection_name
    
    description = _area_scan_3d_camera.EnableDistortionCorrection_description
    
    type = _area_scan_3d_camera.EnableDistortionCorrection_type
    

    def __init__(self):
        r"""__init__(EnableDistortionCorrection self) -> EnableDistortionCorrection"""
        _area_scan_3d_camera.EnableDistortionCorrection_swiginit(self, _area_scan_3d_camera.new_EnableDistortionCorrection())
    __swig_destroy__ = _area_scan_3d_camera.delete_EnableDistortionCorrection

# Register EnableDistortionCorrection in _area_scan_3d_camera:
_area_scan_3d_camera.EnableDistortionCorrection_swigregister(EnableDistortionCorrection)
class DistortionCorrection(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::DistortionCorrection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.DistortionCorrection_name
    
    description = _area_scan_3d_camera.DistortionCorrection_description
    
    type = _area_scan_3d_camera.DistortionCorrection_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.DistortionCorrection_range()
    unit = _area_scan_3d_camera.DistortionCorrection_unit
    

    def __init__(self):
        r"""__init__(DistortionCorrection self) -> DistortionCorrection"""
        _area_scan_3d_camera.DistortionCorrection_swiginit(self, _area_scan_3d_camera.new_DistortionCorrection())
    __swig_destroy__ = _area_scan_3d_camera.delete_DistortionCorrection

# Register DistortionCorrection in _area_scan_3d_camera:
_area_scan_3d_camera.DistortionCorrection_swigregister(DistortionCorrection)
class PointCloudFringeContrastThreshold(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::FringeContrastThreshold class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.PointCloudFringeContrastThreshold_name
    
    description = _area_scan_3d_camera.PointCloudFringeContrastThreshold_description
    
    type = _area_scan_3d_camera.PointCloudFringeContrastThreshold_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.PointCloudFringeContrastThreshold_range()
    unit = _area_scan_3d_camera.PointCloudFringeContrastThreshold_unit
    

    def __init__(self):
        r"""__init__(PointCloudFringeContrastThreshold self) -> PointCloudFringeContrastThreshold"""
        _area_scan_3d_camera.PointCloudFringeContrastThreshold_swiginit(self, _area_scan_3d_camera.new_PointCloudFringeContrastThreshold())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointCloudFringeContrastThreshold

# Register PointCloudFringeContrastThreshold in _area_scan_3d_camera:
_area_scan_3d_camera.PointCloudFringeContrastThreshold_swigregister(PointCloudFringeContrastThreshold)
class PointCloudFringeMinThreshold(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::FringeMinThreshold class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.PointCloudFringeMinThreshold_name
    
    description = _area_scan_3d_camera.PointCloudFringeMinThreshold_description
    
    type = _area_scan_3d_camera.PointCloudFringeMinThreshold_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.PointCloudFringeMinThreshold_range()
    unit = _area_scan_3d_camera.PointCloudFringeMinThreshold_unit
    

    def __init__(self):
        r"""__init__(PointCloudFringeMinThreshold self) -> PointCloudFringeMinThreshold"""
        _area_scan_3d_camera.PointCloudFringeMinThreshold_swiginit(self, _area_scan_3d_camera.new_PointCloudFringeMinThreshold())
    __swig_destroy__ = _area_scan_3d_camera.delete_PointCloudFringeMinThreshold

# Register PointCloudFringeMinThreshold in _area_scan_3d_camera:
_area_scan_3d_camera.PointCloudFringeMinThreshold_swigregister(PointCloudFringeMinThreshold)
class EdgeArtifactRemoval(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::EdgeArtifactRemoval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.EdgeArtifactRemoval_name
    
    description = _area_scan_3d_camera.EdgeArtifactRemoval_description
    
    type = _area_scan_3d_camera.EdgeArtifactRemoval_type
    

    def __init__(self):
        r"""__init__(EdgeArtifactRemoval self) -> EdgeArtifactRemoval"""
        _area_scan_3d_camera.EdgeArtifactRemoval_swiginit(self, _area_scan_3d_camera.new_EdgeArtifactRemoval())
    __swig_destroy__ = _area_scan_3d_camera.delete_EdgeArtifactRemoval

# Register EdgeArtifactRemoval in _area_scan_3d_camera:
_area_scan_3d_camera.EdgeArtifactRemoval_swigregister(EdgeArtifactRemoval)
class EnableGapFilling(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::EnableGapFilling class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.EnableGapFilling_name
    
    description = _area_scan_3d_camera.EnableGapFilling_description
    
    type = _area_scan_3d_camera.EnableGapFilling_type
    

    def __init__(self):
        r"""__init__(EnableGapFilling self) -> EnableGapFilling"""
        _area_scan_3d_camera.EnableGapFilling_swiginit(self, _area_scan_3d_camera.new_EnableGapFilling())
    __swig_destroy__ = _area_scan_3d_camera.delete_EnableGapFilling

# Register EnableGapFilling in _area_scan_3d_camera:
_area_scan_3d_camera.EnableGapFilling_swigregister(EnableGapFilling)
class GapSize(object):
    r"""Proxy of C++ mmind::eye::pointcloud_processing_setting::GapSize class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.GapSize_name
    
    description = _area_scan_3d_camera.GapSize_description
    
    type = _area_scan_3d_camera.GapSize_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.GapSize_range()
    unit = _area_scan_3d_camera.GapSize_unit
    

    def __init__(self):
        r"""__init__(GapSize self) -> GapSize"""
        _area_scan_3d_camera.GapSize_swiginit(self, _area_scan_3d_camera.new_GapSize())
    __swig_destroy__ = _area_scan_3d_camera.delete_GapSize

# Register GapSize in _area_scan_3d_camera:
_area_scan_3d_camera.GapSize_swigregister(GapSize)
class ProjectorPowerLevel(object):
    r"""Proxy of C++ mmind::eye::projector_setting::PowerLevel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.ProjectorPowerLevel_name
    
    description = _area_scan_3d_camera.ProjectorPowerLevel_description
    
    type = _area_scan_3d_camera.ProjectorPowerLevel_type
    
    Value_High = _area_scan_3d_camera.ProjectorPowerLevel_Value_High
    r""" High level is often used for scanning dark objects."""
    Value_Normal = _area_scan_3d_camera.ProjectorPowerLevel_Value_Normal
    r""" Normal level is mostly used."""
    Value_Low = _area_scan_3d_camera.ProjectorPowerLevel_Value_Low
    r""" Low level is used for scanning reflective objects."""

    def __init__(self):
        r"""__init__(ProjectorPowerLevel self) -> ProjectorPowerLevel"""
        _area_scan_3d_camera.ProjectorPowerLevel_swiginit(self, _area_scan_3d_camera.new_ProjectorPowerLevel())
    __swig_destroy__ = _area_scan_3d_camera.delete_ProjectorPowerLevel

# Register ProjectorPowerLevel in _area_scan_3d_camera:
_area_scan_3d_camera.ProjectorPowerLevel_swigregister(ProjectorPowerLevel)
class ProjectorFringeCodingMode(object):
    r"""Proxy of C++ mmind::eye::projector_setting::FringeCodingMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.ProjectorFringeCodingMode_name
    
    description = _area_scan_3d_camera.ProjectorFringeCodingMode_description
    
    type = _area_scan_3d_camera.ProjectorFringeCodingMode_type
    
    Value_Fast = _area_scan_3d_camera.ProjectorFringeCodingMode_Value_Fast
    r"""
    Suitable for opaque objects, provides fast acquisition speed, but the depth data
    quality is lower.
    """
    Value_Accurate = _area_scan_3d_camera.ProjectorFringeCodingMode_Value_Accurate
    r"""
    Suitable for opaque objects, provides high-quality depth data, but the
    acquisition speed is slower.
    """
    Value_Translucent = _area_scan_3d_camera.ProjectorFringeCodingMode_Value_Translucent
    r"""
    PRO S and PRO M only. Suitable for translucent objects, provides
    high-quality depth data, but the acquisition speed is slower.
    """
    Value_Reflective = _area_scan_3d_camera.ProjectorFringeCodingMode_Value_Reflective
    r"""
    PRO S and PRO M only. Suitable for reflective objects, provides
    high-quality depth data, but the acquisition speed is slower.
    """

    def __init__(self):
        r"""__init__(ProjectorFringeCodingMode self) -> ProjectorFringeCodingMode"""
        _area_scan_3d_camera.ProjectorFringeCodingMode_swiginit(self, _area_scan_3d_camera.new_ProjectorFringeCodingMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_ProjectorFringeCodingMode

# Register ProjectorFringeCodingMode in _area_scan_3d_camera:
_area_scan_3d_camera.ProjectorFringeCodingMode_swigregister(ProjectorFringeCodingMode)
class AntiFlickerMode(object):
    r"""Proxy of C++ mmind::eye::projector_setting::AntiFlickerMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.AntiFlickerMode_name
    
    description = _area_scan_3d_camera.AntiFlickerMode_description
    
    type = _area_scan_3d_camera.AntiFlickerMode_type
    
    Value_Off = _area_scan_3d_camera.AntiFlickerMode_Value_Off
    r""" No processing for anti-flicker."""
    Value_AC50Hz = _area_scan_3d_camera.AntiFlickerMode_Value_AC50Hz
    r""" The AC frequency is 50Hz in most countries."""
    Value_AC60Hz = _area_scan_3d_camera.AntiFlickerMode_Value_AC60Hz
    r""" The AC frequency in the U.S. and some Asian countries is 60Hz."""

    def __init__(self):
        r"""__init__(AntiFlickerMode self) -> AntiFlickerMode"""
        _area_scan_3d_camera.AntiFlickerMode_swiginit(self, _area_scan_3d_camera.new_AntiFlickerMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_AntiFlickerMode

# Register AntiFlickerMode in _area_scan_3d_camera:
_area_scan_3d_camera.AntiFlickerMode_swigregister(AntiFlickerMode)
class ProjectorProcessingMode(object):
    r"""Proxy of C++ mmind::eye::projector_setting::ProcessingMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.ProjectorProcessingMode_name
    
    description = _area_scan_3d_camera.ProjectorProcessingMode_description
    
    type = _area_scan_3d_camera.ProjectorProcessingMode_type
    
    Value_Faster = _area_scan_3d_camera.ProjectorProcessingMode_Value_Faster
    r"""
    Provides faster processing speed, but the depth data might have missing points.
    Suitable for scenarios with relatively simple reflective conditions.
    """
    Value_MoreComplete = _area_scan_3d_camera.ProjectorProcessingMode_Value_MoreComplete
    r"""
    Provides more complete depth data, but the processing speed is slower.
    Suitable for scenarios with complex reflective conditions, such as a bin
    whose walls often cause interreflection.
    """

    def __init__(self):
        r"""__init__(ProjectorProcessingMode self) -> ProjectorProcessingMode"""
        _area_scan_3d_camera.ProjectorProcessingMode_swiginit(self, _area_scan_3d_camera.new_ProjectorProcessingMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_ProjectorProcessingMode

# Register ProjectorProcessingMode in _area_scan_3d_camera:
_area_scan_3d_camera.ProjectorProcessingMode_swigregister(ProjectorProcessingMode)
class Scanning2DExposureMode(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::ExposureMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DExposureMode_name
    
    description = _area_scan_3d_camera.Scanning2DExposureMode_description
    
    type = _area_scan_3d_camera.Scanning2DExposureMode_type
    
    Value_Timed = _area_scan_3d_camera.Scanning2DExposureMode_Value_Timed
    
    Value_Auto = _area_scan_3d_camera.Scanning2DExposureMode_Value_Auto
    
    Value_HDR = _area_scan_3d_camera.Scanning2DExposureMode_Value_HDR
    
    Value_Flash = _area_scan_3d_camera.Scanning2DExposureMode_Value_Flash
    

    def __init__(self):
        r"""__init__(Scanning2DExposureMode self) -> Scanning2DExposureMode"""
        _area_scan_3d_camera.Scanning2DExposureMode_swiginit(self, _area_scan_3d_camera.new_Scanning2DExposureMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DExposureMode

# Register Scanning2DExposureMode in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DExposureMode_swigregister(Scanning2DExposureMode)
class Scanning2DExposureTime(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::ExposureTime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DExposureTime_name
    
    description = _area_scan_3d_camera.Scanning2DExposureTime_description
    
    type = _area_scan_3d_camera.Scanning2DExposureTime_type
    

    @staticmethod
    def range():
        r"""range() -> RangeFloat"""
        return _area_scan_3d_camera.Scanning2DExposureTime_range()
    unit = _area_scan_3d_camera.Scanning2DExposureTime_unit
    

    def __init__(self):
        r"""__init__(Scanning2DExposureTime self) -> Scanning2DExposureTime"""
        _area_scan_3d_camera.Scanning2DExposureTime_swiginit(self, _area_scan_3d_camera.new_Scanning2DExposureTime())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DExposureTime

# Register Scanning2DExposureTime in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DExposureTime_swigregister(Scanning2DExposureTime)
class Scanning2DSharpenFactor(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::SharpenFactor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DSharpenFactor_name
    
    description = _area_scan_3d_camera.Scanning2DSharpenFactor_description
    
    type = _area_scan_3d_camera.Scanning2DSharpenFactor_type
    

    @staticmethod
    def range():
        r"""range() -> RangeFloat"""
        return _area_scan_3d_camera.Scanning2DSharpenFactor_range()

    def __init__(self):
        r"""__init__(Scanning2DSharpenFactor self) -> Scanning2DSharpenFactor"""
        _area_scan_3d_camera.Scanning2DSharpenFactor_swiginit(self, _area_scan_3d_camera.new_Scanning2DSharpenFactor())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DSharpenFactor

# Register Scanning2DSharpenFactor in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DSharpenFactor_swigregister(Scanning2DSharpenFactor)
cvar = _area_scan_3d_camera.cvar
Scanning2DSharpenFactor.default_value = _area_scan_3d_camera.cvar.Scanning2DSharpenFactor_default_value

class Scanning2DExpectedGrayValue(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::ExpectedGrayValue class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DExpectedGrayValue_name
    
    description = _area_scan_3d_camera.Scanning2DExpectedGrayValue_description
    
    type = _area_scan_3d_camera.Scanning2DExpectedGrayValue_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.Scanning2DExpectedGrayValue_range()

    def __init__(self):
        r"""__init__(Scanning2DExpectedGrayValue self) -> Scanning2DExpectedGrayValue"""
        _area_scan_3d_camera.Scanning2DExpectedGrayValue_swiginit(self, _area_scan_3d_camera.new_Scanning2DExpectedGrayValue())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DExpectedGrayValue

# Register Scanning2DExpectedGrayValue in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DExpectedGrayValue_swigregister(Scanning2DExpectedGrayValue)
class Scanning2DToneMappingEnable(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::ToneMappingEnable class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DToneMappingEnable_name
    
    description = _area_scan_3d_camera.Scanning2DToneMappingEnable_description
    
    type = _area_scan_3d_camera.Scanning2DToneMappingEnable_type
    

    def __init__(self):
        r"""__init__(Scanning2DToneMappingEnable self) -> Scanning2DToneMappingEnable"""
        _area_scan_3d_camera.Scanning2DToneMappingEnable_swiginit(self, _area_scan_3d_camera.new_Scanning2DToneMappingEnable())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DToneMappingEnable

# Register Scanning2DToneMappingEnable in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DToneMappingEnable_swigregister(Scanning2DToneMappingEnable)
class Scanning2DAutoExposureROI(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::AutoExposureROI class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DAutoExposureROI_name
    
    description = _area_scan_3d_camera.Scanning2DAutoExposureROI_description
    
    type = _area_scan_3d_camera.Scanning2DAutoExposureROI_type
    

    def __init__(self):
        r"""__init__(Scanning2DAutoExposureROI self) -> Scanning2DAutoExposureROI"""
        _area_scan_3d_camera.Scanning2DAutoExposureROI_swiginit(self, _area_scan_3d_camera.new_Scanning2DAutoExposureROI())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DAutoExposureROI

# Register Scanning2DAutoExposureROI in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DAutoExposureROI_swigregister(Scanning2DAutoExposureROI)
class Scanning2DHDRExposureSequence(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::HDRExposureSequence class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DHDRExposureSequence_name
    
    description = _area_scan_3d_camera.Scanning2DHDRExposureSequence_description
    
    type = _area_scan_3d_camera.Scanning2DHDRExposureSequence_type
    

    @staticmethod
    def range():
        r"""range() -> RangeFloat"""
        return _area_scan_3d_camera.Scanning2DHDRExposureSequence_range()

    @staticmethod
    def max_size():
        r"""max_size() -> int"""
        return _area_scan_3d_camera.Scanning2DHDRExposureSequence_max_size()
    unit = _area_scan_3d_camera.Scanning2DHDRExposureSequence_unit
    

    def __init__(self):
        r"""__init__(Scanning2DHDRExposureSequence self) -> Scanning2DHDRExposureSequence"""
        _area_scan_3d_camera.Scanning2DHDRExposureSequence_swiginit(self, _area_scan_3d_camera.new_Scanning2DHDRExposureSequence())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DHDRExposureSequence

# Register Scanning2DHDRExposureSequence in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DHDRExposureSequence_swigregister(Scanning2DHDRExposureSequence)
class Scanning2DDepthSourceExposureMode(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::DepthSourceExposureMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DDepthSourceExposureMode_name
    
    description = _area_scan_3d_camera.Scanning2DDepthSourceExposureMode_description
    
    type = _area_scan_3d_camera.Scanning2DDepthSourceExposureMode_type
    
    Value_Timed = _area_scan_3d_camera.Scanning2DDepthSourceExposureMode_Value_Timed
    
    Value_Flash = _area_scan_3d_camera.Scanning2DDepthSourceExposureMode_Value_Flash
    

    def __init__(self):
        r"""__init__(Scanning2DDepthSourceExposureMode self) -> Scanning2DDepthSourceExposureMode"""
        _area_scan_3d_camera.Scanning2DDepthSourceExposureMode_swiginit(self, _area_scan_3d_camera.new_Scanning2DDepthSourceExposureMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DDepthSourceExposureMode

# Register Scanning2DDepthSourceExposureMode in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DDepthSourceExposureMode_swigregister(Scanning2DDepthSourceExposureMode)
class Scanning2DDepthSourceExposureTime(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::DepthSourceExposureTime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DDepthSourceExposureTime_name
    
    description = _area_scan_3d_camera.Scanning2DDepthSourceExposureTime_description
    
    type = _area_scan_3d_camera.Scanning2DDepthSourceExposureTime_type
    

    @staticmethod
    def range():
        r"""range() -> RangeFloat"""
        return _area_scan_3d_camera.Scanning2DDepthSourceExposureTime_range()
    unit = _area_scan_3d_camera.Scanning2DDepthSourceExposureTime_unit
    

    def __init__(self):
        r"""__init__(Scanning2DDepthSourceExposureTime self) -> Scanning2DDepthSourceExposureTime"""
        _area_scan_3d_camera.Scanning2DDepthSourceExposureTime_swiginit(self, _area_scan_3d_camera.new_Scanning2DDepthSourceExposureTime())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DDepthSourceExposureTime

# Register Scanning2DDepthSourceExposureTime in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DDepthSourceExposureTime_swigregister(Scanning2DDepthSourceExposureTime)
class Scanning2DFlashAcquisitionMode(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::FlashAcquisitionMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DFlashAcquisitionMode_name
    
    description = _area_scan_3d_camera.Scanning2DFlashAcquisitionMode_description
    
    type = _area_scan_3d_camera.Scanning2DFlashAcquisitionMode_type
    
    Value_Responsive = _area_scan_3d_camera.Scanning2DFlashAcquisitionMode_Value_Responsive
    
    Value_Fast = _area_scan_3d_camera.Scanning2DFlashAcquisitionMode_Value_Fast
    

    def __init__(self):
        r"""__init__(Scanning2DFlashAcquisitionMode self) -> Scanning2DFlashAcquisitionMode"""
        _area_scan_3d_camera.Scanning2DFlashAcquisitionMode_swiginit(self, _area_scan_3d_camera.new_Scanning2DFlashAcquisitionMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DFlashAcquisitionMode

# Register Scanning2DFlashAcquisitionMode in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DFlashAcquisitionMode_swigregister(Scanning2DFlashAcquisitionMode)
class Scanning2DFlashExposureTime(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::FlashExposureTime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DFlashExposureTime_name
    
    description = _area_scan_3d_camera.Scanning2DFlashExposureTime_description
    
    type = _area_scan_3d_camera.Scanning2DFlashExposureTime_type
    

    @staticmethod
    def range():
        r"""range() -> RangeFloat"""
        return _area_scan_3d_camera.Scanning2DFlashExposureTime_range()
    unit = _area_scan_3d_camera.Scanning2DFlashExposureTime_unit
    

    def __init__(self):
        r"""__init__(Scanning2DFlashExposureTime self) -> Scanning2DFlashExposureTime"""
        _area_scan_3d_camera.Scanning2DFlashExposureTime_swiginit(self, _area_scan_3d_camera.new_Scanning2DFlashExposureTime())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DFlashExposureTime

# Register Scanning2DFlashExposureTime in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DFlashExposureTime_swigregister(Scanning2DFlashExposureTime)
class Scanning2DGain(object):
    r"""Proxy of C++ mmind::eye::scanning2d_setting::Gain class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning2DGain_name
    
    description = _area_scan_3d_camera.Scanning2DGain_description
    
    type = _area_scan_3d_camera.Scanning2DGain_type
    

    @staticmethod
    def range():
        r"""range() -> RangeDouble"""
        return _area_scan_3d_camera.Scanning2DGain_range()
    unit = _area_scan_3d_camera.Scanning2DGain_unit
    

    def __init__(self):
        r"""__init__(Scanning2DGain self) -> Scanning2DGain"""
        _area_scan_3d_camera.Scanning2DGain_swiginit(self, _area_scan_3d_camera.new_Scanning2DGain())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning2DGain

# Register Scanning2DGain in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning2DGain_swigregister(Scanning2DGain)
class Scanning3DExposureSequence(object):
    r"""Proxy of C++ mmind::eye::scanning3d_setting::ExposureSequence class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning3DExposureSequence_name
    
    description = _area_scan_3d_camera.Scanning3DExposureSequence_description
    
    type = _area_scan_3d_camera.Scanning3DExposureSequence_type
    

    @staticmethod
    def range():
        r"""range() -> RangeDouble"""
        return _area_scan_3d_camera.Scanning3DExposureSequence_range()

    @staticmethod
    def max_size():
        r"""max_size() -> int"""
        return _area_scan_3d_camera.Scanning3DExposureSequence_max_size()
    unit = _area_scan_3d_camera.Scanning3DExposureSequence_unit
    

    def __init__(self):
        r"""__init__(Scanning3DExposureSequence self) -> Scanning3DExposureSequence"""
        _area_scan_3d_camera.Scanning3DExposureSequence_swiginit(self, _area_scan_3d_camera.new_Scanning3DExposureSequence())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning3DExposureSequence

# Register Scanning3DExposureSequence in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning3DExposureSequence_swigregister(Scanning3DExposureSequence)
class Scanning3DGain(object):
    r"""Proxy of C++ mmind::eye::scanning3d_setting::Gain class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning3DGain_name
    
    description = _area_scan_3d_camera.Scanning3DGain_description
    
    type = _area_scan_3d_camera.Scanning3DGain_type
    

    @staticmethod
    def range():
        r"""range() -> RangeDouble"""
        return _area_scan_3d_camera.Scanning3DGain_range()
    unit = _area_scan_3d_camera.Scanning3DGain_unit
    

    def __init__(self):
        r"""__init__(Scanning3DGain self) -> Scanning3DGain"""
        _area_scan_3d_camera.Scanning3DGain_swiginit(self, _area_scan_3d_camera.new_Scanning3DGain())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning3DGain

# Register Scanning3DGain in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning3DGain_swigregister(Scanning3DGain)
class Scanning3DROI(object):
    r"""Proxy of C++ mmind::eye::scanning3d_setting::ROI class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning3DROI_name
    
    description = _area_scan_3d_camera.Scanning3DROI_description
    
    type = _area_scan_3d_camera.Scanning3DROI_type
    

    def __init__(self):
        r"""__init__(Scanning3DROI self) -> Scanning3DROI"""
        _area_scan_3d_camera.Scanning3DROI_swiginit(self, _area_scan_3d_camera.new_Scanning3DROI())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning3DROI

# Register Scanning3DROI in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning3DROI_swigregister(Scanning3DROI)
class Scanning3DDepthRange(object):
    r"""Proxy of C++ mmind::eye::scanning3d_setting::DepthRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.Scanning3DDepthRange_name
    
    description = _area_scan_3d_camera.Scanning3DDepthRange_description
    
    type = _area_scan_3d_camera.Scanning3DDepthRange_type
    

    @staticmethod
    def range():
        r"""range() -> RangeInt"""
        return _area_scan_3d_camera.Scanning3DDepthRange_range()
    unit = _area_scan_3d_camera.Scanning3DDepthRange_unit
    

    def __init__(self):
        r"""__init__(Scanning3DDepthRange self) -> Scanning3DDepthRange"""
        _area_scan_3d_camera.Scanning3DDepthRange_swiginit(self, _area_scan_3d_camera.new_Scanning3DDepthRange())
    __swig_destroy__ = _area_scan_3d_camera.delete_Scanning3DDepthRange

# Register Scanning3DDepthRange in _area_scan_3d_camera:
_area_scan_3d_camera.Scanning3DDepthRange_swigregister(Scanning3DDepthRange)

def get_point_cloud_after_mapping(*args):
    r"""
    get_point_cloud_after_mapping(DepthMap depthMap, GrayScale2DImage textureValidMask, CameraIntrinsics wrappedIntrinsics, UntexturedPointCloud pointCloud) -> ErrorStatus
    get_point_cloud_after_mapping(DepthMap depthMap, GrayScale2DImage textureValidMask, Color2DImage texture, CameraIntrinsics wrappedIntrinsics, TexturedPointCloud pointCloud) -> ErrorStatus
    """
    return _area_scan_3d_camera.get_point_cloud_after_mapping(*args)
class UhpCaptureMode(object):
    r"""Proxy of C++ mmind::eye::uhp_setting::CaptureMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _area_scan_3d_camera.UhpCaptureMode_name
    
    description = _area_scan_3d_camera.UhpCaptureMode_description
    
    type = _area_scan_3d_camera.UhpCaptureMode_type
    
    Value_Camera1 = _area_scan_3d_camera.UhpCaptureMode_Value_Camera1
    
    Value_Camera2 = _area_scan_3d_camera.UhpCaptureMode_Value_Camera2
    
    Value_Merge = _area_scan_3d_camera.UhpCaptureMode_Value_Merge
    

    def __init__(self):
        r"""__init__(UhpCaptureMode self) -> UhpCaptureMode"""
        _area_scan_3d_camera.UhpCaptureMode_swiginit(self, _area_scan_3d_camera.new_UhpCaptureMode())
    __swig_destroy__ = _area_scan_3d_camera.delete_UhpCaptureMode

# Register UhpCaptureMode in _area_scan_3d_camera:
_area_scan_3d_camera.UhpCaptureMode_swigregister(UhpCaptureMode)

def transform_point_cloud(coordinateTransformation, originalPointCloud):
    r"""transform_point_cloud(FrameTransformation coordinateTransformation, UntexturedPointCloud originalPointCloud) -> UntexturedPointCloud"""
    return _area_scan_3d_camera.transform_point_cloud(coordinateTransformation, originalPointCloud)

def transform_point_cloud_with_normals(coordinateTransformation, originalPointCloud):
    r"""transform_point_cloud_with_normals(FrameTransformation coordinateTransformation, UntexturedPointCloud originalPointCloud) -> UntexturedPointCloudWithNormals"""
    return _area_scan_3d_camera.transform_point_cloud_with_normals(coordinateTransformation, originalPointCloud)

def transform_textured_point_cloud(coordinateTransformation, originalTexturedPointCloud):
    r"""transform_textured_point_cloud(FrameTransformation coordinateTransformation, TexturedPointCloud originalTexturedPointCloud) -> TexturedPointCloud"""
    return _area_scan_3d_camera.transform_textured_point_cloud(coordinateTransformation, originalTexturedPointCloud)

def transform_textured_point_cloud_with_normals(coordinateTransformation, originalTexturedPointCloud):
    r"""transform_textured_point_cloud_with_normals(FrameTransformation coordinateTransformation, TexturedPointCloud originalTexturedPointCloud) -> TexturedPointCloudWithNormals"""
    return _area_scan_3d_camera.transform_textured_point_cloud_with_normals(coordinateTransformation, originalTexturedPointCloud)

def get_transformation_params(camera):
    r"""get_transformation_params(Camera camera) -> FrameTransformation"""
    return _area_scan_3d_camera.get_transformation_params(camera)

