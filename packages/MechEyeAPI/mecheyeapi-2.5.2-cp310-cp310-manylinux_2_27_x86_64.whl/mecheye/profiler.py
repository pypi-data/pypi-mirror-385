# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _profiler
else:
    import _profiler

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _profiler.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _profiler.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _profiler.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _profiler.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _profiler.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _profiler.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _profiler.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _profiler.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _profiler.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _profiler.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _profiler.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _profiler.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _profiler.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _profiler.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _profiler.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _profiler.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _profiler.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _profiler:
_profiler.SwigPyIterator_swigregister(SwigPyIterator)
from . import shared
class BatchArrayUint(object):
    r"""Represents the data struct of the profile data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, width):
        r"""Describes a constructor."""
        _profiler.BatchArrayUint_swiginit(self, _profiler.new_BatchArrayUint(width))
    __swig_destroy__ = _profiler.delete_BatchArrayUint

    def width(self):
        r"""Returns the width of the BatchArray object."""
        return _profiler.BatchArrayUint_width(self)

    def height(self):
        r"""Returns the height of the BatchArray object."""
        return _profiler.BatchArrayUint_height(self)

    def set_height(self, height):
        r"""Sets the height of the BatchArray object."""
        return _profiler.BatchArrayUint_set_height(self, height)

    def capacity(self):
        r"""
        Returns the size of the storage space currently allocated for the BatchArray object,
        expressed in number of lines.
        """
        return _profiler.BatchArrayUint_capacity(self)

    def is_empty(self):
        r"""Returns true if the BatchArray object has no elements."""
        return _profiler.BatchArrayUint_is_empty(self)

    def reserve(self, height):
        r"""
        Requests for enough capacity of the BatchArray object to contain
        the number of lines corresponding to the height.
        """
        return _profiler.BatchArrayUint_reserve(self, height)

    def append(self, data):
        r"""Appends the data variable onto the end of this BatchArray object."""
        return _profiler.BatchArrayUint_append(self, data)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _profiler.BatchArrayUint_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint32 * w * h).from_address(int(data)), np.uint32).copy()
        img = np.reshape(img, (h, w))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns an element reference to the specified row and column index in the BatchArray
        object.
        :type row: int
        :param row: Index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: Index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _profiler.BatchArrayUint_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the BatchArray object."""
        return _profiler.BatchArrayUint_clone(self)

    def clear(self):
        r"""Clears the data of the BatchArray object."""
        return _profiler.BatchArrayUint_clear(self)

    def flip(self, flipX, flipY):
        r"""
        Flips the BatchArray object.
        :type flipX: boolean
        :param flipX: Whether to flip the BatchArray object around the X-axis
        :type flipY: boolean
        :param flipY: Whether to flip the BatchArray object around the Y-axis.
        """
        return _profiler.BatchArrayUint_flip(self, flipX, flipY)

    def __getitem__(self, n):
        r"""__getitem__(BatchArrayUint self, size_t n) -> unsigned int &"""
        return _profiler.BatchArrayUint___getitem__(self, n)

# Register BatchArrayUint in _profiler:
_profiler.BatchArrayUint_swigregister(BatchArrayUint)
class IntensityImage(object):
    r"""Represents the data struct of the profile data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, width):
        r"""Describes a constructor."""
        _profiler.IntensityImage_swiginit(self, _profiler.new_IntensityImage(width))
    __swig_destroy__ = _profiler.delete_IntensityImage

    def width(self):
        r"""Returns the width of the BatchArray object."""
        return _profiler.IntensityImage_width(self)

    def height(self):
        r"""Returns the height of the BatchArray object."""
        return _profiler.IntensityImage_height(self)

    def set_height(self, height):
        r"""Sets the height of the BatchArray object."""
        return _profiler.IntensityImage_set_height(self, height)

    def capacity(self):
        r"""
        Returns the size of the storage space currently allocated for the BatchArray object,
        expressed in number of lines.
        """
        return _profiler.IntensityImage_capacity(self)

    def is_empty(self):
        r"""Returns true if the BatchArray object has no elements."""
        return _profiler.IntensityImage_is_empty(self)

    def reserve(self, height):
        r"""
        Requests for enough capacity of the BatchArray object to contain
        the number of lines corresponding to the height.
        """
        return _profiler.IntensityImage_reserve(self, height)

    def append(self, data):
        r"""Appends the data variable onto the end of this BatchArray object."""
        return _profiler.IntensityImage_append(self, data)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _profiler.IntensityImage_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint8 * w * h).from_address(int(data)), np.uint8).copy()
        img = np.reshape(img, (h, w))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns an element reference to the specified row and column index in the BatchArray
        object.
        :type row: int
        :param row: Index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: Index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _profiler.IntensityImage_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the BatchArray object."""
        return _profiler.IntensityImage_clone(self)

    def clear(self):
        r"""Clears the data of the BatchArray object."""
        return _profiler.IntensityImage_clear(self)

    def flip(self, flipX, flipY):
        r"""
        Flips the BatchArray object.
        :type flipX: boolean
        :param flipX: Whether to flip the BatchArray object around the X-axis
        :type flipY: boolean
        :param flipY: Whether to flip the BatchArray object around the Y-axis.
        """
        return _profiler.IntensityImage_flip(self, flipX, flipY)

    def __getitem__(self, n):
        r"""__getitem__(IntensityImage self, size_t n) -> unsigned char &"""
        return _profiler.IntensityImage___getitem__(self, n)

# Register IntensityImage in _profiler:
_profiler.IntensityImage_swigregister(IntensityImage)
class ProfileDepthMap(object):
    r"""Represents the data struct of the profile data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, width):
        r"""Describes a constructor."""
        _profiler.ProfileDepthMap_swiginit(self, _profiler.new_ProfileDepthMap(width))
    __swig_destroy__ = _profiler.delete_ProfileDepthMap

    def width(self):
        r"""Returns the width of the BatchArray object."""
        return _profiler.ProfileDepthMap_width(self)

    def height(self):
        r"""Returns the height of the BatchArray object."""
        return _profiler.ProfileDepthMap_height(self)

    def set_height(self, height):
        r"""Sets the height of the BatchArray object."""
        return _profiler.ProfileDepthMap_set_height(self, height)

    def capacity(self):
        r"""
        Returns the size of the storage space currently allocated for the BatchArray object,
        expressed in number of lines.
        """
        return _profiler.ProfileDepthMap_capacity(self)

    def is_empty(self):
        r"""Returns true if the BatchArray object has no elements."""
        return _profiler.ProfileDepthMap_is_empty(self)

    def reserve(self, height):
        r"""
        Requests for enough capacity of the BatchArray object to contain
        the number of lines corresponding to the height.
        """
        return _profiler.ProfileDepthMap_reserve(self, height)

    def append(self, data):
        r"""Appends the data variable onto the end of this BatchArray object."""
        return _profiler.ProfileDepthMap_append(self, data)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _profiler.ProfileDepthMap_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h).from_address(int(data)), np.float32).copy()
        img = np.reshape(img, (h, w))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns an element reference to the specified row and column index in the BatchArray
        object.
        :type row: int
        :param row: Index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: Index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _profiler.ProfileDepthMap_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the BatchArray object."""
        return _profiler.ProfileDepthMap_clone(self)

    def clear(self):
        r"""Clears the data of the BatchArray object."""
        return _profiler.ProfileDepthMap_clear(self)

    def flip(self, flipX, flipY):
        r"""
        Flips the BatchArray object.
        :type flipX: boolean
        :param flipX: Whether to flip the BatchArray object around the X-axis
        :type flipY: boolean
        :param flipY: Whether to flip the BatchArray object around the Y-axis.
        """
        return _profiler.ProfileDepthMap_flip(self, flipX, flipY)

    def __getitem__(self, n):
        r"""__getitem__(ProfileDepthMap self, size_t n) -> float &"""
        return _profiler.ProfileDepthMap___getitem__(self, n)

# Register ProfileDepthMap in _profiler:
_profiler.ProfileDepthMap_swigregister(ProfileDepthMap)
class UntexturedPointCloud(object):
    r"""Represents the data struct of the profile data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, width):
        r"""Describes a constructor."""
        _profiler.UntexturedPointCloud_swiginit(self, _profiler.new_UntexturedPointCloud(width))
    __swig_destroy__ = _profiler.delete_UntexturedPointCloud

    def width(self):
        r"""Returns the width of the BatchArray object."""
        return _profiler.UntexturedPointCloud_width(self)

    def height(self):
        r"""Returns the height of the BatchArray object."""
        return _profiler.UntexturedPointCloud_height(self)

    def set_height(self, height):
        r"""Sets the height of the BatchArray object."""
        return _profiler.UntexturedPointCloud_set_height(self, height)

    def capacity(self):
        r"""
        Returns the size of the storage space currently allocated for the BatchArray object,
        expressed in number of lines.
        """
        return _profiler.UntexturedPointCloud_capacity(self)

    def is_empty(self):
        r"""Returns true if the BatchArray object has no elements."""
        return _profiler.UntexturedPointCloud_is_empty(self)

    def reserve(self, height):
        r"""
        Requests for enough capacity of the BatchArray object to contain
        the number of lines corresponding to the height.
        """
        return _profiler.UntexturedPointCloud_reserve(self, height)

    def append(self, data):
        r"""Appends the data variable onto the end of this BatchArray object."""
        return _profiler.UntexturedPointCloud_append(self, data)

    def data(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _profiler.UntexturedPointCloud_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 3).from_address(int(data.this)), np.float32)
        img = np.reshape(img, (h, w, 3))
        return img.copy()



    def at(self, row, col):
        r"""
        Returns an element reference to the specified row and column index in the BatchArray
        object.
        :type row: int
        :param row: Index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: Index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _profiler.UntexturedPointCloud_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the BatchArray object."""
        return _profiler.UntexturedPointCloud_clone(self)

    def clear(self):
        r"""Clears the data of the BatchArray object."""
        return _profiler.UntexturedPointCloud_clear(self)

    def flip(self, flipX, flipY):
        r"""
        Flips the BatchArray object.
        :type flipX: boolean
        :param flipX: Whether to flip the BatchArray object around the X-axis
        :type flipY: boolean
        :param flipY: Whether to flip the BatchArray object around the Y-axis.
        """
        return _profiler.UntexturedPointCloud_flip(self, flipX, flipY)

    def __getitem__(self, n):
        r"""__getitem__(UntexturedPointCloud self, size_t n) -> PointXYZ"""
        return _profiler.UntexturedPointCloud___getitem__(self, n)

# Register UntexturedPointCloud in _profiler:
_profiler.UntexturedPointCloud_swigregister(UntexturedPointCloud)
class TexturedPointCloud(object):
    r"""Represents the data struct of the profile data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, width):
        r"""Describes a constructor."""
        _profiler.TexturedPointCloud_swiginit(self, _profiler.new_TexturedPointCloud(width))
    __swig_destroy__ = _profiler.delete_TexturedPointCloud

    def width(self):
        r"""Returns the width of the BatchArray object."""
        return _profiler.TexturedPointCloud_width(self)

    def height(self):
        r"""Returns the height of the BatchArray object."""
        return _profiler.TexturedPointCloud_height(self)

    def set_height(self, height):
        r"""Sets the height of the BatchArray object."""
        return _profiler.TexturedPointCloud_set_height(self, height)

    def capacity(self):
        r"""
        Returns the size of the storage space currently allocated for the BatchArray object,
        expressed in number of lines.
        """
        return _profiler.TexturedPointCloud_capacity(self)

    def is_empty(self):
        r"""Returns true if the BatchArray object has no elements."""
        return _profiler.TexturedPointCloud_is_empty(self)

    def reserve(self, height):
        r"""
        Requests for enough capacity of the BatchArray object to contain
        the number of lines corresponding to the height.
        """
        return _profiler.TexturedPointCloud_reserve(self, height)

    def append(self, data):
        r"""Appends the data variable onto the end of this BatchArray object."""
        return _profiler.TexturedPointCloud_append(self, data)

    def vertices(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _profiler.TexturedPointCloud_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_float * w * h * 4).from_address(int(data.this)), np.float32).copy()
        img = np.reshape(img, (h, w, 4))
        img = img[:, :, :3]
        return img.copy()

    def intensities(self):
        import numpy as np
        import ctypes
        if self.is_empty():
            return np.zeros(1)
        data = _profiler.TexturedPointCloud_data(self)
        w = self.width()
        h = self.height()
        img = np.frombuffer((ctypes.c_uint8 * w * h * 16).from_address(int(data.this)), np.uint8).copy()
        img = np.reshape(img, (h, w, 16))
        img = img[:, :, 12:13]
        return img.copy()



    def at(self, row, col):
        r"""
        Returns an element reference to the specified row and column index in the BatchArray
        object.
        :type row: int
        :param row: Index along the height dimension. An exception is thrown if the input row
            is greater than 'width'.
        :type col: int
        :param col: Index along the width dimension. An exception is thrown if the input col
            is greater than 'height'.
        """
        return _profiler.TexturedPointCloud_at(self, row, col)

    def clone(self):
        r"""Creates a deep copy of the BatchArray object."""
        return _profiler.TexturedPointCloud_clone(self)

    def clear(self):
        r"""Clears the data of the BatchArray object."""
        return _profiler.TexturedPointCloud_clear(self)

    def flip(self, flipX, flipY):
        r"""
        Flips the BatchArray object.
        :type flipX: boolean
        :param flipX: Whether to flip the BatchArray object around the X-axis
        :type flipY: boolean
        :param flipY: Whether to flip the BatchArray object around the Y-axis.
        """
        return _profiler.TexturedPointCloud_flip(self, flipX, flipY)

    def __getitem__(self, n):
        r"""__getitem__(TexturedPointCloud self, size_t n) -> PointXYZI"""
        return _profiler.TexturedPointCloud___getitem__(self, n)

# Register TexturedPointCloud in _profiler:
_profiler.TexturedPointCloud_swigregister(TexturedPointCloud)
class Profile(object):
    r"""Describes a single profile."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    profile_index = property(_profiler.Profile_profile_index_get, _profiler.Profile_profile_index_set, doc=r"""profile_index : unsigned int""")
    encoder = property(_profiler.Profile_encoder_get, _profiler.Profile_encoder_set, doc=r"""encoder : unsigned int""")
    intensity = property(_profiler.Profile_intensity_get, _profiler.Profile_intensity_set, doc=r"""intensity : p.q(const).unsigned char""")
    depth = property(_profiler.Profile_depth_get, _profiler.Profile_depth_set, doc=r"""depth : p.q(const).float""")

    def __init__(self):
        r"""__init__(Profile self) -> Profile"""
        _profiler.Profile_swiginit(self, _profiler.new_Profile())
    __swig_destroy__ = _profiler.delete_Profile

# Register Profile in _profiler:
_profiler.Profile_swigregister(Profile)
class PointXYZI(object):
    r"""
    Represents a point in 'ProfileBatch::TexturedPointCloud' with the coordinate (x, y, z,
    intensity) information.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_profiler.PointXYZI_x_get, _profiler.PointXYZI_x_set, doc=r"""x : float""")
    y = property(_profiler.PointXYZI_y_get, _profiler.PointXYZI_y_set, doc=r"""y : float""")
    z = property(_profiler.PointXYZI_z_get, _profiler.PointXYZI_z_set, doc=r"""z : float""")
    intensity = property(_profiler.PointXYZI_intensity_get, _profiler.PointXYZI_intensity_set, doc=r"""intensity : unsigned char""")

    def __init__(self):
        r"""__init__(PointXYZI self) -> PointXYZI"""
        _profiler.PointXYZI_swiginit(self, _profiler.new_PointXYZI())
    __swig_destroy__ = _profiler.delete_PointXYZI

# Register PointXYZI in _profiler:
_profiler.PointXYZI_swigregister(PointXYZI)
class ProfileBatch(object):
    r"""
    Represents a batch of profiles, which can be obtained by calling
    Profiler.retrieveBatchData(). It contains four elements of profile index, encoder value,
    intensity image, and depth map.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BatchFlag_Success = _profiler.ProfileBatch_BatchFlag_Success
    r""" All profiles in the ProfileBatch object contain valid intensity and depth data."""
    BatchFlag_Incomplete = _profiler.ProfileBatch_BatchFlag_Incomplete
    r"""
    Some profiles in the ProfileBatch object do not contain valid
    intensity and depth data.
    """

    def __init__(self, width):
        r"""Constructor."""
        _profiler.ProfileBatch_swiginit(self, _profiler.new_ProfileBatch(width))
    __swig_destroy__ = _profiler.delete_ProfileBatch

    def width(self):
        r"""Returns the width of the ProfileBatch object (the number of data points per profile)."""
        return _profiler.ProfileBatch_width(self)

    def height(self):
        r"""Returns the height of the ProfileBatch object (the number of profiles in the batch)."""
        return _profiler.ProfileBatch_height(self)

    def valid_height(self):
        r"""
        Returns the valid height of the ProfileBatch object (the number of profiles with
        valid intensity and depth data in the batch).
        """
        return _profiler.ProfileBatch_valid_height(self)

    def is_empty(self):
        r"""Checks if the ProfileBatch object has no elements."""
        return _profiler.ProfileBatch_is_empty(self)

    def reserve(self, height):
        r"""Reserves the input height for the ProfileBatch object."""
        return _profiler.ProfileBatch_reserve(self, height)

    def append(self, batch):
        r"""Appends the data of one ProfileBatch object to another."""
        return _profiler.ProfileBatch_append(self, batch)

    def clear(self):
        r"""Clears the data in the ProfileBatch object."""
        return _profiler.ProfileBatch_clear(self)

    def get_profile(self, profileIndex):
        r"""Gets a profile in the batch by inputting the index of the profile."""
        return _profiler.ProfileBatch_get_profile(self, profileIndex)

    def get_profile_index_array(self):
        r"""
        Gets an array of indices of all profiles in the batch. Each profile data corresponds
        to an index.
        """
        return _profiler.ProfileBatch_get_profile_index_array(self)

    def get_encoder_array(self):
        r"""
        Gets an array of encoder values of all profiles in the batch. Each profile data
        corresponds to an encoder value.
        """
        return _profiler.ProfileBatch_get_encoder_array(self)

    def get_intensity_image(self):
        r"""Gets the intensity image data in the batch. The invalid data of intensity image is 0."""
        return _profiler.ProfileBatch_get_intensity_image(self)

    def get_depth_map(self):
        r"""
        Gets the depth map data in the batch. Each point in DepthMap contains the Z
        information in the laser profiler coordinate system. The depth data unit is mm, and invalid
        data is nan.
        """
        return _profiler.ProfileBatch_get_depth_map(self)

    def get_untextured_point_cloud(self, *args):
        r"""
        Gets the untextured point cloud data in the batch. Each point in UntexturedPointCloud
        contains the X, Y, and Z information in the laser profiler coordinate system. The space of
        the X coordinate data is determined by the xResolution argument. The X coordinate data is
        determined by the column index. The space of the Y coordinate data is determined by
        yResolution argument. The Y coordinate data is determined by the encoder values if the
        useEncoderValues argument is set to true and row index otherwise. The depth data unit is mm,
        and invalid data is nan.
        :param [in]: xResolution determines the space of the X coordinate data.
        :param [in]: yResolution determines the space of the Y coordinate data.
        :param [in]: useEncoderValues determines whether to use the encoder values or row index as the
            data source for Y coordinate data.
        :param [in]: triggerInterval trigger interval of the encoder values.
        :param [in]: coordinateUnit the coordinate unit of the point cloud.
        :rtype: :py:class:`UntexturedPointCloud`
        :return: See 'UntexturedPointCloud' for details.
        """
        return _profiler.ProfileBatch_get_untextured_point_cloud(self, *args)

    def get_textured_point_cloud(self, *args):
        r"""
        Gets the textured point cloud data in the batch. Each point in TexturedPointCloud
        contains the X, Y, Z, and Intensity information in the laser profiler coordinate system. The
        space of the X coordinate data is determined by the xResolution argument. The X coordinate
        data is determined by the column index. The space of the Y coordinate data is determined by
        yResolution argument. The Y coordinate data is determined by the encoder values if the
        useEncoderValues argument is set to true and row index otherwise. The depth data unit is mm,
        and invalid data is nan.
        :param [in]: xResolution determines the space of the X coordinate data.
        :param [in]: yResolution determines the space of the Y coordinate data.
        :param [in]: useEncoderValues determines whether to use the encoder values or row index as the
            data source for Y coordinate data.
        :param [in]: triggerInterval trigger interval of the encoder values.
        :param [in]: coordinateUnit the coordinate unit of the point cloud.
        :rtype: :py:class:`TexturedPointCloud`
        :return: See 'UntexturedPointCloud' for details.
        """
        return _profiler.ProfileBatch_get_textured_point_cloud(self, *args)

    def save_untextured_point_cloud(self, *args):
        r"""
        Saves the untextured point cloud data in the batch. Each point in UntexturedPointCloud
        contains the X, Y, and Z information in the laser profiler coordinate system. The space of
        the X coordinate data is determined by the xResolution argument. The X coordinate data is
        determined by the column index. The space of the Y coordinate data is determined by
        yResolution argument. The Y coordinate data is determined by the encoder values if the
        useEncoderValues argument is set to true and row index otherwise. The depth data unit is mm,
        and invalid data is nan.
        :param [in]: xResolution determines the space of the X coordinate data.
        :param [in]: yResolution determines the space of the Y coordinate data.
        :param [in]: useEncoderValues determines whether to use the encoder values or row index as the
            data source for Y coordinate data.
        :param [in]: triggerInterval trigger interval of the encoder values.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: coordinateUnit the coordinate unit of the point cloud.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'ProfileBatch' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _profiler.ProfileBatch_save_untextured_point_cloud(self, *args)

    def save_textured_point_cloud(self, *args):
        r"""
        Saves the textured point cloud data in the batch. Each point in TexturedPointCloud
        contains the X, Y, Z, and Intensity information in the laser profiler coordinate system. The
        space of the X coordinate data is determined by the xResolution argument. The X coordinate
        data is determined by the column index. The space of the Y coordinate data is determined by
        yResolution argument. The Y coordinate data is determined by the encoder values if the
        useEncoderValues argument is set to true and row index otherwise. The depth data unit is mm,
        and invalid data is nan.
        :param [in]: xResolution determines the space of the X coordinate data.
        :param [in]: yResolution determines the space of the Y coordinate data.
        :param [in]: useEncoderValues determines whether to use the encoder values or row index as the
            data source for Y coordinate data.
        :param [in]: triggerInterval trigger interval of the encoder values.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: coordinateUnit the coordinate unit of the point cloud.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'ProfileBatch' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _profiler.ProfileBatch_save_textured_point_cloud(self, *args)

    @staticmethod
    def save_untextured_point_cloud_static(*args):
        r"""
        Saves the untextured point cloud data in the batch. Each point in UntexturedPointCloud
        contains the X, Y, and Z information in the laser profiler coordinate system. The depth data
        unit is mm, and invalid data is nan.
        :param [in]: pointCloud The point cloud to be saved. See 'UntexturedPointCloud' for
            details.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :param [in]: coordinateUnit the coordinate unit of the point cloud.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'ProfileBatch' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _profiler.ProfileBatch_save_untextured_point_cloud_static(*args)

    @staticmethod
    def save_textured_point_cloud_static(*args):
        r"""
        Saves the textured point cloud data in the batch. Each point in TexturedPointCloud
        contains the X, Y, Z, and Intensity information in the laser profiler coordinate system. The
        depth data unit is mm, and invalid data is nan.
        :param [in]: pointCloud The point cloud to be saved. See 'TexturedPointCloud' for details.
        :param [in]: fileFormat The format of the point cloud file. Possible values include PLY, PCD,
            and CSV. See 'FileFormat' for details.
        :param [in]: fileName The filename of the point cloud file.
        :param [in]: isOrganized Whether the point cloud is organized. An organized point cloud saves
            all points in order, with invalid data as nan, and an unorganized point cloud saves only
            valid points.
        :param [in]: coordinateUnit the coordinate unit of the point cloud.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' 'ProfileBatch' is empty.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Error occurred while writing the point cloud
            file.
        """
        return _profiler.ProfileBatch_save_textured_point_cloud_static(*args)

    def get_error_status(self):
        r"""Gets the error code and description of the function."""
        return _profiler.ProfileBatch_get_error_status(self)

    def get_flag(self):
        r"""Gets the flags of the ProfileBatch object. See 'BatchFlag' for details."""
        return _profiler.ProfileBatch_get_flag(self)

    def check_flag(self, flag):
        r"""Checks if the 'BatchFlag' value of the ProfileBatch object matches the input value."""
        return _profiler.ProfileBatch_check_flag(self, flag)

    def flip(self, flipX, flipY):
        r"""
        Flips the ProfileBatch object.
        :type flipX: boolean
        :param flipX: Whether to flip the intensity image and depth map round the X-axis.
        :type flipY: boolean
        :param flipY: Whether to flip the intensity image and depth map round the Y-axis.
        """
        return _profiler.ProfileBatch_flip(self, flipX, flipY)

# Register ProfileBatch in _profiler:
_profiler.ProfileBatch_swigregister(ProfileBatch)
class MinGrayscaleValue(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::MinGrayscaleValue class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MinGrayscaleValue_name
    
    description = _profiler.MinGrayscaleValue_description
    
    type = _profiler.MinGrayscaleValue_type
    

    def __init__(self):
        r"""__init__(MinGrayscaleValue self) -> MinGrayscaleValue"""
        _profiler.MinGrayscaleValue_swiginit(self, _profiler.new_MinGrayscaleValue())
    __swig_destroy__ = _profiler.delete_MinGrayscaleValue

# Register MinGrayscaleValue in _profiler:
_profiler.MinGrayscaleValue_swigregister(MinGrayscaleValue)
class MinSpotIntensity(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::MinSpotIntensity class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MinSpotIntensity_name
    
    description = _profiler.MinSpotIntensity_description
    
    type = _profiler.MinSpotIntensity_type
    

    def __init__(self):
        r"""__init__(MinSpotIntensity self) -> MinSpotIntensity"""
        _profiler.MinSpotIntensity_swiginit(self, _profiler.new_MinSpotIntensity())
    __swig_destroy__ = _profiler.delete_MinSpotIntensity

# Register MinSpotIntensity in _profiler:
_profiler.MinSpotIntensity_swigregister(MinSpotIntensity)
class MaxSpotIntensity(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::MaxSpotIntensity class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MaxSpotIntensity_name
    
    description = _profiler.MaxSpotIntensity_description
    
    type = _profiler.MaxSpotIntensity_type
    

    def __init__(self):
        r"""__init__(MaxSpotIntensity self) -> MaxSpotIntensity"""
        _profiler.MaxSpotIntensity_swiginit(self, _profiler.new_MaxSpotIntensity())
    __swig_destroy__ = _profiler.delete_MaxSpotIntensity

# Register MaxSpotIntensity in _profiler:
_profiler.MaxSpotIntensity_swigregister(MaxSpotIntensity)
class MinLaserLineWidth(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::MinLaserLineWidth class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MinLaserLineWidth_name
    
    description = _profiler.MinLaserLineWidth_description
    
    type = _profiler.MinLaserLineWidth_type
    

    def __init__(self):
        r"""__init__(MinLaserLineWidth self) -> MinLaserLineWidth"""
        _profiler.MinLaserLineWidth_swiginit(self, _profiler.new_MinLaserLineWidth())
    __swig_destroy__ = _profiler.delete_MinLaserLineWidth

# Register MinLaserLineWidth in _profiler:
_profiler.MinLaserLineWidth_swigregister(MinLaserLineWidth)
class MaxLaserLineWidth(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::MaxLaserLineWidth class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MaxLaserLineWidth_name
    
    description = _profiler.MaxLaserLineWidth_description
    
    type = _profiler.MaxLaserLineWidth_type
    

    def __init__(self):
        r"""__init__(MaxLaserLineWidth self) -> MaxLaserLineWidth"""
        _profiler.MaxLaserLineWidth_swiginit(self, _profiler.new_MaxLaserLineWidth())
    __swig_destroy__ = _profiler.delete_MaxLaserLineWidth

# Register MaxLaserLineWidth in _profiler:
_profiler.MaxLaserLineWidth_swigregister(MaxLaserLineWidth)
class SpotSelection(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::SpotSelection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.SpotSelection_name
    
    description = _profiler.SpotSelection_description
    
    type = _profiler.SpotSelection_type
    
    Value_Strongest = _profiler.SpotSelection_Value_Strongest
    
    Value_Nearest = _profiler.SpotSelection_Value_Nearest
    
    Value_Farthest = _profiler.SpotSelection_Value_Farthest
    
    Value_Invalid = _profiler.SpotSelection_Value_Invalid
    

    def __init__(self):
        r"""__init__(SpotSelection self) -> SpotSelection"""
        _profiler.SpotSelection_swiginit(self, _profiler.new_SpotSelection())
    __swig_destroy__ = _profiler.delete_SpotSelection

# Register SpotSelection in _profiler:
_profiler.SpotSelection_swigregister(SpotSelection)
class EdgeSelection(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::EdgeSelection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EdgeSelection_name
    
    description = _profiler.EdgeSelection_description
    
    type = _profiler.EdgeSelection_type
    
    Value_Center = _profiler.EdgeSelection_Value_Center
    
    Value_TopEdge = _profiler.EdgeSelection_Value_TopEdge
    
    Value_BottomEdge = _profiler.EdgeSelection_Value_BottomEdge
    

    def __init__(self):
        r"""__init__(EdgeSelection self) -> EdgeSelection"""
        _profiler.EdgeSelection_swiginit(self, _profiler.new_EdgeSelection())
    __swig_destroy__ = _profiler.delete_EdgeSelection

# Register EdgeSelection in _profiler:
_profiler.EdgeSelection_swigregister(EdgeSelection)
class MinSharpness(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::MinSharpness class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MinSharpness_name
    
    description = _profiler.MinSharpness_description
    
    type = _profiler.MinSharpness_type
    

    def __init__(self):
        r"""__init__(MinSharpness self) -> MinSharpness"""
        _profiler.MinSharpness_swiginit(self, _profiler.new_MinSharpness())
    __swig_destroy__ = _profiler.delete_MinSharpness

# Register MinSharpness in _profiler:
_profiler.MinSharpness_swigregister(MinSharpness)
class BrightnessAdjustment(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::BrightnessAdjustment class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.BrightnessAdjustment_name
    
    description = _profiler.BrightnessAdjustment_description
    
    type = _profiler.BrightnessAdjustment_type
    
    Value_Scale_0_5_0 = _profiler.BrightnessAdjustment_Value_Scale_0_5_0
    
    Value_Scale_0_7_5 = _profiler.BrightnessAdjustment_Value_Scale_0_7_5
    
    Value_Scale_1_0_0 = _profiler.BrightnessAdjustment_Value_Scale_1_0_0
    
    Value_Scale_1_5_0 = _profiler.BrightnessAdjustment_Value_Scale_1_5_0
    
    Value_Scale_2_0_0 = _profiler.BrightnessAdjustment_Value_Scale_2_0_0
    

    def __init__(self):
        r"""__init__(BrightnessAdjustment self) -> BrightnessAdjustment"""
        _profiler.BrightnessAdjustment_swiginit(self, _profiler.new_BrightnessAdjustment())
    __swig_destroy__ = _profiler.delete_BrightnessAdjustment

# Register BrightnessAdjustment in _profiler:
_profiler.BrightnessAdjustment_swigregister(BrightnessAdjustment)
class ExtractionSensitivityMode(object):
    r"""Proxy of C++ mmind::eye::profile_extraction::ExtractionSensitivityMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ExtractionSensitivityMode_name
    
    description = _profiler.ExtractionSensitivityMode_description
    
    type = _profiler.ExtractionSensitivityMode_type
    
    Value_Stable = _profiler.ExtractionSensitivityMode_Value_Stable
    
    Value_Balanced = _profiler.ExtractionSensitivityMode_Value_Balanced
    
    Value_Sensitive = _profiler.ExtractionSensitivityMode_Value_Sensitive
    

    def __init__(self):
        r"""__init__(ExtractionSensitivityMode self) -> ExtractionSensitivityMode"""
        _profiler.ExtractionSensitivityMode_swiginit(self, _profiler.new_ExtractionSensitivityMode())
    __swig_destroy__ = _profiler.delete_ExtractionSensitivityMode

# Register ExtractionSensitivityMode in _profiler:
_profiler.ExtractionSensitivityMode_swigregister(ExtractionSensitivityMode)
class Filter(object):
    r"""Proxy of C++ mmind::eye::profile_processing::Filter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.Filter_name
    
    description = _profiler.Filter_description
    
    type = _profiler.Filter_type
    
    Value__None = _profiler.Filter_Value__None
    
    Value_Mean = _profiler.Filter_Value_Mean
    
    Value_Median = _profiler.Filter_Value_Median
    

    def __init__(self):
        r"""__init__(Filter self) -> Filter"""
        _profiler.Filter_swiginit(self, _profiler.new_Filter())
    __swig_destroy__ = _profiler.delete_Filter

# Register Filter in _profiler:
_profiler.Filter_swigregister(Filter)
class MeanFilterWindowSize(object):
    r"""Proxy of C++ mmind::eye::profile_processing::MeanFilterWindowSize class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MeanFilterWindowSize_name
    
    description = _profiler.MeanFilterWindowSize_description
    
    type = _profiler.MeanFilterWindowSize_type
    
    Value_WindowSize_2 = _profiler.MeanFilterWindowSize_Value_WindowSize_2
    
    Value_WindowSize_4 = _profiler.MeanFilterWindowSize_Value_WindowSize_4
    
    Value_WindowSize_8 = _profiler.MeanFilterWindowSize_Value_WindowSize_8
    
    Value_WindowSize_16 = _profiler.MeanFilterWindowSize_Value_WindowSize_16
    
    Value_WindowSize_32 = _profiler.MeanFilterWindowSize_Value_WindowSize_32
    

    def __init__(self):
        r"""__init__(MeanFilterWindowSize self) -> MeanFilterWindowSize"""
        _profiler.MeanFilterWindowSize_swiginit(self, _profiler.new_MeanFilterWindowSize())
    __swig_destroy__ = _profiler.delete_MeanFilterWindowSize

# Register MeanFilterWindowSize in _profiler:
_profiler.MeanFilterWindowSize_swigregister(MeanFilterWindowSize)
class MedianFilterWindowSize(object):
    r"""Proxy of C++ mmind::eye::profile_processing::MedianFilterWindowSize class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MedianFilterWindowSize_name
    
    description = _profiler.MedianFilterWindowSize_description
    
    type = _profiler.MedianFilterWindowSize_type
    
    Value_WindowSize_3 = _profiler.MedianFilterWindowSize_Value_WindowSize_3
    
    Value_WindowSize_5 = _profiler.MedianFilterWindowSize_Value_WindowSize_5
    
    Value_WindowSize_7 = _profiler.MedianFilterWindowSize_Value_WindowSize_7
    
    Value_WindowSize_9 = _profiler.MedianFilterWindowSize_Value_WindowSize_9
    

    def __init__(self):
        r"""__init__(MedianFilterWindowSize self) -> MedianFilterWindowSize"""
        _profiler.MedianFilterWindowSize_swiginit(self, _profiler.new_MedianFilterWindowSize())
    __swig_destroy__ = _profiler.delete_MedianFilterWindowSize

# Register MedianFilterWindowSize in _profiler:
_profiler.MedianFilterWindowSize_swigregister(MedianFilterWindowSize)
class GapFilling(object):
    r"""Proxy of C++ mmind::eye::profile_processing::GapFilling class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.GapFilling_name
    
    description = _profiler.GapFilling_description
    
    type = _profiler.GapFilling_type
    

    def __init__(self):
        r"""__init__(GapFilling self) -> GapFilling"""
        _profiler.GapFilling_swiginit(self, _profiler.new_GapFilling())
    __swig_destroy__ = _profiler.delete_GapFilling

# Register GapFilling in _profiler:
_profiler.GapFilling_swigregister(GapFilling)
class GapFillingEdgePreservation(object):
    r"""Proxy of C++ mmind::eye::profile_processing::GapFillingEdgePreservation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.GapFillingEdgePreservation_name
    
    description = _profiler.GapFillingEdgePreservation_description
    
    type = _profiler.GapFillingEdgePreservation_type
    

    def __init__(self):
        r"""__init__(GapFillingEdgePreservation self) -> GapFillingEdgePreservation"""
        _profiler.GapFillingEdgePreservation_swiginit(self, _profiler.new_GapFillingEdgePreservation())
    __swig_destroy__ = _profiler.delete_GapFillingEdgePreservation

# Register GapFillingEdgePreservation in _profiler:
_profiler.GapFillingEdgePreservation_swigregister(GapFillingEdgePreservation)
class Resampling(object):
    r"""Proxy of C++ mmind::eye::profile_processing::Resampling class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.Resampling_name
    
    description = _profiler.Resampling_description
    
    type = _profiler.Resampling_type
    
    Value_Nearest = _profiler.Resampling_Value_Nearest
    
    Value_Farthest = _profiler.Resampling_Value_Farthest
    

    def __init__(self):
        r"""__init__(Resampling self) -> Resampling"""
        _profiler.Resampling_swiginit(self, _profiler.new_Resampling())
    __swig_destroy__ = _profiler.delete_Resampling

# Register Resampling in _profiler:
_profiler.Resampling_swigregister(Resampling)
class ResamplingEdgePreservation(object):
    r"""Proxy of C++ mmind::eye::profile_processing::ResamplingEdgePreservation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ResamplingEdgePreservation_name
    
    description = _profiler.ResamplingEdgePreservation_description
    
    type = _profiler.ResamplingEdgePreservation_type
    

    def __init__(self):
        r"""__init__(ResamplingEdgePreservation self) -> ResamplingEdgePreservation"""
        _profiler.ResamplingEdgePreservation_swiginit(self, _profiler.new_ResamplingEdgePreservation())
    __swig_destroy__ = _profiler.delete_ResamplingEdgePreservation

# Register ResamplingEdgePreservation in _profiler:
_profiler.ResamplingEdgePreservation_swigregister(ResamplingEdgePreservation)
class EnableOutlierRemoval(object):
    r"""Proxy of C++ mmind::eye::profile_processing::EnableOutlierRemoval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableOutlierRemoval_name
    
    description = _profiler.EnableOutlierRemoval_description
    
    type = _profiler.EnableOutlierRemoval_type
    

    def __init__(self):
        r"""__init__(EnableOutlierRemoval self) -> EnableOutlierRemoval"""
        _profiler.EnableOutlierRemoval_swiginit(self, _profiler.new_EnableOutlierRemoval())
    __swig_destroy__ = _profiler.delete_EnableOutlierRemoval

# Register EnableOutlierRemoval in _profiler:
_profiler.EnableOutlierRemoval_swigregister(EnableOutlierRemoval)
class OutlierRemovalIntensity(object):
    r"""Proxy of C++ mmind::eye::profile_processing::OutlierRemovalIntensity class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.OutlierRemovalIntensity_name
    
    description = _profiler.OutlierRemovalIntensity_description
    
    type = _profiler.OutlierRemovalIntensity_type
    
    Value_VeryLow = _profiler.OutlierRemovalIntensity_Value_VeryLow
    
    Value_Low = _profiler.OutlierRemovalIntensity_Value_Low
    
    Value_Medium = _profiler.OutlierRemovalIntensity_Value_Medium
    
    Value_High = _profiler.OutlierRemovalIntensity_Value_High
    
    Value_VeryHigh = _profiler.OutlierRemovalIntensity_Value_VeryHigh
    

    def __init__(self):
        r"""__init__(OutlierRemovalIntensity self) -> OutlierRemovalIntensity"""
        _profiler.OutlierRemovalIntensity_swiginit(self, _profiler.new_OutlierRemovalIntensity())
    __swig_destroy__ = _profiler.delete_OutlierRemovalIntensity

# Register OutlierRemovalIntensity in _profiler:
_profiler.OutlierRemovalIntensity_swigregister(OutlierRemovalIntensity)
class EnableZAxisAlignment(object):
    r"""Proxy of C++ mmind::eye::profile_alignment::EnableZAxisAlignment class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableZAxisAlignment_name
    
    description = _profiler.EnableZAxisAlignment_description
    
    type = _profiler.EnableZAxisAlignment_type
    

    def __init__(self):
        r"""__init__(EnableZAxisAlignment self) -> EnableZAxisAlignment"""
        _profiler.EnableZAxisAlignment_swiginit(self, _profiler.new_EnableZAxisAlignment())
    __swig_destroy__ = _profiler.delete_EnableZAxisAlignment

# Register EnableZAxisAlignment in _profiler:
_profiler.EnableZAxisAlignment_swigregister(EnableZAxisAlignment)
class EnableXAxisAlignment(object):
    r"""Proxy of C++ mmind::eye::profile_alignment::EnableXAxisAlignment class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableXAxisAlignment_name
    
    description = _profiler.EnableXAxisAlignment_description
    
    type = _profiler.EnableXAxisAlignment_type
    

    def __init__(self):
        r"""__init__(EnableXAxisAlignment self) -> EnableXAxisAlignment"""
        _profiler.EnableXAxisAlignment_swiginit(self, _profiler.new_EnableXAxisAlignment())
    __swig_destroy__ = _profiler.delete_EnableXAxisAlignment

# Register EnableXAxisAlignment in _profiler:
_profiler.EnableXAxisAlignment_swigregister(EnableXAxisAlignment)
class EnableBlindSpotFiltering(object):
    r"""Proxy of C++ mmind::eye::filters::EnableBlindSpotFiltering class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableBlindSpotFiltering_name
    
    description = _profiler.EnableBlindSpotFiltering_description
    
    type = _profiler.EnableBlindSpotFiltering_type
    

    def __init__(self):
        r"""__init__(EnableBlindSpotFiltering self) -> EnableBlindSpotFiltering"""
        _profiler.EnableBlindSpotFiltering_swiginit(self, _profiler.new_EnableBlindSpotFiltering())
    __swig_destroy__ = _profiler.delete_EnableBlindSpotFiltering

# Register EnableBlindSpotFiltering in _profiler:
_profiler.EnableBlindSpotFiltering_swigregister(EnableBlindSpotFiltering)
class EnableNoiseRemoval(object):
    r"""Proxy of C++ mmind::eye::filters::EnableNoiseRemoval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableNoiseRemoval_name
    
    description = _profiler.EnableNoiseRemoval_description
    
    type = _profiler.EnableNoiseRemoval_type
    

    def __init__(self):
        r"""__init__(EnableNoiseRemoval self) -> EnableNoiseRemoval"""
        _profiler.EnableNoiseRemoval_swiginit(self, _profiler.new_EnableNoiseRemoval())
    __swig_destroy__ = _profiler.delete_EnableNoiseRemoval

# Register EnableNoiseRemoval in _profiler:
_profiler.EnableNoiseRemoval_swigregister(EnableNoiseRemoval)
class NoiseRemovalIntensity(object):
    r"""Proxy of C++ mmind::eye::filters::NoiseRemovalIntensity class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.NoiseRemovalIntensity_name
    
    description = _profiler.NoiseRemovalIntensity_description
    
    type = _profiler.NoiseRemovalIntensity_type
    
    Value_Low = _profiler.NoiseRemovalIntensity_Value_Low
    
    Value_Medium = _profiler.NoiseRemovalIntensity_Value_Medium
    
    Value_High = _profiler.NoiseRemovalIntensity_Value_High
    

    def __init__(self):
        r"""__init__(NoiseRemovalIntensity self) -> NoiseRemovalIntensity"""
        _profiler.NoiseRemovalIntensity_swiginit(self, _profiler.new_NoiseRemovalIntensity())
    __swig_destroy__ = _profiler.delete_NoiseRemovalIntensity

# Register NoiseRemovalIntensity in _profiler:
_profiler.NoiseRemovalIntensity_swigregister(NoiseRemovalIntensity)
class ProfilerInfo(object):
    r"""Describes the laser profiler information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    model = property(_profiler.ProfilerInfo_model_get, _profiler.ProfilerInfo_model_set, doc=r"""model : std::string""")
    device_name = property(_profiler.ProfilerInfo_device_name_get, _profiler.ProfilerInfo_device_name_set, doc=r"""device_name : std::string""")
    controller_sn = property(_profiler.ProfilerInfo_controller_sn_get, _profiler.ProfilerInfo_controller_sn_set, doc=r"""controller_sn : std::string""")
    sensor_sn = property(_profiler.ProfilerInfo_sensor_sn_get, _profiler.ProfilerInfo_sensor_sn_set, doc=r"""sensor_sn : std::string""")
    hardware_version = property(_profiler.ProfilerInfo_hardware_version_get, _profiler.ProfilerInfo_hardware_version_set, doc=r"""hardware_version : mmind::eye::Version""")
    firmware_version = property(_profiler.ProfilerInfo_firmware_version_get, _profiler.ProfilerInfo_firmware_version_set, doc=r"""firmware_version : mmind::eye::Version""")
    ip_address = property(_profiler.ProfilerInfo_ip_address_get, _profiler.ProfilerInfo_ip_address_set, doc=r"""ip_address : std::string""")
    subnet_mask = property(_profiler.ProfilerInfo_subnet_mask_get, _profiler.ProfilerInfo_subnet_mask_set, doc=r"""subnet_mask : std::string""")
    ip_assignment_method = property(_profiler.ProfilerInfo_ip_assignment_method_get, _profiler.ProfilerInfo_ip_assignment_method_set, doc=r"""ip_assignment_method : mmind::eye::IpAssignmentMethod""")
    port = property(_profiler.ProfilerInfo_port_get, _profiler.ProfilerInfo_port_set, doc=r"""port : uint16_t""")
    supported = property(_profiler.ProfilerInfo_supported_get, _profiler.ProfilerInfo_supported_set, doc=r"""supported : bool""")
    last_supported_version = property(_profiler.ProfilerInfo_last_supported_version_get, _profiler.ProfilerInfo_last_supported_version_set, doc=r""" The last supported version of the device.""")

    def __init__(self):
        r"""__init__(ProfilerInfo self) -> ProfilerInfo"""
        _profiler.ProfilerInfo_swiginit(self, _profiler.new_ProfilerInfo())
    __swig_destroy__ = _profiler.delete_ProfilerInfo

# Register ProfilerInfo in _profiler:
_profiler.ProfilerInfo_swigregister(ProfilerInfo)
class AcquisitionCallbackBase(object):
    r"""Proxy of C++ AcquisitionCallbackBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def run(self, batch):
        r"""run(AcquisitionCallbackBase self, ProfileBatch batch)"""
        return _profiler.AcquisitionCallbackBase_run(self, batch)
    __swig_destroy__ = _profiler.delete_AcquisitionCallbackBase

    def __init__(self):
        r"""__init__(AcquisitionCallbackBase self) -> AcquisitionCallbackBase"""
        if self.__class__ == AcquisitionCallbackBase:
            _self = None
        else:
            _self = self
        _profiler.AcquisitionCallbackBase_swiginit(self, _profiler.new_AcquisitionCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _profiler.disown_AcquisitionCallbackBase(self)
        return weakref.proxy(self)

# Register AcquisitionCallbackBase in _profiler:
_profiler.AcquisitionCallbackBase_swigregister(AcquisitionCallbackBase)

def acquisition_callback_wrapper(batch, pUser):
    r"""acquisition_callback_wrapper(ProfileBatch batch, void * pUser)"""
    return _profiler.acquisition_callback_wrapper(batch, pUser)
OutputLineGPIO_Line21 = _profiler.OutputLineGPIO_Line21

OutputLineGPIO_Line22 = _profiler.OutputLineGPIO_Line22

OutputLineGPIO_Line23 = _profiler.OutputLineGPIO_Line23

OutputLineGPIO_Line24 = _profiler.OutputLineGPIO_Line24

OutputLineGPIO_Line25 = _profiler.OutputLineGPIO_Line25

OutputLineGPIO_Line26 = _profiler.OutputLineGPIO_Line26

OutputLineGPIO_Line27 = _profiler.OutputLineGPIO_Line27

OutputLineGPIO_Line28 = _profiler.OutputLineGPIO_Line28

OutputLevel_Low = _profiler.OutputLevel_Low

OutputLevel_High = _profiler.OutputLevel_High

AcquisitionStatus_AcquisitionTriggerWait = _profiler.AcquisitionStatus_AcquisitionTriggerWait
r""" 'Profiler::startAcquisition' not called."""
AcquisitionStatus_AcquisitionActive = _profiler.AcquisitionStatus_AcquisitionActive
r""" 'Profiler::startAcquisition' called."""
AcquisitionStatus_FrameTriggerWait = _profiler.AcquisitionStatus_FrameTriggerWait
r"""
    'Profiler::triggerSoftware' not called or GPIO input frame start
    signal not received.
    """
AcquisitionStatus_FrameActive = _profiler.AcquisitionStatus_FrameActive
r"""
    'Profiler::triggerSoftware' called or GPIO input frame start signal
    received.
    """
class ProfilerTemperature(object):
    r"""Describes the laser profiler temperatures."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    controller_cpu_temperature = property(_profiler.ProfilerTemperature_controller_cpu_temperature_get, _profiler.ProfilerTemperature_controller_cpu_temperature_set, doc=r"""controller_cpu_temperature : float""")
    sensor_cpu_temperature = property(_profiler.ProfilerTemperature_sensor_cpu_temperature_get, _profiler.ProfilerTemperature_sensor_cpu_temperature_set, doc=r"""sensor_cpu_temperature : float""")

    def __init__(self):
        r"""__init__(ProfilerTemperature self) -> ProfilerTemperature"""
        _profiler.ProfilerTemperature_swiginit(self, _profiler.new_ProfilerTemperature())
    __swig_destroy__ = _profiler.delete_ProfilerTemperature

# Register ProfilerTemperature in _profiler:
_profiler.ProfilerTemperature_swigregister(ProfilerTemperature)
cvar = _profiler.cvar

class ProfilerStatus(object):
    r"""Describes the laser profiler's statuses."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    temperature = property(_profiler.ProfilerStatus_temperature_get, _profiler.ProfilerStatus_temperature_set, doc=r"""temperature : mmind::eye::ProfilerTemperature""")

    def __init__(self):
        r"""__init__(ProfilerStatus self) -> ProfilerStatus"""
        _profiler.ProfilerStatus_swiginit(self, _profiler.new_ProfilerStatus())
    __swig_destroy__ = _profiler.delete_ProfilerStatus

# Register ProfilerStatus in _profiler:
_profiler.ProfilerStatus_swigregister(ProfilerStatus)
class Profiler(object):
    r"""
    Operates the laser profiler.
    Use 'Profiler.connect' to connect an available laser profiler, retrieve profile data,
    configure parameters and so on.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _profiler.delete_Profiler

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        |

        *Overload 2:*

        Copy constructor.
        """
        _profiler.Profiler_swiginit(self, _profiler.new_Profiler(*args))

    @staticmethod
    def discover_profilers(timeoutMs=5000):
        r"""
        Discovers all available laser profilers and returns the list of
        information of all available laser profilers. If a laser profiler is not successfully
        discovered, please check the network connection and indicator lights on the laser profiler.
        :param [in]: timeoutMs The timeout period (in ms) for discovering laser profilers. If no laser
            profilers are discovered after the timeout period has passed, this method returns an empty
            list.
        :rtype: std::vector< mmind::eye::ProfilerInfo,std::allocator< mmind::eye::ProfilerInfo > >
        :return: The list of information of all available laser profilers.
        """
        return _profiler.Profiler_discover_profilers(timeoutMs)

    def save_virtual_device_file(self, data, fileName):
        r"""
        Saves the acquired 'ProfileBatch' data, 'Parameter' s, and
        ProfilerInfo in an MRAW format file that can be loaded as a 'VirtualProfiler'.

        :type data: :py:class:`ProfileBatch`
        :param data: The acquired 'ProfileBatch' data to be saved.
        :type fileName: string
        :param fileName: The name of the MRAW file to be saved. You can add a path before the name to
            specify the path for saving the file.
        Notes: Depending on the parameter settings and amount of data to be saved, it may take up to a
        few minutes to save the virtual device file.Please ensure that the file name is encoded in
        UTF-8 format.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.

             'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Failed to create the virtual device file.
        """
        return _profiler.Profiler_save_virtual_device_file(self, data, fileName)

    def connect(self, *args):
        r"""
        *Overload 1:*

        Connects to a laser profiler via 'ProfilerInfo'.
        :param [in]: info Laser profiler information. Use 'Profiler.discoverProfilers' to find
            all available laser profilers.
        :param [in]: timeoutMs The timeout for connecting a laser profiler(ms). If the execution
            time of the connecting process is greater than the timeout, the function will immediately
            return 'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' IP address format error.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' IP address not corresponding to an available
             device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Laser profiler model or
             firmware version not supported.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.


        |

        *Overload 2:*

        Connects to a laser profiler via IP address.
        :param [in]: ipAddress Valid IP address of the laser profiler, e.g. in "100.100.1.1" format.
        :param [in]: timeoutMs The timeout for connecting a laser profiler (ms). If the execution
            time of the connecting process is greater than the timeout, the function will immediately
            return 'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' IP address format error.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' IP address not corresponding to an
             available device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Laser profiler model or
             firmware version not supported.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.


        |

        *Overload 3:*

        Connects to a laser profiler via IP address.
        :param [in]: ipAddress Valid IP address of the laser profiler, e.g. in "100.100.1.1" format.
        :param [in]: timeoutMs The timeout for connecting a laser profiler (ms). If the execution
            time of the connecting process is greater than the timeout, the function will immediately
            return 'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' IP address format error.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' IP address not corresponding to an
             available device.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Laser profiler model or
             firmware version not supported.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _profiler.Profiler_connect(self, *args)

    def disconnect(self):
        r"""
        Disconnects from the current laser profiler and releases the associated resources.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse Response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _profiler.Profiler_disconnect(self)

    def set_heartbeat_interval(self, intervalMs):
        r"""
        Sets the time interval at which the client sends periodic heartbeat messages to the
        profiler side. The default time interval is 10s.
        :param [in]: timeIntervalMs The time interval for periodic sending heartbeat messages in
            milliseconds. The valid setting range is from 1s to 3600s.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Profiler disconnected.

             'ErrorStatus.MMIND_STATUS_OUT_OF_RANGE_ERROR' Invalid parameter input.
        """
        return _profiler.Profiler_set_heartbeat_interval(self, intervalMs)

    def get_profiler_info(self, info):
        r"""
        Gets the basic information of the laser profiler, such as model, serial number,
        firmware version, and IP setting, etc.
        :param [out]: See 'ProfilerInfo' for details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.
        """
        return _profiler.Profiler_get_profiler_info(self, info)

    def get_profiler_status(self, status):
        r"""
        Gets various statuses of the laser profiler.
        :param [out]: See 'ProfilerStatus' for details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Profiler disconnected.
        """
        return _profiler.Profiler_get_profiler_status(self, status)

    def user_set_manager(self):
        r"""
        Gets the 'UserSetManager' of the laser profiler. 'UserSetManager' provides
        various operations to manage all user set saved in the laser profiler, including adding and
        deleting the user set and selecting the user set currently in effect. It is also available to
        save all user set details to a json file and read a json file to load user set details.
        :rtype: :py:class:`UserSetManager`
        :return: See 'UserSetManager' for details.
        """
        return _profiler.Profiler_user_set_manager(self)

    def current_user_set(self):
        r"""
        Gets the 'UserSet' currently in effect of the laser profiler. 'UserSet' can
        access all available parameters of the laser profiler related to profile data acquisition.
        'UserSet' can also directly set and get parameters instead of using 'Parameter'
        interface.
        :rtype: :py:class:`UserSet`
        :return: See 'UserSet' for details.
        """
        return _profiler.Profiler_current_user_set(self)

    def retrieve_batch_data(self, batch, timeoutMs=4000):
        r"""
        Retrieves a batch of the profiles. There are two ways to retrieve profile
        data, by polling or callback. This method is only used with the polling method.
        The number of profiles contained in a batch varies depending on the scan rate and the rate at
        which this method is called.
        :param [out]: batch The retrieving result, it contains information including profile index,
            encoder value intensity image, and depth data. See 'ProfileBatch' for details.
        :param [in]: timeoutMs The timeout for capturing in milliseconds. If the execution time of
            the capturing process is greater than the timeout, the function will immediately return
            'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR'.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_NO_DATA_ERROR' No profile data obtained. Some error may have
             occurred on the laser profiler.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_ACQUISITION_TRIGGER_WAIT' Acquisition not started or stopped.
        """
        return _profiler.Profiler_retrieve_batch_data(self, batch, timeoutMs)

    def trigger_software(self):
        r"""
        Sends a software signal to trigger data acquisition. This method is used when no
        external signals are input to trigger data acquisition and must be called after
        startAcquisition.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.
        """
        return _profiler.Profiler_trigger_software(self)

    def start_acquisition(self):
        r"""
        Enters the laser profiler into the acquisition ready status, where it can accept
        trigger signals for scanning.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.
        """
        return _profiler.Profiler_start_acquisition(self)

    def stop_acquisition(self):
        r"""
        Exits the laser profiler from the acquisition ready status to avoid accidental
        triggering of scanning. If a callback function is being executed when this method is called,
        this method is not executed until the execution of the callback function is finished.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.
        """
        return _profiler.Profiler_stop_acquisition(self)

    def set_output_for_gpio(self, outputLine, value, holdTimeMs=-1):
        r"""
        Sets controller GPIO output value.
        :type holdTimeMs: int, optional
        :param holdTimeMs: Use this parameter to pull down the GPO after certain amount of time when
            setting OutputLevel to High. -1 means do not pull down. Notes: This parameter is only
        available on profilers with firmware version >= v2.5.0.
        When setting :type holdTimeMs: int, optional
        :param holdTimeMs: for several times, the last setting will be valid.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid laser profiler handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Laser profiler disconnected.

             'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Parameter holdTimeMs is not supported.

             'ErrorStatus.MMIND_STATUS_TIMEOUT_ERROR' Timeout error.

             'ErrorStatus.MMIND_STATUS_RESPONSE_PARSE_ERROR' Parse response error.

             'ErrorStatus.MMIND_STATUS_REPLY_WITH_ERROR' There are errors in reply.
        """
        return _profiler.Profiler_set_output_for_gpio(self, outputLine, value, holdTimeMs)

    def register_acquisition_callback(self, func):
        r"""register_acquisition_callback(Profiler self, AcquisitionCallbackBase func) -> ErrorStatus"""
        return _profiler.Profiler_register_acquisition_callback(self, func)

    def get_acquisition_status(self):
        r"""get_acquisition_status(Profiler self) -> ErrorStatus"""
        return _profiler.Profiler_get_acquisition_status(self)

# Register Profiler in _profiler:
_profiler.Profiler_swigregister(Profiler)
class VectorProfilerInfo(object):
    r"""Proxy of C++ std::vector< mmind::eye::ProfilerInfo > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(VectorProfilerInfo self) -> SwigPyIterator"""
        return _profiler.VectorProfilerInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(VectorProfilerInfo self) -> bool"""
        return _profiler.VectorProfilerInfo___nonzero__(self)

    def __bool__(self):
        r"""__bool__(VectorProfilerInfo self) -> bool"""
        return _profiler.VectorProfilerInfo___bool__(self)

    def __len__(self):
        r"""__len__(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::size_type"""
        return _profiler.VectorProfilerInfo___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i, std::vector< mmind::eye::ProfilerInfo >::difference_type j) -> VectorProfilerInfo"""
        return _profiler.VectorProfilerInfo___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i, std::vector< mmind::eye::ProfilerInfo >::difference_type j)
        __setslice__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i, std::vector< mmind::eye::ProfilerInfo >::difference_type j, VectorProfilerInfo v)
        """
        return _profiler.VectorProfilerInfo___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i, std::vector< mmind::eye::ProfilerInfo >::difference_type j)"""
        return _profiler.VectorProfilerInfo___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i)
        __delitem__(VectorProfilerInfo self, SWIGPY_SLICEOBJECT * slice)
        """
        return _profiler.VectorProfilerInfo___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(VectorProfilerInfo self, SWIGPY_SLICEOBJECT * slice) -> VectorProfilerInfo
        __getitem__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i) -> ProfilerInfo
        """
        return _profiler.VectorProfilerInfo___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(VectorProfilerInfo self, SWIGPY_SLICEOBJECT * slice, VectorProfilerInfo v)
        __setitem__(VectorProfilerInfo self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::difference_type i, ProfilerInfo x)
        """
        return _profiler.VectorProfilerInfo___setitem__(self, *args)

    def pop(self):
        r"""pop(VectorProfilerInfo self) -> ProfilerInfo"""
        return _profiler.VectorProfilerInfo_pop(self)

    def append(self, x):
        r"""append(VectorProfilerInfo self, ProfilerInfo x)"""
        return _profiler.VectorProfilerInfo_append(self, x)

    def empty(self):
        r"""empty(VectorProfilerInfo self) -> bool"""
        return _profiler.VectorProfilerInfo_empty(self)

    def size(self):
        r"""size(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::size_type"""
        return _profiler.VectorProfilerInfo_size(self)

    def swap(self, v):
        r"""swap(VectorProfilerInfo self, VectorProfilerInfo v)"""
        return _profiler.VectorProfilerInfo_swap(self, v)

    def begin(self):
        r"""begin(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::iterator"""
        return _profiler.VectorProfilerInfo_begin(self)

    def end(self):
        r"""end(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::iterator"""
        return _profiler.VectorProfilerInfo_end(self)

    def rbegin(self):
        r"""rbegin(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::reverse_iterator"""
        return _profiler.VectorProfilerInfo_rbegin(self)

    def rend(self):
        r"""rend(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::reverse_iterator"""
        return _profiler.VectorProfilerInfo_rend(self)

    def clear(self):
        r"""clear(VectorProfilerInfo self)"""
        return _profiler.VectorProfilerInfo_clear(self)

    def get_allocator(self):
        r"""get_allocator(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::allocator_type"""
        return _profiler.VectorProfilerInfo_get_allocator(self)

    def pop_back(self):
        r"""pop_back(VectorProfilerInfo self)"""
        return _profiler.VectorProfilerInfo_pop_back(self)

    def erase(self, *args):
        r"""
        erase(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::iterator pos) -> std::vector< mmind::eye::ProfilerInfo >::iterator
        erase(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::iterator first, std::vector< mmind::eye::ProfilerInfo >::iterator last) -> std::vector< mmind::eye::ProfilerInfo >::iterator
        """
        return _profiler.VectorProfilerInfo_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(VectorProfilerInfo self) -> VectorProfilerInfo
        __init__(VectorProfilerInfo self, VectorProfilerInfo other) -> VectorProfilerInfo
        __init__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::size_type size) -> VectorProfilerInfo
        __init__(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::size_type size, ProfilerInfo value) -> VectorProfilerInfo
        """
        _profiler.VectorProfilerInfo_swiginit(self, _profiler.new_VectorProfilerInfo(*args))

    def push_back(self, x):
        r"""push_back(VectorProfilerInfo self, ProfilerInfo x)"""
        return _profiler.VectorProfilerInfo_push_back(self, x)

    def front(self):
        r"""front(VectorProfilerInfo self) -> ProfilerInfo"""
        return _profiler.VectorProfilerInfo_front(self)

    def back(self):
        r"""back(VectorProfilerInfo self) -> ProfilerInfo"""
        return _profiler.VectorProfilerInfo_back(self)

    def assign(self, n, x):
        r"""assign(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::size_type n, ProfilerInfo x)"""
        return _profiler.VectorProfilerInfo_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::size_type new_size)
        resize(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::size_type new_size, ProfilerInfo x)
        """
        return _profiler.VectorProfilerInfo_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::iterator pos, ProfilerInfo x) -> std::vector< mmind::eye::ProfilerInfo >::iterator
        insert(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::iterator pos, std::vector< mmind::eye::ProfilerInfo >::size_type n, ProfilerInfo x)
        """
        return _profiler.VectorProfilerInfo_insert(self, *args)

    def reserve(self, n):
        r"""reserve(VectorProfilerInfo self, std::vector< mmind::eye::ProfilerInfo >::size_type n)"""
        return _profiler.VectorProfilerInfo_reserve(self, n)

    def capacity(self):
        r"""capacity(VectorProfilerInfo self) -> std::vector< mmind::eye::ProfilerInfo >::size_type"""
        return _profiler.VectorProfilerInfo_capacity(self)
    __swig_destroy__ = _profiler.delete_VectorProfilerInfo

# Register VectorProfilerInfo in _profiler:
_profiler.VectorProfilerInfo_swigregister(VectorProfilerInfo)

def virtual_acquisition_callback_wrapper(batch, pUser):
    r"""virtual_acquisition_callback_wrapper(ProfileBatch batch, void * pUser)"""
    return _profiler.virtual_acquisition_callback_wrapper(batch, pUser)
class VirtualProfiler(object):
    r"""Proxy of C++ mmind::eye::VirtualProfiler class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _profiler.delete_VirtualProfiler

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor
        Notes: Please ensure that the file name is encoded in UTF-8 format.
        :type filePath: string
        :param filePath: The path of the virtual laser profiler file (.mraw) to be loaded.

         'ErrorStatus.MMIND_STATUS_FILE_IO_ERROR' Fails to load the virtual data.

        |

        *Overload 2:*

        Copy constructor.
        """
        _profiler.VirtualProfiler_swiginit(self, _profiler.new_VirtualProfiler(*args))

    def get_profiler_info(self, info):
        r"""
        Gets the basic information of the virtual laser profiler, such as model, serial
        number, and firmware version.
        :param [out]: See 'ProfilerInfo' for details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.
        """
        return _profiler.VirtualProfiler_get_profiler_info(self, info)

    def current_user_set(self):
        r"""
        Gets the parameter information used when the virtual device was saved.
        :rtype: :py:class:`VirtualUserSet`
        :return: An object of
            VirtualUserSet. Through
            VirtualUserSet, you can access all available parameters of the virtual device. See
            VirtualUserSet for details.
        """
        return _profiler.VirtualProfiler_current_user_set(self)

    def retrieve_batch_data(self, batch):
        r"""
        Retrieves a batch of the profiles. There are two ways to retrieve profile
        data, by polling or callback. This method is only used with the polling method.
        :param [out]: batch The retrieved data of multiple profiles. See 'ProfileBatch' for
            details.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_ACQUISITION_TRIGGER_WAIT' Acquisition not started or stopped.

             'ErrorStatus.MMIND_STATUS_INVALID_INPUT_ERROR' The 'ProfileBatch' batch input is
            invalid.
        """
        return _profiler.VirtualProfiler_retrieve_batch_data(self, batch)

    def start_acquisition(self):
        r"""
        Enters the virtual device into the acquisition ready status, where it can accept
        trigger signals for scanning.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.
        """
        return _profiler.VirtualProfiler_start_acquisition(self)

    def stop_acquisition(self):
        r"""
        Exits the virtual profiler from the acquisition ready status to avoid accidental
        triggering of scanning. If a callback function is being executed when this method is called,
        this method is not executed until the execution of the callback function is finished.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.
        """
        return _profiler.VirtualProfiler_stop_acquisition(self)

    def register_acquisition_callback(self, func):
        r"""register_acquisition_callback(VirtualProfiler self, AcquisitionCallbackBase func) -> ErrorStatus"""
        return _profiler.VirtualProfiler_register_acquisition_callback(self, func)

# Register VirtualProfiler in _profiler:
_profiler.VirtualProfiler_swigregister(VirtualProfiler)
class EventCallbackBase(object):
    r"""Proxy of C++ EventCallbackBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def run(self, event):
        r"""run(EventCallbackBase self, mmind::eye::ProfilerEvent::Event event)"""
        return _profiler.EventCallbackBase_run(self, event)

    def process_event(self, eventData, extraPayload):
        r"""process_event(EventCallbackBase self, EventData eventData, Payload extraPayload)"""
        return _profiler.EventCallbackBase_process_event(self, eventData, extraPayload)
    __swig_destroy__ = _profiler.delete_EventCallbackBase

    def __init__(self):
        r"""__init__(EventCallbackBase self) -> EventCallbackBase"""
        if self.__class__ == EventCallbackBase:
            _self = None
        else:
            _self = self
        _profiler.EventCallbackBase_swiginit(self, _profiler.new_EventCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _profiler.disown_EventCallbackBase(self)
        return weakref.proxy(self)

# Register EventCallbackBase in _profiler:
_profiler.EventCallbackBase_swigregister(EventCallbackBase)
class ProfilerEvent(object):
    r"""
    Describes the event of profiler.
    Use 'ProfilerEvent.registerProfilerEventCallback' to register an event of interest.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PROFILER_EVENT_DISCONNECTED = _profiler.ProfilerEvent_PROFILER_EVENT_DISCONNECTED
    r""" The profiler has disconnected."""
    PROFILER_EVENT_ALL = _profiler.ProfilerEvent_PROFILER_EVENT_ALL
    r""" All profiler events."""

    @staticmethod
    def get_supported_events(profiler, eventInfos):
        r"""
        Get supported events by the profiler

        :type profiler: :py:class:`Profiler`
        :param profiler: The profiler for which to get supported events.
        :type eventInfos: std::vector< mmind::eye::ProfilerEvent::EventInfo,std::allocator< mmind::eye::ProfilerEvent::EventInfo > >
        :param eventInfos: The information of the events supported.
        :rtype: :py:class:`ErrorStatus`
        :return: 
             'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

             'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid camera handle.

             'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Camera disconnected.
        """
        return _profiler.ProfilerEvent_get_supported_events(profiler, eventInfos)

    def register_profiler_event_callback(self, *args):
        r"""
        register_profiler_event_callback(ProfilerEvent self, Profiler profiler, EventCallbackBase callback, unsigned int events) -> ErrorStatus
            :brief [deprecated] Registers a profiler event of interest.

            :type profiler: :py:class:`Profiler`
            :param profiler: The profiler object to unregister the callback for.
            :type callback: :py:class:`EventCallbackBase`
            :param callback: User-derived version of :py:class:`EventCallbackBase` for handling profiler events.
            :type event: int
            :param event: The profiler event. See :py:enum:`ProfilerEvent.Event` for details.

            :rtype: :py:class:`ErrorStatus`
            :return:
                 'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

                 'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid profiler handle, not connected to any
                       device.

                 'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Profiler disconnected due to network issues.

                 'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Not supported profiler model or firmware.

        register_profiler_event_callback(ProfilerEvent self, Profiler profiler, uint16_t event, EventCallbackBase callback) -> ErrorStatus

            :brief Registers a callback to handle a profiler event.
            This function registers a callback function to be invoked when a specified event occurs
            on the given profiler object.

            :type profiler: :py:class:`Profiler`
            :param profiler: The profiler object to unregister the callback for.
            :type event: int
            :param event: The profiler event. See `ProfilerEvent.get_supported_events` for details.
            :type callback: :py:class:`EventCallbackBase`
            :param callback: User-derived version of :py:class:`EventCallbackBase` for handling profiler events.

            :rtype: :py:class:`ErrorStatus`
            :return:
                'ErrorStatus.MMIND_STATUS_SUCCESS' Success.

                'ErrorStatus.MMIND_STATUS_INVALID_DEVICE' Invalid profiler handle, not connected to any
                     device.

                'ErrorStatus.MMIND_STATUS_DEVICE_OFFLINE' Profiler disconnected due to network issues.

                'ErrorStatus.MMIND_STATUS_NO_SUPPORT_ERROR' Not supported profiler model or firmware.

                'ErrorStatus.MMIND_STATUS_INVALID_CALLBACKFUNC' Callback function is null or has been
                                                                                     registered already.

                'ErrorStatus.MMIND_STATUS_MESSAGE_CHANNEL_ERROR' Failed to establish message channel
                                                                                     for reporting events.
        """
        return _profiler.ProfilerEvent_register_profiler_event_callback(self, *args)



    def unregister_profiler_event_callback(self, profiler, event):
        r"""unregister_profiler_event_callback(ProfilerEvent self, Profiler profiler, uint16_t event) -> ErrorStatus"""
        return _profiler.ProfilerEvent_unregister_profiler_event_callback(self, profiler, event)

    def __init__(self):
        r"""__init__(ProfilerEvent self) -> ProfilerEvent"""
        _profiler.ProfilerEvent_swiginit(self, _profiler.new_ProfilerEvent())
    __swig_destroy__ = _profiler.delete_ProfilerEvent

# Register ProfilerEvent in _profiler:
_profiler.ProfilerEvent_swigregister(ProfilerEvent)
class EventInfo(object):
    r"""Describes the event information."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    event_name = property(_profiler.EventInfo_event_name_get, _profiler.EventInfo_event_name_set, doc=r"""event_name : std::string""")
    event_id = property(_profiler.EventInfo_event_id_get, _profiler.EventInfo_event_id_set, doc=r"""event_id : uint16_t""")

    def __init__(self, *args):
        r"""
        __init__(EventInfo self) -> EventInfo
        __init__(EventInfo self, std::string const & eventName, uint16_t eventId) -> EventInfo
        """
        _profiler.EventInfo_swiginit(self, _profiler.new_EventInfo(*args))
    __swig_destroy__ = _profiler.delete_EventInfo

# Register EventInfo in _profiler:
_profiler.EventInfo_swigregister(EventInfo)
class EventData(object):
    r"""Proxy of C++ mmind::eye::ProfilerEvent::EventData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    event_id = property(_profiler.EventData_event_id_get, _profiler.EventData_event_id_set, doc=r"""event_id : int""")
    event_name = property(_profiler.EventData_event_name_get, _profiler.EventData_event_name_set, doc=r"""event_name : std::string""")
    timestamp = property(_profiler.EventData_timestamp_get, _profiler.EventData_timestamp_set, doc=r"""timestamp : int64_t""")

    def __init__(self):
        r"""__init__(EventData self) -> EventData"""
        _profiler.EventData_swiginit(self, _profiler.new_EventData())
    __swig_destroy__ = _profiler.delete_EventData

# Register EventData in _profiler:
_profiler.EventData_swigregister(EventData)
class PayloadMember(object):
    r"""Describes the data member of the event's payload"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_profiler.PayloadMember_name_get, _profiler.PayloadMember_name_set, doc=r""" Member name""")
    Type__UInt32 = _profiler.PayloadMember_Type__UInt32
    
    Type__Int32 = _profiler.PayloadMember_Type__Int32
    
    Type__Int64 = _profiler.PayloadMember_Type__Int64
    
    Type__Float = _profiler.PayloadMember_Type__Float
    
    Type__Double = _profiler.PayloadMember_Type__Double
    
    Type__Bool = _profiler.PayloadMember_Type__Bool
    
    Type__String = _profiler.PayloadMember_Type__String
    
    type = property(_profiler.PayloadMember_type_get, _profiler.PayloadMember_type_set, doc=r""" Member type""")
    value = property(_profiler.PayloadMember_value_get, _profiler.PayloadMember_value_set, doc=r""" Member value""")

    def __init__(self):
        r"""__init__(PayloadMember self) -> PayloadMember"""
        _profiler.PayloadMember_swiginit(self, _profiler.new_PayloadMember())
    __swig_destroy__ = _profiler.delete_PayloadMember

# Register PayloadMember in _profiler:
_profiler.PayloadMember_swigregister(PayloadMember)
class MemberValue(object):
    r"""Proxy of C++ mmind::eye::ProfilerEvent::PayloadMember::MemberValue class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uint_32value = property(_profiler.MemberValue_uint_32value_get, _profiler.MemberValue_uint_32value_set, doc=r"""uint_32value : uint32_t""")
    int_32value = property(_profiler.MemberValue_int_32value_get, _profiler.MemberValue_int_32value_set, doc=r"""int_32value : int32_t""")
    int_64value = property(_profiler.MemberValue_int_64value_get, _profiler.MemberValue_int_64value_set, doc=r"""int_64value : int64_t""")
    float_value = property(_profiler.MemberValue_float_value_get, _profiler.MemberValue_float_value_set, doc=r"""float_value : float""")
    double_value = property(_profiler.MemberValue_double_value_get, _profiler.MemberValue_double_value_set, doc=r"""double_value : double""")
    bool_value = property(_profiler.MemberValue_bool_value_get, _profiler.MemberValue_bool_value_set, doc=r"""bool_value : bool""")
    string_value = property(_profiler.MemberValue_string_value_get, _profiler.MemberValue_string_value_set, doc=r"""string_value : std::string""")

    def __init__(self):
        r"""__init__(MemberValue self) -> MemberValue"""
        _profiler.MemberValue_swiginit(self, _profiler.new_MemberValue())
    __swig_destroy__ = _profiler.delete_MemberValue

# Register MemberValue in _profiler:
_profiler.MemberValue_swigregister(MemberValue)
class Payload(object):
    r"""Proxy of C++ std::vector< mmind::eye::ProfilerEvent::PayloadMember > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(Payload self) -> SwigPyIterator"""
        return _profiler.Payload_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(Payload self) -> bool"""
        return _profiler.Payload___nonzero__(self)

    def __bool__(self):
        r"""__bool__(Payload self) -> bool"""
        return _profiler.Payload___bool__(self)

    def __len__(self):
        r"""__len__(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type"""
        return _profiler.Payload___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type j) -> Payload"""
        return _profiler.Payload___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type j)
        __setslice__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type j, Payload v)
        """
        return _profiler.Payload___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type j)"""
        return _profiler.Payload___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i)
        __delitem__(Payload self, SWIGPY_SLICEOBJECT * slice)
        """
        return _profiler.Payload___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(Payload self, SWIGPY_SLICEOBJECT * slice) -> Payload
        __getitem__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i) -> PayloadMember
        """
        return _profiler.Payload___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(Payload self, SWIGPY_SLICEOBJECT * slice, Payload v)
        __setitem__(Payload self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::difference_type i, PayloadMember x)
        """
        return _profiler.Payload___setitem__(self, *args)

    def pop(self):
        r"""pop(Payload self) -> PayloadMember"""
        return _profiler.Payload_pop(self)

    def append(self, x):
        r"""append(Payload self, PayloadMember x)"""
        return _profiler.Payload_append(self, x)

    def empty(self):
        r"""empty(Payload self) -> bool"""
        return _profiler.Payload_empty(self)

    def size(self):
        r"""size(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type"""
        return _profiler.Payload_size(self)

    def swap(self, v):
        r"""swap(Payload self, Payload v)"""
        return _profiler.Payload_swap(self, v)

    def begin(self):
        r"""begin(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator"""
        return _profiler.Payload_begin(self)

    def end(self):
        r"""end(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator"""
        return _profiler.Payload_end(self)

    def rbegin(self):
        r"""rbegin(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::reverse_iterator"""
        return _profiler.Payload_rbegin(self)

    def rend(self):
        r"""rend(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::reverse_iterator"""
        return _profiler.Payload_rend(self)

    def clear(self):
        r"""clear(Payload self)"""
        return _profiler.Payload_clear(self)

    def get_allocator(self):
        r"""get_allocator(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::allocator_type"""
        return _profiler.Payload_get_allocator(self)

    def pop_back(self):
        r"""pop_back(Payload self)"""
        return _profiler.Payload_pop_back(self)

    def erase(self, *args):
        r"""
        erase(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator pos) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator
        erase(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator first, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator last) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator
        """
        return _profiler.Payload_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(Payload self) -> Payload
        __init__(Payload self, Payload other) -> Payload
        __init__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type size) -> Payload
        __init__(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type size, PayloadMember value) -> Payload
        """
        _profiler.Payload_swiginit(self, _profiler.new_Payload(*args))

    def push_back(self, x):
        r"""push_back(Payload self, PayloadMember x)"""
        return _profiler.Payload_push_back(self, x)

    def front(self):
        r"""front(Payload self) -> PayloadMember"""
        return _profiler.Payload_front(self)

    def back(self):
        r"""back(Payload self) -> PayloadMember"""
        return _profiler.Payload_back(self)

    def assign(self, n, x):
        r"""assign(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type n, PayloadMember x)"""
        return _profiler.Payload_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type new_size)
        resize(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type new_size, PayloadMember x)
        """
        return _profiler.Payload_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator pos, PayloadMember x) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator
        insert(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::iterator pos, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type n, PayloadMember x)
        """
        return _profiler.Payload_insert(self, *args)

    def reserve(self, n):
        r"""reserve(Payload self, std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type n)"""
        return _profiler.Payload_reserve(self, n)

    def capacity(self):
        r"""capacity(Payload self) -> std::vector< mmind::eye::ProfilerEvent::PayloadMember >::size_type"""
        return _profiler.Payload_capacity(self)
    __swig_destroy__ = _profiler.delete_Payload

# Register Payload in _profiler:
_profiler.Payload_swigregister(Payload)
class EventInfos(object):
    r"""Proxy of C++ std::vector< mmind::eye::ProfilerEvent::EventInfo > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(EventInfos self) -> SwigPyIterator"""
        return _profiler.EventInfos_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(EventInfos self) -> bool"""
        return _profiler.EventInfos___nonzero__(self)

    def __bool__(self):
        r"""__bool__(EventInfos self) -> bool"""
        return _profiler.EventInfos___bool__(self)

    def __len__(self):
        r"""__len__(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type"""
        return _profiler.EventInfos___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type j) -> EventInfos"""
        return _profiler.EventInfos___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type j)
        __setslice__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type j, EventInfos v)
        """
        return _profiler.EventInfos___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type j)"""
        return _profiler.EventInfos___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i)
        __delitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice)
        """
        return _profiler.EventInfos___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice) -> EventInfos
        __getitem__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i) -> EventInfo
        """
        return _profiler.EventInfos___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice, EventInfos v)
        __setitem__(EventInfos self, SWIGPY_SLICEOBJECT * slice)
        __setitem__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::difference_type i, EventInfo x)
        """
        return _profiler.EventInfos___setitem__(self, *args)

    def pop(self):
        r"""pop(EventInfos self) -> EventInfo"""
        return _profiler.EventInfos_pop(self)

    def append(self, x):
        r"""append(EventInfos self, EventInfo x)"""
        return _profiler.EventInfos_append(self, x)

    def empty(self):
        r"""empty(EventInfos self) -> bool"""
        return _profiler.EventInfos_empty(self)

    def size(self):
        r"""size(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type"""
        return _profiler.EventInfos_size(self)

    def swap(self, v):
        r"""swap(EventInfos self, EventInfos v)"""
        return _profiler.EventInfos_swap(self, v)

    def begin(self):
        r"""begin(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator"""
        return _profiler.EventInfos_begin(self)

    def end(self):
        r"""end(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator"""
        return _profiler.EventInfos_end(self)

    def rbegin(self):
        r"""rbegin(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::reverse_iterator"""
        return _profiler.EventInfos_rbegin(self)

    def rend(self):
        r"""rend(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::reverse_iterator"""
        return _profiler.EventInfos_rend(self)

    def clear(self):
        r"""clear(EventInfos self)"""
        return _profiler.EventInfos_clear(self)

    def get_allocator(self):
        r"""get_allocator(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::allocator_type"""
        return _profiler.EventInfos_get_allocator(self)

    def pop_back(self):
        r"""pop_back(EventInfos self)"""
        return _profiler.EventInfos_pop_back(self)

    def erase(self, *args):
        r"""
        erase(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator pos) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator
        erase(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator first, std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator last) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator
        """
        return _profiler.EventInfos_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(EventInfos self) -> EventInfos
        __init__(EventInfos self, EventInfos other) -> EventInfos
        __init__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type size) -> EventInfos
        __init__(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type size, EventInfo value) -> EventInfos
        """
        _profiler.EventInfos_swiginit(self, _profiler.new_EventInfos(*args))

    def push_back(self, x):
        r"""push_back(EventInfos self, EventInfo x)"""
        return _profiler.EventInfos_push_back(self, x)

    def front(self):
        r"""front(EventInfos self) -> EventInfo"""
        return _profiler.EventInfos_front(self)

    def back(self):
        r"""back(EventInfos self) -> EventInfo"""
        return _profiler.EventInfos_back(self)

    def assign(self, n, x):
        r"""assign(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type n, EventInfo x)"""
        return _profiler.EventInfos_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type new_size)
        resize(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type new_size, EventInfo x)
        """
        return _profiler.EventInfos_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator pos, EventInfo x) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator
        insert(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::iterator pos, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type n, EventInfo x)
        """
        return _profiler.EventInfos_insert(self, *args)

    def reserve(self, n):
        r"""reserve(EventInfos self, std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type n)"""
        return _profiler.EventInfos_reserve(self, n)

    def capacity(self):
        r"""capacity(EventInfos self) -> std::vector< mmind::eye::ProfilerEvent::EventInfo >::size_type"""
        return _profiler.EventInfos_capacity(self)
    __swig_destroy__ = _profiler.delete_EventInfos

# Register EventInfos in _profiler:
_profiler.EventInfos_swigregister(EventInfos)
class ExposureMode(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::ExposureMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ExposureMode_name
    
    description = _profiler.ExposureMode_description
    
    type = _profiler.ExposureMode_type
    
    Value_HDR = _profiler.ExposureMode_Value_HDR
    
    Value_Timed = _profiler.ExposureMode_Value_Timed
    

    def __init__(self):
        r"""__init__(ExposureMode self) -> ExposureMode"""
        _profiler.ExposureMode_swiginit(self, _profiler.new_ExposureMode())
    __swig_destroy__ = _profiler.delete_ExposureMode

# Register ExposureMode in _profiler:
_profiler.ExposureMode_swigregister(ExposureMode)
class ExposureTime(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::ExposureTime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ExposureTime_name
    
    description = _profiler.ExposureTime_description
    
    type = _profiler.ExposureTime_type
    
    unit = _profiler.ExposureTime_unit
    

    def __init__(self):
        r"""__init__(ExposureTime self) -> ExposureTime"""
        _profiler.ExposureTime_swiginit(self, _profiler.new_ExposureTime())
    __swig_destroy__ = _profiler.delete_ExposureTime

# Register ExposureTime in _profiler:
_profiler.ExposureTime_swigregister(ExposureTime)
class HdrExposureTimeProportion1(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::HdrExposureTimeProportion1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.HdrExposureTimeProportion1_name
    
    description = _profiler.HdrExposureTimeProportion1_description
    
    type = _profiler.HdrExposureTimeProportion1_type
    
    unit = _profiler.HdrExposureTimeProportion1_unit
    

    def __init__(self):
        r"""__init__(HdrExposureTimeProportion1 self) -> HdrExposureTimeProportion1"""
        _profiler.HdrExposureTimeProportion1_swiginit(self, _profiler.new_HdrExposureTimeProportion1())
    __swig_destroy__ = _profiler.delete_HdrExposureTimeProportion1

# Register HdrExposureTimeProportion1 in _profiler:
_profiler.HdrExposureTimeProportion1_swigregister(HdrExposureTimeProportion1)
class HdrExposureTimeProportion2(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::HdrExposureTimeProportion2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.HdrExposureTimeProportion2_name
    
    description = _profiler.HdrExposureTimeProportion2_description
    
    type = _profiler.HdrExposureTimeProportion2_type
    
    unit = _profiler.HdrExposureTimeProportion2_unit
    

    def __init__(self):
        r"""__init__(HdrExposureTimeProportion2 self) -> HdrExposureTimeProportion2"""
        _profiler.HdrExposureTimeProportion2_swiginit(self, _profiler.new_HdrExposureTimeProportion2())
    __swig_destroy__ = _profiler.delete_HdrExposureTimeProportion2

# Register HdrExposureTimeProportion2 in _profiler:
_profiler.HdrExposureTimeProportion2_swigregister(HdrExposureTimeProportion2)
class HdrFirstThreshold(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::HdrFirstThreshold class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.HdrFirstThreshold_name
    
    description = _profiler.HdrFirstThreshold_description
    
    type = _profiler.HdrFirstThreshold_type
    
    unit = _profiler.HdrFirstThreshold_unit
    

    def __init__(self):
        r"""__init__(HdrFirstThreshold self) -> HdrFirstThreshold"""
        _profiler.HdrFirstThreshold_swiginit(self, _profiler.new_HdrFirstThreshold())
    __swig_destroy__ = _profiler.delete_HdrFirstThreshold

# Register HdrFirstThreshold in _profiler:
_profiler.HdrFirstThreshold_swigregister(HdrFirstThreshold)
class HdrSecondThreshold(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::HdrSecondThreshold class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.HdrSecondThreshold_name
    
    description = _profiler.HdrSecondThreshold_description
    
    type = _profiler.HdrSecondThreshold_type
    
    unit = _profiler.HdrSecondThreshold_unit
    

    def __init__(self):
        r"""__init__(HdrSecondThreshold self) -> HdrSecondThreshold"""
        _profiler.HdrSecondThreshold_swiginit(self, _profiler.new_HdrSecondThreshold())
    __swig_destroy__ = _profiler.delete_HdrSecondThreshold

# Register HdrSecondThreshold in _profiler:
_profiler.HdrSecondThreshold_swigregister(HdrSecondThreshold)
class AnalogGain(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::AnalogGain class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.AnalogGain_name
    
    description = _profiler.AnalogGain_description
    
    type = _profiler.AnalogGain_type
    
    Value_Gain_1 = _profiler.AnalogGain_Value_Gain_1
    
    Value_Gain_2 = _profiler.AnalogGain_Value_Gain_2
    
    Value_Gain_3 = _profiler.AnalogGain_Value_Gain_3
    
    Value_Gain_4 = _profiler.AnalogGain_Value_Gain_4
    
    Value_Gain_5 = _profiler.AnalogGain_Value_Gain_5
    r""" LNX-8300, LNX-8080, LNX-75300, and LNX-7580 only."""

    def __init__(self):
        r"""__init__(AnalogGain self) -> AnalogGain"""
        _profiler.AnalogGain_swiginit(self, _profiler.new_AnalogGain())
    __swig_destroy__ = _profiler.delete_AnalogGain

# Register AnalogGain in _profiler:
_profiler.AnalogGain_swigregister(AnalogGain)
class AnalogGainFor8030(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::AnalogGainFor8030 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.AnalogGainFor8030_name
    
    description = _profiler.AnalogGainFor8030_description
    
    type = _profiler.AnalogGainFor8030_type
    
    Value_Gain_1_0 = _profiler.AnalogGainFor8030_Value_Gain_1_0
    
    Value_Gain_1_3 = _profiler.AnalogGainFor8030_Value_Gain_1_3
    
    Value_Gain_2_0 = _profiler.AnalogGainFor8030_Value_Gain_2_0
    
    Value_Gain_3_0 = _profiler.AnalogGainFor8030_Value_Gain_3_0
    

    def __init__(self):
        r"""__init__(AnalogGainFor8030 self) -> AnalogGainFor8030"""
        _profiler.AnalogGainFor8030_swiginit(self, _profiler.new_AnalogGainFor8030())
    __swig_destroy__ = _profiler.delete_AnalogGainFor8030

# Register AnalogGainFor8030 in _profiler:
_profiler.AnalogGainFor8030_swigregister(AnalogGainFor8030)
class DigitalGain(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::DigitalGain class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.DigitalGain_name
    
    description = _profiler.DigitalGain_description
    
    type = _profiler.DigitalGain_type
    

    def __init__(self):
        r"""__init__(DigitalGain self) -> DigitalGain"""
        _profiler.DigitalGain_swiginit(self, _profiler.new_DigitalGain())
    __swig_destroy__ = _profiler.delete_DigitalGain

# Register DigitalGain in _profiler:
_profiler.DigitalGain_swigregister(DigitalGain)
class LaserPower(object):
    r"""Proxy of C++ mmind::eye::brightness_settings::LaserPower class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.LaserPower_name
    
    description = _profiler.LaserPower_description
    
    type = _profiler.LaserPower_type
    

    def __init__(self):
        r"""__init__(LaserPower self) -> LaserPower"""
        _profiler.LaserPower_swiginit(self, _profiler.new_LaserPower())
    __swig_destroy__ = _profiler.delete_LaserPower

# Register LaserPower in _profiler:
_profiler.LaserPower_swigregister(LaserPower)
class ZDirectionRoi(object):
    r"""Proxy of C++ mmind::eye::roi::ZDirectionRoi class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ZDirectionRoi_name
    
    description = _profiler.ZDirectionRoi_description
    
    type = _profiler.ZDirectionRoi_type
    
    Value_ImageHeight_1_1 = _profiler.ZDirectionRoi_Value_ImageHeight_1_1
    
    Value_ImageHeight_1_2 = _profiler.ZDirectionRoi_Value_ImageHeight_1_2
    
    Value_ImageHeight_1_4 = _profiler.ZDirectionRoi_Value_ImageHeight_1_4
    
    Value_ImageHeight_1_8 = _profiler.ZDirectionRoi_Value_ImageHeight_1_8
    
    Value_ImageHeight_1_16 = _profiler.ZDirectionRoi_Value_ImageHeight_1_16
    

    def __init__(self):
        r"""__init__(ZDirectionRoi self) -> ZDirectionRoi"""
        _profiler.ZDirectionRoi_swiginit(self, _profiler.new_ZDirectionRoi())
    __swig_destroy__ = _profiler.delete_ZDirectionRoi

# Register ZDirectionRoi in _profiler:
_profiler.ZDirectionRoi_swigregister(ZDirectionRoi)
class ROI(object):
    r"""Proxy of C++ mmind::eye::roi::ROI class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ROI_name
    
    description = _profiler.ROI_description
    
    type = _profiler.ROI_type
    

    def __init__(self):
        r"""__init__(ROI self) -> ROI"""
        _profiler.ROI_swiginit(self, _profiler.new_ROI())
    __swig_destroy__ = _profiler.delete_ROI

# Register ROI in _profiler:
_profiler.ROI_swigregister(ROI)
class DataAcquisitionMethod(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::DataAcquisitionMethod class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.DataAcquisitionMethod_name
    
    description = _profiler.DataAcquisitionMethod_description
    
    type = _profiler.DataAcquisitionMethod_type
    
    Value_Frame_Based = _profiler.DataAcquisitionMethod_Value_Frame_Based
    
    Value_Nonstop = _profiler.DataAcquisitionMethod_Value_Nonstop
    

    def __init__(self):
        r"""__init__(DataAcquisitionMethod self) -> DataAcquisitionMethod"""
        _profiler.DataAcquisitionMethod_swiginit(self, _profiler.new_DataAcquisitionMethod())
    __swig_destroy__ = _profiler.delete_DataAcquisitionMethod

# Register DataAcquisitionMethod in _profiler:
_profiler.DataAcquisitionMethod_swigregister(DataAcquisitionMethod)
class DataAcquisitionTriggerSource(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::DataAcquisitionTriggerSource class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.DataAcquisitionTriggerSource_name
    
    description = _profiler.DataAcquisitionTriggerSource_description
    
    type = _profiler.DataAcquisitionTriggerSource_type
    
    Value_Software = _profiler.DataAcquisitionTriggerSource_Value_Software
    
    Value_External = _profiler.DataAcquisitionTriggerSource_Value_External
    

    def __init__(self):
        r"""__init__(DataAcquisitionTriggerSource self) -> DataAcquisitionTriggerSource"""
        _profiler.DataAcquisitionTriggerSource_swiginit(self, _profiler.new_DataAcquisitionTriggerSource())
    __swig_destroy__ = _profiler.delete_DataAcquisitionTriggerSource

# Register DataAcquisitionTriggerSource in _profiler:
_profiler.DataAcquisitionTriggerSource_swigregister(DataAcquisitionTriggerSource)
class LineScanTriggerSource(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::LineScanTriggerSource class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.LineScanTriggerSource_name
    
    description = _profiler.LineScanTriggerSource_description
    
    type = _profiler.LineScanTriggerSource_type
    
    Value_FixedRate = _profiler.LineScanTriggerSource_Value_FixedRate
    
    Value_Encoder = _profiler.LineScanTriggerSource_Value_Encoder
    

    def __init__(self):
        r"""__init__(LineScanTriggerSource self) -> LineScanTriggerSource"""
        _profiler.LineScanTriggerSource_swiginit(self, _profiler.new_LineScanTriggerSource())
    __swig_destroy__ = _profiler.delete_LineScanTriggerSource

# Register LineScanTriggerSource in _profiler:
_profiler.LineScanTriggerSource_swigregister(LineScanTriggerSource)
class SoftwareTriggerRate(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::SoftwareTriggerRate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.SoftwareTriggerRate_name
    
    description = _profiler.SoftwareTriggerRate_description
    
    type = _profiler.SoftwareTriggerRate_type
    
    unit = _profiler.SoftwareTriggerRate_unit
    

    def __init__(self):
        r"""__init__(SoftwareTriggerRate self) -> SoftwareTriggerRate"""
        _profiler.SoftwareTriggerRate_swiginit(self, _profiler.new_SoftwareTriggerRate())
    __swig_destroy__ = _profiler.delete_SoftwareTriggerRate

# Register SoftwareTriggerRate in _profiler:
_profiler.SoftwareTriggerRate_swigregister(SoftwareTriggerRate)
class MaxScanRate(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::MaxScanRate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.MaxScanRate_name
    
    description = _profiler.MaxScanRate_description
    
    type = _profiler.MaxScanRate_type
    
    unit = _profiler.MaxScanRate_unit
    

    def __init__(self):
        r"""__init__(MaxScanRate self) -> MaxScanRate"""
        _profiler.MaxScanRate_swiginit(self, _profiler.new_MaxScanRate())
    __swig_destroy__ = _profiler.delete_MaxScanRate

# Register MaxScanRate in _profiler:
_profiler.MaxScanRate_swigregister(MaxScanRate)
class TriggerDelay(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::TriggerDelay class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.TriggerDelay_name
    
    description = _profiler.TriggerDelay_description
    
    type = _profiler.TriggerDelay_type
    
    unit = _profiler.TriggerDelay_unit
    

    def __init__(self):
        r"""__init__(TriggerDelay self) -> TriggerDelay"""
        _profiler.TriggerDelay_swiginit(self, _profiler.new_TriggerDelay())
    __swig_destroy__ = _profiler.delete_TriggerDelay

# Register TriggerDelay in _profiler:
_profiler.TriggerDelay_swigregister(TriggerDelay)
class EncoderTriggerDirection(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::EncoderTriggerDirection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EncoderTriggerDirection_name
    
    description = _profiler.EncoderTriggerDirection_description
    
    type = _profiler.EncoderTriggerDirection_type
    
    Value_ChannelALeading = _profiler.EncoderTriggerDirection_Value_ChannelALeading
    
    Value_ChannelBLeading = _profiler.EncoderTriggerDirection_Value_ChannelBLeading
    
    Value_Both = _profiler.EncoderTriggerDirection_Value_Both
    

    def __init__(self):
        r"""__init__(EncoderTriggerDirection self) -> EncoderTriggerDirection"""
        _profiler.EncoderTriggerDirection_swiginit(self, _profiler.new_EncoderTriggerDirection())
    __swig_destroy__ = _profiler.delete_EncoderTriggerDirection

# Register EncoderTriggerDirection in _profiler:
_profiler.EncoderTriggerDirection_swigregister(EncoderTriggerDirection)
class EncoderTriggerSignalCountingMode(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::EncoderTriggerSignalCountingMode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EncoderTriggerSignalCountingMode_name
    
    description = _profiler.EncoderTriggerSignalCountingMode_description
    
    type = _profiler.EncoderTriggerSignalCountingMode_type
    
    Value_Multiple_1 = _profiler.EncoderTriggerSignalCountingMode_Value_Multiple_1
    
    Value_Multiple_2 = _profiler.EncoderTriggerSignalCountingMode_Value_Multiple_2
    
    Value_Multiple_4 = _profiler.EncoderTriggerSignalCountingMode_Value_Multiple_4
    

    def __init__(self):
        r"""__init__(EncoderTriggerSignalCountingMode self) -> EncoderTriggerSignalCountingMode"""
        _profiler.EncoderTriggerSignalCountingMode_swiginit(self, _profiler.new_EncoderTriggerSignalCountingMode())
    __swig_destroy__ = _profiler.delete_EncoderTriggerSignalCountingMode

# Register EncoderTriggerSignalCountingMode in _profiler:
_profiler.EncoderTriggerSignalCountingMode_swigregister(EncoderTriggerSignalCountingMode)
class EncoderTriggerInterval(object):
    r"""Proxy of C++ mmind::eye::trigger_settings::EncoderTriggerInterval class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EncoderTriggerInterval_name
    
    description = _profiler.EncoderTriggerInterval_description
    
    type = _profiler.EncoderTriggerInterval_type
    

    def __init__(self):
        r"""__init__(EncoderTriggerInterval self) -> EncoderTriggerInterval"""
        _profiler.EncoderTriggerInterval_swiginit(self, _profiler.new_EncoderTriggerInterval())
    __swig_destroy__ = _profiler.delete_EncoderTriggerInterval

# Register EncoderTriggerInterval in _profiler:
_profiler.EncoderTriggerInterval_swigregister(EncoderTriggerInterval)
class ScanLineCount(object):
    r"""Proxy of C++ mmind::eye::scan_settings::ScanLineCount class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ScanLineCount_name
    
    description = _profiler.ScanLineCount_description
    
    type = _profiler.ScanLineCount_type
    

    def __init__(self):
        r"""__init__(ScanLineCount self) -> ScanLineCount"""
        _profiler.ScanLineCount_swiginit(self, _profiler.new_ScanLineCount())
    __swig_destroy__ = _profiler.delete_ScanLineCount

# Register ScanLineCount in _profiler:
_profiler.ScanLineCount_swigregister(ScanLineCount)
class DataPointsPerProfile(object):
    r"""Proxy of C++ mmind::eye::scan_settings::DataPointsPerProfile class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.DataPointsPerProfile_name
    
    description = _profiler.DataPointsPerProfile_description
    
    type = _profiler.DataPointsPerProfile_type
    
    unit = _profiler.DataPointsPerProfile_unit
    

    def __init__(self):
        r"""__init__(DataPointsPerProfile self) -> DataPointsPerProfile"""
        _profiler.DataPointsPerProfile_swiginit(self, _profiler.new_DataPointsPerProfile())
    __swig_destroy__ = _profiler.delete_DataPointsPerProfile

# Register DataPointsPerProfile in _profiler:
_profiler.DataPointsPerProfile_swigregister(DataPointsPerProfile)
class ExposureDelay(object):
    r"""Proxy of C++ mmind::eye::scan_settings::ExposureDelay class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.ExposureDelay_name
    
    description = _profiler.ExposureDelay_description
    
    type = _profiler.ExposureDelay_type
    
    unit = _profiler.ExposureDelay_unit
    

    def __init__(self):
        r"""__init__(ExposureDelay self) -> ExposureDelay"""
        _profiler.ExposureDelay_swiginit(self, _profiler.new_ExposureDelay())
    __swig_destroy__ = _profiler.delete_ExposureDelay

# Register ExposureDelay in _profiler:
_profiler.ExposureDelay_swigregister(ExposureDelay)
class BatchRetrievalTimeout(object):
    r"""Proxy of C++ mmind::eye::scan_settings::BatchRetrievalTimeout class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.BatchRetrievalTimeout_name
    
    description = _profiler.BatchRetrievalTimeout_description
    
    type = _profiler.BatchRetrievalTimeout_type
    
    unit = _profiler.BatchRetrievalTimeout_unit
    

    def __init__(self):
        r"""__init__(BatchRetrievalTimeout self) -> BatchRetrievalTimeout"""
        _profiler.BatchRetrievalTimeout_swiginit(self, _profiler.new_BatchRetrievalTimeout())
    __swig_destroy__ = _profiler.delete_BatchRetrievalTimeout

# Register BatchRetrievalTimeout in _profiler:
_profiler.BatchRetrievalTimeout_swigregister(BatchRetrievalTimeout)
class CallbackRetrievalTimeout(object):
    r"""Proxy of C++ mmind::eye::scan_settings::CallbackRetrievalTimeout class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.CallbackRetrievalTimeout_name
    
    description = _profiler.CallbackRetrievalTimeout_description
    
    type = _profiler.CallbackRetrievalTimeout_type
    
    unit = _profiler.CallbackRetrievalTimeout_unit
    

    def __init__(self):
        r"""__init__(CallbackRetrievalTimeout self) -> CallbackRetrievalTimeout"""
        _profiler.CallbackRetrievalTimeout_swiginit(self, _profiler.new_CallbackRetrievalTimeout())
    __swig_destroy__ = _profiler.delete_CallbackRetrievalTimeout

# Register CallbackRetrievalTimeout in _profiler:
_profiler.CallbackRetrievalTimeout_swigregister(CallbackRetrievalTimeout)
class XAxisResolution(object):
    r"""Proxy of C++ mmind::eye::point_cloud_resolutions::XAxisResolution class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.XAxisResolution_name
    
    description = _profiler.XAxisResolution_description
    
    type = _profiler.XAxisResolution_type
    
    unit = _profiler.XAxisResolution_unit
    

    def __init__(self):
        r"""__init__(XAxisResolution self) -> XAxisResolution"""
        _profiler.XAxisResolution_swiginit(self, _profiler.new_XAxisResolution())
    __swig_destroy__ = _profiler.delete_XAxisResolution

# Register XAxisResolution in _profiler:
_profiler.XAxisResolution_swigregister(XAxisResolution)
class YResolution(object):
    r"""Proxy of C++ mmind::eye::point_cloud_resolutions::YResolution class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.YResolution_name
    
    description = _profiler.YResolution_description
    
    type = _profiler.YResolution_type
    
    unit = _profiler.YResolution_unit
    

    def __init__(self):
        r"""__init__(YResolution self) -> YResolution"""
        _profiler.YResolution_swiginit(self, _profiler.new_YResolution())
    __swig_destroy__ = _profiler.delete_YResolution

# Register YResolution in _profiler:
_profiler.YResolution_swigregister(YResolution)
class EnableTiltCorrection(object):
    r"""Proxy of C++ mmind::eye::correction::EnableTiltCorrection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableTiltCorrection_name
    
    description = _profiler.EnableTiltCorrection_description
    
    type = _profiler.EnableTiltCorrection_type
    

    def __init__(self):
        r"""__init__(EnableTiltCorrection self) -> EnableTiltCorrection"""
        _profiler.EnableTiltCorrection_swiginit(self, _profiler.new_EnableTiltCorrection())
    __swig_destroy__ = _profiler.delete_EnableTiltCorrection

# Register EnableTiltCorrection in _profiler:
_profiler.EnableTiltCorrection_swigregister(EnableTiltCorrection)
class EnableHeightCorrection(object):
    r"""Proxy of C++ mmind::eye::correction::EnableHeightCorrection class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.EnableHeightCorrection_name
    
    description = _profiler.EnableHeightCorrection_description
    
    type = _profiler.EnableHeightCorrection_type
    

    def __init__(self):
        r"""__init__(EnableHeightCorrection self) -> EnableHeightCorrection"""
        _profiler.EnableHeightCorrection_swiginit(self, _profiler.new_EnableHeightCorrection())
    __swig_destroy__ = _profiler.delete_EnableHeightCorrection

# Register EnableHeightCorrection in _profiler:
_profiler.EnableHeightCorrection_swigregister(EnableHeightCorrection)
class TiltCorrectionAngle(object):
    r"""Proxy of C++ mmind::eye::correction::TiltCorrectionAngle class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.TiltCorrectionAngle_name
    
    description = _profiler.TiltCorrectionAngle_description
    
    type = _profiler.TiltCorrectionAngle_type
    
    unit = _profiler.TiltCorrectionAngle_unit
    

    def __init__(self):
        r"""__init__(TiltCorrectionAngle self) -> TiltCorrectionAngle"""
        _profiler.TiltCorrectionAngle_swiginit(self, _profiler.new_TiltCorrectionAngle())
    __swig_destroy__ = _profiler.delete_TiltCorrectionAngle

# Register TiltCorrectionAngle in _profiler:
_profiler.TiltCorrectionAngle_swigregister(TiltCorrectionAngle)
class HeightCorrectionRatio(object):
    r"""Proxy of C++ mmind::eye::correction::HeightCorrectionRatio class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.HeightCorrectionRatio_name
    
    description = _profiler.HeightCorrectionRatio_description
    
    type = _profiler.HeightCorrectionRatio_type
    

    def __init__(self):
        r"""__init__(HeightCorrectionRatio self) -> HeightCorrectionRatio"""
        _profiler.HeightCorrectionRatio_swiginit(self, _profiler.new_HeightCorrectionRatio())
    __swig_destroy__ = _profiler.delete_HeightCorrectionRatio

# Register HeightCorrectionRatio in _profiler:
_profiler.HeightCorrectionRatio_swigregister(HeightCorrectionRatio)
class CoordinateTransformation(object):
    r"""Proxy of C++ mmind::eye::transformation::CoordinateTransformation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = _profiler.CoordinateTransformation_name
    
    description = _profiler.CoordinateTransformation_description
    
    type = _profiler.CoordinateTransformation_type
    

    def __init__(self):
        r"""__init__(CoordinateTransformation self) -> CoordinateTransformation"""
        _profiler.CoordinateTransformation_swiginit(self, _profiler.new_CoordinateTransformation())
    __swig_destroy__ = _profiler.delete_CoordinateTransformation

# Register CoordinateTransformation in _profiler:
_profiler.CoordinateTransformation_swigregister(CoordinateTransformation)
class FrameTransformation(object):
    r"""Proxy of C++ WrappedFrameTransformation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rotation = property(_profiler.FrameTransformation_rotation_get, _profiler.FrameTransformation_rotation_set, doc=r"""rotation : wrapped_matrix<(double,3)>""")
    translation = property(_profiler.FrameTransformation_translation_get, _profiler.FrameTransformation_translation_set, doc=r"""translation : wrapped_array<(double,3)>""")

    def __rotate__(self, theta, axis):
        r"""__rotate__(FrameTransformation self, double theta, int axis)"""
        return _profiler.FrameTransformation___rotate__(self, theta, axis)

    def __translate__(self, translateX, translateY, translateZ):
        r"""__translate__(FrameTransformation self, double translateX, double translateY, double translateZ)"""
        return _profiler.FrameTransformation___translate__(self, translateX, translateY, translateZ)

    def __is__valid__(self):
        r"""__is__valid__(FrameTransformation self) -> bool"""
        return _profiler.FrameTransformation___is__valid__(self)

    def __init__(self):
        r"""__init__(FrameTransformation self) -> FrameTransformation"""
        _profiler.FrameTransformation_swiginit(self, _profiler.new_FrameTransformation())
    __swig_destroy__ = _profiler.delete_FrameTransformation

# Register FrameTransformation in _profiler:
_profiler.FrameTransformation_swigregister(FrameTransformation)

def wrapped_to_frame_transformation(frameTransformation, wrappedFrameTransformation):
    r"""wrapped_to_frame_transformation(mmind::eye::FrameTransformation & frameTransformation, FrameTransformation wrappedFrameTransformation)"""
    return _profiler.wrapped_to_frame_transformation(frameTransformation, wrappedFrameTransformation)

def frame_transformation_towrapped(frameTransformation, wrappedFrameTransformation):
    r"""frame_transformation_towrapped(mmind::eye::FrameTransformation const & frameTransformation, FrameTransformation wrappedFrameTransformation)"""
    return _profiler.frame_transformation_towrapped(frameTransformation, wrappedFrameTransformation)
class doubleArray3(object):
    r"""Proxy of C++ wrapped_array< double,3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_profiler.doubleArray3_data_get, _profiler.doubleArray3_data_set, doc=r"""data : a(3).double""")

    def __len__(self):
        r"""__len__(doubleArray3 self) -> size_t"""
        return _profiler.doubleArray3___len__(self)

    def __getitem__(self, i):
        r"""__getitem__(doubleArray3 self, size_t i) -> double const &"""
        return _profiler.doubleArray3___getitem__(self, i)

    def __setitem__(self, i, v):
        r"""__setitem__(doubleArray3 self, size_t i, double const & v)"""
        return _profiler.doubleArray3___setitem__(self, i, v)

    def __init__(self):
        r"""__init__(doubleArray3 self) -> doubleArray3"""
        _profiler.doubleArray3_swiginit(self, _profiler.new_doubleArray3())
    __swig_destroy__ = _profiler.delete_doubleArray3

# Register doubleArray3 in _profiler:
_profiler.doubleArray3_swigregister(doubleArray3)
class doubleMatrix3(object):
    r"""Proxy of C++ wrapped_matrix< double,3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_profiler.doubleMatrix3_data_get, _profiler.doubleMatrix3_data_set, doc=r"""data : a(3).a(3).double""")

    def __len__(self):
        r"""__len__(doubleMatrix3 self) -> size_t"""
        return _profiler.doubleMatrix3___len__(self)

    def __getitem__(self, i):
        r"""__getitem__(doubleMatrix3 self, size_t i) -> doubleArray3"""
        return _profiler.doubleMatrix3___getitem__(self, i)

    def __setitem__(self, i, v):
        r"""__setitem__(doubleMatrix3 self, size_t i, doubleArray3 v)"""
        return _profiler.doubleMatrix3___setitem__(self, i, v)

    def __init__(self):
        r"""__init__(doubleMatrix3 self) -> doubleMatrix3"""
        _profiler.doubleMatrix3_swiginit(self, _profiler.new_doubleMatrix3())
    __swig_destroy__ = _profiler.delete_doubleMatrix3

# Register doubleMatrix3 in _profiler:
_profiler.doubleMatrix3_swigregister(doubleMatrix3)

def get_transformation_params(profiler):
    r"""get_transformation_params(Profiler profiler) -> FrameTransformation"""
    return _profiler.get_transformation_params(profiler)

def transform_point_cloud(coordinateTransformation, originalPointCloud):
    r"""transform_point_cloud(FrameTransformation coordinateTransformation, UntexturedPointCloud originalPointCloud) -> UntexturedPointCloud"""
    return _profiler.transform_point_cloud(coordinateTransformation, originalPointCloud)

def transform_textured_point_cloud(coordinateTransformation, originalTexturedPointCloud):
    r"""transform_textured_point_cloud(FrameTransformation coordinateTransformation, TexturedPointCloud originalTexturedPointCloud) -> TexturedPointCloud"""
    return _profiler.transform_textured_point_cloud(coordinateTransformation, originalTexturedPointCloud)

