import asyncio
import typing

from flyte._logging import logger
from flyte.remote._client.auth._authenticators.base import Authenticator
from flyte.remote._client.auth._keyring import Credentials
from flyte.remote._client.auth.errors import AuthenticationError


class AsyncCommandAuthenticator(Authenticator):
    """
    This Authenticator retrieves access_token using the provided command
    """

    def __init__(self, command: typing.Optional[typing.List[str]], **kwargs):
        """
        Initialize the command authenticator.

        :param command: List of command strings to execute for token retrieval
        :param kwargs: Additional keyword arguments passed to the base Authenticator

        **Keyword Arguments passed to base Authenticator**:
        :param endpoint: The endpoint URL for authentication
        :param cfg_store: Optional client configuration store for retrieving remote configuration
        :param client_config: Optional client configuration containing authentication settings
        :param credentials: Optional credentials to use for authentication
        :param http_session: Optional HTTP session to use for requests
        :param http_proxy_url: Optional HTTP proxy URL
        :param verify: Whether to verify SSL certificates (default: True)
        :param ca_cert_path: Optional path to CA certificate file

        **Additional Keyword Arguments**:
        :param header_key: Header key to use for authentication (defaults to "authorization")
        :param proxy_env: Environment variables for the command execution
        :param proxy_timeout: Timeout for command execution
        """
        self._cmd = command
        if not self._cmd:
            raise AuthenticationError("Command cannot be empty for command authenticator")
        super().__init__(**kwargs)

    async def _do_refresh_credentials(self) -> Credentials:
        """
        Refreshes the authentication credentials by executing an external command.

        This function is used when the configuration value for AUTH_MODE is set to 'external_process'.
        It reads an id token generated by an external process started by running the 'command'.
        Uses asyncio.create_subprocess_exec for non-blocking operation.

        The command is executed with stdout and stderr captured, and the stdout output is used
        as the access token for authentication.

        :raises AuthenticationError: If the command fails to execute or returns a non-zero exit code
        """
        cmd_joined = " ".join(typing.cast(str, self._cmd))
        logger.debug("Starting external process to generate id token. Command `{}`".format(" ".join(cmd_joined)))
        try:
            # Use asyncio subprocess for non-blocking operation
            process = await asyncio.create_subprocess_exec(
                *typing.cast(typing.List[str], self._cmd),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                logger.error(f"Failed to generate token from command `{cmd_joined}`. Error: {stderr.decode()}")
                raise AuthenticationError(
                    f"Failed to refresh token with command `{cmd_joined}`."
                    f" Please execute this command in your terminal to debug."
                )

            return Credentials(for_endpoint=self._endpoint, access_token=stdout.decode().strip())
        except Exception as e:
            logger.error(f"Failed to generate token from command `{cmd_joined}`. Error: {e!s}")
            raise AuthenticationError(
                f"Failed to refresh token with command `{cmd_joined}`."
                f" Please execute this command in your terminal to debug."
            )
