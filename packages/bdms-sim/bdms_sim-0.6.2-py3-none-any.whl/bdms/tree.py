r"""Core tree simulation classes."""

from __future__ import annotations
import ete3
from ete3.coretype.tree import TreeError as ete_TreeError
from bdms import mutators, poisson, utils
import numpy as np
from typing import Any, Literal, Hashable, Callable
from collections.abc import Mapping, Iterator, Generator
import itertools
from collections import defaultdict
import copy
import math


class TreeError(ete_TreeError):
    r"""Exception raised for tree-related errors.

    Args:
        value: Explanation of the error.
    """

    pass


class TreeNode(ete3.Tree):
    r"""A tree generated by a BDMS process. Subclasses :py:class:`ete3.TreeNode`.

    Args:
        t: Time of this node.
        state: State of this node.
        state_attr: Name of the node attribute to store the state in.
        kwargs: Keyword arguments passed to :py:class:`ete3.TreeNode` initializer.
    """

    _BIRTH_EVENT = "birth"
    _DEATH_EVENT = "death"
    _MUTATION_EVENT = "mutation"
    _SURVIVAL_EVENT = "survival"
    _SAMPLING_EVENT = "sampling"

    _OFFSPRING_NUMBER = 2

    _name_generator: Iterator[int] = itertools.count()

    _mutation_face = ete3.AttrFace(
        "n_mutations",
        fsize=6,
        ftype="Arial",
        fgcolor="black",
    )

    def __init__(
        self,
        t: float = 0,
        state: Hashable = None,
        state_attr: str = "state",
        **kwargs: Any,
    ) -> None:
        if "dist" not in kwargs:
            kwargs["dist"] = 0
        if "name" not in kwargs:
            TreeNode._name_generator = itertools.count()
            self.name: int = next(self._name_generator)
            kwargs["name"] = self.name
        super().__init__(**kwargs)
        self.t: float = t
        """Time of the node."""
        self.state_attr: str = state_attr
        """Name of the node attribute to store the state in."""
        setattr(self, state_attr, state)
        self.event: str | None = None
        """Event at this node."""
        self.n_mutations: int = 0
        """Number of mutations on the branch above this node (zero unless the tree has
        been pruned above this node, removing mutation event nodes)."""
        self._sampled: bool = False
        """Whether sampling has been run on this tree.

        (Not whether the node has been sampled as part of this sampling process).
        """
        self._pruned: bool = False
        """Whether pruning has been run on this tree."""
        self._mutations_removed: bool = False
        """Whether unifurcating mutation event nodes have been removed from this
        tree."""

    def _birth_outcome(
        self,
        mutation_event_fn: Callable[[Any, np.random.Generator], float],
        mutator: mutators.Mutator,
        rng: np.random.Generator,
    ) -> Generator[TreeNode, None, None]:
        r"""Generate the outcome of a birth event at this node.

        Args:
            mutation_event_fn: Mutation event sampler for each daughter node. Takes a
                               node and rng as an argument and returns ``True`` or
                               ``False``.
            mutator: Generator of mutation effects.
            rng: Random number generator.

        Yields:
            The child nodes, or mutated grandchild nodes.
        """
        assert self.event == self._BIRTH_EVENT
        for _ in range(self._OFFSPRING_NUMBER):
            child = TreeNode(
                t=self.t,
                dist=0,
                name=next(self._name_generator),
            )
            setattr(child, mutator.attr, copy.copy(getattr(self, mutator.attr)))
            if mutation_event_fn(child, rng):
                child.event = self._MUTATION_EVENT
                mutator.mutate(child, seed=rng)
                grandchild = TreeNode(
                    t=child.t,
                    dist=0,
                    name=next(self._name_generator),
                )
                setattr(
                    grandchild, mutator.attr, copy.copy(getattr(child, mutator.attr))
                )
                child.add_child(grandchild)
                yield grandchild
            else:
                yield child
            self.add_child(child)

    def _mutation_outcome(
        self, mutator: mutators.Mutator, rng: np.random.Generator
    ) -> Generator[TreeNode, None, None]:
        r"""Generate the outcome of a mutation event at this node.

        Args:
            mutator: Generator of mutation effects.
            rng: Random number generator.

        Yields:
            The mutated child node.
        """
        assert self.event == self._MUTATION_EVENT
        mutator.mutate(self, seed=rng)
        child = TreeNode(
            t=self.t,
            dist=0,
            name=next(self._name_generator),
        )
        setattr(child, mutator.attr, copy.copy(getattr(self, mutator.attr)))
        self.add_child(child)
        yield child

    def evolve(
        self,
        t: float,
        birth_process: poisson.Process = poisson.ConstantProcess(1),
        death_process: poisson.Process = poisson.ConstantProcess(0),
        mutation_process: poisson.Process = poisson.ConstantProcess(0),
        mutator: mutators.Mutator = mutators.DiscreteMutator((None,), np.array([[1]])),
        birth_mutation_prob: float | Callable[[Any], float] = 0.0,
        min_survivors: int = 1,
        capacity: int = 1000,
        capacity_method: Literal["birth", "death", "hard"] | None = None,
        init_population: int = 1,
        seed: int | np.random.Generator | None = None,
        verbose: bool = False,
    ) -> None:
        r"""Evolve for time :math:`\Delta t`.

        Args:
            t: Evolve for a duration of :math:`t` time units.
            birth_process: Birth process function.
            death_process: Death process function.
            mutation_process: Mutation process function.
            mutator: Generator of mutation effects at mutation events
                     (and possibly on daughters of birth events if
                     ``birth_mutation_prob > 0``).
            birth_mutation_prob: Probability of a mutation event for each daughter node
                                 of a birth event. If a callable, then it should take a
                                 node attribute as an argument and return a probability.
            min_survivors: Minimum number of survivors. If the simulation finishes with
                           fewer than this number of survivors, then a
                           :py:class:`TreeError` is raised.
            capacity: Population carrying capacity.
            capacity_method: Method to enforce population carrying capacity. If
                             ``None``, then a :py:class:`TreeError` is raised if
                             the population exceeds the carrying capacity.
                             If ``'stop'``, then the simulation stops when the
                             population reaches the carrying capacity.
                             If ``'birth'``, then the birth rate is logistically
                             modulated such that the process is critical when the
                             population is at carrying capacity.
                             If ``'death'``, then the death rate is logistically
                             modulated such that the process is critical when the
                             population is at carrying capacity.
                             If ``'hard'``, then a random individual is chosen to
                             die whenever a birth event results in carrying capacity
                             being exceeded.
            init_population: Initial population size.
            seed: A seed to initialize the random number generation.
                  If ``None``, then fresh, unpredictable entropy will be pulled from
                  the OS.
                  If an ``int``, then it will be used to derive the initial state.
                  If a :py:class:`numpy.random.Generator`, then it will be used
                  directly.
            verbose: Flag to indicate whether to print progress information.

        Raises:
            TreeError: If the tree is not a root node, or if the tree has already
                       evolved, or if the number of survivors is less than
                       ``min_survivors``, or if the population exceeds ``capacity``
                       with ``capacity_method=None``.
            ValueError: If ``init_population`` is greater than ``capacity`` or if
                        the event processes refer to different node attributes.
        """
        if not self.is_root():
            raise TreeError("Cannot evolve a non-root node")
        if self.children:
            raise TreeError(
                "tree has already evolved at node "
                f"{self.name} with {len(self.children)} descendant lineages"
            )
        if init_population > capacity:
            raise ValueError(f"{init_population=} must be less than {capacity=}")
        if birth_process.attr != death_process.attr != mutation_process.attr:
            raise ValueError(
                f"Event processes must refer to the same node attribute. Got: "
                f"{birth_process.attr=}, {death_process.attr=}, "
                f"{mutation_process.attr=}"
            )
        state_attr = birth_process.attr
        if not hasattr(self, state_attr):
            raise ValueError(
                f"node {self.name} does not have attribute {state_attr} "
                "required by mutator"
            )
        # NOTE: this may go later when we revise how mutators work
        if mutator.attr != state_attr:
            raise ValueError(
                f"mutator attribute {mutator.attr} does not match state attribute "
                f"{state_attr}"
            )

        rng = np.random.default_rng(seed)

        if verbose:

            def print_progress(current_time: float, n_nodes_active: int):
                print(f"t={current_time:.3f}, n={n_nodes_active}", end="   \r")

        else:

            def print_progress(current_time: float, n_nodes_active: int):
                pass

        if callable(birth_mutation_prob):

            def mutation_event_fn(node: TreeNode, rng: np.random.Generator) -> bool:
                return rng.random() < birth_mutation_prob(getattr(node, state_attr))

        elif birth_mutation_prob == 0.0:

            def mutation_event_fn(node: TreeNode, rng: np.random.Generator) -> bool:
                return False

        else:

            def mutation_event_fn(node: TreeNode, rng: np.random.Generator) -> bool:
                return rng.random() < birth_mutation_prob

        current_time = self.t
        end_time = self.t + t
        processes = {
            self._BIRTH_EVENT: birth_process,
            self._DEATH_EVENT: death_process,
            self._MUTATION_EVENT: mutation_process,
        }

        # initialize population
        names_nodes_all: dict[int, TreeNode] = dict()
        names_active = utils.RandomizedSet()
        state_names_active: defaultdict[str, utils.RandomizedSet] = defaultdict(
            utils.RandomizedSet
        )
        total_birth_rate = 0.0
        total_death_rate = 0.0
        for _ in range(init_population):
            start_node = TreeNode(
                t=self.t,
                dist=0,
                name=next(self._name_generator),
            )
            setattr(start_node, state_attr, copy.copy(getattr(self, state_attr)))
            self.add_child(start_node)
            names_nodes_all[start_node.name] = start_node
            names_active.add(start_node.name)
            state_names_active[getattr(start_node, state_attr)].add(start_node.name)
            total_birth_rate += birth_process(start_node)
            total_death_rate += death_process(start_node)

        # initialize rate multipliers, which are used to modulate
        # rates in accordance with the carrying capacity
        rate_multipliers: dict[str, float] = {
            self._BIRTH_EVENT: 1.0,
            self._DEATH_EVENT: 1.0,
            self._MUTATION_EVENT: 1.0,
        }
        while len(names_active) > 0:
            if capacity_method == "birth":
                rate_multipliers[self._BIRTH_EVENT] = (  # type:ignore
                    total_death_rate / total_birth_rate
                ) ** (len(names_active) / capacity)
            elif capacity_method == "death":
                rate_multipliers[self._DEATH_EVENT] = (  # type:ignore
                    total_birth_rate / total_death_rate
                ) ** (len(names_active) / capacity)
            elif capacity_method == "hard":
                if len(names_active) > capacity:
                    node_to_die_name: int = names_active.choice(rng)
                    node_to_die = names_nodes_all[node_to_die_name]
                    assert node_to_die.up is not None
                    node_to_die.dist = current_time - node_to_die.up.t
                    node_to_die.event = self._DEATH_EVENT
                    node_to_die.t = current_time
                    names_active.remove(node_to_die_name)
                    state_names_active[getattr(node_to_die, state_attr)].remove(
                        node_to_die.name
                    )
                    total_birth_rate -= birth_process(node_to_die)
                    total_death_rate -= death_process(node_to_die)
            elif capacity_method == "stop":
                if len(names_active) >= capacity:
                    end_time = current_time
            elif capacity_method is None:
                if len(names_active) > capacity:
                    self._aborted_evolve_cleanup()
                    if verbose:
                        print()
                    raise TreeError(f"{capacity=} exceeded at time={current_time}")
            else:
                raise ValueError(f"{capacity_method=} not recognized")
            waiting_time, event, state = min(
                (
                    processes[event].waiting_time_rv(
                        state,
                        current_time,
                        rate_multiplier=rate_multipliers[event]
                        * len(state_names_active[state]),
                        seed=rng,
                    ),
                    event,
                    state,
                )
                for event in processes
                for state in state_names_active
                if len(state_names_active[state]) > 0
            )
            Δt = float(np.minimum(waiting_time, end_time - current_time))
            current_time += Δt
            if current_time < end_time:
                event_node_name = state_names_active[state].choice(rng)
                event_node = names_nodes_all[event_node_name]
                event_node.t = current_time
                assert event_node.up is not None
                event_node.dist = current_time - event_node.up.t
                event_node.event = event
                names_active.remove(event_node_name)
                state_names_active[getattr(event_node, state_attr)].remove(
                    event_node.name
                )
                total_birth_rate -= birth_process(event_node)
                total_death_rate -= death_process(event_node)
                if event_node.event == self._DEATH_EVENT:
                    new_nodes = ()
                elif event_node.event == self._BIRTH_EVENT:
                    new_nodes = event_node._birth_outcome(
                        mutation_event_fn, mutator, rng
                    )
                elif event_node.event == self._MUTATION_EVENT:
                    new_nodes = event_node._mutation_outcome(mutator, rng)
                else:
                    raise ValueError(f"invalid event {event_node.event}")
                for new_node in new_nodes:
                    names_nodes_all[new_node.name] = new_node
                    names_active.add(new_node.name)
                    state_names_active[getattr(new_node, state_attr)].add(new_node.name)
                    total_birth_rate += birth_process(new_node)
                    total_death_rate += death_process(new_node)
                print_progress(float(current_time), len(names_active))
            else:
                # deal with possible loss of significance
                if current_time > end_time:
                    # NOTE: math.isclose is much faster than np.isclose
                    assert math.isclose(
                        current_time, end_time
                    ), f"{current_time=}, {end_time=}"
                    current_time = end_time
                print_progress(float(current_time), len(names_active))
                for node_name in reversed(names_active):
                    node = names_nodes_all[node_name]
                    node.t = current_time
                    assert node.up is not None
                    node.dist = current_time - node.up.t
                    node.event = self._SURVIVAL_EVENT
                    names_active.remove(node_name)
                    state_names_active[getattr(node, state_attr)].remove(node.name)
                assert len(names_active) == 0
                assert not any(
                    len(state_names_active[state]) > 0 for state in state_names_active
                )
        if verbose:
            print()
        n_survivors = sum(leaf.event == self._SURVIVAL_EVENT for leaf in self)
        if n_survivors < min_survivors:
            self._aborted_evolve_cleanup()
            raise TreeError(
                f"number of survivors {n_survivors} is less than {min_survivors=}"
            )

    def _aborted_evolve_cleanup(self) -> None:
        """Remove any children added to the root node during an aborted evolution
        attempt, and reset the node name generator."""
        for child in self.children.copy():
            child.detach()
            del child
        TreeNode._name_generator = itertools.count(start=self.name + 1)

    def sample_survivors(
        self,
        n: int | None = None,
        p: float | None = 1.0,
        seed: int | np.random.Generator | None = None,
    ) -> None:
        """Choose :math:`n` survivor leaves from the tree, or each survivor leaf with
        probability :math:`p`, to mark as sampled (via the event attribute).

        Args:
            n: Number of leaves to sample.
            p: Probability of sampling a leaf.
            seed: A seed to initialize the random number generation. If ``None``, then
                  fresh, unpredictable entropy will be pulled from the OS. If an
                  ``int``, then it will be used to derive the initial state. If a
                  :py:class:`numpy.random.Generator`, then it will be used directly.

        Raises:
            ValueError: If the tree has already been sampled below this node, or if
                        neither ``n`` nor ``p`` is specified.
        """
        if self._sampled:
            raise ValueError(f"tree has already been sampled below node {self.name}")
        rng = np.random.default_rng(seed)
        surviving_leaves: list[TreeNode] = [
            leaf for leaf in self if leaf.event == self._SURVIVAL_EVENT
        ]
        if n is not None:
            for leaf in rng.choice(
                surviving_leaves, size=n, replace=False  # type:ignore
            ):
                leaf.event = self._SAMPLING_EVENT
        elif p is not None:
            for leaf in surviving_leaves:
                if rng.choice(range(2), p=(1 - p, p)):
                    leaf.event = self._SAMPLING_EVENT
        else:
            raise ValueError("must specify either n or p")
        for node in self.traverse():  # type:ignore
            node._sampled = True

    # NOTE: this could be generalized to take an ordered array-valued t,
    #       and made efficient via ordered traversal
    def slice(self, t: float, attr: str = "x") -> list[Any]:
        r"""
        Args:
            t: Slice the tree at time :math:`t`.
            attr: Attribute to extract from slice.

        Returns:
            List of attribute ``attr`` values at time :math:`t` for all lineages alive
            at that time.

        Raises:
            ValueError: If the tree has not evolved or has already been pruned below
                        this node, or if the tree has not been sampled below this node,
                        or if ``t`` is before the root time or after the tree end time.
        """
        if self._pruned:
            raise ValueError("Cannot slice a pruned tree")
        if not self.children:
            raise ValueError("Cannot slice an unevolved tree")
        if t < self.t:
            raise ValueError(f"Cannot slice at time {t} before root time {self.t}")
        tree_end_time = max(node.t for node in self)
        if t > tree_end_time:
            raise ValueError(
                f"cannot slice at time {t} after tree end time {tree_end_time}"
            )

        if self.t == t:
            return [getattr(self, attr)]

        def is_leaf_fn(node: TreeNode):
            return node.up is not None and (node.up.t < t <= node.t)

        return [
            (getattr(node, attr) if node.t == t else getattr(node.up, attr))
            for node in self.iter_leaves(is_leaf_fn=is_leaf_fn)
        ]

    def prune_unsampled(self) -> None:
        r"""Prune the tree to the subtree subtending the sampled leaves, removing
        unobserved subtrees.

        Raises:
            ValueError: If the tree has not been sampled below this node, or if the
                        tree has already been pruned below this node.
            TreeError: If no leaves were sampled.
        """
        if self._pruned:
            raise ValueError(f"tree has already been pruned below node {self.name}")
        if not self._sampled:
            raise ValueError(f"tree has not been sampled below node {self.name}")

        event_cache: dict[TreeNode, set[str]] = self.get_cached_content(
            store_attr="event"
        )
        if self._SAMPLING_EVENT not in event_cache[self]:
            raise TreeError("cannot prune because no leaves were sampled")

        def is_leaf_fn(node: TreeNode):
            return self._SAMPLING_EVENT not in event_cache[node]

        for node in self.iter_leaves(is_leaf_fn=is_leaf_fn):
            parent = node.up
            assert parent is not None
            parent.remove_child(node)
            assert parent.event == self._BIRTH_EVENT or parent.is_root()
            parent.delete(
                prevent_nondicotomic=False,
                preserve_branch_length=True,
            )
        for node in self.traverse():  # type:ignore
            node._pruned = True

    def remove_mutation_events(self) -> None:
        r"""Remove unifurcating mutation event nodes, preserving branch length, and
        annotate mutation counts in child node ``n_mutations`` attribute.

        Raises:
            ValueError: If the tree has not been pruned below this node with
                        :py:meth:`prune`.
        """
        if not self._pruned:
            raise ValueError(f"tree has not been pruned below node {self.name}")
        for node in self.traverse(strategy="postorder"):  # type:ignore
            if node.event == self._MUTATION_EVENT:
                assert len(node.children) == 1
                node.children[0].n_mutations += 1
                node.delete(
                    prevent_nondicotomic=False,
                    preserve_branch_length=True,
                )
        for node in self.traverse():  # type:ignore
            node._mutations_removed = True

    def render(  # type:ignore
        self,
        file_name: str,
        color_by: str | None = "state",
        color_map: Mapping[Any, str] | None = None,
        mode: Literal["c", "r"] = "r",
        scale: float | None = None,
        **kwargs: Any,
    ) -> Any:
        r"""A thin wrapper around :py:meth:`ete3.TreeNode.render` that adds some custom
        decoration and a color bar. See also ETE's tree rendering `tutorial`_ and linked
        API docs pages there.

        .. _tutorial: http://etetoolkit.org/docs/latest/tutorial/tutorial_drawing.html

        If tree is not pruned (or is pruned without removing mutation events), then
        branches are colored according to the attribute specified by ``color_by``,
        extinct lineages are indicated as dotted branches, unsampled non-extint
        lineages are indicated as solid branches, and sampled lineages are indicated
        as thick solid branches. Sampled leaves are indicated with a circle.

        If tree is pruned without retaining mutation events, then nodes are colored
        according to the attribute specified by ``color_by``, branches are annotated
        above with branch length (in black text) and below with number of mutations
        (in green text).

        Args:
            file_name: Filename to save the rendered tree to. Use ``"%%inline"`` to
                      render inline in a notebook.
            color_by: If not ``None``, color tree by this numerical node attribute.
            color_map: mapping from node attribute values to color names or hex codes.
            mode: ``"c"`` for circular tree, ``"r"`` for rectangular tree.
            scale: Scale branch lengths by this factor (ignored if a ``tree_style`` is
                   passed in ``kwargs``). If ``None``, then the scale is chosen
                   automatically.
            kwargs: Keyword arguments to pass to :py:meth:`ete3.TreeNode.render`.

        Returns:
            The return value of :py:meth:`ete3.TreeNode.render`.
        """
        if "tree_style" not in kwargs:
            kwargs["tree_style"] = ete3.TreeStyle()
            kwargs["tree_style"].show_leaf_name = False
            kwargs["tree_style"].show_scale = False
            kwargs["tree_style"].rotation = 90
            kwargs["tree_style"].mode = mode
            kwargs["tree_style"].scale = scale  # type:ignore
            kwargs["tree_style"].branch_vertical_margin = 2

        event_cache: dict[TreeNode, set[str]] = self.get_cached_content(
            store_attr="event", leaves_only=False
        )
        if (not self._pruned) or (not self._mutations_removed):
            for node in self.traverse():  # type:ignore
                nstyle = ete3.NodeStyle()
                if (
                    self._SURVIVAL_EVENT not in event_cache[node]
                    and self._SAMPLING_EVENT not in event_cache[node]
                ):
                    nstyle["hz_line_type"] = 1
                    nstyle["vt_line_type"] = 1
                    nstyle["hz_line_width"] = 0
                    nstyle["vt_line_width"] = 0
                elif self._SAMPLING_EVENT not in event_cache[node]:
                    nstyle["hz_line_width"] = 1
                    nstyle["vt_line_width"] = 1
                else:
                    nstyle["hz_line_width"] = 2
                    nstyle["vt_line_width"] = 2
                if color_map is not None:
                    assert color_by is not None
                    nstyle["vt_line_color"] = color_map[getattr(node, color_by)]
                    if not node.is_root():
                        assert node.up is not None
                        nstyle["hz_line_color"] = color_map[getattr(node.up, color_by)]
                    nstyle["fgcolor"] = color_map[getattr(node, color_by)]
                if node.event == self._SAMPLING_EVENT:
                    nstyle["size"] = 2
                else:
                    nstyle["size"] = 0
                node.set_style(nstyle)
        else:
            for node in self.traverse():  # type:ignore
                nstyle = ete3.NodeStyle()
                if color_map is not None:
                    assert color_by is not None
                    nstyle["fgcolor"] = color_map[getattr(node, color_by)]
                if not node.is_root() and not getattr(node.faces, "branch-bottom"):
                    node.add_face(self._mutation_face, 0, position="branch-bottom")
                node.set_style(nstyle)

        return super().render(file_name, **kwargs)
