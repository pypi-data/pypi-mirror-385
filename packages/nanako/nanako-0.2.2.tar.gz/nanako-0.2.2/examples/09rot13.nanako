# ROT13 暗号化・復号化
# アルファベットを13文字ずらす暗号

# 文字が大文字のA-Zかチェック
大文字判定 = 入力 文字コード に対し {
    # A=65, Z=90
    もし 文字コード が 65 以上 ならば、{
        もし 文字コード が 90 以下 ならば、{
            1が答え
        }
    }
    0が答え
}

# 文字が小文字のa-zかチェック  
小文字判定 = 入力 文字コード に対し {
    # a=97, z=122
    もし 文字コード が 97 以上 ならば、{
        もし 文字コード が 122 以下 ならば、{
            1が答え
        }
    }
    0が答え
}

# ROT13変換（1文字）
文字ROT13 = 入力 文字コード に対し {
    もし 大文字判定(文字コード) が 1 ならば、{
        # 大文字の場合：A(65)を基準に13ずらす
        相対位置 = 引き算(文字コード, 65)
        新位置 = あまり(足し算(相対位置, 13), 26)
        足し算(新位置, 65)が答え
    }
    
    もし 小文字判定(文字コード) が 1 ならば、{
        # 小文字の場合：a(97)を基準に13ずらす
        相対位置 = 引き算(文字コード, 97)
        新位置 = あまり(足し算(相対位置, 13), 26)
        足し算(新位置, 97)が答え
    }
    
    # アルファベット以外はそのまま
    文字コードが答え
}

# 文字列全体をROT13変換
文字列ROT13 = 入力 文字列 に対し {
    結果 = []
    i = 0
    長さ = |文字列|
    
    長さ回、くり返す {
        元文字 = 文字列[i]
        新文字 = 文字ROT13(元文字)
        結果[?] = 新文字
        iを増やす
    }
    
    結果が答え
}

# 剰余計算（割り算の余り）
あまり = 入力 被除数, 除数 に対し {
    もし 被除数 が 除数 より小さい ならば、{
        被除数が答え
    }
    あまり(引き算(被除数, 除数), 除数)が答え
}

# 必要な補助関数
足し算 = 入力 X, Y に対し {
    Y回、くり返す {
        Xを増やす
    }
    Xが答え
}

引き算 = 入力 X, Y に対し {
    Y回、くり返す {
        Xを減らす
    }
    Xが答え
}

# テスト用の文字列
# "Hello World" の文字コード配列
# H=72, e=101, l=108, l=108, o=111, (space)=32, W=87, o=111, r=114, l=108, d=100
元文字列 = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]

# 暗号化
暗号化文字列 = 文字列ROT13(元文字列)

# 復号化（ROT13は対称なので2回適用で元に戻る）
復号化文字列 = 文字列ROT13(暗号化文字列)

# 結果表示
元文字列
暗号化文字列
復号化文字列
