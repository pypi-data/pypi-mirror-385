# hermetic/bootstrap.py
# WARNING: THIS FILE IS AUTO-GENERATED BY scripts/build_bootstrap.py. DO NOT EDIT.
from __future__ import annotations

import json
import os
import tempfile
from textwrap import dedent
from typing import Any, Dict

from .errors import BootstrapError

# Minimal bootstrap sitecustomize that installs guards without requiring hermetic package to be importable.
# Encodes guards inline to survive foreign interpreters/venvs.

_SITE_CUSTOMIZE = dedent(
    r"""
    # --- BOOTSTRAP START ---
    import os, sys, json, socket, ssl, subprocess, asyncio, builtins, importlib.machinery as mach, pathlib, time, errno

    class _HPolicy(RuntimeError): pass

    # policy-aware excepthook so bootstrap exits cleanly on guard violations
    _orig_excepthook = sys.excepthook
    def _hermetic_excepthook(exctype, value, tb):
        # Donâ€™t intercept KeyboardInterrupt
        if exctype is KeyboardInterrupt:
            return _orig_excepthook(exctype, value, tb)
        # Our policy exceptions get a clean, consistent exit
        if exctype.__name__ in {"_HPolicy", "PolicyViolation"}:
            try:
                sys.stderr.write(f"hermetic: blocked action: {value}\n")
                sys.stderr.flush()
            finally:
                os._exit(2)  # hard-exit: no teardown that might deadlock
        # otherwise, default behavior
        return _orig_excepthook(exctype, value, tb)

    sys.excepthook = _hermetic_excepthook

    cfg = json.loads(os.environ.pop("HERMETIC_FLAGS_JSON", "{}"))
    trace = bool(cfg.get("trace"))
    def _tr(msg):
        if trace:
            print(f"[hermetic] {msg}", file=sys.stderr, flush=True)

    # --- GUARDS START ---
    # --- network ---
    if cfg.get("no_network"):
        _orig_socket = socket.socket
        _orig_create_connection = socket.create_connection
        _orig_getaddrinfo = socket.getaddrinfo
        _orig_wrap_socket = ssl.SSLContext.wrap_socket
    
        ALLOW_LOCAL = bool(cfg.get("allow_localhost"))
        ALLOW_DOMAINS = set([d.lower() for d in cfg.get("allow_domains", []) if d])
        META = {"169.254.169.254", "metadata.google.internal"}
        LOCAL = {"127.0.0.1","::1","localhost","0.0.0.0"}  # nosec
    
        def _host_from(addr):
            try:
                if isinstance(addr, (tuple, list)) and len(addr) >= 1: return str(addr[0])
                return str(addr)
            except Exception: return ""
    
        def _is_net_allowed(host:str)->bool:
            h = (host or "").lower()
            if h in META: return False
            if ALLOW_LOCAL and h in LOCAL: return True
            return any((d in h) for d in ALLOW_DOMAINS)
    
        class GuardedSocket(_orig_socket):
            def connect(self, address):
                host = _host_from(address)
                if _is_net_allowed(host): return super().connect(address)
                _tr(f"blocked socket.connect host={host}"); raise _HPolicy("network disabled")
            def connect_ex(self, address):
                host = _host_from(address)
                if _is_net_allowed(host): return super().connect_ex(address)
                _tr(f"blocked socket.connect_ex host={host}"); return errno.EACCES
    
        def _guard_create_connection(addr, *a, **k):
            host = _host_from(addr)
            if _is_net_allowed(host): return _orig_create_connection(addr, *a, **k)
            _tr(f"blocked socket.create_connection host={host}"); raise _HPolicy("network disabled")
    
        def _guard_getaddrinfo(host, *a, **k):
            if _is_net_allowed(str(host)): return _orig_getaddrinfo(host, *a, **k)
            _tr(f"blocked socket.getaddrinfo host={host}"); raise _HPolicy("network disabled")
    
        def _guard_wrap_socket(self, sock, *a, **k):
            _tr("blocked ssl.wrap_socket"); raise _HPolicy("network disabled")
    
        socket.socket = GuardedSocket
        socket.create_connection = _guard_create_connection
        socket.getaddrinfo = _guard_getaddrinfo
        ssl.SSLContext.wrap_socket = _guard_wrap_socket
    
    
    # --- subprocess ---
    if cfg.get("no_subprocess"):
        def _deny_exec(*a,**k): _tr("blocked subprocess reason=no-subprocess"); raise _HPolicy("subprocess disabled")
        targets = {
            "subprocess": ("Popen", "run", "call", "check_output"),
            "os": ("system", "execv", "execve", "execl", "execle", "execlp", "execlpe", "execvp", "execvpe", "fork", "forkpty", "spawnl", "spawnle", "spawnlp", "spawnlpe", "spawnv", "spawnve", "spawnvp", "spawnvpe"),
            "asyncio": ("create_subprocess_exec", "create_subprocess_shell"),
        }
        for mod_name, funcs in targets.items():
            try:
                mod = __import__(mod_name)
                for name in funcs:
                    if hasattr(mod, name):
                        setattr(mod, name, _deny_exec)
            except ImportError:
                pass
    
    
    # --- fs readonly ---
    if cfg.get("fs_readonly"):
        ROOT = cfg.get("fs_root")
        _o = {"open": builtins.open, "Popen": pathlib.Path.open, "os.open": os.open}
        def _norm(p):
            try: import os as _os; return _os.path.realpath(p)
            except Exception: return p
        def _within(p, r):
            if not r: return False
            P, R = _norm(p), _norm(r)
            return P==R or P.startswith(R + ("/" if "/" in R else "\\"))
        def _open_guard(f, mode="r", *a, **k):
            path = str(f)
            if any(m in mode for m in ("w","a","x","+")): _tr(f"blocked open write path={path}"); raise _HPolicy("fs readonly")
            if ROOT and not _within(path, ROOT): _tr(f"blocked open read-outside-root path={path}"); raise _HPolicy("read outside root")
            return _o["open"](f, mode, *a, **k)
        WRITE_FLAGS = getattr(os, "O_WRONLY", 2) | getattr(os, "O_RDWR", 4) | getattr(os, "O_APPEND", 8) | getattr(os, "O_CREAT", 1)
        def os_open_guard(path, flags, *a, **k):
            mode = "r" if not (flags & WRITE_FLAGS) else "w"
            return _open_guard(path, mode, *a, **k)
    
        builtins.open = _open_guard
        pathlib.Path.open = lambda self,*a,**k: _open_guard(str(self), *a, **k)
        os.open = os_open_guard
        def _deny_fs(*a,**k): _tr("blocked fs mutation"); raise _HPolicy("fs mutation disabled")
        for name in ("remove","rename","replace","unlink","rmdir","mkdir","makedirs", "chmod", "chown"):
            if hasattr(os, name):
                setattr(os, name, _deny_fs)
    
    
    # --- strict imports ---
    if cfg.get("block_native"):
        _origExt = mach.ExtensionFileLoader
        _origImp = builtins.__import__
        def _trimp(n): _tr(f"blocked import name={n}")
        class GuardedExtLoader(_origExt):
            def create_module(self, spec): _tr(f"blocked native import spec={spec.name}"); raise _HPolicy("native import blocked")
        def guarded_import(name, globals=None, locals=None, fromlist=(), level=0):
            root = name.split(".",1)[0]
            if root in {"ctypes","cffi"}: _trimp(name); raise _HPolicy("import blocked")
            return _origImp(name, globals, locals, fromlist, level)
        mach.ExtensionFileLoader = GuardedExtLoader
        builtins.__import__ = guarded_import
    # --- GUARDS END ---
    # --- BOOTSTRAP END ---
    """
)


def write_sitecustomize(flags: Dict[str, Any]) -> str:
    try:
        d = tempfile.mkdtemp(prefix="hermetic_site_")
        path = os.path.join(d, "sitecustomize.py")
        with open(path, "w", encoding="utf-8") as f:
            f.write(_SITE_CUSTOMIZE)
        os.environ["HERMETIC_FLAGS_JSON"] = json.dumps(flags)
        return d
    except Exception as e:
        raise BootstrapError(f"failed to write sitecustomize: {e}")
