# coding: utf-8

"""
    Fortanix SDKMS REST API

    This is a set of REST APIs for accessing the Fortanix Self-Defending Key Management System. This includes APIs for managing accounts, and for performing cryptographic and key management operations. 

    OpenAPI spec version: 1.0.0-20200608
    Contact: support@fortanix.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


# NOTE: This class is auto generated by the swagger code generator program.
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
class EncryptionAndDecryptionApi(object):

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def batch_decrypt(self, body, async_call=False, **kwargs):
        """
        The data to be decrypted and the key ids to be used are provided in the request body. The decrypted plain text is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `BatchDecryptRequest`
        :param body: Batch decryption request (required)
        :rtype: `BatchDecryptResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.batch_decrypt_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.batch_decrypt_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def batch_decrypt_with_http_info(self, body, async_call=False, **kwargs):
        """
        The data to be decrypted and the key ids to be used are provided in the request body. The decrypted plain text is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.batch_decrypt_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `BatchDecryptRequest`
        :param body: Batch decryption request (required)
        :rtype: `BatchDecryptResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_decrypt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `batch_decrypt`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/batch/decrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BatchDecryptResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def batch_encrypt(self, body, async_call=False, **kwargs):
        """
        The data to be encrypted and the key ids to be used are provided in the request body. The encrypted cipher text is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `BatchEncryptRequest`
        :param body: Batch Encryption request (required)
        :rtype: `BatchEncryptResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.batch_encrypt_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.batch_encrypt_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def batch_encrypt_with_http_info(self, body, async_call=False, **kwargs):
        """
        The data to be encrypted and the key ids to be used are provided in the request body. The encrypted cipher text is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.batch_encrypt_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `BatchEncryptRequest`
        :param body: Batch Encryption request (required)
        :rtype: `BatchEncryptResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_encrypt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `batch_encrypt`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/batch/encrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='BatchEncryptResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt(self, key_id, body, async_call=False, **kwargs):
        """
        Decrypt data using a symmetric or asymmetric key. For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is required for symmetric ciphers and unused for asymmetric ciphers. It must contain the initialization value used when the object was encrypted. <br> Objects of type opaque, EC, or HMAC may not be used for encryption or decryption. <br> 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptRequest`
        :param body: Decryption request (required)
        :rtype: `DecryptResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def decrypt_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Decrypt data using a symmetric or asymmetric key. For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is required for symmetric ciphers and unused for asymmetric ciphers. It must contain the initialization value used when the object was encrypted. <br> Objects of type opaque, EC, or HMAC may not be used for encryption or decryption. <br> 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptRequest`
        :param body: Decryption request (required)
        :rtype: `DecryptResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `decrypt`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/decrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_ex(self, body, async_call=False, **kwargs):
        """
        Decrypt data using a symmetric or asymmetric key. For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is required for symmetric ciphers and unused for asymmetric ciphers. It must contain the initialization value used when the object was encrypted. <br> Objects of type opaque, EC, or HMAC may not be used for encryption or decryption. <br> 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptRequestEx`
        :param body: Decryption request (required)
        :rtype: `DecryptResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def decrypt_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Decrypt data using a symmetric or asymmetric key. For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is required for symmetric ciphers and unused for asymmetric ciphers. It must contain the initialization value used when the object was encrypted. <br> Objects of type opaque, EC, or HMAC may not be used for encryption or decryption. <br> 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptRequestEx`
        :param body: Decryption request (required)
        :rtype: `DecryptResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/decrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_final(self, key_id, body, async_call=False, **kwargs):
        """
        Conclude a multi-part decryption operation. See `decrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptFinalRequest`
        :param body: Finish multi-part decryption (required)
        :rtype: `DecryptFinalResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_final_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_final_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def decrypt_final_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Conclude a multi-part decryption operation. See `decrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_final_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptFinalRequest`
        :param body: Finish multi-part decryption (required)
        :rtype: `DecryptFinalResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_final" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `decrypt_final`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_final`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/decrypt/final', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptFinalResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_final_ex(self, body, async_call=False, **kwargs):
        """
        Conclude a multi-part decryption operation. See `decrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptFinalRequestEx`
        :param body: Finish multi-part decryption (required)
        :rtype: `DecryptFinalResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_final_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_final_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def decrypt_final_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Conclude a multi-part decryption operation. See `decrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_final_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptFinalRequestEx`
        :param body: Finish multi-part decryption (required)
        :rtype: `DecryptFinalResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_final_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_final_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/decrypt/final', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptFinalResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_init(self, key_id, body, async_call=False, **kwargs):
        """
        This API is used when decrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part decryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptInitRequest`
        :param body: Multi-part decryption initialization request (required)
        :rtype: `DecryptInitResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_init_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_init_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def decrypt_init_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        This API is used when decrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part decryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_init_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptInitRequest`
        :param body: Multi-part decryption initialization request (required)
        :rtype: `DecryptInitResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_init" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `decrypt_init`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_init`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/decrypt/init', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptInitResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_init_ex(self, body, async_call=False, **kwargs):
        """
        This API is used when decrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part decryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptInitRequestEx`
        :param body: Multi-part decryption initialization request (required)
        :rtype: `DecryptInitResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_init_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_init_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def decrypt_init_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        This API is used when decrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part decryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_init_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptInitRequestEx`
        :param body: Multi-part decryption initialization request (required)
        :rtype: `DecryptInitResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_init_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_init_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/decrypt/init', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptInitResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_update(self, key_id, body, async_call=False, **kwargs):
        """
        Continue a multi-part decryption operation. See `decrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptUpdateRequest`
        :param body: Multi-part decryption (required)
        :rtype: `DecryptUpdateResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_update_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_update_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def decrypt_update_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Continue a multi-part decryption operation. See `decrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_update_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `DecryptUpdateRequest`
        :param body: Multi-part decryption (required)
        :rtype: `DecryptUpdateResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `decrypt_update`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_update`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/decrypt/update', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptUpdateResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def decrypt_update_ex(self, body, async_call=False, **kwargs):
        """
        Continue a multi-part decryption operation. See `decrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptUpdateRequestEx`
        :param body: Multi-part decryption (required)
        :rtype: `DecryptUpdateResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.decrypt_update_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.decrypt_update_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def decrypt_update_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Continue a multi-part decryption operation. See `decrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.decrypt_update_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptUpdateRequestEx`
        :param body: Multi-part decryption (required)
        :rtype: `DecryptUpdateResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decrypt_update_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `decrypt_update_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/decrypt/update', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptUpdateResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt(self, key_id, body, async_call=False, **kwargs):
        """
        Encrypt data using a symmetric or asymmetric key. <br> For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is optional for symmetric ciphers and unused for asymmetric ciphers. If provided, it will be used as the cipher initialization value. Length of iv must match the initialization value size for the cipher and mode. If not provided, SDKMS will create a random iv of the correct length for the cipher and mode and return this value in the response. <br> Objects of type Opaque, EC, or HMAC may not be used for encryption or decryption. <br> 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptRequest`
        :param body: Encryption request (required)
        :rtype: `EncryptResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def encrypt_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Encrypt data using a symmetric or asymmetric key. <br> For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is optional for symmetric ciphers and unused for asymmetric ciphers. If provided, it will be used as the cipher initialization value. Length of iv must match the initialization value size for the cipher and mode. If not provided, SDKMS will create a random iv of the correct length for the cipher and mode and return this value in the response. <br> Objects of type Opaque, EC, or HMAC may not be used for encryption or decryption. <br> 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptRequest`
        :param body: Encryption request (required)
        :rtype: `EncryptResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `encrypt`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/encrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_ex(self, body, async_call=False, **kwargs):
        """
        Encrypt data using a symmetric or asymmetric key. <br> For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is optional for symmetric ciphers and unused for asymmetric ciphers. If provided, it will be used as the cipher initialization value. Length of iv must match the initialization value size for the cipher and mode. If not provided, SDKMS will create a random iv of the correct length for the cipher and mode and return this value in the response. <br> Objects of type Opaque, EC, or HMAC may not be used for encryption or decryption. <br> 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptRequestEx`
        :param body: Encryption request (required)
        :rtype: `EncryptResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def encrypt_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Encrypt data using a symmetric or asymmetric key. <br> For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br> For GCM and CCM modes, tag_len is a required field. <br> iv is optional for symmetric ciphers and unused for asymmetric ciphers. If provided, it will be used as the cipher initialization value. Length of iv must match the initialization value size for the cipher and mode. If not provided, SDKMS will create a random iv of the correct length for the cipher and mode and return this value in the response. <br> Objects of type Opaque, EC, or HMAC may not be used for encryption or decryption. <br> 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptRequestEx`
        :param body: Encryption request (required)
        :rtype: `EncryptResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/encrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_final(self, key_id, body, async_call=False, **kwargs):
        """
        Conclude a multi-part encryption operation. See `encrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptFinalRequest`
        :param body: Finish multi-part encryption (required)
        :rtype: `EncryptFinalResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_final_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_final_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def encrypt_final_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Conclude a multi-part encryption operation. See `encrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_final_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptFinalRequest`
        :param body: Finish multi-part encryption (required)
        :rtype: `EncryptFinalResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_final" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `encrypt_final`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_final`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/encrypt/final', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptFinalResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_final_ex(self, body, async_call=False, **kwargs):
        """
        Conclude a multi-part encryption operation. See `encrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptFinalRequestEx`
        :param body: Finish multi-part encryption (required)
        :rtype: `EncryptFinalResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_final_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_final_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def encrypt_final_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Conclude a multi-part encryption operation. See `encrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_final_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptFinalRequestEx`
        :param body: Finish multi-part encryption (required)
        :rtype: `EncryptFinalResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_final_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_final_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/encrypt/final', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptFinalResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_init(self, key_id, body, async_call=False, **kwargs):
        """
        This API is used when encrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part encryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptInitRequest`
        :param body: Multi-part encryption initialization request (required)
        :rtype: `EncryptInitResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_init_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_init_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def encrypt_init_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        This API is used when encrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part encryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_init_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptInitRequest`
        :param body: Multi-part encryption initialization request (required)
        :rtype: `EncryptInitResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_init" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `encrypt_init`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_init`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/encrypt/init', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptInitResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_init_ex(self, body, async_call=False, **kwargs):
        """
        This API is used when encrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part encryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptInitRequestEx`
        :param body: Multi-part encryption initialization request (required)
        :rtype: `EncryptInitResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_init_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_init_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def encrypt_init_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        This API is used when encrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part encryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_init_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptInitRequestEx`
        :param body: Multi-part encryption initialization request (required)
        :rtype: `EncryptInitResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_init_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_init_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/encrypt/init', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptInitResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_update(self, key_id, body, async_call=False, **kwargs):
        """
        Continue a multi-part encryption operation. See `encrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptUpdateRequest`
        :param body: Multi-part encryption (required)
        :rtype: `EncryptUpdateResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_update_with_http_info(key_id, body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_update_with_http_info(key_id, body, async_call=async_call, **kwargs)
            return data

    def encrypt_update_with_http_info(self, key_id, body, async_call=False, **kwargs):
        """
        Continue a multi-part encryption operation. See `encrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_update_with_http_info(key_id, body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type key_id: `str`
        :param key_id: kid of security object (required)
        :type body: `EncryptUpdateRequest`
        :param body: Multi-part encryption (required)
        :rtype: `EncryptUpdateResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['key_id', 'body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'key_id' is set
        if ('key_id' not in params) or (params['key_id'] is None):
            raise ValueError("Missing the required parameter `key_id` when calling `encrypt_update`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_update`")


        collection_formats = {}

        path_params = {}
        if 'key_id' in params:
            path_params['key-id'] = params['key_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/keys/{key-id}/encrypt/update', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptUpdateResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def encrypt_update_ex(self, body, async_call=False, **kwargs):
        """
        Continue a multi-part encryption operation. See `encrypt/init` for details. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptUpdateRequestEx`
        :param body: Multi-part encryption (required)
        :rtype: `EncryptUpdateResponse`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.encrypt_update_ex_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.encrypt_update_ex_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def encrypt_update_ex_with_http_info(self, body, async_call=False, **kwargs):
        """
        Continue a multi-part encryption operation. See `encrypt/init` for details. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.encrypt_update_ex_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptUpdateRequestEx`
        :param body: Multi-part encryption (required)
        :rtype: `EncryptUpdateResponse`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encrypt_update_ex" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `encrypt_update_ex`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/encrypt/update', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptUpdateResponse',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def stream_decrypt(self, body, async_call=False, **kwargs):
        """
        Decrypt a stream of data.  Like the multi-part API, this API is used when the data to be encrypted is large (>512KiB), or the size of the data is not known ahead of time.  It supports symmetric ciphers in the ECB, CBC, CBCNOPAD, CFB, OFB, CTR, and GCM modes of operation.  Unlike the multi-part API, a single long-running request is used, where the request and response bodies are streamed simultaneously.  <br> Both the request and response are a sequence of frames, each encoded in CBOR.  The frames are concatenated into a CBOR sequence, following RFC 8742.  The request consists of an \"init\" frame, zero or more \"ad\" frames, one or more \"cipher\" frames, and a \"final\" frame.  A successful response consists of an \"init\" frame, one or more \"plain\" frames, and a \"final\" frame.  <br> If an error occurs processing the \"init\" frame, the error is indicated as an HTTP status code and plain-text body, like all other APIs.  If an error occurs later, it is reported as an \"error\" frame, and no further frames are sent. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptRequestFrame`
        :param body: Stream of decrypt request frames (required)
        :rtype: `DecryptResponseFrame`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.stream_decrypt_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.stream_decrypt_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def stream_decrypt_with_http_info(self, body, async_call=False, **kwargs):
        """
        Decrypt a stream of data.  Like the multi-part API, this API is used when the data to be encrypted is large (>512KiB), or the size of the data is not known ahead of time.  It supports symmetric ciphers in the ECB, CBC, CBCNOPAD, CFB, OFB, CTR, and GCM modes of operation.  Unlike the multi-part API, a single long-running request is used, where the request and response bodies are streamed simultaneously.  <br> Both the request and response are a sequence of frames, each encoded in CBOR.  The frames are concatenated into a CBOR sequence, following RFC 8742.  The request consists of an \"init\" frame, zero or more \"ad\" frames, one or more \"cipher\" frames, and a \"final\" frame.  A successful response consists of an \"init\" frame, one or more \"plain\" frames, and a \"final\" frame.  <br> If an error occurs processing the \"init\" frame, the error is indicated as an HTTP status code and plain-text body, like all other APIs.  If an error occurs later, it is reported as an \"error\" frame, and no further frames are sent. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.stream_decrypt_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `DecryptRequestFrame`
        :param body: Stream of decrypt request frames (required)
        :rtype: `DecryptResponseFrame`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_decrypt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `stream_decrypt`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/cbor-seq'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/cbor-seq'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/stream/decrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DecryptResponseFrame',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def stream_encrypt(self, body, async_call=False, **kwargs):
        """
        Encrypt a stream of data.  Like the multi-part API, this API is used when the data to be encrypted is large (>512KiB), or the size of the data is not known ahead of time.  It supports symmetric ciphers in the ECB, CBC, CBCNOPAD, CFB, OFB, CTR, and GCM modes of operation.  Unlike the multi-part API, a single long-running request is used, where the request and response bodies are streamed simultaneously.  <br> Both the request and response are a sequence of frames, each encoded in CBOR.  The frames are concatenated into a CBOR sequence, following RFC 8742.  The request consists of an \"init\" frame, zero or more \"ad\" frames, one or more \"plain\" frames, and a \"final\" frame.  A successful response consists of an \"init\" frame, one or more \"cipher\" frames, and a \"final\" frame.  <br> If an error occurs processing the \"init\" frame, the error is indicated as an HTTP status code and plain-text body, like all other APIs.  If an error occurs later, it is reported as an \"error\" frame, and no further frames are sent. 

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptRequestFrame`
        :param body: Stream of encrypt request frames (required)
        :rtype: `EncryptResponseFrame`
        :return:
        
        If the method is called asynchronously, returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if async_call:
            return self.stream_encrypt_with_http_info(body, async_call=async_call, **kwargs)
        else:
            (data) = self.stream_encrypt_with_http_info(body, async_call=async_call, **kwargs)
            return data

    def stream_encrypt_with_http_info(self, body, async_call=False, **kwargs):
        """
        Encrypt a stream of data.  Like the multi-part API, this API is used when the data to be encrypted is large (>512KiB), or the size of the data is not known ahead of time.  It supports symmetric ciphers in the ECB, CBC, CBCNOPAD, CFB, OFB, CTR, and GCM modes of operation.  Unlike the multi-part API, a single long-running request is used, where the request and response bodies are streamed simultaneously.  <br> Both the request and response are a sequence of frames, each encoded in CBOR.  The frames are concatenated into a CBOR sequence, following RFC 8742.  The request consists of an \"init\" frame, zero or more \"ad\" frames, one or more \"plain\" frames, and a \"final\" frame.  A successful response consists of an \"init\" frame, one or more \"cipher\" frames, and a \"final\" frame.  <br> If an error occurs processing the \"init\" frame, the error is indicated as an HTTP status code and plain-text body, like all other APIs.  If an error occurs later, it is reported as an \"error\" frame, and no further frames are sent. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_call=True::

            >>> thread = api.stream_encrypt_with_http_info(body, async_call=True)
            >>> result = thread.get()

        :type async_call: bool
        :param async_call: Whether the call should be performed asynchronously. (Default is False).
        :type body: `EncryptRequestFrame`
        :param body: Stream of encrypt request frames (required)
        :rtype: `EncryptResponseFrame`
        :return:

        If the method is called asynchronously, returns the request thread.
        """

        all_params = ['body']
        all_params.append('async_call')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stream_encrypt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `stream_encrypt`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/cbor-seq'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/cbor-seq'])

        # Authentication setting
        auth_settings = ['bearerToken']

        return self.api_client.call_api('/crypto/v1/stream/encrypt', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EncryptResponseFrame',
                                        auth_settings=auth_settings,
                                        async_call=params.get('async_call'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
