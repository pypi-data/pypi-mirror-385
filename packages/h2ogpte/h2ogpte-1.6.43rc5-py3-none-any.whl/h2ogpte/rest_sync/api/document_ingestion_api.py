# coding: utf-8

"""
    h2oGPTe REST API

     # Overview   Users can easily interact with the h2oGPTe API through its REST API, allowing HTTP requests from any programming language.  ## Authorization: Getting an API key  Sign up/in at Enterprise h2oGPTe and generate one of the following two types of API keys:   - **Global API key**: If a Collection is not specified when creating a new API Key, that key is considered to be a global API Key. Use global API Keys to grant full user impersonation and system-wide access to all of your work. Anyone with access to one of your global API Keys can create, delete, or interact with any of your past, current, and future Collections, Documents, Chats, and settings.  - **Collection-specific API key**: Use Collection-specific API Keys to grant external access to only Chat with a specified Collection and make related API calls to it. Collection-specific API keys do not allow other API calls, such as creation, deletion, or access to other Collections or Chats.   Access Enterprise h2oGPTe through your [H2O Generative AI](https://genai.h2o.ai/appstore) app store account, available with a freemium tier.  ## Authorization: Using an API key   All h2oGPTe REST API requests must include an API Key in the \"Authorization\" HTTP header, formatted as follows:  ``` Authorization: Bearer sk-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ```  ```sh curl -X 'POST' \\   'https://h2ogpte.genai.h2o.ai/api/v1/collections' \\   -H 'accept: application/json' \\   -H 'Content-Type: application/json' \\   -H 'Authorization: Bearer sk-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' \\   -d '{     \"name\": \"The name of my Collection\",     \"description\": \"The description of my Collection\",     \"embedding_model\": \"BAAI/bge-large-en-v1.5\"   }' ```      ## Interactive h2oGPTe API testing  This page only showcases the h2oGPTe REST API; you can test it directly in the [Swagger UI](https://h2ogpte.genai.h2o.ai/swagger-ui/). Ensure that you are logged into your Enterprise h2oGPTe account. 

    The version of the OpenAPI document: v1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from h2ogpte.rest_sync.models.ingest_from_azure_blob_storage_body import IngestFromAzureBlobStorageBody
from h2ogpte.rest_sync.models.ingest_from_confluence_body import IngestFromConfluenceBody
from h2ogpte.rest_sync.models.ingest_from_file_system_body import IngestFromFileSystemBody
from h2ogpte.rest_sync.models.ingest_from_gcs_body import IngestFromGcsBody
from h2ogpte.rest_sync.models.ingest_from_s3_body import IngestFromS3Body
from h2ogpte.rest_sync.models.ingest_from_website_body import IngestFromWebsiteBody
from h2ogpte.rest_sync.models.ingest_upload_body import IngestUploadBody
from h2ogpte.rest_sync.models.job_details import JobDetails
from h2ogpte.rest_sync.models.uploaded_file import UploadedFile

from h2ogpte.rest_sync.api_client import ApiClient, RequestSerialized
from h2ogpte.rest_sync.api_response import ApiResponse
from h2ogpte.rest_sync.rest import RESTResponseType


class DocumentIngestionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_ingest_agent_only_to_standard_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        document_id: Annotated[StrictStr, Field(description="String id of the document to be parsed.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to parse files uploaded in \"agent_only\" ingest mode.

        Creates a job to parse files uploaded in \"agent_only\" ingest mode.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param document_id: String id of the document to be parsed. (required)
        :type document_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_agent_only_to_standard_job_serialize(
            collection_id=collection_id,
            document_id=document_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            restricted=restricted,
            permissions=permissions,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_agent_only_to_standard_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        document_id: Annotated[StrictStr, Field(description="String id of the document to be parsed.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to parse files uploaded in \"agent_only\" ingest mode.

        Creates a job to parse files uploaded in \"agent_only\" ingest mode.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param document_id: String id of the document to be parsed. (required)
        :type document_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_agent_only_to_standard_job_serialize(
            collection_id=collection_id,
            document_id=document_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            restricted=restricted,
            permissions=permissions,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_agent_only_to_standard_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        document_id: Annotated[StrictStr, Field(description="String id of the document to be parsed.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to parse files uploaded in \"agent_only\" ingest mode.

        Creates a job to parse files uploaded in \"agent_only\" ingest mode.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param document_id: String id of the document to be parsed. (required)
        :type document_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_agent_only_to_standard_job_serialize(
            collection_id=collection_id,
            document_id=document_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            restricted=restricted,
            permissions=permissions,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_agent_only_to_standard_job_serialize(
        self,
        collection_id,
        document_id,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        restricted,
        permissions,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'permissions': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if document_id is not None:
            
            _query_params.append(('document_id', document_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if restricted is not None:
            
            _query_params.append(('restricted', restricted))
            
        if permissions is not None:
            
            _query_params.append(('permissions', permissions))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/agent_only_to_standard/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_azure_blob_storage_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to add files from the Azure Blob Storage into a collection.

        Creates a job to add files from the Azure Blob Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_azure_blob_storage_body: (required)
        :type ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_azure_blob_storage_job_serialize(
            collection_id=collection_id,
            ingest_from_azure_blob_storage_body=ingest_from_azure_blob_storage_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_azure_blob_storage_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to add files from the Azure Blob Storage into a collection.

        Creates a job to add files from the Azure Blob Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_azure_blob_storage_body: (required)
        :type ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_azure_blob_storage_job_serialize(
            collection_id=collection_id,
            ingest_from_azure_blob_storage_body=ingest_from_azure_blob_storage_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_azure_blob_storage_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to add files from the Azure Blob Storage into a collection.

        Creates a job to add files from the Azure Blob Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_azure_blob_storage_body: (required)
        :type ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_azure_blob_storage_job_serialize(
            collection_id=collection_id,
            ingest_from_azure_blob_storage_body=ingest_from_azure_blob_storage_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_azure_blob_storage_job_serialize(
        self,
        collection_id,
        ingest_from_azure_blob_storage_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_azure_blob_storage_body is not None:
            _body_params = ingest_from_azure_blob_storage_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/azure_blob_storage/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_confluence_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_confluence_body: IngestFromConfluenceBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to ingest confluence pages into collection.

        Creates a job to confluence pages into collection. If an ingested page has sub-pages, the subpages are also ingested.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_confluence_body: (required)
        :type ingest_from_confluence_body: IngestFromConfluenceBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_confluence_job_serialize(
            collection_id=collection_id,
            ingest_from_confluence_body=ingest_from_confluence_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_confluence_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_confluence_body: IngestFromConfluenceBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to ingest confluence pages into collection.

        Creates a job to confluence pages into collection. If an ingested page has sub-pages, the subpages are also ingested.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_confluence_body: (required)
        :type ingest_from_confluence_body: IngestFromConfluenceBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_confluence_job_serialize(
            collection_id=collection_id,
            ingest_from_confluence_body=ingest_from_confluence_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_confluence_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_confluence_body: IngestFromConfluenceBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to ingest confluence pages into collection.

        Creates a job to confluence pages into collection. If an ingested page has sub-pages, the subpages are also ingested.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_confluence_body: (required)
        :type ingest_from_confluence_body: IngestFromConfluenceBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_confluence_job_serialize(
            collection_id=collection_id,
            ingest_from_confluence_body=ingest_from_confluence_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_confluence_job_serialize(
        self,
        collection_id,
        ingest_from_confluence_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_confluence_body is not None:
            _body_params = ingest_from_confluence_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/confluence/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_file_system_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_file_system_body: IngestFromFileSystemBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to add files from the local system into a collection.

        Creates a job to add files from the local system into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_file_system_body: (required)
        :type ingest_from_file_system_body: IngestFromFileSystemBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_file_system_job_serialize(
            collection_id=collection_id,
            ingest_from_file_system_body=ingest_from_file_system_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_file_system_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_file_system_body: IngestFromFileSystemBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to add files from the local system into a collection.

        Creates a job to add files from the local system into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_file_system_body: (required)
        :type ingest_from_file_system_body: IngestFromFileSystemBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_file_system_job_serialize(
            collection_id=collection_id,
            ingest_from_file_system_body=ingest_from_file_system_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_file_system_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_file_system_body: IngestFromFileSystemBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to add files from the local system into a collection.

        Creates a job to add files from the local system into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_file_system_body: (required)
        :type ingest_from_file_system_body: IngestFromFileSystemBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_file_system_job_serialize(
            collection_id=collection_id,
            ingest_from_file_system_body=ingest_from_file_system_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_file_system_job_serialize(
        self,
        collection_id,
        ingest_from_file_system_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_file_system_body is not None:
            _body_params = ingest_from_file_system_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/file_system/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_gcs_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_gcs_body: IngestFromGcsBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to add files from the Google Cloud Storage into a collection.

        Creates a job to add files from the Google Cloud Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_gcs_body: (required)
        :type ingest_from_gcs_body: IngestFromGcsBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_gcs_job_serialize(
            collection_id=collection_id,
            ingest_from_gcs_body=ingest_from_gcs_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_gcs_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_gcs_body: IngestFromGcsBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to add files from the Google Cloud Storage into a collection.

        Creates a job to add files from the Google Cloud Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_gcs_body: (required)
        :type ingest_from_gcs_body: IngestFromGcsBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_gcs_job_serialize(
            collection_id=collection_id,
            ingest_from_gcs_body=ingest_from_gcs_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_gcs_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_gcs_body: IngestFromGcsBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to add files from the Google Cloud Storage into a collection.

        Creates a job to add files from the Google Cloud Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_gcs_body: (required)
        :type ingest_from_gcs_body: IngestFromGcsBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_gcs_job_serialize(
            collection_id=collection_id,
            ingest_from_gcs_body=ingest_from_gcs_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_gcs_job_serialize(
        self,
        collection_id,
        ingest_from_gcs_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_gcs_body is not None:
            _body_params = ingest_from_gcs_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/gcs/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_plain_text_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        file_name: Annotated[StrictStr, Field(description="String of the file name to use for the document.")],
        body: Annotated[StrictStr, Field(description="The text that will ingested into a collection.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="String with json-encoded metadata for the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to add plain text to a collection.

        Creates a job to add plain text to a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param file_name: String of the file name to use for the document. (required)
        :type file_name: str
        :param body: The text that will ingested into a collection. (required)
        :type body: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param metadata: String with json-encoded metadata for the document.
        :type metadata: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_plain_text_job_serialize(
            collection_id=collection_id,
            file_name=file_name,
            body=body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            metadata=metadata,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_plain_text_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        file_name: Annotated[StrictStr, Field(description="String of the file name to use for the document.")],
        body: Annotated[StrictStr, Field(description="The text that will ingested into a collection.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="String with json-encoded metadata for the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to add plain text to a collection.

        Creates a job to add plain text to a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param file_name: String of the file name to use for the document. (required)
        :type file_name: str
        :param body: The text that will ingested into a collection. (required)
        :type body: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param metadata: String with json-encoded metadata for the document.
        :type metadata: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_plain_text_job_serialize(
            collection_id=collection_id,
            file_name=file_name,
            body=body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            metadata=metadata,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_plain_text_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        file_name: Annotated[StrictStr, Field(description="String of the file name to use for the document.")],
        body: Annotated[StrictStr, Field(description="The text that will ingested into a collection.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="String with json-encoded metadata for the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to add plain text to a collection.

        Creates a job to add plain text to a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param file_name: String of the file name to use for the document. (required)
        :type file_name: str
        :param body: The text that will ingested into a collection. (required)
        :type body: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param metadata: String with json-encoded metadata for the document.
        :type metadata: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_plain_text_job_serialize(
            collection_id=collection_id,
            file_name=file_name,
            body=body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            metadata=metadata,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_plain_text_job_serialize(
        self,
        collection_id,
        file_name,
        body,
        gen_doc_summaries,
        gen_doc_questions,
        metadata,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if file_name is not None:
            
            _query_params.append(('file_name', file_name))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'text/plain'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/plain_text/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_s3_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_s3_body: IngestFromS3Body,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to add files from the AWS S3 storage into a collection.

        Creates a job to add files from the AWS S3 storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_s3_body: (required)
        :type ingest_from_s3_body: IngestFromS3Body
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_s3_job_serialize(
            collection_id=collection_id,
            ingest_from_s3_body=ingest_from_s3_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_s3_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_s3_body: IngestFromS3Body,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to add files from the AWS S3 storage into a collection.

        Creates a job to add files from the AWS S3 storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_s3_body: (required)
        :type ingest_from_s3_body: IngestFromS3Body
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_s3_job_serialize(
            collection_id=collection_id,
            ingest_from_s3_body=ingest_from_s3_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_s3_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_s3_body: IngestFromS3Body,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to add files from the AWS S3 storage into a collection.

        Creates a job to add files from the AWS S3 storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_s3_body: (required)
        :type ingest_from_s3_body: IngestFromS3Body
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_s3_job_serialize(
            collection_id=collection_id,
            ingest_from_s3_body=ingest_from_s3_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_s3_job_serialize(
        self,
        collection_id,
        ingest_from_s3_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_s3_body is not None:
            _body_params = ingest_from_s3_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/s3/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_from_website_job(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_website_body: IngestFromWebsiteBody,
        follow_links: Annotated[Optional[StrictBool], Field(description="Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.")] = None,
        max_depth: Annotated[Optional[StrictInt], Field(description="Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).")] = None,
        max_documents: Annotated[Optional[StrictInt], Field(description="Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).")] = None,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to crawl and ingest a URL into a collection.

        Creates a job to crawl and ingest a URL into a collection. The web page or document linked from this URL will be imported.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_website_body: (required)
        :type ingest_from_website_body: IngestFromWebsiteBody
        :param follow_links: Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.
        :type follow_links: bool
        :param max_depth: Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).
        :type max_depth: int
        :param max_documents: Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).
        :type max_documents: int
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_website_job_serialize(
            collection_id=collection_id,
            ingest_from_website_body=ingest_from_website_body,
            follow_links=follow_links,
            max_depth=max_depth,
            max_documents=max_documents,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_from_website_job_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_website_body: IngestFromWebsiteBody,
        follow_links: Annotated[Optional[StrictBool], Field(description="Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.")] = None,
        max_depth: Annotated[Optional[StrictInt], Field(description="Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).")] = None,
        max_documents: Annotated[Optional[StrictInt], Field(description="Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).")] = None,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to crawl and ingest a URL into a collection.

        Creates a job to crawl and ingest a URL into a collection. The web page or document linked from this URL will be imported.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_website_body: (required)
        :type ingest_from_website_body: IngestFromWebsiteBody
        :param follow_links: Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.
        :type follow_links: bool
        :param max_depth: Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).
        :type max_depth: int
        :param max_documents: Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).
        :type max_documents: int
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_website_job_serialize(
            collection_id=collection_id,
            ingest_from_website_body=ingest_from_website_body,
            follow_links=follow_links,
            max_depth=max_depth,
            max_documents=max_documents,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_from_website_job_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_website_body: IngestFromWebsiteBody,
        follow_links: Annotated[Optional[StrictBool], Field(description="Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.")] = None,
        max_depth: Annotated[Optional[StrictInt], Field(description="Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).")] = None,
        max_documents: Annotated[Optional[StrictInt], Field(description="Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).")] = None,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to crawl and ingest a URL into a collection.

        Creates a job to crawl and ingest a URL into a collection. The web page or document linked from this URL will be imported.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_website_body: (required)
        :type ingest_from_website_body: IngestFromWebsiteBody
        :param follow_links: Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.
        :type follow_links: bool
        :param max_depth: Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).
        :type max_depth: int
        :param max_documents: Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).
        :type max_documents: int
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_from_website_job_serialize(
            collection_id=collection_id,
            ingest_from_website_body=ingest_from_website_body,
            follow_links=follow_links,
            max_depth=max_depth,
            max_documents=max_documents,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_from_website_job_serialize(
        self,
        collection_id,
        ingest_from_website_body,
        follow_links,
        max_depth,
        max_documents,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if follow_links is not None:
            
            _query_params.append(('follow_links', follow_links))
            
        if max_depth is not None:
            
            _query_params.append(('max_depth', max_depth))
            
        if max_documents is not None:
            
            _query_params.append(('max_documents', max_documents))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_website_body is not None:
            _body_params = ingest_from_website_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/website/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_ingest_upload_job(
        self,
        upload_ids: Annotated[List[StrictStr], Field(description="Id of uploaded document")],
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        ingest_upload_body: Optional[IngestUploadBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobDetails:
        """Creates a job to ingest uploaded document

        Creates a job to ingest uploaded document identified to a given collection

        :param upload_ids: Id of uploaded document (required)
        :type upload_ids: List[str]
        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param timeout: Timeout in seconds
        :type timeout: float
        :param ingest_upload_body:
        :type ingest_upload_body: IngestUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_upload_job_serialize(
            upload_ids=upload_ids,
            collection_id=collection_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            restricted=restricted,
            permissions=permissions,
            timeout=timeout,
            ingest_upload_body=ingest_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_ingest_upload_job_with_http_info(
        self,
        upload_ids: Annotated[List[StrictStr], Field(description="Id of uploaded document")],
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        ingest_upload_body: Optional[IngestUploadBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobDetails]:
        """Creates a job to ingest uploaded document

        Creates a job to ingest uploaded document identified to a given collection

        :param upload_ids: Id of uploaded document (required)
        :type upload_ids: List[str]
        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param timeout: Timeout in seconds
        :type timeout: float
        :param ingest_upload_body:
        :type ingest_upload_body: IngestUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_upload_job_serialize(
            upload_ids=upload_ids,
            collection_id=collection_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            restricted=restricted,
            permissions=permissions,
            timeout=timeout,
            ingest_upload_body=ingest_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_ingest_upload_job_without_preload_content(
        self,
        upload_ids: Annotated[List[StrictStr], Field(description="Id of uploaded document")],
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        ingest_upload_body: Optional[IngestUploadBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates a job to ingest uploaded document

        Creates a job to ingest uploaded document identified to a given collection

        :param upload_ids: Id of uploaded document (required)
        :type upload_ids: List[str]
        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param timeout: Timeout in seconds
        :type timeout: float
        :param ingest_upload_body:
        :type ingest_upload_body: IngestUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_ingest_upload_job_serialize(
            upload_ids=upload_ids,
            collection_id=collection_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            restricted=restricted,
            permissions=permissions,
            timeout=timeout,
            ingest_upload_body=ingest_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "JobDetails",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_ingest_upload_job_serialize(
        self,
        upload_ids,
        collection_id,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        restricted,
        permissions,
        timeout,
        ingest_upload_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'upload_ids': 'csv',
            'permissions': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if upload_ids is not None:
            _path_params['upload_ids'] = upload_ids
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if restricted is not None:
            
            _query_params.append(('restricted', restricted))
            
        if permissions is not None:
            
            _query_params.append(('permissions', permissions))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_upload_body is not None:
            _body_params = ingest_upload_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/uploads/{upload_ids}/ingest/job',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_agent_only_to_standard(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        document_id: Annotated[StrictStr, Field(description="String id of the document to be parsed.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Converts files uploaded in \"agent_only\" ingest mode  to PDF and parses them.

        Converts files uploaded in \"agent_only\" ingest mode  to PDF and parses them.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param document_id: String id of the document to be parsed. (required)
        :type document_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_agent_only_to_standard_serialize(
            collection_id=collection_id,
            document_id=document_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            restricted=restricted,
            permissions=permissions,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_agent_only_to_standard_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        document_id: Annotated[StrictStr, Field(description="String id of the document to be parsed.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Converts files uploaded in \"agent_only\" ingest mode  to PDF and parses them.

        Converts files uploaded in \"agent_only\" ingest mode  to PDF and parses them.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param document_id: String id of the document to be parsed. (required)
        :type document_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_agent_only_to_standard_serialize(
            collection_id=collection_id,
            document_id=document_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            restricted=restricted,
            permissions=permissions,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_agent_only_to_standard_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        document_id: Annotated[StrictStr, Field(description="String id of the document to be parsed.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Converts files uploaded in \"agent_only\" ingest mode  to PDF and parses them.

        Converts files uploaded in \"agent_only\" ingest mode  to PDF and parses them.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param document_id: String id of the document to be parsed. (required)
        :type document_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_agent_only_to_standard_serialize(
            collection_id=collection_id,
            document_id=document_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            restricted=restricted,
            permissions=permissions,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_agent_only_to_standard_serialize(
        self,
        collection_id,
        document_id,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        restricted,
        permissions,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'permissions': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if document_id is not None:
            
            _query_params.append(('document_id', document_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if restricted is not None:
            
            _query_params.append(('restricted', restricted))
            
        if permissions is not None:
            
            _query_params.append(('permissions', permissions))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/agent_only_to_standard',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_azure_blob_storage(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Adds files from the Azure Blob Storage into a collection.

        Adds files from the Azure Blob Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_azure_blob_storage_body: (required)
        :type ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_azure_blob_storage_serialize(
            collection_id=collection_id,
            ingest_from_azure_blob_storage_body=ingest_from_azure_blob_storage_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_azure_blob_storage_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Adds files from the Azure Blob Storage into a collection.

        Adds files from the Azure Blob Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_azure_blob_storage_body: (required)
        :type ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_azure_blob_storage_serialize(
            collection_id=collection_id,
            ingest_from_azure_blob_storage_body=ingest_from_azure_blob_storage_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_azure_blob_storage_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds files from the Azure Blob Storage into a collection.

        Adds files from the Azure Blob Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_azure_blob_storage_body: (required)
        :type ingest_from_azure_blob_storage_body: IngestFromAzureBlobStorageBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_azure_blob_storage_serialize(
            collection_id=collection_id,
            ingest_from_azure_blob_storage_body=ingest_from_azure_blob_storage_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_azure_blob_storage_serialize(
        self,
        collection_id,
        ingest_from_azure_blob_storage_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_azure_blob_storage_body is not None:
            _body_params = ingest_from_azure_blob_storage_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/azure_blob_storage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_confluence(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_confluence_body: IngestFromConfluenceBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Ingests confluence pages into collection.

        Ingests confluence pages into collection. If an ingested page has sub-pages, the subpages are also ingested.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_confluence_body: (required)
        :type ingest_from_confluence_body: IngestFromConfluenceBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_confluence_serialize(
            collection_id=collection_id,
            ingest_from_confluence_body=ingest_from_confluence_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_confluence_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_confluence_body: IngestFromConfluenceBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Ingests confluence pages into collection.

        Ingests confluence pages into collection. If an ingested page has sub-pages, the subpages are also ingested.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_confluence_body: (required)
        :type ingest_from_confluence_body: IngestFromConfluenceBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_confluence_serialize(
            collection_id=collection_id,
            ingest_from_confluence_body=ingest_from_confluence_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_confluence_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_confluence_body: IngestFromConfluenceBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ingests confluence pages into collection.

        Ingests confluence pages into collection. If an ingested page has sub-pages, the subpages are also ingested.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_confluence_body: (required)
        :type ingest_from_confluence_body: IngestFromConfluenceBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_confluence_serialize(
            collection_id=collection_id,
            ingest_from_confluence_body=ingest_from_confluence_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_confluence_serialize(
        self,
        collection_id,
        ingest_from_confluence_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_confluence_body is not None:
            _body_params = ingest_from_confluence_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/confluence',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_file_system(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_file_system_body: IngestFromFileSystemBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Adds files from the local system into a collection.

        Adds files from the local system into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_file_system_body: (required)
        :type ingest_from_file_system_body: IngestFromFileSystemBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_file_system_serialize(
            collection_id=collection_id,
            ingest_from_file_system_body=ingest_from_file_system_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_file_system_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_file_system_body: IngestFromFileSystemBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Adds files from the local system into a collection.

        Adds files from the local system into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_file_system_body: (required)
        :type ingest_from_file_system_body: IngestFromFileSystemBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_file_system_serialize(
            collection_id=collection_id,
            ingest_from_file_system_body=ingest_from_file_system_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_file_system_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_file_system_body: IngestFromFileSystemBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds files from the local system into a collection.

        Adds files from the local system into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_file_system_body: (required)
        :type ingest_from_file_system_body: IngestFromFileSystemBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_file_system_serialize(
            collection_id=collection_id,
            ingest_from_file_system_body=ingest_from_file_system_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_file_system_serialize(
        self,
        collection_id,
        ingest_from_file_system_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_file_system_body is not None:
            _body_params = ingest_from_file_system_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/file_system',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_gcs(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_gcs_body: IngestFromGcsBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Adds files from the Google Cloud Storage into a collection.

        Adds files from the Google Cloud Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_gcs_body: (required)
        :type ingest_from_gcs_body: IngestFromGcsBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_gcs_serialize(
            collection_id=collection_id,
            ingest_from_gcs_body=ingest_from_gcs_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_gcs_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_gcs_body: IngestFromGcsBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Adds files from the Google Cloud Storage into a collection.

        Adds files from the Google Cloud Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_gcs_body: (required)
        :type ingest_from_gcs_body: IngestFromGcsBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_gcs_serialize(
            collection_id=collection_id,
            ingest_from_gcs_body=ingest_from_gcs_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_gcs_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_gcs_body: IngestFromGcsBody,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds files from the Google Cloud Storage into a collection.

        Adds files from the Google Cloud Storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_gcs_body: (required)
        :type ingest_from_gcs_body: IngestFromGcsBody
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_gcs_serialize(
            collection_id=collection_id,
            ingest_from_gcs_body=ingest_from_gcs_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_gcs_serialize(
        self,
        collection_id,
        ingest_from_gcs_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_gcs_body is not None:
            _body_params = ingest_from_gcs_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/gcs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_plain_text(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        file_name: Annotated[StrictStr, Field(description="String of the file name to use for the document.")],
        body: Annotated[StrictStr, Field(description="The text that will ingested into a collection.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="String with json-encoded metadata for the document.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Adds plain text to a collection.

        Adds plain text to a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param file_name: String of the file name to use for the document. (required)
        :type file_name: str
        :param body: The text that will ingested into a collection. (required)
        :type body: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param metadata: String with json-encoded metadata for the document.
        :type metadata: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_plain_text_serialize(
            collection_id=collection_id,
            file_name=file_name,
            body=body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            timeout=timeout,
            metadata=metadata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_plain_text_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        file_name: Annotated[StrictStr, Field(description="String of the file name to use for the document.")],
        body: Annotated[StrictStr, Field(description="The text that will ingested into a collection.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="String with json-encoded metadata for the document.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Adds plain text to a collection.

        Adds plain text to a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param file_name: String of the file name to use for the document. (required)
        :type file_name: str
        :param body: The text that will ingested into a collection. (required)
        :type body: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param metadata: String with json-encoded metadata for the document.
        :type metadata: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_plain_text_serialize(
            collection_id=collection_id,
            file_name=file_name,
            body=body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            timeout=timeout,
            metadata=metadata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_plain_text_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        file_name: Annotated[StrictStr, Field(description="String of the file name to use for the document.")],
        body: Annotated[StrictStr, Field(description="The text that will ingested into a collection.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        metadata: Annotated[Optional[StrictStr], Field(description="String with json-encoded metadata for the document.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds plain text to a collection.

        Adds plain text to a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param file_name: String of the file name to use for the document. (required)
        :type file_name: str
        :param body: The text that will ingested into a collection. (required)
        :type body: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param timeout: Timeout in seconds
        :type timeout: float
        :param metadata: String with json-encoded metadata for the document.
        :type metadata: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_plain_text_serialize(
            collection_id=collection_id,
            file_name=file_name,
            body=body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            timeout=timeout,
            metadata=metadata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_plain_text_serialize(
        self,
        collection_id,
        file_name,
        body,
        gen_doc_summaries,
        gen_doc_questions,
        timeout,
        metadata,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if file_name is not None:
            
            _query_params.append(('file_name', file_name))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        if metadata is not None:
            
            _query_params.append(('metadata', metadata))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'text/plain'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/plain_text',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_s3(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_s3_body: IngestFromS3Body,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Adds files from the AWS S3 storage into a collection.

        Adds files from the AWS S3 storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_s3_body: (required)
        :type ingest_from_s3_body: IngestFromS3Body
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_s3_serialize(
            collection_id=collection_id,
            ingest_from_s3_body=ingest_from_s3_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_s3_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_s3_body: IngestFromS3Body,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Adds files from the AWS S3 storage into a collection.

        Adds files from the AWS S3 storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_s3_body: (required)
        :type ingest_from_s3_body: IngestFromS3Body
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_s3_serialize(
            collection_id=collection_id,
            ingest_from_s3_body=ingest_from_s3_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_s3_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_s3_body: IngestFromS3Body,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Adds files from the AWS S3 storage into a collection.

        Adds files from the AWS S3 storage into a collection.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_s3_body: (required)
        :type ingest_from_s3_body: IngestFromS3Body
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_s3_serialize(
            collection_id=collection_id,
            ingest_from_s3_body=ingest_from_s3_body,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_s3_serialize(
        self,
        collection_id,
        ingest_from_s3_body,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_s3_body is not None:
            _body_params = ingest_from_s3_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/s3',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_from_website(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_website_body: IngestFromWebsiteBody,
        follow_links: Annotated[Optional[StrictBool], Field(description="Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.")] = None,
        max_depth: Annotated[Optional[StrictInt], Field(description="Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).")] = None,
        max_documents: Annotated[Optional[StrictInt], Field(description="Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).")] = None,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Crawls and ingest a URL into a collection.

        Crawls and ingest a URL into a collection. The web page or document linked from this URL will be imported.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_website_body: (required)
        :type ingest_from_website_body: IngestFromWebsiteBody
        :param follow_links: Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.
        :type follow_links: bool
        :param max_depth: Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).
        :type max_depth: int
        :param max_documents: Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).
        :type max_documents: int
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_website_serialize(
            collection_id=collection_id,
            ingest_from_website_body=ingest_from_website_body,
            follow_links=follow_links,
            max_depth=max_depth,
            max_documents=max_documents,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_from_website_with_http_info(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_website_body: IngestFromWebsiteBody,
        follow_links: Annotated[Optional[StrictBool], Field(description="Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.")] = None,
        max_depth: Annotated[Optional[StrictInt], Field(description="Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).")] = None,
        max_documents: Annotated[Optional[StrictInt], Field(description="Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).")] = None,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Crawls and ingest a URL into a collection.

        Crawls and ingest a URL into a collection. The web page or document linked from this URL will be imported.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_website_body: (required)
        :type ingest_from_website_body: IngestFromWebsiteBody
        :param follow_links: Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.
        :type follow_links: bool
        :param max_depth: Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).
        :type max_depth: int
        :param max_documents: Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).
        :type max_documents: int
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_website_serialize(
            collection_id=collection_id,
            ingest_from_website_body=ingest_from_website_body,
            follow_links=follow_links,
            max_depth=max_depth,
            max_documents=max_documents,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_from_website_without_preload_content(
        self,
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        ingest_from_website_body: IngestFromWebsiteBody,
        follow_links: Annotated[Optional[StrictBool], Field(description="Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.")] = None,
        max_depth: Annotated[Optional[StrictInt], Field(description="Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).")] = None,
        max_documents: Annotated[Optional[StrictInt], Field(description="Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).")] = None,
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Crawls and ingest a URL into a collection.

        Crawls and ingest a URL into a collection. The web page or document linked from this URL will be imported.

        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param ingest_from_website_body: (required)
        :type ingest_from_website_body: IngestFromWebsiteBody
        :param follow_links: Whether to import all web pages linked from this URL will be imported. External links will be ignored. Links to other pages on the same domain will be followed as long as they are at the same level or below the URL you specify. Each page will be transformed into a PDF document.
        :type follow_links: bool
        :param max_depth: Max depth of recursion when following links, only when follow_links is `true`. Max_depth of 0 means don't follow any links, max_depth of 1 means follow only top-level links, etc. Use -1 for automatic (system settings).
        :type max_depth: int
        :param max_documents: Max number of documents when following links, only when follow_links is `true`. Use None for automatic (system defaults). Use -1 for max (system limit).
        :type max_documents: int
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param timeout: Timeout in seconds
        :type timeout: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_from_website_serialize(
            collection_id=collection_id,
            ingest_from_website_body=ingest_from_website_body,
            follow_links=follow_links,
            max_depth=max_depth,
            max_documents=max_documents,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            timeout=timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_from_website_serialize(
        self,
        collection_id,
        ingest_from_website_body,
        follow_links,
        max_depth,
        max_documents,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if follow_links is not None:
            
            _query_params.append(('follow_links', follow_links))
            
        if max_depth is not None:
            
            _query_params.append(('max_depth', max_depth))
            
        if max_documents is not None:
            
            _query_params.append(('max_documents', max_documents))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_from_website_body is not None:
            _body_params = ingest_from_website_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ingest/website',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingest_upload(
        self,
        upload_ids: Annotated[List[StrictStr], Field(description="Id of uploaded document")],
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        ingest_upload_body: Optional[IngestUploadBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Ingest uploaded document

        Ingests uploaded document identified to a given collection

        :param upload_ids: Id of uploaded document (required)
        :type upload_ids: List[str]
        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param timeout: Timeout in seconds
        :type timeout: float
        :param ingest_upload_body:
        :type ingest_upload_body: IngestUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_upload_serialize(
            upload_ids=upload_ids,
            collection_id=collection_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            restricted=restricted,
            permissions=permissions,
            timeout=timeout,
            ingest_upload_body=ingest_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingest_upload_with_http_info(
        self,
        upload_ids: Annotated[List[StrictStr], Field(description="Id of uploaded document")],
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        ingest_upload_body: Optional[IngestUploadBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Ingest uploaded document

        Ingests uploaded document identified to a given collection

        :param upload_ids: Id of uploaded document (required)
        :type upload_ids: List[str]
        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param timeout: Timeout in seconds
        :type timeout: float
        :param ingest_upload_body:
        :type ingest_upload_body: IngestUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_upload_serialize(
            upload_ids=upload_ids,
            collection_id=collection_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            restricted=restricted,
            permissions=permissions,
            timeout=timeout,
            ingest_upload_body=ingest_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingest_upload_without_preload_content(
        self,
        upload_ids: Annotated[List[StrictStr], Field(description="Id of uploaded document")],
        collection_id: Annotated[StrictStr, Field(description="String id of the collection to add the ingested documents into.")],
        gen_doc_summaries: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate document summaries (uses LLM).")] = None,
        gen_doc_questions: Annotated[Optional[StrictBool], Field(description="Whether to auto-generate sample questions for each document (uses LLM).")] = None,
        audio_input_language: Annotated[Optional[StrictStr], Field(description="Language of audio files.")] = None,
        ocr_model: Annotated[Optional[StrictStr], Field(description="Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).")] = None,
        tesseract_lang: Annotated[Optional[StrictStr], Field(description="Which language to use when using ocr_model=\"tesseract\".")] = None,
        keep_tables_as_one_chunk: Annotated[Optional[StrictBool], Field(description="When tables are identified by the table parser the table tokens will be kept in a single chunk.")] = None,
        chunk_by_page: Annotated[Optional[StrictBool], Field(description="Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.")] = None,
        handwriting_check: Annotated[Optional[StrictBool], Field(description="Check pages for handwriting. Will use specialized models if handwriting is found.")] = None,
        ingest_mode: Annotated[Optional[StrictStr], Field(description="Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.")] = None,
        restricted: Annotated[Optional[StrictBool], Field(description="Whether the document should be restricted only to certain users.")] = None,
        permissions: Annotated[Optional[List[StrictStr]], Field(description="The list of usernames having permissions to the document.")] = None,
        timeout: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timeout in seconds")] = None,
        ingest_upload_body: Optional[IngestUploadBody] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ingest uploaded document

        Ingests uploaded document identified to a given collection

        :param upload_ids: Id of uploaded document (required)
        :type upload_ids: List[str]
        :param collection_id: String id of the collection to add the ingested documents into. (required)
        :type collection_id: str
        :param gen_doc_summaries: Whether to auto-generate document summaries (uses LLM).
        :type gen_doc_summaries: bool
        :param gen_doc_questions: Whether to auto-generate sample questions for each document (uses LLM).
        :type gen_doc_questions: bool
        :param audio_input_language: Language of audio files.
        :type audio_input_language: str
        :param ocr_model: Which method to use to extract text from images using AI-enabled optical character recognition (OCR) models. docTR is best for Latin text, PaddleOCR is best for certain non-Latin languages, Tesseract covers a wide range of languages. Mississippi works well on handwriting. - `auto` - Automatic will auto-select the best OCR model for every page. - `off` - Disable OCR for speed, but all images will then be skipped (also no image captions will be made).
        :type ocr_model: str
        :param tesseract_lang: Which language to use when using ocr_model=\"tesseract\".
        :type tesseract_lang: str
        :param keep_tables_as_one_chunk: When tables are identified by the table parser the table tokens will be kept in a single chunk.
        :type keep_tables_as_one_chunk: bool
        :param chunk_by_page: Each page will be a chunk. `keep_tables_as_one_chunk` will be ignored if this is `true`.
        :type chunk_by_page: bool
        :param handwriting_check: Check pages for handwriting. Will use specialized models if handwriting is found.
        :type handwriting_check: bool
        :param ingest_mode: Ingest mode to use. - `standard` - Files will be ingested for use with RAG - `agent_only` - Bypasses standard ingestion. Files can only be used with agents.
        :type ingest_mode: str
        :param restricted: Whether the document should be restricted only to certain users.
        :type restricted: bool
        :param permissions: The list of usernames having permissions to the document.
        :type permissions: List[str]
        :param timeout: Timeout in seconds
        :type timeout: float
        :param ingest_upload_body:
        :type ingest_upload_body: IngestUploadBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingest_upload_serialize(
            upload_ids=upload_ids,
            collection_id=collection_id,
            gen_doc_summaries=gen_doc_summaries,
            gen_doc_questions=gen_doc_questions,
            audio_input_language=audio_input_language,
            ocr_model=ocr_model,
            tesseract_lang=tesseract_lang,
            keep_tables_as_one_chunk=keep_tables_as_one_chunk,
            chunk_by_page=chunk_by_page,
            handwriting_check=handwriting_check,
            ingest_mode=ingest_mode,
            restricted=restricted,
            permissions=permissions,
            timeout=timeout,
            ingest_upload_body=ingest_upload_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingest_upload_serialize(
        self,
        upload_ids,
        collection_id,
        gen_doc_summaries,
        gen_doc_questions,
        audio_input_language,
        ocr_model,
        tesseract_lang,
        keep_tables_as_one_chunk,
        chunk_by_page,
        handwriting_check,
        ingest_mode,
        restricted,
        permissions,
        timeout,
        ingest_upload_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'upload_ids': 'csv',
            'permissions': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if upload_ids is not None:
            _path_params['upload_ids'] = upload_ids
        # process the query parameters
        if collection_id is not None:
            
            _query_params.append(('collection_id', collection_id))
            
        if gen_doc_summaries is not None:
            
            _query_params.append(('gen_doc_summaries', gen_doc_summaries))
            
        if gen_doc_questions is not None:
            
            _query_params.append(('gen_doc_questions', gen_doc_questions))
            
        if audio_input_language is not None:
            
            _query_params.append(('audio_input_language', audio_input_language))
            
        if ocr_model is not None:
            
            _query_params.append(('ocr_model', ocr_model))
            
        if tesseract_lang is not None:
            
            _query_params.append(('tesseract_lang', tesseract_lang))
            
        if keep_tables_as_one_chunk is not None:
            
            _query_params.append(('keep_tables_as_one_chunk', keep_tables_as_one_chunk))
            
        if chunk_by_page is not None:
            
            _query_params.append(('chunk_by_page', chunk_by_page))
            
        if handwriting_check is not None:
            
            _query_params.append(('handwriting_check', handwriting_check))
            
        if ingest_mode is not None:
            
            _query_params.append(('ingest_mode', ingest_mode))
            
        if restricted is not None:
            
            _query_params.append(('restricted', restricted))
            
        if permissions is not None:
            
            _query_params.append(('permissions', permissions))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ingest_upload_body is not None:
            _body_params = ingest_upload_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/uploads/{upload_ids}/ingest',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def upload_file(
        self,
        file: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UploadedFile:
        """upload_file

        Uploads file to H2OGPTe instance

        :param file:
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_serialize(
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UploadedFile",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def upload_file_with_http_info(
        self,
        file: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UploadedFile]:
        """upload_file

        Uploads file to H2OGPTe instance

        :param file:
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_serialize(
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UploadedFile",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def upload_file_without_preload_content(
        self,
        file: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """upload_file

        Uploads file to H2OGPTe instance

        :param file:
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_file_serialize(
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UploadedFile",
            '401': "EndpointError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _upload_file_serialize(
        self,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'bearerAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/uploads',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


