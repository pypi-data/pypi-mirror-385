Metadata-Version: 2.4
Name: facture_electronique
Version: 0.8.2
Summary: Facturation Electronique SDK est une biblioth√®que Python qui simplifie l'interaction avec les principales API de facturation √©lectronique en France, notamment **Chorus Pro**, et d'autres partenaires priv√©s. Elle supporte √©galement le format Factur-X pour la cr√©ation et l'envoi de factures √©lectroniques.
Author-email: Thierry Martin <thierry.martin.2008@gadz.org>
License: MIT
Project-URL: Homepage, https://github.com/thierryjmartin/facturation_electronique
Project-URL: Source Code, https://github.com/thierryjmartin/facturation_electronique
Project-URL: Documentation, https://thierryjmartin.github.io/facturation_electronique/
Keywords: chorus pro,choruspro,facturx,factur-x,facture √©lectronique,EN16931,invoice
Classifier: Development Status :: 3 - Alpha
Classifier: Programming Language :: Python :: 3
Classifier: Intended Audience :: Developers
Classifier: Operating System :: OS Independent
Classifier: Topic :: Office/Business :: Financial :: Accounting
Classifier: License :: OSI Approved :: MIT License
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: requests>=2.32.3
Requires-Dist: python-dateutil>=2.8.2
Requires-Dist: pydantic>=2.9.2
Requires-Dist: factur-x>=3.4
Requires-Dist: ghostscript>=0.7
Requires-Dist: xsdata>=24.9
Requires-Dist: saxonche>=12.5.0
Requires-Dist: pyHanko[image-support,opentype,pkcs11]>=0.25.3
Provides-Extra: test
Requires-Dist: pytest; extra == "test"
Requires-Dist: pytest-cov; extra == "test"
Requires-Dist: pytest-markdown-docs; extra == "test"
Provides-Extra: dev
Requires-Dist: ruff; extra == "dev"
Requires-Dist: pre-commit; extra == "dev"
Requires-Dist: pip-tools; extra == "dev"
Requires-Dist: facture-electronique[test]; extra == "dev"
Dynamic: license-file

# Facturation Electronique SDK

[![CI - Tests Python](https://github.com/thierryjmartin/facturation_electronique/actions/workflows/ci-tests.yml/badge.svg)](https://github.com/thierryjmartin/facturation_electronique/actions/workflows/ci-tests.yml)
[![codecov](https://codecov.io/github/thierryjmartin/facturation_electronique/graph/badge.svg?token=TCWSSLACFQ)](https://codecov.io/github/thierryjmartin/facturation_electronique)
[![PyPI version](https://badge.fury.io/py/facture-electronique.svg)](https://badge.fury.io/py/facture-electronique)
[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/facture-electronique)](https://pypi.org/project/facture-electronique/)
[![GitHub license](https://img.shields.io/github/license/thierryjmartin/facturation_electronique)](https://github.com/thierryjmartin/facturation_electronique/blob/main/LICENSE)

## Description
`Facturation Electronique` est une biblioth√®que Python compl√®te con√ßue pour simplifier l'interaction avec les principales API de facturation √©lectronique en France, notamment **Chorus Pro** et d'autres Plateformes de D√©mat√©rialisation Partenaires (PDP). Elle offre une approche robuste pour la cr√©ation, la validation et l'envoi de factures √©lectroniques conformes au standard **Factur-X**.

Contrairement √† la biblioth√®que `factur-x` qui fournit les structures de donn√©es XML brutes, ce SDK se positionne comme une surcouche intelligente. Il vous permet de manipuler vos donn√©es de facture via des **mod√®les Pydantic intuitifs et valid√©s**, puis d'orchestrer leur conversion en XML Factur-X et leur soumission aux plateformes requises.

## Fonctionnalit√©s

### Mod√©lisation et Validation des Donn√©es (Pydantic)
- D√©finissez vos factures avec des mod√®les Pydantic riches, typ√©s et auto-valid√©s.
- B√©n√©ficiez d'une validation automatique des types, formats et contraintes m√©tier (ex: montants positifs) d√®s la saisie de vos donn√©es, bien avant la g√©n√©ration du XML.

### G√©n√©ration Factur-X Compl√®te
- Cr√©ez des factures au format PDF/A-3 avec XML embarqu√©, supportant les profils MINIMUM, BASIC, EN16931, EXTENDED.
- **API Fluide et Simplifi√©e** : La g√©n√©ration de Factur-X est d√©sormais orchestr√©e via une API fluide et intuitive, permettant de cha√Æner les √©tapes de validation, d'int√©gration PDF/A et d'enregistrement en un seul appel.
- **Conformit√© PDF/A-3** : Le module assure la g√©n√©ration de documents PDF/A-3, un format d'archivage √† long terme qui permet l'int√©gration du fichier XML Factur-X directement dans le PDF. Cette conformit√© est essentielle pour l'interop√©rabilit√© et la validit√© l√©gale des factures √©lectroniques.
- **Signature √âlectronique** : Int√©grez des signatures √©lectroniques qualifi√©es (e-Seal) √† vos documents PDF/A-3, garantissant l'authenticit√© et l'int√©grit√© de vos factures.
- **Validation Multi-couches** :
  - **Validation Pydantic** : Assure l'int√©grit√© de vos donn√©es d'entr√©e.
  - **Validation de R√®gles M√©tier** : Des contr√¥les sp√©cifiques aux profils Factur-X (ex: interdiction de remises globales TTC pour le profil BASIC) sont appliqu√©s.
  - **Validation Schematron (`valider_xml_facturx_schematron`)** : Une validation approfondie du XML g√©n√©r√© contre les r√®gles m√©tier officielles de Factur-X, utilisant XSLT et `saxonche`. Cette √©tape cruciale garantit la conformit√© de votre facture aux exigences les plus strictes, allant au-del√† de la simple validation de sch√©ma XML (XSD).

### Client API Chorus Pro
- **Gestion compl√®te du cycle de vie** : Cr√©ez, envoyez, suivez et r√©cup√©rez le statut de vos factures via l'API officielle Chorus Pro.
- **Authentification OAuth2** : Gestion automatique de l'authentification et du renouvellement des tokens.
- **Ajout de pi√®ces jointes** : Associez des documents compl√©mentaires √† vos factures.
- **Mode Sandbox** : Testez votre int√©gration sans affecter vos donn√©es de production.

### Client G√©n√©rique AFNOR XP Z12-013 pour les Plateformes de D√©mat√©rialisation Partenaires (PDP)
La biblioth√®que int√®gre un **client HTTP complet et conforme √† la norme exp√©rimentale AFNOR XP Z12-013** (Mai 2025), permettant une interop√©rabilit√© standardis√©e avec toutes les Plateformes de D√©mat√©rialisation Partenaires (PDP) qui impl√©mentent cette norme.

**Pourquoi c'est important :**
- **Interop√©rabilit√© garantie** : La norme AFNOR XP Z12-013 d√©finit un socle technique commun pour toutes les PDP, vous permettant de changer de plateforme sans r√©√©crire votre code.
- **Compl√©mentaire √† Chorus Pro** : Alors que le client Chorus Pro est sp√©cifique √† la plateforme publique, le client AFNOR fonctionne avec n'importe quelle PDP certifi√©e (ex: Docaposte, Generix, Ediware, etc.).
- **Conformit√© r√©glementaire** : Respect strict des sp√©cifications techniques requises pour la facturation √©lectronique en France (r√©forme 2024-2026).

**Fonctionnalit√©s principales :**

- ‚úÖ **Flow Service API** : Soumission, recherche et t√©l√©chargement de flux (factures, cycles de vie, e-reporting)
- ‚úÖ **Directory Service API** : Consultation de l'annuaire des entreprises (SIREN/SIRET), gestion des codes de routage et des lignes d'annuaire
- ‚úÖ **Authentification OAuth2** : Gestion automatique avec renouvellement des tokens (RFC 6750)
- ‚úÖ **Monitoring int√©gr√©** : Logs structur√©s (JSON/texte), m√©triques, rapports HTML/CSV et dashboard temps r√©el
- ‚úÖ **Validation Swagger** : Tests automatiques de conformit√© aux sp√©cifications OpenAPI 3.0.3
- ‚úÖ **Tests complets** : Suite de tests unitaires, d'int√©gration et de sc√©narios m√©tier (EDI, Expert-comptable)

## D√©veloppement et Tests avec le Serveur de Mock AFNOR

En attendant que les API des Plateformes de D√©mat√©rialisation Partenaires (PDP) soient largement disponibles, cette biblioth√®que fournit un **serveur de mock local complet**. Cet outil est essentiel pour d√©velopper, tester et int√©grer le client AFNOR de mani√®re fiable et autonome.

**Pourquoi utiliser le serveur de mock ?**
- **D√©veloppement hors ligne** : Travaillez sur votre int√©gration sans aucune connexion √† une API externe.
- **Tests rapides et pr√©visibles** : Ex√©cutez vos tests unitaires et d'int√©gration dans un environnement contr√¥l√© qui renvoie des r√©ponses instantan√©es et coh√©rentes.
- **Ind√©pendance** : Ne soyez pas bloqu√© par l'indisponibilit√© ou les quotas d'une API de test externe.
- **CI/CD** : Int√©grez facilement des tests du client AFNOR dans vos pipelines d'int√©gration continue.

### Comment l'utiliser ?

#### 1. Lancement du serveur
Une fois la biblioth√®que install√©e, le serveur de mock peut √™tre lanc√© directement depuis votre terminal gr√¢ce √† la commande `fe-afnor-mock` :

```bash
fe-afnor-mock
```
Le serveur d√©marrera et listera tous les endpoints disponibles, pr√™ts √† √™tre utilis√©s :
```
Lancement du serveur de mock...
----------------------------------------------------------------------
Endpoints disponibles sur ce serveur de mock :
----------------------------------------------------------------------

‚ñ∂ API : AFNOR Flow Service (Chemin de base: /flow/v1)
	POST    /flow/v1/flows                                     (Submit a flow)
	POST    /flow/v1/flows/search                              (Search for flows)
	GET     /flow/v1/flows/{flowId}                            (Download a flow document)
	GET     /flow/v1/healthcheck                               (Healthcheck)

‚ñ∂ API : AFNOR Directory Service (Chemin de base: /directory/v1)
	POST    /directory/v1/directory-line/search                (Search for directory lines)
	POST    /directory/v1/directory-line                       (Create a directory line)
...

----------------------------------------------------------------------
Interfaces Swagger UI disponibles :
  - Flow Service:      http://127.0.0.1:8080/flow/v1/ui/
  - Directory Service: http://127.0.0.1:8080/directory/v1/ui/
----------------------------------------------------------------------

Serveur d√©marr√© sur http://127.0.0.1:8080. Appuyez sur Ctrl+C pour arr√™ter.
```

Le serveur est configurable. Utilisez `--help` pour voir les options :
```bash
fe-afnor-mock --help
```

#### 2. Adapter le code de votre client
Dans votre code, il vous suffit de pointer les clients `FlowServiceClient` et `DirectoryServiceClient` vers les URLs du serveur local. Le reste de votre logique m√©tier reste **inchang√©**.

```python
from facture_electronique.afnor_client.client import FlowServiceClient, DirectoryServiceClient

# URLs du serveur de mock local
URL_BASE_FLOW = "http://localhost:8080/flow/v1"
URL_BASE_DIRECTORY = "http://localhost:8080/directory/v1"
# Le serveur de mock n'impl√©mente pas de vrai OAuth2, l'URL du token peut √™tre factice.
URL_TOKEN_FICTIVE = "http://localhost:8080/token"

# Initialisation des clients pour le d√©veloppement local
flow_client = FlowServiceClient(
  base_url=URL_BASE_FLOW,
  token_url=URL_TOKEN_FICTIVE,
  client_id="id_fictif",
  client_secret="secret_fictif"
)

directory_client = DirectoryServiceClient(
  base_url=URL_BASE_DIRECTORY,
  token_url=URL_TOKEN_FICTIVE,
  client_id="id_fictif",
  client_secret="secret_fictif"
)

# Vous pouvez maintenant utiliser les clients comme vous le feriez avec une vraie API.
# Le serveur de mock interceptera les appels et renverra des r√©ponses conformes.
try:
    company = directory_client.get_siren("702042755")
    print(f"Entreprise trouv√©e via le mock: {company['businessName']}")
except Exception as e:
    print(f"Erreur lors de l'appel au serveur de mock : {e}")
```

**Pour en savoir plus**, consultez la documentation compl√®te du client AFNOR dans la section d√©di√©e de la documentation : [Guide d'utilisation du client AFNOR XP Z12-013](https://thierryjmartin.github.io/facturation_electronique/)

## Ressources

Pour vous aider √† d√©marrer et √† utiliser ce projet, voici les ressources essentielles :

- üìñ **Documentation Compl√®te** : Explorez le guide complet, les tutoriels et la r√©f√©rence de l'API.
  - **https://thierryjmartin.github.io/facturation_electronique/**
- üì¶ **Paquet PyPI** : Installez la derni√®re version stable directement depuis le Python Package Index.
  - **https://pypi.org/project/facture-electronique/**

## Installation

Le paquet est disponible sur PyPI :
```bash
pip install facture-electronique
```

Pour le d√©veloppement, clonez le d√©p√¥t et installez les d√©pendances :
```bash
git clone https://github.com/thierryjmartin/facturation_electronique.git
cd facturation_electronique
pip install -r requirements-dev.txt
```

## Configuration

Les interactions avec les API (comme Chorus Pro ou les PDP) n√©cessitent des identifiants. Cette biblioth√®que se configure via des **variables d'environnement**.

Pour le d√©veloppement local, copiez le fichier `.env.example` en `.env` √† la racine de votre projet, puis remplissez les valeurs :

```bash
cp .env.example .env
```
N'oubliez pas d'ajouter le fichier `.env` √† votre `.gitignore`.

Les classes API, comme `ChorusProAPI` ou `FlowServiceClient`, liront automatiquement ces variables. Vous pouvez √©galement les fournir explicitement lors de l'instanciation.

**Variables d'environnement pour le client AFNOR :**
```bash
export AFNOR_FLOW_SERVICE_URL="https://api.pdp.com/flow-service"
export AFNOR_DIRECTORY_SERVICE_URL="https://api.pdp.com/directory-service"
export AFNOR_OAUTH_TOKEN_URL="https://auth.pdp.com/oauth/token"
export AFNOR_CLIENT_ID="votre_client_id"
export AFNOR_CLIENT_SECRET="votre_client_secret"
```

## Construire une Adresse √âlectronique (Recommand√©)

La norme de facturation √©lectronique fran√ßaise (AFNOR XP Z12-014) d√©finit des formats d'adressage pr√©cis bas√©s sur le SIREN, comme `SIREN_SIRET` ou `SIREN_SIRET_CODEROUTAGE`. Pour simplifier la cr√©ation de ces identifiants et √©viter les erreurs, la biblioth√®que fournit un constructeur d√©di√© : `ConstructeurAdresse`.

L'utilisation de ce "builder" est la m√©thode recommand√©e pour garantir la conformit√© de vos adresses.

```python
from facture_electronique.models import ConstructeurAdresse, AdresseElectronique, SchemeID

# Cas 1 : Adresse simple avec SIREN
adresse_simple = ConstructeurAdresse(siren="123456789").construire()
# -> identifiant = "123456789"

# Cas 2 : Adresse avec SIRET pour un √©tablissement
adresse_etablissement = ConstructeurAdresse(siren="123456789").avec_siret("12345678901234").construire()
# -> identifiant = "123456789_12345678901234"

# Cas 3 : Adresse avec un code de routage pour un service public
adresse_service = (
    ConstructeurAdresse(siren="123456789")
    .avec_siret("12345678901234")
    .avec_code_routage("SERVICE01")
    .construire()
)
# -> identifiant = "123456789_12345678901234_SERVICE01"

# Il reste possible de cr√©er une adresse manuellement (non recommand√© pour les cas complexes)
adresse_manuelle = AdresseElectronique(identifiant="123456789", scheme_id=SchemeID.FR_SIREN)
```

## Utilisation

Voici des exemples simples pour les cas d'usage les plus courants. Pour des sc√©narios plus avanc√©s (tous les profils Factur-X, signature, envoi de PDF...), consultez le fichier `facture_electronique/exemples/exemple_decoupe.py`.

### Exemple 1 : G√©n√©rer une facture au format Factur-X

Cet exemple montre comment cr√©er une facture simple et la sauvegarder en tant que fichier PDF contenant un XML Factur-X au profil `EN16931`.

```python
from decimal import Decimal
from facture_electronique.models import (
    FactureFacturX, ModeDepot, Destinataire, Fournisseur, CadreDeFacturation,
    CodeCadreFacturation, References, TypeFacture, TypeTVA, ModePaiement,
    LigneDePoste, LigneDeTVA, MontantTotal, AdresseElectronique, SchemeID, AdressePostale
)
from facture_electronique.utils.facturx import ProfilFacturX
from facture_electronique.utils.files import get_absolute_path

# 1. D√©finir les donn√©es de la facture avec les mod√®les Pydantic
facture_simple = FactureFacturX(
    mode_depot=ModeDepot.DEPOT_PDF_API,
    numero_facture="F2025-001",
    date_echeance_paiement="2025-11-17",
    destinataire=Destinataire(
        nom="Client Test SAS",
        adresse_electronique=AdresseElectronique(
            identifiant="12345678901234", scheme_id=SchemeID.FR_SIREN
        ),
        adresse_postale=AdressePostale(pays_code_iso="FR"),
    ),
    fournisseur=Fournisseur(
        nom="Fournisseur Test SARL",
        adresse_electronique=AdresseElectronique(
            identifiant="11122233300011", scheme_id=SchemeID.FR_SIREN
        ),
        id_fournisseur=12345,  # ID Chorus Pro du fournisseur (fictif ici)
        numero_tva_intra="FR12111222333",
        iban="FR7630006000011234567890189",
        adresse_postale=AdressePostale(pays_code_iso="FR"),
    ),
    cadre_de_facturation=CadreDeFacturation(
        code_cadre_facturation=CodeCadreFacturation.A1_FACTURE_FOURNISSEUR
    ),
    references=References(
        type_facture=TypeFacture.FACTURE,
        type_tva=TypeTVA.SUR_DEBIT,
        mode_paiement=ModePaiement.VIREMENT,
    ),
    lignes_de_poste=[
        LigneDePoste(
            numero=1,
            denomination="Prestation de conseil",
            quantite=Decimal("1"),
            unite="pce",  # pi√®ce
            montant_unitaire_ht=Decimal("100.00"),
            taux_tva_manuel=Decimal("20.0"),
        )
    ],
    lignes_de_tva=[
        LigneDeTVA(
            montant_base_ht=Decimal("100.00"),
            montant_tva=Decimal("20.00"),
            taux_manuel=Decimal("20.0"),
        )
    ],
    montant_total=MontantTotal(
        montant_ht_total=Decimal("100.00"),
        montant_tva=Decimal("20.00"),
        montant_ttc_total=Decimal("120.00"),
        montant_a_payer=Decimal("120.00"),
    ),
)

# 2. Utiliser l'API fluide pour g√©n√©rer le fichier
# Un PDF source est requis pour y int√©grer le XML.
chemin_pdf_source = get_absolute_path("facture_electronique/exemples/dummy.pdf")
nom_fichier_sortie = "facture_simple_en16931.pdf"

try:
    with facture_simple.generer_facturx(profil=ProfilFacturX.EN16931) as constructeur:
        resultat = (
            constructeur.valider_conformite()
            .integrer_dans_pdfa(chemin_pdf_source)
            .enregistrer_sous(nom_fichier_sortie)
        )
    print(f"Facture Factur-X g√©n√©r√©e avec succ√®s : {resultat['chemin_fichier']}")
except Exception as e:
    print(f"Erreur lors de la g√©n√©ration Factur-X : {e}")
```

### Exemple 2 : Envoyer une facture √† Chorus Pro (mode API)

Cet exemple montre comment envoyer les donn√©es d'une facture directement √† l'API de Chorus Pro (`SAISIE_API`), sans g√©n√©rer de fichier PDF.

```python
from decimal import Decimal
from facture_electronique.api.chorus_pro import ChorusProAPI
from facture_electronique.models import (
    FactureChorus, ModeDepot, Destinataire, Fournisseur, CadreDeFacturation,
    CodeCadreFacturation, References, TypeFacture, TypeTVA, ModePaiement,
    LigneDePoste, LigneDeTVA, MontantTotal, AdresseElectronique, SchemeID, AdressePostale
)

# 1. Initialiser le client API (en mode sandbox)
# Assurez-vous que vos identifiants sont dans les variables d'environnement
# (PISTE_CLIENT_ID, PISTE_CLIENT_SECRET, CHORUS_PRO_LOGIN, CHORUS_PRO_PASSWORD)
try:
    client_chorus = ChorusProAPI(sandbox=True)
except Exception as e:
    print(f"Erreur d'initialisation du client API : {e}")
    # Dans un vrai sc√©nario, on arr√™terait ici.
    # Pour l'exemple, on continue sans client fonctionnel.
    client_chorus = None

# 2. D√©finir les donn√©es de la facture pour le mode SAISIE_API
facture_api = FactureChorus(
    mode_depot=ModeDepot.SAISIE_API,
    numero_facture="API-2025-001",
    date_echeance_paiement="2025-12-17",
    destinataire=Destinataire(
        nom="Client Public Test",
        adresse_electronique=AdresseElectronique(
            identifiant="12345678901234", scheme_id=SchemeID.FR_SIREN
        ),
        adresse_postale=AdressePostale(pays_code_iso="FR"),
    ),  # SIRET du client public
    fournisseur=Fournisseur(
        nom="Mon Entreprise Test",
        id_fournisseur=12345,  # Votre ID technique Chorus Pro
        adresse_electronique=AdresseElectronique(
            identifiant="11122233300011", scheme_id=SchemeID.FR_SIREN
        ),
        adresse_postale=AdressePostale(pays_code_iso="FR"),
    ),
    cadre_de_facturation=CadreDeFacturation(
        code_cadre_facturation=CodeCadreFacturation.A1_FACTURE_FOURNISSEUR
    ),
    references=References(
        type_facture=TypeFacture.FACTURE,
        type_tva=TypeTVA.SUR_DEBIT,
        mode_paiement=ModePaiement.VIREMENT,
    ),
    lignes_de_poste=[
        LigneDePoste(
            numero=1,
            denomination="Fournitures de bureau",
            quantite=Decimal("1"),
            unite="lot",
            montant_unitaire_ht=Decimal("75.50"),
            taux_tva_manuel=Decimal("20.0"),
        )
    ],
    lignes_de_tva=[
        LigneDeTVA(
            montant_base_ht=Decimal("75.50"),
            montant_tva=Decimal("15.10"),
            taux_manuel=Decimal("20.0"),
        )
    ],
    montant_total=MontantTotal(
        montant_ht_total=Decimal("75.50"),
        montant_tva=Decimal("15.10"),
        montant_ttc_total=Decimal("90.60"),
        montant_a_payer=Decimal("90.60"),
    ),
    commentaire="Facture simple envoy√©e via API"
)

# 3. Pr√©parer et envoyer la facture
# L'envoi r√©el est comment√© car il n√©cessite des identifiants valides.
if client_chorus:
    try:
        payload = facture_api.to_api_payload()
        print("Payload g√©n√©r√© pour l'API Chorus Pro.")
        # print(payload) # D√©commentez pour voir le payload

        # --- D√©commentez la ligne suivante pour envoyer la facture ---
        # reponse = client_chorus.envoyer_facture(payload)
        # print(f"Facture envoy√©e avec succ√®s ! ID Chorus Pro : {reponse.get('identifiantFactureCPP')}")

        print("\nL'envoi r√©el est comment√©. D√©commentez le code pour l'activer.")

    except Exception as e:
        print(f"Erreur lors de la pr√©paration ou de l'envoi de la facture : {e}")

```

### Exemple 3 : Utiliser le client AFNOR pour interagir avec une PDP

Cet exemple montre comment utiliser le client g√©n√©rique AFNOR XP Z12-013 pour soumettre une facture et consulter l'annuaire d'une PDP.

```python
import requests.exceptions
from facture_electronique.afnor_client.client import FlowServiceClient, DirectoryServiceClient
from datetime import datetime, timedelta

# 1. Initialiser le client Flow Service
flow_client = FlowServiceClient(
  base_url="https://api.pdp.com/flow-service",
  token_url="https://auth.pdp.com/oauth/token",
  client_id="your_client_id",
  client_secret="your_client_secret"
)

try:
  # 2. Soumettre une facture CII
  result = flow_client.submit_flow(
    file_path="facture_cii.xml",
    flow_name="Facture PDP-2025-001",
    flow_syntax="CII",
    flow_profile="CIUS",
    tracking_id="TRACK-PDP-001"
  )
  print(f"Facture soumise avec Flow ID: {result['flowId']}")
except FileNotFoundError:
  pass

# 3. Rechercher des factures r√©centes
try:
  results = flow_client.search_flows(
    updated_after=datetime.now() - timedelta(days=7),
    flow_type=["SupplierInvoice"],
    flow_direction=["Out"],
    limit=25
  )
  print(f"Trouv√© {results['total']} factures")


  # 4. Utiliser le Directory Service pour consulter une entreprise
  directory_client = DirectoryServiceClient(
    base_url="https://api.pdp.com/directory-service",
    token_url="https://auth.pdp.com/oauth/token",
    client_id="your_client_id",
    client_secret="your_client_secret"
  )
  
  company = directory_client.get_siren("702042755")
  print(f"Entreprise trouv√©e: {company['businessName']}")
except requests.exceptions.SSLError:
  pass
```

## Petite note technique
Le code dans le r√©pertoire `generated` est g√©n√©r√© √† partir des sch√©mas XSD officiels de Factur-X √† l'aide de la commande `xsdata`:
```bash
xsdata generate xsd/facturx-minimum/Factur-X_1.07.2_MINIMUM.xsd
```

## Contribution
Les contributions sont les bienvenues ! Veuillez cloner le d√©p√¥t, cr√©er une branche et soumettre une Pull Request.

## Licence
Ce projet est sous licence MIT.

## Auteur
D√©velopp√© par Thierry Martin

## Changelog

### 0.8.1 (20 octobre 2025)
- **Outil de D√©veloppement : Serveur de mock AFNOR via ligne de commande**
  - Le serveur de mock (`serveur_mock.py`) est maintenant installable en tant que commande `fe-afnor-mock` via un point d'entr√©e `project.scripts`.
  - ‚úÖ **Utilisation simplifi√©e** : Plus besoin de lancer le script manuellement, la commande est disponible apr√®s installation du package.
  - ‚úÖ **Simulation compl√®te** des API Flow Service et Directory Service bas√©e sur les sp√©cifications OpenAPI officielles.
  - ‚úÖ **Configurable** via la ligne de commande (port, h√¥te).
  - ‚úÖ **Auto-descriptif** : Le serveur liste tous les endpoints disponibles √† son d√©marrage pour une prise en main imm√©diate.
- **Documentation** : Mise √† jour du `README.md` et du guide pour refl√©ter le lancement du serveur de mock via la commande `fe-afnor-mock`.

### 0.8.0 (19 octobre 2025)
- **Ajout d'un client HTTP conforme AFNOR XP Z12-013 (Juillet 2025)**
  - Client g√©n√©rique pour toutes les Plateformes de D√©mat√©rialisation Partenaires (PDP)
  - Flow Service API v1.0.2 : Soumission, recherche et t√©l√©chargement de flux
  - Directory Service API v1.0.0 : Consultation annuaire, gestion codes routage
  - Authentification OAuth2 automatique avec renouvellement des tokens
  - Monitoring int√©gr√© : logs structur√©s, m√©triques, rapports HTML/CSV, dashboard temps r√©el
  - Tests complets : validation Swagger, tests unitaires, tests d'int√©gration E2E
  - Documentation compl√®te avec guide d'utilisation et r√©f√©rence API

### 0.7.0 (18 octobre 2025)
- **CHANGEMENT MAJEUR (non r√©trocompatible)**: Refonte compl√®te de la gestion des adresses des partenaires commerciaux pour se conformer √† la norme AFNOR XP Z12-014.
  - Les mod√®les `Destinataire` et `Fournisseur` n'utilisent plus de simples cha√Ænes de caract√®res pour les identifiants.
  - Introduction du mod√®le `AdresseElectronique` (contenant un `identifiant` et un `scheme_id`) qui est maintenant un champ obligatoire pour `Destinataire` et `Fournisseur`.
  - Le champ `code_destinataire` a √©t√© supprim√© du mod√®le `Destinataire`.
- **Nouvelle fonctionnalit√©**: Ajout d'un constructeur `ConstructeurAdresse` pour cr√©er de mani√®re fluide et s√©curis√©e des adresses √©lectroniques complexes (ex: `SIREN_SIRET_CODEROUTAGE`).
- **Am√©liorations**:
  - La robustesse du client `ChorusProAPI` a √©t√© am√©lior√©e pour mieux g√©rer les erreurs r√©seau lors de l'authentification, en levant une `ErreurConfiguration` coh√©rente.
  - La couverture de test a √©t√© √©tendue pour inclure les exemples de code du fichier `readme.md` gr√¢ce √† l'int√©gration de `pytest-markdown-docs`.
- **Corrections**:
  - Mise √† jour de l'ensemble des tests unitaires et des tests de la documentation pour s'aligner sur la nouvelle structure des mod√®les de donn√©es.
  - Correction d'une logique de test erron√©e pour la validation de la configuration de l'API.
- **Documentation**: Mise √† jour compl√®te du `readme.md` et des guides pour refl√©ter l'utilisation des nouveaux mod√®les `AdresseElectronique` et `ConstructeurAdresse`.

### 0.6.0 (17 octobre 2025)
- **Nouvelle fonctionnalit√©** : Ajout du support pour le profil Factur-X EXTENDED.
- **Changement d'API (potentiellement non r√©trocompatible)** : La fonction `valider_xml_xldt` a √©t√© renomm√©e en `valider_xml_facturx_schematron` dans `facture_electronique/utils/facturx.py` pour une meilleure clart√© et coh√©rence.

### 0.5.9
- Mise √† jour pour le support de Factur-X 1.0.7.3.

### 0.5.8
- **Fix** : Correction d'un bug qui emp√™chait l'exception `XSLTValidationError` d'√™tre intercept√©e (`catch`). L'exception a √©t√© refactoris√©e pour accepter une liste d'erreurs, la rendant robuste et testable.

### 0.5.4
- maj API et tests.

### 0.5.3
- version plus robuste de validation des XML factur-X

### 0.5.2
- mise √† jour de `__init__.py` de mani√®re √† exposer l'API.

### 0.5.0
- **Changement majeur (non r√©trocompatible)** : Refonte compl√®te de la gestion de la configuration pour les clients API.
  - Suppression du syst√®me fragile bas√© sur l'import d'un fichier `config.py` ou `template_config.py`.
  - La configuration se fait d√©sormais via des **variables d'environnement** (recommand√©) ou en passant les identifiants directement au constructeur de la classe API.
  - Introduction d'une nouvelle exception `ErreurConfiguration` lev√©e lorsque des identifiants requis sont manquants.
  - Ajout d'un fichier `.env.example` pour guider les utilisateurs.
- **Documentation** : Mise √† jour compl√®te du `README.md` pour refl√©ter la nouvelle m√©thode d'installation et de configuration.

### 0.4.0
- Gestion des d√©pendances centralis√©e via pyproject.toml

### 0.3.0
- Utilisation du type Decimal de pr√©f√©rence

### 0.2.1
- **Fix** : Correction de plusieurs `TypeError` dans la logique de g√©n√©ration Factur-X (`utils/facturx.py`) li√©s √† la gestion des champs optionnels (`None`).
- **Tests** : Ajout d'une suite de tests d√©di√©e (`tests/test_facturx.py`) pour la g√©n√©ration des factures Factur-X.

### 0.2.0
- Refactoring majeur des mod√®les de donn√©es (`Facture` -> `FactureChorus` / `FactureFacturX`).
- Harmonisation des noms de champs en fran√ßais.
- Ajout de tests unitaires pour les mod√®les.
- Mise √† jour de la documentation et des exemples.

### 0.1.24
- Modernisation de la gestion des d√©pendances avec `pip-tools`.

### 0.1.22
- Maj validation XML via Schematron

### 0.1.19
- Ajout des XSD de factur-x au package, en particulier pour pouvoir utiliser utils.facturx.valider_xml_facturx_schematron plus facilement.

### 0.1.16
- Ajout d'exemple de code pour signer les PDFs avec PyHanko, car cela devrait √™tre n√©cessaire pour faire des Factur-X (Qualified eSeal). Pour le moment la signature casse la validit√© PDF/A...

### 0.1.13
- Ajout de la g√©n√©ration de Factur-X EN16931 (en plus des profils Minimum et Basic).

### 0.1.12
- Mise √† jour pour le support de Factur-X 1.0.7.2.
