from typing import List
import numpy as np
import xml.etree.ElementTree as ET
from pathlib import Path
import re
from sys import argv

script_dir = Path(__file__).parent


def readTrodesExtractedDataFile(filename):
    with open(filename, "rb") as f:
        # Check if first line is start of settings block
        if f.readline().decode("ascii").strip() != "<Start settings>":
            raise Exception("Settings format not supported")
        fields = True
        fieldsText = {}
        for line in f:
            # Read through block of settings
            if fields:
                line = line.decode("ascii").strip()
                # filling in fields dict
                if line != "<End settings>":
                    vals = line.split(": ")
                    fieldsText.update({vals[0].lower(): vals[1]})
                # End of settings block, signal end of fields
                else:
                    fields = False
                    dt = parseFields(fieldsText["fields"])
                    fieldsText["data"] = np.zeros([1], dtype=dt)
                    break
        # Reads rest of file at once, using dtype format generated by parseFields()
        dt = parseFields(fieldsText["fields"])
        data = np.fromfile(f, dt)
        fieldsText.update({"data": data})
        return fieldsText


# Parses last fields parameter (<time uint32><...>) as a single string
# Assumes it is formatted as <name number * type> or <name type>
# Returns: np.dtype
def parseFields(fieldstr):
    # Returns np.dtype from field string
    sep = re.split("\s", re.sub(r"\>\<|\>|\<", " ", fieldstr).strip())
    # print(sep)
    typearr = []
    # Every two elmts is fieldname followed by datatype
    for i in range(0, sep.__len__(), 2):
        fieldname = sep[i]
        repeats = 1
        ftype = "uint32"
        # Finds if a <num>* is included in datatype
        if sep[i + 1].__contains__("*"):
            temptypes = re.split("\*", sep[i + 1])
            # Results in the correct assignment, whether str is num*dtype or dtype*num
            ftype = temptypes[temptypes[0].isdigit()]
            repeats = int(temptypes[temptypes[1].isdigit()])
        else:
            ftype = sep[i + 1]
        try:
            fieldtype = getattr(np, ftype)
        except AttributeError:
            print(ftype + " is not a valid field type.\n")
            exit(1)
        else:
            typearr.append((str(fieldname), fieldtype, repeats))
    return np.dtype(typearr)


def create_trodesconf_from_scratch(num_channels: int, out_path: str):
    """Generate a trodesconf (XML) file based on the number of channels.
    - Channel orders are numerical in HWChan.
    - 128 channels per page in Trodes (four columns, 32 channels per column).
    - All the channels will be in a single Ntrode.

    Parameters
    ----------
    num_channels : int
    out_path : str
        path to save the trodesconf file
    """

    assert isinstance(num_channels, int), "`num_channels` must be of type int"

    base = ET.parse(script_dir / "trode_conf_base.xml")
    base_root = base.getroot()

    StreamDisplay = base_root.find("StreamDisplay")
    StreamDisplay.attrib["pages"] = str(int(np.ceil(num_channels / 128)))

    HardwareConfiguration = base_root.find("HardwareConfiguration")
    HardwareConfiguration.attrib["numChannels"] = str(num_channels)

    SpikeConfiguration = base_root.find("SpikeConfiguration")

    # define spikeNtrode
    SpikeNTrode = ET.Element("SpikeNTrode")
    SpikeNTrode_attrib_str = 'viewStimBand="0" rawScalingToUv="0.19500000000000001" lfpRefOn="0" rawRefOn="0" notchFilterOn="0" LFPHighFilter="200" viewLFPBand="0" filterOn="1" refNTrodeID="-1" moduleDataOn="0" LFPChan="1" refGroup="0" lfpFilterOn="0" color="#ffffff" lfpScalingToUv="0.19500000000000001" lowFilter="300" refOn="0" groupRefOn="0" viewSpikeBand="1" notchBW="10" highFilter="6000" refChan="1" spikeScalingToUv="0.19500000000000001" notchFreq="60"'
    SpikeNTrode_attrib_dict = dict(
        item.split("=") for item in SpikeNTrode_attrib_str.split(" ")
    )
    for key, value in SpikeNTrode_attrib_dict.items():
        SpikeNTrode.attrib[key] = str(value[1:-1])
    # give id of 1
    SpikeNTrode.attrib["id"] = str(1)

    # define SpikeChannel within SpikeNTrode
    for i in range(num_channels):
        SpikeChannel = ET.Element("SpikeChannel")
        SpikeChannel_attrib_str = 'coord_ap="0" coord_dv="0" coord_ml="0" thresh="30" triggerOn="1" stimCapable="0" spikeSortingGroup="0" maxDisp="200"'
        SpikeChannel_attrib_dict = dict(
            item.split("=") for item in SpikeChannel_attrib_str.split(" ")
        )
        for key, value in SpikeChannel_attrib_dict.items():
            SpikeChannel.attrib[key] = str(value[1:-1])
        SpikeChannel.attrib["hwChan"] = str(i)
        SpikeNTrode.append(SpikeChannel)

    SpikeConfiguration.append(SpikeNTrode)

    indent(base_root)

    base.write(out_path, encoding="utf-8", xml_declaration=True)


def create_trodesconf_from_template(probe_list: List, out_path: str):
    """Generate a trodesconf (XML) file based on probe type sequence.
    - This works for following probe types: Livermore probes of type 15um or 20um and 32 tetrode drive with EIB from SpikeGadgets.
    - Can specify any (finite) sequence of the probe types.
    - Each probe will be displayed in a separate page in Trodes, with each column column containing 32 channels.
    - If Livermore 15um or 20um, the order of the channels will be from top to bottom with the contact side facing you.
    - Each Ntrode contains 4 contacts for all probe types.
    - Blank is for place-hodler probe boards (not attached to any probe)

    Parameters
    ----------
    probe_types : List[Union['blank', '15um', '20um', '32tet']]
        example: ['20um','15um','20um'] for three probe implant with 20um, 15um, 20um types (in this order)
    out_path : str
        path to save the trodesconf file
    """
    probe_to_xml_dict = {
        "15um": "spike_config_15.xml",
        "20um": "spike_config_20.xml",
        "32tet": "spike_config_32tet.xml",
        "blank": None,
    }

    assert all(
        probe_type in probe_to_xml_dict.keys() for probe_type in probe_list
    ), "Probe type must be '15um', '20um' or '32tet'"

    base = ET.parse(script_dir / "trode_conf_base.xml")
    base_root = base.getroot()

    StreamDisplay = base_root.find("StreamDisplay")
    StreamDisplay.attrib["pages"] = str(len(probe_list))

    HardwareConfiguration = base_root.find("HardwareConfiguration")
    HardwareConfiguration.attrib["numChannels"] = str(128 * len(probe_list))

    SpikeConfiguration = base_root.find("SpikeConfiguration")
    for probe_idx in range(len(probe_list)):
        probe_type = probe_list[probe_idx]
        if probe_type == "blank":
            continue
        probe_root = ET.parse(script_dir / probe_to_xml_dict[probe_type]).getroot()
        for SpikeNTrode in probe_root.findall(".//SpikeNTrode"):
            SpikeNTrode.attrib["id"] = str(
                int(SpikeNTrode.attrib["id"]) + 32 * probe_idx
            )
            for SpikeChannel in SpikeNTrode.findall("SpikeChannel"):
                SpikeChannel.attrib["hwChan"] = str(
                    int(SpikeChannel.attrib["hwChan"]) + 128 * probe_idx
                )
            SpikeConfiguration.append(SpikeNTrode)

    indent(base_root)

    base.write(out_path, encoding="utf-8", xml_declaration=True)


def indent(elem, level=0):
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


def compare_elements(elem1, elem2, differences):
    if elem1.tag != elem2.tag:
        differences.append(f"Different tag: {elem1.tag} != {elem2.tag}")
        return False
    if elem1.attrib != elem2.attrib:
        differences.append(
            f"Different attributes in tag {elem1.tag}: {elem1.attrib} != {elem2.attrib}"
        )
        return False
    if elem1.text != elem2.text:
        differences.append(
            f"Different text in tag {elem1.tag}: {elem1.text} != {elem2.text}"
        )
        return False

    children1 = list(elem1)
    children2 = list(elem2)

    if len(children1) != len(children2):
        differences.append(f"Different number of children in tag {elem1.tag}")
        return False

    are_same = True
    for child1, child2 in zip(children1, children2):
        if not compare_elements(child1, child2, differences):
            are_same = False

    return are_same


def compare_xml_files(file1, file2):
    tree1 = ET.parse(file1)
    root1 = tree1.getroot()

    tree2 = ET.parse(file2)
    root2 = tree2.getroot()

    differences = []
    are_same = compare_elements(root1, root2, differences)

    if are_same:
        print("The XML files are the same.")
    else:
        print("The XML files are different.")
        print("Differences:")
        for diff in differences:
            print(f"  - {diff}")
