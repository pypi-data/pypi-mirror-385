{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { GLOBAL_API_REF, isInternalFilter } from '../../../colDef/utils';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { getPublicApiRef } from '../../../utils/getPublicApiRef';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\nvar hasEval;\nfunction getHasEval() {\n  if (hasEval !== undefined) {\n    return hasEval;\n  }\n  try {\n    hasEval = new Function('return true')();\n  } catch (_) {\n    hasEval = false;\n  }\n  return hasEval;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport var cleanFilterItem = function cleanFilterItem(item, apiRef) {\n  var cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    var column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nvar filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nvar filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nvar filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport var sanitizeFilterModel = function sanitizeFilterModel(model, disableMultipleColumnsFiltering, apiRef) {\n  var hasSeveralItems = model.items.length > 1;\n  var items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  var hasItemsWithoutIds = hasSeveralItems && items.some(function (item) {\n    return item.id == null;\n  });\n  var hasItemWithoutOperator = items.some(function (item) {\n    return item.operator == null;\n  });\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(function (item) {\n        return cleanFilterItem(item, apiRef);\n      })\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items: items\n    });\n  }\n  return model;\n};\nexport var mergeStateWithFilterModel = function mergeStateWithFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef) {\n  return function (filteringState) {\n    return _extends({}, filteringState, {\n      filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n    });\n  };\n};\nexport var removeDiacritics = function removeDiacritics(value) {\n  if (typeof value === 'string') {\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n  }\n  return value;\n};\nvar getFilterCallbackFromItem = function getFilterCallbackFromItem(filterItem, apiRef) {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  var column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  var parsedValue;\n  if (column.valueParser) {\n    var _filterItem$value;\n    var parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(function (x) {\n      return parser(x);\n    }) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  var ignoreDiacritics = apiRef.current.rootProps.ignoreDiacritics;\n  if (ignoreDiacritics) {\n    parsedValue = removeDiacritics(parsedValue);\n  }\n  var newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  var filterOperators = column.filterOperators;\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(\"MUI: No filter operators found for column '\".concat(column.field, \"'.\"));\n  }\n  var filterOperator = filterOperators.find(function (operator) {\n    return operator.value === newFilterItem.operator;\n  });\n  if (!filterOperator) {\n    throw new Error(\"MUI: No filter operator found for column '\".concat(column.field, \"' and operator value '\").concat(newFilterItem.operator, \"'.\"));\n  }\n  var hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);\n  var hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);\n  var publicApiRef = getPublicApiRef(apiRef);\n  if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n    var _applyFilterOnRow = filterOperator.getApplyFilterFnV7(newFilterItem, column);\n    if (typeof _applyFilterOnRow !== 'function') {\n      return null;\n    }\n    return {\n      v7: true,\n      item: newFilterItem,\n      fn: function fn(row) {\n        var value = apiRef.current.getRowValue(row, column);\n        if (ignoreDiacritics) {\n          value = removeDiacritics(value);\n        }\n        return _applyFilterOnRow(value, row, column, publicApiRef);\n      }\n    };\n  }\n  var applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    v7: false,\n    item: newFilterItem,\n    fn: function fn(rowId) {\n      var params = apiRef.current.getCellParams(rowId, newFilterItem.field);\n      GLOBAL_API_REF.current = publicApiRef;\n      if (ignoreDiacritics) {\n        params.value = removeDiacritics(params.value);\n      }\n      var result = applyFilterOnRow(params);\n      GLOBAL_API_REF.current = null;\n      return result;\n    }\n  };\n};\nvar filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nvar buildAggregatedFilterItemsApplier = function buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval) {\n  var items = filterModel.items;\n  var appliers = items.map(function (item) {\n    return getFilterCallbackFromItem(item, apiRef);\n  }).filter(function (callback) {\n    return !!callback;\n  });\n  if (appliers.length === 0) {\n    return null;\n  }\n  if (disableEval || !getHasEval()) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return function (row, shouldApplyFilter) {\n      var resultPerItemId = {};\n      for (var i = 0; i < appliers.length; i += 1) {\n        var applier = appliers[i];\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.v7 ? applier.fn(row) : applier.fn(apiRef.current.getRowId(row));\n        }\n      }\n      return resultPerItemId;\n    };\n  }\n\n  // We generate a new function with `new Function()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, e.g. `{ [dynamicKey]: value }`.\n  var filterItemCore = new Function('getRowId', 'appliers', 'row', 'shouldApplyFilter', \"\\\"use strict\\\";\\n\".concat(appliers.map(function (applier, i) {\n    return \"const shouldApply\".concat(i, \" = !shouldApplyFilter || shouldApplyFilter(\").concat(JSON.stringify(applier.item.field), \");\");\n  }).join('\\n'), \"\\n\\nconst result$$ = {\\n\").concat(appliers.map(function (applier, i) {\n    return \"  \".concat(JSON.stringify(String(applier.item.id)), \": !shouldApply\").concat(i, \"\\n    ? false\\n    : \").concat(applier.v7 ? \"appliers[\".concat(i, \"].fn(row)\") : \"appliers[\".concat(i, \"].fn(getRowId(row))\"), \",\");\n  }).join('\\n'), \"\\n};\\n\\nreturn result$$;\").replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n\n  // Assign to the arrow function a name to help debugging\n  var filterItem = function filterItem(row, shouldApplyItem) {\n    return filterItemCore(apiRef.current.getRowId, appliers, row, shouldApplyItem);\n  };\n  return filterItem;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nvar buildAggregatedQuickFilterApplier = function buildAggregatedQuickFilterApplier(filterModel, apiRef) {\n  var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;\n  var quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  var quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;\n  var columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  var appliersPerField = [];\n  var ignoreDiacritics = apiRef.current.rootProps.ignoreDiacritics;\n  var publicApiRef = getPublicApiRef(apiRef);\n  columnFields.forEach(function (field) {\n    var column = apiRef.current.getColumn(field);\n    var getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n    var getApplyQuickFilterFnV7 = column == null ? void 0 : column.getApplyQuickFilterFnV7;\n    var hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);\n    var hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);\n    if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n      appliersPerField.push({\n        column: column,\n        appliers: quickFilterValues.map(function (quickFilterValue) {\n          var value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            v7: true,\n            fn: getApplyQuickFilterFnV7(value, column, publicApiRef)\n          };\n        })\n      });\n    } else if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column: column,\n        appliers: quickFilterValues.map(function (quickFilterValue) {\n          var value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            v7: false,\n            fn: getApplyQuickFilterFn(value, column, publicApiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    var result = {};\n    var usedCellParams = {};\n\n    /* eslint-disable no-restricted-syntax, no-labels */\n    outer: for (var v = 0; v < quickFilterValues.length; v += 1) {\n      var filterValue = quickFilterValues[v];\n      for (var i = 0; i < appliersPerField.length; i += 1) {\n        var _appliersPerField$i = appliersPerField[i],\n          column = _appliersPerField$i.column,\n          appliers = _appliersPerField$i.appliers;\n        var field = column.field;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        var applier = appliers[v];\n        var value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (applier.v7) {\n          if (ignoreDiacritics) {\n            value = removeDiacritics(value);\n          }\n          var isMatching = applier.fn(value, row, column, publicApiRef);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        } else {\n          var _usedCellParams$field;\n          var cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef.current.getCellParams(apiRef.current.getRowId(row), field);\n          if (ignoreDiacritics) {\n            cellParams.value = removeDiacritics(cellParams.value);\n          }\n          usedCellParams[field] = cellParams;\n          var _isMatching = applier.fn(cellParams);\n          if (_isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        }\n      }\n      result[filterValue] = false;\n    }\n    /* eslint-enable no-restricted-syntax, no-labels */\n\n    return result;\n  };\n};\nexport var buildAggregatedFilterApplier = function buildAggregatedFilterApplier(filterModel, apiRef, disableEval) {\n  var isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);\n  var isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    var _isRowMatchingFilterI, _isRowMatchingQuickFi;\n    result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;\n    result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;\n  };\n};\nvar isNotNull = function isNotNull(result) {\n  return result != null;\n};\nvar filterModelItems = function filterModelItems(cache, apiRef, items) {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(function (item) {\n      return getFilterCallbackFromItem(item, apiRef) !== null;\n    });\n  }\n  return cache.cleanedFilterItems;\n};\nexport var passFilterLogic = function passFilterLogic(allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) {\n  var cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  var cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  var cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    var _filterModel$logicOpe;\n    // Return true if the item pass with one of the rows\n    var filterItemPredicate = function filterItemPredicate(item) {\n      return cleanedFilterItemResults.some(function (filterItemResult) {\n        return filterItemResult[item.id];\n      });\n    };\n    var logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;\n    if (logicOperator === GridLogicOperator.And) {\n      var passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      var passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    var _filterModel$quickFil4;\n    // Return true if the item pass with one of the rows\n    var quickFilterValuePredicate = function quickFilterValuePredicate(value) {\n      return cleanedQuickFilterResults.some(function (quickFilterValueResult) {\n        return quickFilterValueResult[value];\n      });\n    };\n    var quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      var passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      var passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};","map":{"version":3,"names":["_extends","GridLogicOperator","GLOBAL_API_REF","isInternalFilter","getDefaultGridFilterModel","buildWarning","getPublicApiRef","gridColumnFieldsSelector","gridColumnLookupSelector","gridVisibleColumnFieldsSelector","hasEval","getHasEval","undefined","Function","_","cleanFilterItem","item","apiRef","cleanItem","id","Math","round","random","operator","column","field","filterOperators","value","filterModelDisableMultiColumnsFilteringWarning","filterModelMissingItemIdWarning","filterModelMissingItemOperatorWarning","sanitizeFilterModel","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","hasItemsWithoutIds","some","hasItemWithoutOperator","map","mergeStateWithFilterModel","filterModel","filteringState","removeDiacritics","normalize","replace","getFilterCallbackFromItem","filterItem","current","getColumn","parsedValue","valueParser","_filterItem$value","parser","Array","isArray","x","ignoreDiacritics","rootProps","newFilterItem","Error","concat","filterOperator","find","hasUserFunctionLegacy","getApplyFilterFn","hasUserFunctionV7","getApplyFilterFnV7","publicApiRef","applyFilterOnRow","v7","fn","row","getRowValue","rowId","params","getCellParams","result","filterItemsApplierId","buildAggregatedFilterItemsApplier","disableEval","appliers","filter","callback","shouldApplyFilter","resultPerItemId","i","applier","getRowId","filterItemCore","JSON","stringify","join","String","replaceAll","shouldApplyItem","buildAggregatedQuickFilterApplier","_filterModel$quickFil","_filterModel$quickFil2","_filterModel$quickFil3","quickFilterValues","Boolean","quickFilterExcludeHiddenColumns","columnFields","appliersPerField","forEach","getApplyQuickFilterFn","getApplyQuickFilterFnV7","push","quickFilterValue","isRowMatchingQuickFilter","usedCellParams","outer","v","filterValue","_appliersPerField$i","isMatching","_usedCellParams$field","cellParams","buildAggregatedFilterApplier","isRowMatchingFilterItems","isRowMatchingFilters","_isRowMatchingFilterI","_isRowMatchingQuickFi","passingFilterItems","passingQuickFilterValues","isNotNull","filterModelItems","cache","cleanedFilterItems","passFilterLogic","allFilterItemResults","allQuickFilterResults","cleanedFilterItemResults","cleanedQuickFilterResults","_filterModel$logicOpe","filterItemPredicate","filterItemResult","logicOperator","And","passesAllFilters","every","passesSomeFilters","_filterModel$quickFil4","quickFilterValuePredicate","quickFilterValueResult","quickFilterLogicOperator","passesAllQuickFilterValues","passesSomeQuickFilterValues"],"sources":["/home/runner/work/inference/inference/xinference/ui/web/ui/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { GLOBAL_API_REF, isInternalFilter } from '../../../colDef/utils';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { getPublicApiRef } from '../../../utils/getPublicApiRef';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\nlet hasEval;\nfunction getHasEval() {\n  if (hasEval !== undefined) {\n    return hasEval;\n  }\n  try {\n    hasEval = new Function('return true')();\n  } catch (_) {\n    hasEval = false;\n  }\n  return hasEval;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nexport const removeDiacritics = value => {\n  if (typeof value === 'string') {\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n  }\n  return value;\n};\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    var _filterItem$value;\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  if (ignoreDiacritics) {\n    parsedValue = removeDiacritics(parsedValue);\n  }\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);\n  const hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);\n  const publicApiRef = getPublicApiRef(apiRef);\n  if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n    const applyFilterOnRow = filterOperator.getApplyFilterFnV7(newFilterItem, column);\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n    return {\n      v7: true,\n      item: newFilterItem,\n      fn: row => {\n        let value = apiRef.current.getRowValue(row, column);\n        if (ignoreDiacritics) {\n          value = removeDiacritics(value);\n        }\n        return applyFilterOnRow(value, row, column, publicApiRef);\n      }\n    };\n  }\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    v7: false,\n    item: newFilterItem,\n    fn: rowId => {\n      const params = apiRef.current.getCellParams(rowId, newFilterItem.field);\n      GLOBAL_API_REF.current = publicApiRef;\n      if (ignoreDiacritics) {\n        params.value = removeDiacritics(params.value);\n      }\n      const result = applyFilterOnRow(params);\n      GLOBAL_API_REF.current = null;\n      return result;\n    }\n  };\n};\nlet filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nconst buildAggregatedFilterItemsApplier = (filterModel, apiRef, disableEval) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n  if (disableEval || !getHasEval()) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return (row, shouldApplyFilter) => {\n      const resultPerItemId = {};\n      for (let i = 0; i < appliers.length; i += 1) {\n        const applier = appliers[i];\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.v7 ? applier.fn(row) : applier.fn(apiRef.current.getRowId(row));\n        }\n      }\n      return resultPerItemId;\n    };\n  }\n\n  // We generate a new function with `new Function()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, e.g. `{ [dynamicKey]: value }`.\n  const filterItemCore = new Function('getRowId', 'appliers', 'row', 'shouldApplyFilter', `\"use strict\";\n${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\nconst result$$ = {\n${appliers.map((applier, i) => `  ${JSON.stringify(String(applier.item.id))}: !shouldApply${i}\n    ? false\n    : ${applier.v7 ? `appliers[${i}].fn(row)` : `appliers[${i}].fn(getRowId(row))`},`).join('\\n')}\n};\n\nreturn result$$;`.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n\n  // Assign to the arrow function a name to help debugging\n  const filterItem = (row, shouldApplyItem) => filterItemCore(apiRef.current.getRowId, appliers, row, shouldApplyItem);\n  return filterItem;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nconst buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;\n  const quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;\n  const columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  const appliersPerField = [];\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  const publicApiRef = getPublicApiRef(apiRef);\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n    const getApplyQuickFilterFnV7 = column == null ? void 0 : column.getApplyQuickFilterFnV7;\n    const hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);\n    const hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);\n    if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(quickFilterValue => {\n          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            v7: true,\n            fn: getApplyQuickFilterFnV7(value, column, publicApiRef)\n          };\n        })\n      });\n    } else if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(quickFilterValue => {\n          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            v7: false,\n            fn: getApplyQuickFilterFn(value, column, publicApiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n    const usedCellParams = {};\n\n    /* eslint-disable no-restricted-syntax, no-labels */\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        const applier = appliers[v];\n        let value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (applier.v7) {\n          if (ignoreDiacritics) {\n            value = removeDiacritics(value);\n          }\n          const isMatching = applier.fn(value, row, column, publicApiRef);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        } else {\n          var _usedCellParams$field;\n          const cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef.current.getCellParams(apiRef.current.getRowId(row), field);\n          if (ignoreDiacritics) {\n            cellParams.value = removeDiacritics(cellParams.value);\n          }\n          usedCellParams[field] = cellParams;\n          const isMatching = applier.fn(cellParams);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        }\n      }\n      result[filterValue] = false;\n    }\n    /* eslint-enable no-restricted-syntax, no-labels */\n\n    return result;\n  };\n};\nexport const buildAggregatedFilterApplier = (filterModel, apiRef, disableEval) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    var _isRowMatchingFilterI, _isRowMatchingQuickFi;\n    result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;\n    result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;\n  };\n};\nconst isNotNull = result => result != null;\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n  return cache.cleanedFilterItems;\n};\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    var _filterModel$logicOpe;\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    const logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    var _filterModel$quickFil4;\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    const quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}