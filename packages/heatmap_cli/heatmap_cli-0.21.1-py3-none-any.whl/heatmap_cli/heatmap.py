# Copyright (C) 2023,2024,2025 Kian-Meng Ang
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Main logic to generate heatmap."""

import argparse
import copy
import multiprocessing
import re
import shutil
import webbrowser
from datetime import datetime, timedelta
from pathlib import Path

import io

import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from PIL import Image

# Generate matplotlib graphs without an X server.
# See http://stackoverflow.com/a/4935945
mpl.use("agg")

# Define constants for figure and image settings
DEFAULT_FIGURE_SIZE = (8, 5)
DEFAULT_DPI = 76

# Define constants for GIF animation settings
GIF_DURATION_MS = 1000
GIF_LOOP_COUNT = 0

# Define constants for font sizes
DEFAULT_TICK_LABEL_FONTSIZE = 9
ANNOTATION_FONTSIZE = 8
TITLE_FONTSIZE = 11

# Define constants for colorbar settings
COLORBAR_PAD = 0.10
COLORBAR_ASPECT = 60

# Define constant for filename sanitization
MAX_FILENAME_LENGTH = 100

# Define constants for default title strings
DEFAULT_TITLE_PREFIX = "Year {config.year}: Total Daily Walking Steps"
DEFAULT_TITLE_WEEK_SUFFIX = " Through Week {config.week:02d}"

# Define constants for colorbar labels
COLORBAR_BASE_LABEL = (
    "Generated by: pypi.org/project/heatmap_cli, colormap: {cmap}"
)
COLORBAR_ANNOTATION_SUFFIX = ", count: nearest hundred"

# Define constants for count truncation
TRUNCATE_DIVISOR = 100
TRUNCATE_ROUND_DECIMALS = -2

# Define constants for week ranges
ALL_WEEKS_RANGE = range(1, 54)
ALL_WEEKDAYS_RANGE = range(1, 8)

logger = multiprocessing.get_logger()


def run(config: argparse.Namespace) -> None:
    """Run the main flow.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        None
    """
    logger.debug(config)
    logger.debug("number of cpu: %d", multiprocessing.cpu_count())

    _refresh_output_dir(config)

    base_dataframe = _read_and_prepare_data(config)

    if config.animate_by_week:
        _generate_animated_heatmap(base_dataframe, config)
    else:
        pivoted_dataframe = _filter_and_pivot_data(base_dataframe, config)
        _generate_static_heatmaps(pivoted_dataframe, config)


def _generate_animated_heatmap(
    base_dataframe: pd.DataFrame, config: argparse.Namespace
) -> None:
    """Generate animated heatmap by week.

    This function optimizes the animation generation by pivoting the data only
    once for the entire target week. It then progressively builds each frame
    by adding one day's data at a time, avoiding costly re-computation in a loop.

    Args:
        base_dataframe (pd.DataFrame): The base dataframe with all data.
        config (argparse.Namespace): Config from command line arguments.
    """
    # Pivot the data once for the entire week to get the final state.
    final_pivoted_df = _filter_and_pivot_data(base_dataframe, config)

    # Determine the dates for the animation frames.
    start_of_week = datetime.strptime(
        f"{config.year}-W{config.week}-1", "%G-W%V-%u"
    ).date()
    dates_in_week = [start_of_week + timedelta(days=i) for i in range(7)]

    # Get the data for all weeks *before* the animation week to use as a base.
    config_pre_week = copy.copy(config)
    pre_week_end_date = start_of_week - timedelta(days=1)
    config_pre_week.end_date = pre_week_end_date.strftime("%Y-%m-%d")
    frame_pivoted_df = _filter_and_pivot_data(base_dataframe, config_pre_week)

    frames = []
    for seq, day in enumerate(dates_in_week, 1):
        # Get week and weekday, matching the dataframe's index/columns format.
        iso_week = str(day.isocalendar().week).zfill(2)
        iso_weekday = day.isocalendar().weekday

        # Add the current day's data to the frame's dataframe.
        if (
            iso_week in frame_pivoted_df.columns
            and iso_weekday in frame_pivoted_df.index
        ):
            count = final_pivoted_df.loc[iso_weekday, iso_week]
            frame_pivoted_df.loc[iso_weekday, iso_week] = count

        # Generate the heatmap image for the current state.
        config_for_heatmap = copy.copy(config)
        config_for_heatmap.end_date = day.strftime("%Y-%m-%d")
        config_for_heatmap.open = False

        frame = _generate_heatmap(
            seq,
            config.cmap[0],
            config_for_heatmap,
            frame_pivoted_df.copy(),  # Pass a copy to avoid side effects
            return_image=True,
        )
        frames.append(frame)

    if not frames:
        logger.warning("no frames generated to create GIF animation.")
        return

    config.format = "gif"
    title = _generate_title(config)
    output_dir = _get_output_dir(config)
    img_filename = output_dir / _generate_filename(
        config, 0, config.cmap[0], title
    )
    img_filename.parent.mkdir(parents=True, exist_ok=True)

    frames[0].save(
        img_filename,
        save_all=True,
        append_images=frames[1:],
        optimize=True,
        duration=GIF_DURATION_MS,
        loop=GIF_LOOP_COUNT,
    )
    logger.info("generate animated heatmap: %s", img_filename)

    if config.open:
        _open_heatmap(img_filename)


def _generate_static_heatmaps(
    pivoted_dataframe: pd.DataFrame, config: argparse.Namespace
) -> None:
    """Generate regular heatmaps.

    Args:
        pivoted_dataframe (pd.DataFrame): A fully processed and pivoted DataFrame.
        config (argparse.Namespace): Config from command line arguments.
    """
    args = [
        (*seq_cmap, config, pivoted_dataframe, False)
        for seq_cmap in enumerate(config.cmap, 1)
    ]
    logger.debug(args)

    # Fork, instead of spawn process (child) inherit parent logger config.
    # See https://stackoverflow.com/q/14643568
    with multiprocessing.get_context("fork").Pool() as pool:
        pool.starmap(_generate_heatmap, args)


def _read_and_prepare_data(config: argparse.Namespace) -> pd.DataFrame:
    """
    Reads and performs initial preparation of the data from the CSV file.

    This includes reading the file, converting date columns, checking for
    duplicates, and adding necessary calendar-related columns.

    Args:
        config (argparse.Namespace): Configuration from command line arguments.

    Returns:
        pd.DataFrame: A DataFrame with initial preparations applied.

    Raises:
        FileNotFoundError: If the input CSV file does not exist.
        ValueError: If duplicate dates are found in the input file.
    """
    try:
        dataframe = pd.read_csv(
            config.input_filename, header=None, names=["date", "count"]
        )
    except FileNotFoundError as e:
        logger.error("Input file not found: %s", config.input_filename)
        raise e

    dataframe["date"] = pd.to_datetime(dataframe["date"])

    duplicate_dates = dataframe[dataframe["date"].duplicated(keep=False)]
    if not duplicate_dates.empty:
        dup_dates_str = ", ".join(
            duplicate_dates["date"].dt.date.astype(str).unique()
        )
        raise ValueError(f"Duplicate dates found: {dup_dates_str}")

    dataframe["weekday"] = dataframe["date"].dt.weekday + 1
    dataframe["year"] = dataframe["date"].dt.isocalendar().year
    dataframe["week"] = (
        dataframe["date"].dt.isocalendar().week.astype(str).str.zfill(2)
    )
    if config.annotate:
        dataframe["count"] = dataframe["count"].apply(_truncate_rounded_count)

    return dataframe


def _filter_and_pivot_data(
    dataframe: pd.DataFrame, config: argparse.Namespace
) -> pd.DataFrame:
    """
    Filters, structures, and pivots the prepared data for the heatmap.

    This function takes a prepared DataFrame, filters it based on the year and
    week/end date, merges it with a full-year structure to handle missing
    days, and pivots it into the final format for plotting.

    Args:
        dataframe (pd.DataFrame): The initially prepared DataFrame.
        config (argparse.Namespace): Configuration from command line arguments.

    Returns:
        pd.DataFrame: A pivoted DataFrame ready for heatmap plotting.

    Raises:
        ValueError: If no data is extracted for the specified period.
    """
    if config.end_date:
        steps = dataframe.loc[
            (dataframe["year"] == config.year)
            & (dataframe["date"] <= config.end_date)
        ].copy()
    elif config.week >= 52:
        steps = dataframe.loc[dataframe["year"] == config.year].copy()
    else:
        steps = dataframe[
            (dataframe["year"] == config.year)
            & (dataframe["week"] <= str(config.week).zfill(2))
        ].copy()

    if steps.empty:
        raise ValueError(
            "No data extracted from CSV file for the specified period!"
        )

    logger.debug("Last date in filtered data: %s", max(steps["date"]).date())

    start_date = pd.to_datetime(f"{config.year}-01-01")
    end_date = pd.to_datetime(f"{config.year}-12-31")
    full_year_dates = pd.date_range(start=start_date, end=end_date, freq="D")
    full_year_structure = pd.DataFrame({"date": full_year_dates})
    full_year_structure["weekday"] = full_year_structure["date"].dt.weekday + 1
    full_year_structure["week"] = (
        full_year_structure["date"]
        .dt.isocalendar()
        .week.astype(str)
        .str.zfill(2)
    )

    steps_to_merge = steps[["date", "count"]]
    merged_data = pd.merge(
        full_year_structure, steps_to_merge, on="date", how="left"
    )

    merged_data["count"] = merged_data["count"].fillna(0).astype(int)

    year_dataframe = merged_data.pivot_table(
        values="count", index=["weekday"], columns=["week"], fill_value=0
    )

    all_weeks = [str(w).zfill(2) for w in ALL_WEEKS_RANGE]
    year_dataframe = year_dataframe.reindex(columns=all_weeks, fill_value=0)
    year_dataframe = year_dataframe.reindex(
        index=ALL_WEEKDAYS_RANGE, fill_value=0
    )

    return year_dataframe


def _truncate_rounded_count(count: float) -> int:
    """Truncate and round count values to fit them in heatmap box.

    Rounds the count to the nearest hundred and then divides by 100.
    This transformation is applied when annotations are enabled to simplify
    large numbers and make them fit visually within the heatmap cells.
    For example, 12345 becomes 123, 5678 becomes 57.

    Args:
        count (int/float): The original count value.

    Returns:
        int: Truncated count value (divided by 100).
    """
    return int(round(count, TRUNCATE_ROUND_DECIMALS) / TRUNCATE_DIVISOR)


def _generate_heatmap(
    seq: int,
    cmap: str,
    config: argparse.Namespace,
    dataframe: pd.DataFrame,
    return_image: bool = False,
) -> Image.Image | None:
    """Generate a heatmap.

    Args:
        seq (int): Sequence number for generated heatmap image file.
        cmap (str): Colormap name used for the heatmap.
        config (argparse.Namespace): Config from command line arguments.
        dataframe (pd.core.frame.DataFrame): DataFrame with data loaded from
        CSV file.
        return_image (bool): If True, returns a PIL Image object instead of
        saving to disk.

    Returns:
        Optional[Image.Image]: The PIL Image object if return_image is True,
        otherwise None.
    """
    _, axis = plt.subplots(figsize=DEFAULT_FIGURE_SIZE)
    axis.tick_params(
        axis="both", which="major", labelsize=DEFAULT_TICK_LABEL_FONTSIZE
    )
    axis.tick_params(
        axis="both", which="minor", labelsize=DEFAULT_TICK_LABEL_FONTSIZE
    )

    options, cbar_options = _configure_heatmap_options(config, cmap, axis)
    res = sns.heatmap(dataframe, **options)

    if config.annotate:
        _apply_annotations(res)

    if config.cbar:
        _configure_cbar(res)

    title = _generate_title(config)
    _set_plot_titles(axis, config, title)

    result = _save_heatmap_figure(config, seq, cmap, title, return_image)

    if return_image:
        return result

    img_filename = result
    logger.info("generate heatmap: %s", img_filename)

    if config.open:
        _open_heatmap(img_filename)

    return None


def _configure_heatmap_options(
    config: argparse.Namespace, cmap: str, axis: plt.Axes
) -> tuple[dict, dict]:
    """Configure options for the heatmap plot.

    Args:
        config (argparse.Namespace): Config from command line arguments.
        cmap (str): Colormap name for the heatmap.
        axis (plt.Axes): Matplotlib axes object.

    Returns:
        tuple[dict, dict]: A tuple containing heatmap options and colorbar options.
    """
    cbar_options = {
        "orientation": "horizontal",
        "label": COLORBAR_BASE_LABEL.format(cmap=cmap),
        "pad": COLORBAR_PAD,
        "aspect": COLORBAR_ASPECT,
        "extend": "max",
    }
    options = {
        "ax": axis,
        "fmt": "",
        "square": True,
        "cmap": cmap,
        "cbar": config.cbar,
        "cbar_kws": cbar_options,
    }

    if config.cmap_min:
        options["vmin"] = config.cmap_min
    if config.cmap_max:
        options["vmax"] = config.cmap_max

    if config.annotate:
        cbar_options["label"] = (
            f"{cbar_options['label']}{COLORBAR_ANNOTATION_SUFFIX}"
        )
        options.update(
            {
                "annot": True,
                "annot_kws": {"fontsize": ANNOTATION_FONTSIZE},
                "linewidth": 0,
            }
        )
    return options, cbar_options


def _apply_annotations(res: plt.Axes) -> None:
    """Apply custom annotations to the heatmap cells.

    Args:
        res (plt.Axes): The matplotlib axes object returned by seaborn.
    """
    for text in res.texts:
        count = int(float(text.get_text()))
        if count >= 100:
            text.set_text(">" + str(count)[0])
        else:
            text.set_text(str(count))


def _configure_cbar(res: plt.Axes) -> None:
    """Configure the colorbar of the heatmap.

    Args:
        res (plt.Axes): The matplotlib axes object returned by seaborn.
    """
    cbar = res.collections[0].colorbar
    cbar.set_label(cbar.ax.get_xlabel(), rotation=0, labelpad=8, loc="left")


def _set_plot_titles(
    axis: plt.Axes, config: argparse.Namespace, title: str
) -> None:
    """Set the titles for the heatmap plot.

    Args:
        axis (plt.Axes): Matplotlib axes object.
        config (argparse.Namespace): Config from command line arguments.
        title (str): The main title of the plot.
    """
    axis.set_title(title, fontsize=TITLE_FONTSIZE, loc="left")
    axis.set_title(config.author, fontsize=TITLE_FONTSIZE, loc="right")


def _save_heatmap_figure(
    config: argparse.Namespace,
    seq: int,
    cmap: str,
    title: str,
    return_image: bool = False,
) -> Path | Image.Image:
    """Save the heatmap figure to a file or return it as a PIL Image object.

    Args:
        config (argparse.Namespace): Config from command line arguments.
        seq (int): Sequence number for the output file.
        cmap (str): Colormap name used for the heatmap.
        title (str): The title of the heatmap.
        return_image (bool): If True, returns a PIL Image object instead of
        saving to disk.

    Returns:
        Path: The path to the saved image file if not returning image.
        Image.Image: The PIL Image object if return_image is True.
    """
    plt.tight_layout()

    if return_image:
        buffer = io.BytesIO()
        plt.savefig(
            buffer,
            bbox_inches="tight",
            transparent=False,
            dpi=DEFAULT_DPI,
            format="png",
        )
        plt.close()
        buffer.seek(0)
        return Image.open(buffer).copy()

    output_dir = _get_output_dir(config)
    img_filename = output_dir / _generate_filename(config, seq, cmap, title)
    img_filename.parent.mkdir(parents=True, exist_ok=True)

    plt.savefig(
        img_filename,
        bbox_inches="tight",
        transparent=False,
        dpi=DEFAULT_DPI,
        format=config.format,
    )
    plt.close()
    return img_filename


def _open_heatmap(filename: Path) -> None:
    """Open generated heatmap using the default program.

    Args:
        filename (str): The filename of the heatmap to open.

    Returns:
        None
    """
    file_uri = f"file://{filename.resolve()}"
    webbrowser.open(file_uri)
    logger.info("Open heatmap: %s using default program.", filename.resolve())


def _sanitize_string_for_filename(s: str) -> str:
    """Sanitize a string to be suitable for use in a filename.

    Replaces spaces with underscores, removes non-alphanumeric characters
    (except underscore, dot, and hyphen), and limits length.

    Args:
        s (str): The input string to sanitize.

    Returns:
        str: The sanitized string.
    """
    s = s.strip().lower()
    s = re.sub(r"\s+", "_", s)  # Replace spaces with single underscore
    # Remove characters not alphanumeric, underscore, dot, or hyphen
    s = re.sub(r"[^\w._-]+", "", s)
    # Limit length to prevent overly long filenames
    return s[:MAX_FILENAME_LENGTH]


def _generate_filename(
    config: argparse.Namespace, seq: int, cmap: str, title_str: str
) -> str:
    """Generate an image filename based on the title.

    Args:
        config (argparse.Namespace): Config from command line arguments.
        seq (int): Sequence number for generated heatmap image file.
        cmap (str): Colormap name used for the heatmap.
        title_str (str): The title of the heatmap.

    Returns:
        str: A generated file name for the image.
    """
    annotated_suffix = "_annotated" if config.annotate else ""
    animated_suffix = "_animated" if config.format == "gif" else ""

    sanitized_title_part = _sanitize_string_for_filename(title_str)

    return (
        f"{seq:03d}_{sanitized_title_part}_{cmap}{annotated_suffix}{animated_suffix}"
        f".{config.format}"
    )


def _generate_title(config: argparse.Namespace) -> str:
    """Generate a title for the heatmap.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        str: A generated title for the heatmap.
    """
    if not config.title:
        title = DEFAULT_TITLE_PREFIX.format(config=config)
        # If config.week is less than 52, it means a partial year is requested.
        # config.week >= 52 implies the whole year data is used (as per
        # _massage_data logic).
        if config.week < 52:
            title += DEFAULT_TITLE_WEEK_SUFFIX.format(config=config)
    else:
        title = config.title

    logger.debug(title)
    return title


def _refresh_output_dir(config: argparse.Namespace) -> None:
    """Delete and recreate the output folder.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        None
    """
    output_dir = _get_output_dir(config)

    # Determine if purging is required based on --purge and --yes flags.
    should_purge = False
    if config.purge:
        if config.yes:
            should_purge = True
        else:
            prompt = (
                f"Are you sure to purge output folder: {output_dir}? [y/N] "
            )
            if input(prompt).lower() in ["y", "yes"]:
                should_purge = True

    # If purging is required and the directory exists, remove it.
    if should_purge and output_dir.exists():
        logger.info("Purging output folder: %s", output_dir.absolute())
        try:
            shutil.rmtree(output_dir)
        except OSError as e:
            logger.error("Error removing directory: %s - %s.", output_dir, e)
            # Depending on desired error handling, you might want to raise an exception here.
            return

    # Ensure the output directory exists for writing files.
    # This will create it if it doesn't exist or was just purged.
    logger.info("Ensuring output folder exists: %s", output_dir.absolute())
    output_dir.mkdir(parents=True, exist_ok=True)


def _get_output_dir(config: argparse.Namespace) -> Path:
    """Get the current working directory.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        str: The output directory path.
    """
    output_dir = Path(config.output_dir)
    if output_dir.is_absolute():
        return output_dir

    return Path.cwd() / config.output_dir
