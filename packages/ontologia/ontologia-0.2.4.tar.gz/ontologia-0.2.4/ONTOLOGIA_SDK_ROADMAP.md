# Ontologia SDK and CLI — Roadmap to 100% Programmatic

This document guides contributors to evolve Ontologia into a Foundry-like, fully programmatic platform. It describes what exists today, the target developer experience, the architecture, and a step-by-step plan with concrete deliverables, acceptance criteria, and test strategy.

The only inputs you need are this document and the codebase.

---

## 1) Current Capabilities (Baseline)

The baseline is already solid and ready to extend.

- **CLI package**: `ontologia_cli/`
  - Commands in `ontologia_cli/main.py`:
    - `validate` — validates local YAML under `example_project/ontology/`
    - `diff` — compares local YAML vs server, with impact analysis
    - `apply` — applies a plan to the server (safe by default; `--yes`, `--allow-destructive`)
    - `generate-sdk` — generates a static SDK from the server or local YAML
  - Remote vs Local generation:
    - Remote: `uv run ontologia-cli generate-sdk --host http://127.0.0.1:8000 --ontology default`
    - Local: `uv run ontologia-cli --dir example_project/ontology generate-sdk --source local`
  - Diff intelligence: `--deps` and `--impact` consult API capabilities (e.g., aggregates) to estimate risk.

- **SDK package**: `ontologia_sdk/`
  - Client: `ontologia_sdk/client.py` (`OntologyClient`)
    - Metamodel: `list_object_types()`, `list_link_types()`, `list_interfaces()`
    - Objects: `get_object()`, `upsert_object()`, `delete_object()`, `search_objects()`
    - Traversal: `traverse(from_object_type, from_pk, link_type, limit, offset)`
    - Links: `create_link()`, `get_link()`, `list_links()`, `delete_link()`
    - Actions: `list_actions()`, `execute_action()`
  - Query builder: `ontologia_sdk/query.py` (initial skeleton)
  - Mocking: `ontologia_sdk/testing.py` (`MockOntologyClient` for unit tests)

- **Code generation (SDK)**
  - Files generated by `generate-sdk` into `ontologia_sdk/ontology/`:
    - `objects.py` — one class per `ObjectType` with typed attributes; helpers for traversal and links; actions helpers; search helpers and `search_builder()`
    - `links.py` — one class per `LinkType` with typed link property containers (`<LinkType>LinkProperties`)
    - `__init__.py` — explicit imports + `__all__` for linters
  - Generated helpers example on an `Employee` object:
    - `traverse_works_for(limit=100, offset=0)`
    - `get_works_for_link(to_pk)` / `get_works_for_link_typed(to_pk)`
    - `create_works_for(to_pk, properties)` / `delete_works_for(to_pk)` / `list_works_for(to_pk=None)`
    - `list_actions()` / `execute_action(action_api_name, parameters)`
    - `search(client, where=[...], ...)` and `search_builder(client)`

- **API contract (v2) relevant to SDK**
  - Linked objects: see `api/v2/routers/linked_objects.py`
    - `POST   /links/{linkTypeApiName}` (create)
    - `GET    /links/{linkTypeApiName}` (list)
    - `GET    /links/{linkTypeApiName}/{fromPk}/{toPk}` (get)
    - `DELETE /links/{linkTypeApiName}/{fromPk}/{toPk}` (delete)
  - Actions: see `api/v2/routers/actions.py`
    - `GET  /objects/{objectType}/{pk}/actions` (discover)
    - `POST /objects/{objectType}/{pk}/actions/{action}/execute` (execute)

- **Tests**
  - `tests/unit/test_cli_generate_sdk.py` and `tests/unit/test_cli_generate_sdk_links.py` — validate codegen
  - `tests/unit/test_sdk_smoke_mock.py` — smoke test using `MockOntologyClient`

---

## 2) Design Principles

- **Ontology as Code**: YAML is the local source of truth; API reconciles to the server state.
- **Code generation is idempotent**: running the generator repeatedly yields stable outputs.
- **Type safety and linting**: MyPy-friendly shapes where practical; Ruff/Black cleanups; no star-imports.
- **Backwards compatibility**: keep existing generated helpers while introducing richer abstractions.
- **Ergonomics over ceremony**: Results should look and feel like a first-class, fluent SDK.

---

## 3) Target Developer Experience (DX)

- **Queries**
  - Write fluent, typed filters with operator overloading:
    ```python
    from ontologia_sdk.ontology import Employee

    engineers = (
        Employee
        .search_builder(client)
        .where((Employee.dept == "Engineering") & (Employee.age >= 30))
        .order_by(Employee.age.asc())
        .limit(50)
        .all()
    )
    ```

- **Links as collections**
  - Access links via a natural collection-like API:
    ```python
    alice = Employee.get(client, "e1")
    companies = alice.works_for.all()
    alice.works_for.create(to_pk="c1", properties={"role": "Engineer"})
    role = alice.works_for.get_typed("c1").role
    alice.works_for.delete("c1")
    ```

- **Actions as callables**
  - Invoke actions through a dynamic namespace, optionally with parameter validation:
    ```python
    # Client-level
    client.actions.promote_employee(object_type="employee", pk="e1", level="L3")

    # Object-level
    alice.actions.promote(level="L3")
    ```

- **Typed responses + pagination**
  - Iterate pages and map link properties to typed classes automatically:
    ```python
    results = alice.works_for.iter_pages(page_size=100)
    for page in results:
        for edge in page.data:
            assert edge.link_properties.role in ("Engineer", "Manager")
    ```

---

## 4) Implementation Plan (Phased)

Each phase is independently shippable and keeps current helpers working.

### Phase 1 — Query DSL (FieldDescriptor)

- **Goal**: Replace dict-based filters by a fluent DSL; still accept dicts for compatibility.
- **Modules**
  - `ontologia_sdk/dsl.py`
    - `FieldDescriptor`: describes a property, overloads `==`, `!=`, `>`, `>=`, `<`, `<=`, `in`.
    - `Expr`: composable expression with `&` and `|` (and parentheses for precedence).
    - `OrderKey`: e.g., `Employee.age.asc()` / `Employee.age.desc()`.
  - `ontologia_sdk/query.py`
    - Update `QueryBuilder.where()` and `.order_by()` to accept `Expr`/`OrderKey` or legacy dicts.
- **Codegen** (`ontologia_cli/main.py`)
  - Emit a metaclass `ObjectTypeMeta` that defines `__getattr__` to return `FieldDescriptor` for class-level access: `Employee.dept`.
  - Keep instance attributes typed as today (`emp.dept` remains a value), avoiding conflicts.
  - Register `__fields__` on each generated class with property metadata.
- **Example**
  ```python
  # New
  Employee.search_builder(client).where(Employee.dept == "Eng").all()
  # Legacy still works
  Employee.search(client, where=[{"property": "dept", "op": "eq", "value": "Eng"}])
  ```
- **Acceptance**
  - Unit tests cover operator overloads, composition, and serialization.

### Phase 2 — LinkSetProxy (links como coleções)

- **Goal**: Substituir métodos `traverse_*`/`create_*` por um descritor colecionável, mantendo os helpers atuais.
- **Modules**
  - `ontologia_sdk/link_proxy.py`
    - `LinkDescriptor(link_type, to_object_type)` → on class
    - `BoundLinkSetProxy(instance, link_type, to_object_type, client)`
      - `.all(limit=100, offset=0)` — traversal results
      - `.get(to_pk)` / `.get_typed(to_pk)`
      - `.create(to_pk, properties=None)` / `.delete(to_pk)`
      - `.list(to_pk=None)`
      - `.iter_pages(page_size=100)`
- **Codegen** (`ontologia_cli/main.py`)
  - For each outgoing `LinkType`, add `link_name = LinkDescriptor("<api>", to="<toType>")` on the source class.
  - Keep generating existing helpers to avoid breaking users.
- **Acceptance**
  - Unit tests verifying all methods with `MockOntologyClient`.

### Phase 3 — Actions Namespace (dinâmico, validável)

- **Goal**: Invocar ações como funções com validação opcional.
- **Modules**
  - `ontologia_sdk/actions.py`
    - `ActionsNamespace(client)` com `__getattr__` → retorna `ActionCallable` (client-level)
    - `ObjectActionsNamespace(client, object_type, pk)` (object-level)
    - Validação (opcional): cache de `list_actions()` com TTL; falha amigável para parâmetros ausentes/tipo incorreto.
  - `ontologia_sdk/client.py`
    - Expor `self.actions = ActionsNamespace(self)`
  - Codegen: `BaseObject` expõe `self.actions = ObjectActionsNamespace(self._client, cls.object_type_api_name, self.pk)`
- **Acceptance**
  - Unit tests cobrindo caminho feliz e erros de validação.

### Phase 4 — Typed Responses e Paginação

- **Goal**: Retornos enriquecidos com tipos, sem quebrar compat.
- **Modules**
  - `ontologia_sdk/types.py`
    - `Page[T]` (genérico)
    - `LinkedEdge` com `link_properties` do tipo `<LinkType>LinkProperties` quando aplicável
    - `TraversalResult`, `ObjectRef`
  - Mapping em `OntologyClient`/proxies para opcionalmente construir wrappers tipados.
- **API**
  - `.all_typed()` retorna `Page[LinkedEdge]`
  - `.iter_pages_typed(page_size)` — gerador de páginas tipadas
- **Acceptance**
  - Unit tests asseguram mapeamento para classes *LinkProperties*.

### Phase 5 — Documentação do SDK

- **Goal**: Entregável de DX — guia completo para devs.
- **Artifacts**
  - `ontologia_sdk/README.md` com: instalação, geração, cliente, DSL, links (proxy), ações, paginação, mocking, troubleshooting.
  - Trechos prontos para copiar/colar e diagramas simples (Mermaid quando útil).

### Phase 6 — CI, Versionamento e Release

- **Goal**: Confiança e distribuição.
- **Pipeline**
  - Pre-commit: Ruff/Black, type checks (Pyright/Mypy se habilitado)
  - Testes: incluir geração de SDK contra `example_project/ontology/`
  - Build: `uvx python -m build` + `twine check`
  - Release: TestPyPI opcional, depois PyPI (sem chaves no repo)

---

## 5) Task Breakdown, Owners e Checklists

Para cada fase, crie PRs pequenos com testes e docs parciais.

- **Phase 1 – Query DSL**
  - [ ] `ontologia_sdk/dsl.py` com `FieldDescriptor`, `Expr`, `OrderKey`
  - [ ] Atualizar `ontologia_sdk/query.py` para aceitar DSL
  - [ ] Codegen: metaclass e `__fields__` por classe
  - [ ] Testes: operadores, composição, serialização

- **Phase 2 – LinkSetProxy**
  - [ ] `ontologia_sdk/link_proxy.py` com descritor e proxy encadeado
  - [ ] Codegen: adicionar descritores por `LinkType` de saída
  - [ ] Testes: `all()`, `get()`, `get_typed()`, `create()`, `delete()`, `iter_pages()`

- **Phase 3 – Actions Namespace**
  - [ ] `ontologia_sdk/actions.py` com namespaces (client e object)
  - [ ] Wire no `OntologyClient` e `BaseObject`
  - [ ] Testes com e sem validação

- **Phase 4 – Typed Responses**
  - [ ] `ontologia_sdk/types.py` com wrappers
  - [ ] Mapear mapeamentos opcionais no client/proxies
  - [ ] Testes de paginação e tipos

- **Phase 5 – Docs**
  - [ ] `ontologia_sdk/README.md` com Quickstart e exemplos

- **Phase 6 – Release**
  - [ ] Tarefas Just e workflow CI
  - [ ] Versionamento + CHANGELOG

---

## 6) Testing Strategy

- **Unit**
  - DSL: operadores (`==`, `!=`, `>`, `>=`, `<`, `<=`, `in`), composição `&`/`|`, order keys
  - Link proxies: todas operações, incluindo `iter_pages()`
  - Actions: execução, validação, mensagens de erro
  - Typed responses: mapeamento de `linkProperties`
- **Integration (lightweight)**
  - Codegen em cima de `example_project/ontology/` local; executar smoke com `MockOntologyClient` e (opcional) contra API local
- **Non-goals**
  - Performance benchmarking (fora do escopo inicial)

---

## 7) Development Guidelines

- **Lint/format**: Ruff + Black (pre-commit); evitar star-import; adicionar `# noqa: N815` em atributos gerados com `mixedCase`
- **Compatibilidade**: manter helpers gerados existentes; adições não devem quebrar usuários
- **Tipos**: preferir `typing` padrão; evitar dependência forte em Pydantic nos modelos gerados (são simples classes)
- **Erros**: clientes devem propagar HTTP errors de forma clara (`httpx.raise_for_status()` já cumpre)
- **Commits**: pequenos, descritivos; testes e docs juntos

---

## 8) Open Questions

- Devemos oferecer um cliente assíncrono (`httpx.AsyncClient`)?
- Precisamos suportar tipos adicionais (`decimal`, `uuid`)? Mapeamento e coerção.
- Cache de `list_actions`: TTL padrão? Invalidar sob quais condições?
- Paginadores de traversal: streaming vs page-by-page; qual API pública preferir?

---

## 9) Appendix — Quick References

- **Commands**
  ```bash
  # Local (YAML)
  uv run ontologia-cli --dir example_project/ontology generate-sdk --source local

  # Remoto (API)
  uv run ontologia-cli generate-sdk --host http://127.0.0.1:8000 --ontology default
  ```

- **Key paths**
  - CLI: `ontologia_cli/main.py`
  - SDK client: `ontologia_sdk/client.py`
  - SDK query: `ontologia_sdk/query.py`
  - SDK testing: `ontologia_sdk/testing.py`
  - Generated SDK: `ontologia_sdk/ontology/`
  - API routers: `api/v2/routers/linked_objects.py`, `api/v2/routers/actions.py`

- **Environment flags**
- `USE_UNIFIED_GRAPH=1` — reforça o modo unificado (já habilitado por padrão)
  - `USE_TEMPORAL_ACTIONS=1` — usa Temporal para ações (quando disponível)

---

## 10) Definition of Done (per phase)

- Código implementado + testes passando (local e CI)
- Documentação atualizada (trechos no README do SDK quando relevante)
- Sem regressões nos helpers existentes
- Code review aprovado; lints e format limpos
