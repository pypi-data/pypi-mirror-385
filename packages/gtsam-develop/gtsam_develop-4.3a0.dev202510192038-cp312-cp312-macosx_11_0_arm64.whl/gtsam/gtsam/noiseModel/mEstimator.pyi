"""
mEstimator submodule
"""
from __future__ import annotations
import collections.abc
import typing
__all__: list[str] = ['AsymmetricCauchy', 'AsymmetricTukey', 'Base', 'Cauchy', 'Custom', 'DCS', 'Fair', 'GemanMcClure', 'Huber', 'L2WithDeadZone', 'Null', 'Tukey', 'Welsch']
class AsymmetricCauchy(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> AsymmetricCauchy:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class AsymmetricTukey(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> AsymmetricTukey:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Base:
    class ReweightScheme:
        """
        Members:
        
          Scalar
        
          Block
        """
        Block: typing.ClassVar[Base.ReweightScheme]  # value = <ReweightScheme.Block: 1>
        Scalar: typing.ClassVar[Base.ReweightScheme]  # value = <ReweightScheme.Scalar: 0>
        __members__: typing.ClassVar[dict[str, Base.ReweightScheme]]  # value = {'Scalar': <ReweightScheme.Scalar: 0>, 'Block': <ReweightScheme.Block: 1>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: typing.SupportsInt) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: typing.SupportsInt) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __repr__(self, s: str = '') -> str:
        ...
    def print(self, s: str = '') -> None:
        ...
class Cauchy(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> Cauchy:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Custom(Base):
    @staticmethod
    def Create(weight: collections.abc.Callable[[typing.SupportsFloat], float], loss: collections.abc.Callable[[typing.SupportsFloat], float], reweight: Base.ReweightScheme, name: str) -> Custom:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, weight: collections.abc.Callable[[typing.SupportsFloat], float], loss: collections.abc.Callable[[typing.SupportsFloat], float], reweight: Base.ReweightScheme, name: str) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class DCS(Base):
    @staticmethod
    def Create(c: typing.SupportsFloat) -> DCS:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, c: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, c: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Fair(Base):
    @staticmethod
    def Create(c: typing.SupportsFloat) -> Fair:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, c: typing.SupportsFloat) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class GemanMcClure(Base):
    @staticmethod
    def Create(c: typing.SupportsFloat) -> GemanMcClure:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, c: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, c: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Huber(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> Huber:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class L2WithDeadZone(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> L2WithDeadZone:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Null(Base):
    @staticmethod
    def Create() -> Null:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Tukey(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> Tukey:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
class Welsch(Base):
    @staticmethod
    def Create(k: typing.SupportsFloat) -> Welsch:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, k: typing.SupportsFloat, reweight: Base.ReweightScheme) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def loss(self, error: typing.SupportsFloat) -> float:
        ...
    def serialize(self) -> str:
        ...
    def weight(self, error: typing.SupportsFloat) -> float:
        """
        produce a weight vector according to an error vector and the implemented robust function
        """
