"""
utilities submodule
"""
from __future__ import annotations
import collections.abc
import gtsam.gtsam
import gtsam.gtsam.noiseModel
import numpy
import numpy.typing
import typing
__all__: list[str] = ['allPose2s', 'allPose3s', 'createKeyList', 'createKeySet', 'createKeyVector', 'extractPoint2', 'extractPoint3', 'extractPose2', 'extractPose3', 'extractVectors', 'insertBackprojections', 'insertProjectionFactors', 'localToWorld', 'perturbPoint2', 'perturbPoint3', 'perturbPose2', 'reprojectionErrors']
def allPose2s(values: gtsam.gtsam.Values) -> gtsam.gtsam.Values:
    ...
def allPose3s(values: gtsam.gtsam.Values) -> gtsam.gtsam.Values:
    ...
@typing.overload
def createKeyList(I: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> gtsam.gtsam.KeyList:
    ...
@typing.overload
def createKeyList(s: str, I: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> gtsam.gtsam.KeyList:
    ...
@typing.overload
def createKeySet(I: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> gtsam.gtsam.KeySet:
    ...
@typing.overload
def createKeySet(s: str, I: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> gtsam.gtsam.KeySet:
    ...
@typing.overload
def createKeyVector(I: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> list[int]:
    ...
@typing.overload
def createKeyVector(s: str, I: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> list[int]:
    ...
def extractPoint2(values: gtsam.gtsam.Values) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
    ...
def extractPoint3(values: gtsam.gtsam.Values) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
    ...
def extractPose2(values: gtsam.gtsam.Values) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
    ...
def extractPose3(values: gtsam.gtsam.Values) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
    ...
def extractVectors(values: gtsam.gtsam.Values, c: str) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
    ...
def insertBackprojections(values: gtsam.gtsam.Values, c: gtsam.gtsam.PinholeCameraCal3_S2, J: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], Z: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, n]"], depth: typing.SupportsFloat) -> None:
    ...
def insertProjectionFactors(graph: gtsam.gtsam.NonlinearFactorGraph, i: typing.SupportsInt, J: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], Z: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, n]"], model: gtsam.gtsam.noiseModel.Base, K: gtsam.gtsam.Cal3_S2, body_P_sensor: gtsam.gtsam.Pose3 = ...) -> None:
    ...
@typing.overload
def localToWorld(local: gtsam.gtsam.Values, base: gtsam.gtsam.Pose2) -> gtsam.gtsam.Values:
    ...
@typing.overload
def localToWorld(local: gtsam.gtsam.Values, base: gtsam.gtsam.Pose2, keys: collections.abc.Sequence[typing.SupportsInt]) -> gtsam.gtsam.Values:
    ...
def perturbPoint2(values: gtsam.gtsam.Values, sigma: typing.SupportsFloat, seed: typing.SupportsInt = 42) -> None:
    ...
def perturbPoint3(values: gtsam.gtsam.Values, sigma: typing.SupportsFloat, seed: typing.SupportsInt = 42) -> None:
    ...
def perturbPose2(values: gtsam.gtsam.Values, sigmaT: typing.SupportsFloat, sigmaR: typing.SupportsFloat, seed: typing.SupportsInt = 42) -> None:
    ...
def reprojectionErrors(graph: gtsam.gtsam.NonlinearFactorGraph, values: gtsam.gtsam.Values) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
    ...
