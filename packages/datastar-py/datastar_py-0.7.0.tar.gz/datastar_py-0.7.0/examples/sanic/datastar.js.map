{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/text.ts", "../library/src/utils/polyfills.ts", "../library/src/utils/paths.ts", "../library/src/engine/signals.ts", "../library/src/utils/dom.ts", "../library/src/engine/engine.ts", "../library/src/engine/morph.ts", "../library/src/plugins/actions/peek.ts", "../library/src/plugins/actions/setAll.ts", "../library/src/plugins/actions/toggleAll.ts", "../library/src/plugins/actions/fetch.ts", "../library/src/plugins/attributes/attr.ts", "../library/src/plugins/attributes/bind.ts", "../library/src/plugins/attributes/class.ts", "../library/src/plugins/attributes/computed.ts", "../library/src/plugins/attributes/effect.ts", "../library/src/plugins/attributes/indicator.ts", "../library/src/plugins/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/attributes/on.ts", "../library/src/plugins/attributes/onIntersect.ts", "../library/src/plugins/attributes/onInterval.ts", "../library/src/plugins/attributes/init.ts", "../library/src/plugins/attributes/onSignalPatch.ts", "../library/src/plugins/attributes/ref.ts", "../library/src/plugins/attributes/show.ts", "../library/src/plugins/attributes/signals.ts", "../library/src/plugins/attributes/style.ts", "../library/src/plugins/attributes/text.ts", "../library/src/plugins/watchers/patchElements.ts", "../library/src/plugins/watchers/patchSignals.ts"],
  "sourcesContent": ["const lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\nexport const DATASTAR_FETCH_EVENT = 'datastar-fetch'\nexport const DATASTAR_SIGNAL_PATCH_EVENT = 'datastar-signal-patch'\n", "import type { Modifiers } from '@engine/types'\n\nexport const kebab = (str: string): string =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string): string =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string): string => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string): string =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = {\n  camel: (str) => str.replace(/-[a-z]/g, (x) => x[1].toUpperCase()),\n  snake: (str) => str.replace(/-/g, '_'),\n  pascal: (str) => str[0].toUpperCase() + caseFns.camel(str.slice(1)),\n}\n\nexport const modifyCasing = (\n  str: string,\n  mods: Modifiers,\n  defaultCase = 'camel',\n): string => {\n  for (const c of mods.get('case') || [defaultCase]) {\n    str = caseFns[c]?.(str) || str\n  }\n  return str\n}\n\nexport const aliasify = (name: string) =>\n  ALIAS ? `data-${ALIAS}-${name}` : `data-${name}`\n", "export const hasOwn: (obj: object, prop: PropertyKey) => boolean =\n  // @ts-expect-error\n  Object.hasOwn ?? Object.prototype.hasOwnProperty.call\n", "import type { Paths } from '@engine/types'\nimport { hasOwn } from '@utils/polyfills'\n\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport const isEmpty = (obj: Record<string, any>): boolean => {\n  for (const prop in obj) {\n    if (hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const updateLeaves = (\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) => {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (paths: Paths): Record<string, any> => {\n  const result: Record<string, any> = {}\n  for (const [path, value] of paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result)\n    obj[lastKey] = value\n  }\n  return result\n}\n", "import { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport type {\n  Computed,\n  Effect,\n  JSONPatch,\n  MergePatchArgs,\n  Paths,\n  Signal,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { isPojo, pathToObj } from '@utils/paths'\nimport { hasOwn } from '@utils/polyfills'\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  version_: number\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = unknown> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = unknown> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nconst currentPatch: Paths = []\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet prevSub: ReactiveNode | undefined\nlet activeSub: ReactiveNode | undefined\nlet version = 0\n\nexport const beginBatch = (): void => {\n  batchDepth++\n}\n\nexport const endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nexport const startPeeking = (sub?: ReactiveNode): void => {\n  prevSub = activeSub\n  activeSub = sub\n}\n\nexport const stopPeeking = (): void => {\n  activeSub = prevSub\n  prevSub = undefined\n}\n\nexport const signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nexport const computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-expect-error\n  c[computedSymbol] = 1\n  return c\n}\n\nexport const effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  startPeeking(e)\n  beginBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    stopPeeking()\n  }\n  return effectOper.bind(0, e)\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  startPeeking(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    stopPeeking()\n    endTracking(c)\n  }\n}\n\nconst updateSignal = <T>(s: AlienSignal<T>, value: T): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    startPeeking(e)\n    startTracking(e)\n    beginBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      stopPeeking()\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    if (s.value_ !== (s.value_ = value[0])) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  const nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n  if (nextDep && nextDep.dep_ === dep) {\n    nextDep.version_ = version\n    sub.depsTail_ = nextDep\n    return\n  }\n  const prevSub = dep.subsTail_\n  if (prevSub && prevSub.version_ === version && prevSub.sub_ === sub) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        version_: version,\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (\n      !(\n        flags &\n        (60 as\n          | ReactiveFlags.RecursedCheck\n          | ReactiveFlags.Recursed\n          | ReactiveFlags.Dirty\n          | ReactiveFlags.Pending)\n      )\n    ) {\n      sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n    ) {\n      flags = 0 satisfies ReactiveFlags.None\n    } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n      sub.flags_ =\n        (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n        (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n      isValidLink(link, sub)\n    ) {\n      sub.flags_ =\n        flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n      flags &= 1 satisfies ReactiveFlags.Mutable\n    } else {\n      flags = 0 satisfies ReactiveFlags.None\n    }\n\n    if (flags & (2 satisfies ReactiveFlags.Watching)) {\n      notify(sub as AlienEffect)\n    }\n\n    if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n      const subSubs = sub.subs_\n      if (subSubs) {\n        const nextSub = (link = subSubs).nextSub_\n        if (nextSub) {\n          stack = { value_: next, prev_: stack }\n          next = nextSub\n        }\n        continue\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  version++\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n  let dirty = false\n\n  top: while (true) {\n    const dep = link.dep_\n    const flags = dep.flags_\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (flags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (flags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty) {\n      const nextDep = link.nextDep_\n      if (nextDep) {\n        link = nextDep\n        continue\n      }\n    }\n\n    while (checkDepth--) {\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n        dirty = false\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const flags = sub.flags_\n    if (\n      (flags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = flags | (16 satisfies ReactiveFlags.Dirty)\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n  } while ((link = link.nextSub_!))\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  let link = sub.depsTail_\n  while (link) {\n    if (link === checkLink) {\n      return true\n    }\n    link = link.prevDep_\n  }\n  return false\n}\n\nexport const getPath = <T = any>(path: string): T | undefined => {\n  let result = root\n  const split = path.split('.')\n  for (const path of split) {\n    if (result == null || !hasOwn(result, path)) {\n      return\n    }\n    result = result[path]\n  }\n  return result as T\n}\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal<any>>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal<any>>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get(_, prop: string) {\n        // JSON.stringify calls `.toJSON()` directly instead of checking if it exists on the object\n        // so we have to check if `toJSON` is being called and prevent a signal from automatically\n        // being made so JSON.stringify can fallback to the default stringify\n        if (!(prop === 'toJSON' && !hasOwn(deepObj, prop))) {\n          // special case for when prop is an array function because every array function needs to\n          // be reactive to when the keys change\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          }\n          // if prop is a symbol just return the symbol because we don't want to make up that theres\n          // an iterator symbol on an object or not\n          if (typeof prop === 'symbol') {\n            return deepObj[prop]\n          }\n          // if obj doesnt have prop OR prop is null or undefined then create a signal and default\n          // to an empty string\n          if (!hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n            deepObj[prop] = signal('')\n            dispatch(prefix + prop, '')\n            keys(keys() + 1)\n          }\n          return deepObj[prop]()\n        }\n      },\n      set(_, prop: string, newValue) {\n        const path = prefix + prop\n        // special case for when setting length so we can make a diff patch\n        if (isArr && prop === 'length') {\n          const diff = (deepObj[prop] as unknown as number) - newValue\n          deepObj[prop] = newValue\n          // manually make a diff patch for now, shouldnt have to do this when object diffing is\n          // implemented. see https://github.com/starfederation/datastar-dev/issues/274\n          if (diff > 0) {\n            const patch: Record<string, any> = {}\n            for (let i = newValue; i < deepObj[prop]; i++) {\n              patch[i] = null\n            }\n            dispatch(prefix.slice(0, -1), patch)\n            keys(keys() + 1)\n          }\n        } else if (hasOwn(deepObj, prop)) {\n          if (newValue == null) {\n            delete deepObj[prop]\n            // if newValue is a computed set the computed directly instead of wrapping in signal\n          } else if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n            // if prop changed after setting it then dispatch\n          } else if (deepObj[prop](deep(newValue, `${path}.`))) {\n            dispatch(path, newValue)\n          }\n          // if newValue is null or undefined then noop\n        } else if (newValue != null) {\n          // if newValue is a computed set the computed directly instead of wrapping in signal\n          if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${path}.`))\n            dispatch(path, newValue)\n          }\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty(_, prop: string) {\n        delete deepObj[prop]\n        keys(keys() + 1)\n        return true\n      },\n      ownKeys() {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (path?: string, value?: any) => {\n  if (path !== undefined && value !== undefined) {\n    currentPatch.push([path, value])\n  }\n  if (!batchDepth && currentPatch.length) {\n    const detail = pathToObj(currentPatch)\n    currentPatch.length = 0\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail,\n      }),\n    )\n  }\n}\n\nexport const mergePatch = (\n  patch: JSONPatch,\n  { ifMissing }: MergePatchArgs = {},\n): void => {\n  beginBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nexport const mergePaths = (paths: Paths, options?: MergePatchArgs): void =>\n  mergePatch(pathToObj(paths), options)\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nconst toRegExp = (val: string | RegExp): RegExp =>\n  typeof val === 'string' ? RegExp(val.replace(/^\\/|\\/$/g, '')) : val\n\n/**\n * Filters the root store based on an include and exclude RegExp\n *\n * @returns The filtered object\n */\nexport const filtered = (\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n): Record<string, any> => {\n  const includeRe = toRegExp(include)\n  const excludeRe = toRegExp(exclude)\n  const paths: Paths = []\n  const stack: [any, string][] = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      const path = prefix + key\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${path}.`])\n      } else if (includeRe.test(path) && !excludeRe.test(path)) {\n        paths.push([path, getPath(path)])\n      }\n    }\n  }\n\n  return pathToObj(paths)\n}\n\nexport const root: Record<string, any> = deep({})\n", "import type { HTMLOrSVG } from '@engine/types'\n\nexport const isHTMLOrSVG = (el: Node): el is HTMLOrSVG =>\n  el instanceof HTMLElement ||\n  el instanceof SVGElement ||\n  el instanceof MathMLElement\n", "import { DATASTAR_FETCH_EVENT, DSP, DSS } from '@engine/consts'\nimport { snake } from '@utils/text'\nimport { root } from '@engine/signals'\nimport type {\n  ActionPlugin,\n  ActionContext,\n  AttributeContext,\n  AttributePlugin,\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  Requirement,\n  WatcherPlugin,\n} from '@engine/types'\nimport { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify } from '@utils/text'\n\nconst url = 'https://data-star.dev/errors'\n\nconst error = (\n  ctx: Record<string, any>,\n  reason: string,\n  metadata: Record<string, any> = {},\n) => {\n  Object.assign(metadata, ctx)\n  const e = new Error()\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nconst actionPlugins: Map<string, ActionPlugin> = new Map()\nconst attributePlugins: Map<string, AttributePlugin> = new Map()\nconst watcherPlugins: Map<string, WatcherPlugin> = new Map()\n\nexport const actions: Record<\n  string,\n  (ctx: ActionContext, ...args: any[]) => any\n> = new Proxy(\n  {},\n  {\n    get: (_, prop: string) => actionPlugins.get(prop)?.apply,\n    has: (_, prop: string) => actionPlugins.has(prop),\n    ownKeys: () => Reflect.ownKeys(actionPlugins),\n    set: () => false,\n    deleteProperty: () => false,\n  },\n)\n\n// Map of cleanups keyed by element and attribute name\nconst removals = new Map<HTMLOrSVG, Map<string, () => void>>()\n\nconst queuedAttributes: AttributePlugin[] = []\nconst queuedAttributeNames = new Set<string>()\nexport const attribute = <R extends Requirement, B extends boolean>(\n  plugin: AttributePlugin<R, B>,\n): void => {\n  queuedAttributes.push(plugin as unknown as AttributePlugin)\n\n  if (queuedAttributes.length === 1) {\n    setTimeout(() => {\n      for (const attribute of queuedAttributes) {\n        queuedAttributeNames.add(attribute.name)\n        attributePlugins.set(attribute.name, attribute)\n      }\n      queuedAttributes.length = 0\n      apply()\n      queuedAttributeNames.clear()\n    })\n  }\n}\n\nexport const action = <T>(plugin: ActionPlugin<T>): void => {\n  actionPlugins.set(plugin.name, plugin)\n}\n\ndocument.addEventListener(DATASTAR_FETCH_EVENT, ((\n  evt: CustomEvent<DatastarFetchEvent>,\n) => {\n  const plugin = watcherPlugins.get(evt.detail.type)\n  if (plugin) {\n    plugin.apply(\n      {\n        error: error.bind(0, {\n          plugin: { type: 'watcher', name: plugin.name },\n          element: {\n            id: (evt.target as Element).id,\n            tag: (evt.target as Element).tagName,\n          },\n        }),\n      },\n      evt.detail.argsRaw,\n    )\n  }\n}) as EventListener)\n\nexport const watcher = (plugin: WatcherPlugin): void => {\n  watcherPlugins.set(plugin.name, plugin)\n}\n\nconst cleanupEls = (els: Iterable<HTMLOrSVG>): void => {\n  for (const el of els) {\n    const cleanups = removals.get(el)\n    // If removals has el, delete it and run all cleanup functions\n    if (removals.delete(el)) {\n      for (const cleanup of cleanups!.values()) {\n        cleanup()\n      }\n      cleanups!.clear()\n    }\n  }\n}\n\nconst aliasedIgnore = aliasify('ignore')\nconst aliasedIgnoreAttr = `[${aliasedIgnore}]`\nconst shouldIgnore = (el: HTMLOrSVG) =>\n  el.hasAttribute(`${aliasedIgnore}__self`) || !!el.closest(aliasedIgnoreAttr)\n\nconst applyEls = (els: Iterable<HTMLOrSVG>, onlyNew?: boolean): void => {\n  for (const el of els) {\n    if (!shouldIgnore(el)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(\n          el,\n          key.replace(/[A-Z]/g, '-$&').toLowerCase(),\n          el.dataset[key]!,\n          onlyNew,\n        )\n      }\n    }\n  }\n}\n\nconst observe = (mutations: MutationRecord[]) => {\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          cleanupEls([node])\n          cleanupEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (\n      type === 'attributes' &&\n      attributeName!.startsWith('data-') &&\n      isHTMLOrSVG(target) &&\n      !shouldIgnore(target)\n    ) {\n      // skip over 'data-'\n      const key = attributeName!.slice(5)\n      const value = target.getAttribute(attributeName!)\n      if (value === null) {\n        const cleanups = removals.get(target)\n        if (cleanups) {\n          cleanups.get(key)?.()\n          cleanups.delete(key)\n        }\n      } else {\n        applyAttributePlugin(target, key, value)\n      }\n    }\n  }\n}\n\n// TODO: mutation observer per root so applying to web component doesnt overwrite main observer\nconst mutationObserver = new MutationObserver(observe)\n\nexport const apply = (\n  root: HTMLOrSVG | ShadowRoot = document.documentElement,\n): void => {\n  if (isHTMLOrSVG(root)) {\n    applyEls([root], true)\n  }\n  applyEls(root.querySelectorAll<HTMLOrSVG>('*'), true)\n\n  mutationObserver.observe(root, {\n    subtree: true,\n    childList: true,\n    attributes: true,\n  })\n}\n\nconst applyAttributePlugin = (\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n  onlyNew?: boolean,\n): void => {\n  if (!ALIAS || attrKey.startsWith(`${ALIAS}-`)) {\n    const rawKey = ALIAS ? attrKey.slice(ALIAS.length + 1) : attrKey\n    const [namePart, ...rawModifiers] = rawKey.split('__')\n    const [pluginName, key] = namePart.split(/:(.+)/)\n    const plugin = attributePlugins.get(pluginName)\n    if ((!onlyNew || queuedAttributeNames.has(pluginName)) && plugin) {\n      const ctx = {\n        el,\n        rawKey,\n        mods: new Map(),\n        error: error.bind(0, {\n          plugin: { type: 'attribute', name: plugin.name },\n          element: { id: el.id, tag: el.tagName },\n          expression: { rawKey, key, value },\n        }),\n        key,\n        value,\n        rx: undefined,\n      } as AttributeContext\n\n      const keyReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.key)) ||\n        'allowed'\n      const valueReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.value)) ||\n        'allowed'\n\n      if (key) {\n        if (keyReq === 'denied') {\n          throw ctx.error('KeyNotAllowed')\n        }\n      } else if (keyReq === 'must') {\n        throw ctx.error('KeyRequired')\n      }\n\n      if (value) {\n        if (valueReq === 'denied') {\n          throw ctx.error('ValueNotAllowed')\n        }\n      } else if (valueReq === 'must') {\n        throw ctx.error('ValueRequired')\n      }\n\n      if (keyReq === 'exclusive' || valueReq === 'exclusive') {\n        if (key && value) {\n          throw ctx.error('KeyAndValueProvided')\n        }\n        if (!key && !value) {\n          throw ctx.error('KeyOrValueRequired')\n        }\n      }\n\n      if (value) {\n        let cachedRx: GenRxFn\n        ctx.rx = (...args: any[]) => {\n          if (!cachedRx) {\n            cachedRx = genRx(value, {\n              returnsValue: plugin.returnsValue,\n              argNames: plugin.argNames,\n            })\n          }\n          return cachedRx(el, ...args)\n        }\n      }\n\n      for (const rawMod of rawModifiers) {\n        const [label, ...mod] = rawMod.split('.')\n        ctx.mods.set(label, new Set(mod))\n      }\n\n      const cleanup = plugin.apply(ctx)\n      if (cleanup) {\n        let cleanups = removals.get(el)\n        if (cleanups) {\n          cleanups.get(rawKey)?.()\n        } else {\n          cleanups = new Map()\n          removals.set(el, cleanups)\n        }\n        cleanups.set(rawKey, cleanup)\n      }\n    }\n  }\n}\n\ntype GenRxOptions = {\n  returnsValue?: boolean\n  argNames?: string[]\n}\n\ntype GenRxFn = <T>(el: HTMLOrSVG, ...args: any[]) => T\n\nconst genRx = (\n  value: string,\n  { returnsValue = false, argNames = [] }: GenRxOptions = {},\n): GenRxFn => {\n  let expr = ''\n  if (returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = value.trim()\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  let counter = 0\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `__escaped${counter++}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  // Replace signal references with bracket notation\n  // Examples:\n  //   $count          -> $['count']\n  //   $count--        -> $['count']--\n  //   $foo.bar        -> $['foo']['bar']\n  //   $foo-bar        -> $['foo-bar']\n  //   $foo.bar-baz    -> $['foo']['bar-baz']\n  //   $foo-$bar       -> $['foo']-$['bar']\n  //   $arr[$index]    -> $['arr'][$['index']]\n  //   $['foo']        -> $['foo']\n  //   $foo[obj.bar]   -> $['foo'][obj.bar]\n  //   $foo['bar.baz'] -> $['foo']['bar.baz']\n  //   $123            -> $['123']\n  //   $foo.0.name     -> $['foo']['0']['name']\n\n  expr = expr\n    // $['x'] -> $x (normalize existing bracket notation)\n    .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n    // $x -> $['x'] (including dots and hyphens)\n    .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) =>\n      signalName\n        .split('.')\n        .reduce((acc: string, part: string) => `${acc}['${part}']`, '$'),\n    )\n    // [$x] -> [$['x']] ($ inside brackets)\n    .replace(\n      /\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g,\n      (_, varName) => `[$['${varName.slice(1)}']]`,\n    )\n\n  expr = expr.replaceAll(/@(\\w+)\\(/g, '__action(\"$1\",evt,')\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  try {\n    const fn = Function('el', '$', '__action', 'evt', ...argNames, expr)\n    return (el: HTMLOrSVG, ...args: any[]) => {\n      const action = (name: string, evt: Event | undefined, ...args: any[]) => {\n        const err = error.bind(0, {\n          plugin: { type: 'action', name },\n          element: { id: el.id, tag: el.tagName },\n          expression: {\n            fnContent: expr,\n            value,\n          },\n        })\n        const fn = actions[name]\n        if (fn) {\n          return fn(\n            {\n              el,\n              evt,\n              error: err,\n            },\n            ...args,\n          )\n        }\n        throw err('UndefinedAction')\n      }\n      try {\n        return fn(el, root, action, undefined, ...args)\n      } catch (e: any) {\n        console.error(e)\n        throw error(\n          {\n            element: { id: el.id, tag: el.tagName },\n            expression: {\n              fnContent: expr,\n              value,\n            },\n            error: e.message,\n          },\n          'ExecuteExpression',\n        )\n      }\n    }\n  } catch (e: any) {\n    console.error(e)\n    throw error(\n      {\n        expression: {\n          fnContent: expr,\n          value,\n        },\n        error: e.message,\n      },\n      'GenerateExpression',\n    )\n  }\n}\n", "import { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify } from '@utils/text'\n\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst oldIdTagNameMap = new Map<string, string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nconst aliasedIgnoreMorph = aliasify('ignore-morph')\nconst aliasedIgnoreMorphAttr = `[${aliasedIgnoreMorph}]`\nexport const morph = (\n  oldElt: Element | ShadowRoot,\n  newContent: DocumentFragment | Element,\n  mode: 'outer' | 'inner' = 'outer',\n): void => {\n  if (\n    (isHTMLOrSVG(oldElt) &&\n      isHTMLOrSVG(newContent) &&\n      oldElt.hasAttribute(aliasedIgnoreMorph) &&\n      newContent.hasAttribute(aliasedIgnoreMorph)) ||\n    oldElt.parentElement?.closest(aliasedIgnoreMorphAttr)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newContent)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt instanceof Element && oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  oldIdTagNameMap.clear()\n  duplicateIds.clear()\n  ctxIdMap.clear()\n\n  const parent = mode === 'outer' ? oldElt.parentElement! : oldElt\n  populateIdMapWithTree(parent, oldIdElements)\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    parent,\n    normalizedElt,\n    mode === 'outer' ? oldElt : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nconst morphChildren = (\n  oldParent: Element | ShadowRoot, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void => {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(newChild.id)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n      const movedChild = document.getElementById(newChild.id) as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(newChild.id)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nconst findBestMatch = (\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null => {\n  let bestMatch: Node | null | undefined = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven\u2019t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\n// ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\nconst isSoftMatch = (oldNode: Node, newNode: Node): boolean =>\n  oldNode.nodeType === newNode.nodeType &&\n  (oldNode as Element).tagName === (newNode as Element).tagName &&\n  // If oldElt has an `id` with possible state and it doesn\u2019t match newElt.id then avoid morphing.\n  // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n  // its not persistent, and new nodes can't have any hidden state.\n  (!(oldNode as Element).id ||\n    (oldNode as Element).id === (newNode as Element).id)\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nconst removeNode = (node: Node): void => {\n  // are we going to id set match this later?\n  ctxIdMap.has(node)\n    ? // skip callbacks and move to pantry\n      moveBefore(ctxPantry, node, null)\n    : // remove for realsies\n      node.parentNode?.removeChild(node)\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-expect-error\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nconst aliasedPreserveAttr = aliasify('preserve-attr')\n\n// syncs the oldNode to the newNode, copying over all attributes and\n// inner element state from the newNode to the oldNode\nconst morphNode = (\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node => {\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const oldElt = oldNode as Element\n    const newElt = newNode as Element\n    if (\n      oldElt.hasAttribute(aliasedIgnoreMorph) &&\n      newElt.hasAttribute(aliasedIgnoreMorph)\n    ) {\n      return oldNode\n    }\n\n    //  many bothans died to bring us this information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n    if (\n      oldElt instanceof HTMLInputElement &&\n      newElt instanceof HTMLInputElement &&\n      newElt.type !== 'file'\n    ) {\n      // https://github.com/bigskysoftware/idiomorph/issues/27\n      // | old input value | new input value  | behaviour                              |\n      // | --------------- | ---------------- | -------------------------------------- |\n      // | `null`          | `null`           | preserve old input value               |\n      // | some value      | the same value   | preserve old input value               |\n      // | some value      | `null`           | set old input value to `\"\"`            |\n      // | `null`          | some value       | set old input value to new input value |\n      // | some value      | some other value | set old input value to new input value |\n      if (newElt.getAttribute('value') !== oldElt.getAttribute('value')) {\n        oldElt.value = newElt.getAttribute('value') ?? ''\n      }\n    } else if (\n      oldElt instanceof HTMLTextAreaElement &&\n      newElt instanceof HTMLTextAreaElement\n    ) {\n      if (newElt.value !== oldElt.value) {\n        oldElt.value = newElt.value\n      }\n      if (oldElt.firstChild && oldElt.firstChild.nodeValue !== newElt.value) {\n        oldElt.firstChild.nodeValue = newElt.value\n      }\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasedPreserveAttr) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of newElt.attributes) {\n      if (\n        oldElt.getAttribute(name) !== value &&\n        !preserveAttrs.includes(name)\n      ) {\n        oldElt.setAttribute(name, value)\n      }\n    }\n\n    for (let i = oldElt.attributes.length - 1; i >= 0; i--) {\n      const { name } = oldElt.attributes[i]!\n      if (!newElt.hasAttribute(name) && !preserveAttrs.includes(name)) {\n        oldElt.removeAttribute(name)\n      }\n    }\n\n    if (!oldElt.isEqualNode(newElt)) {\n      morphChildren(oldElt, newElt)\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nconst populateIdMapWithTree = (\n  root: Element | ShadowRoot | null,\n  elements: Iterable<Element>,\n): void => {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesn\u2019t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport { action } from '@engine'\nimport { startPeeking, stopPeeking } from '@engine/signals'\n\naction({\n  name: 'peek',\n  apply(_, fn: () => any) {\n    startPeeking()\n    try {\n      return fn()\n    } finally {\n      stopPeeking()\n    }\n  },\n})\n", "// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport { action } from '@engine'\nimport {\n  filtered,\n  mergePatch,\n  startPeeking,\n  stopPeeking,\n} from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { updateLeaves } from '@utils/paths'\n\naction({\n  name: 'setAll',\n  apply(_, value: any, filter: SignalFilterOptions) {\n    // peek because in an effect you would be subscribing to signals and then setting them which\n    // would cause an infinite loop and why would you want to infinite loop on purpose\n    startPeeking()\n    const masked = filtered(filter)\n    updateLeaves(masked, () => value)\n    mergePatch(masked)\n    stopPeeking()\n  },\n})\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport { action } from '@engine'\nimport {\n  filtered,\n  mergePatch,\n  startPeeking,\n  stopPeeking,\n} from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { updateLeaves } from '@utils/paths'\n\naction({\n  name: 'toggleAll',\n  apply(_, filter: SignalFilterOptions) {\n    // peek because in an effect you would be subscribing to signals and then setting them which\n    // would cause an infinite loop and why would you want to infinite loop on purpose\n    startPeeking()\n    const masked = filtered(filter)\n    updateLeaves(masked, (oldValue: any) => !oldValue)\n    mergePatch(masked)\n    stopPeeking()\n  },\n})\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport { action } from '@engine'\nimport { DATASTAR_FETCH_EVENT } from '@engine/consts'\nimport { filtered } from '@engine/signals'\nimport type {\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { kebab } from '@utils/text'\n\nconst fetchAbortControllers = new WeakMap<HTMLOrSVG, AbortController>()\n\nconst createHttpMethod = (name: string, method: string): void =>\n  action({\n    name,\n    apply: async (\n      { el, evt, error },\n      url: string,\n      {\n        selector,\n        headers: userHeaders,\n        contentType = 'json',\n        filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {},\n        openWhenHidden = false,\n        alwaysReconnect = true,\n        retryInterval = 1000,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n        requestCancellation = 'auto',\n      }: FetchArgs = {},\n    ) => {\n      const controller =\n        requestCancellation instanceof AbortController\n          ? requestCancellation\n          : new AbortController()\n      const isDisabled = requestCancellation === 'disabled'\n      if (!isDisabled) {\n        const oldController = fetchAbortControllers.get(el)\n        if (oldController) {\n          oldController.abort()\n          // wait one tick for FINISHED to fire\n          await Promise.resolve()\n        }\n      }\n\n      if (!isDisabled && !(requestCancellation instanceof AbortController)) {\n        fetchAbortControllers.set(el, controller)\n      }\n\n      try {\n        let cleanupFn = () => {}\n        try {\n          if (!url?.length) {\n            throw error('FetchNoUrlProvided', { action })\n          }\n\n          const initialHeaders: Record<string, any> = {\n            Accept: 'text/event-stream, text/html, application/json',\n            'Datastar-Request': true,\n          }\n          if (contentType === 'json') {\n            initialHeaders['Content-Type'] = 'application/json'\n          }\n          const headers = Object.assign({}, initialHeaders, userHeaders)\n\n          // We ignore the content-type header if using form data\n          // if missing the boundary will be set automatically\n\n          const req: FetchEventSourceInit = {\n            method,\n            headers,\n            openWhenHidden,\n            alwaysReconnect,\n            retryInterval,\n            retryScaler,\n            retryMaxWaitMs,\n            retryMaxCount,\n            signal: controller.signal,\n            onopen: async (response: Response) => {\n              if (response.status >= 400)\n                dispatchFetch(ERROR, el, { status: response.status.toString() })\n            },\n            onmessage: (evt) => {\n              if (!evt.event.startsWith('datastar')) return\n              const type = evt.event\n              const argsRawLines: Record<string, string[]> = {}\n\n              for (const line of evt.data.split('\\n')) {\n                const i = line.indexOf(' ')\n                const k = line.slice(0, i)\n                const v = line.slice(i + 1)\n                ;(argsRawLines[k] ||= []).push(v)\n              }\n\n              const argsRaw = Object.fromEntries(\n                Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n              )\n\n              dispatchFetch(type, el, argsRaw)\n            },\n            onerror: (error) => {\n              if (isWrongContent(error)) {\n                // don't retry if the content-type is wrong\n                throw error('FetchExpectedTextEventStream', { url })\n              }\n              // do nothing and it will retry\n              if (error) {\n                console.error(error.message)\n                dispatchFetch(RETRYING, el, { message: error.message })\n              }\n            },\n          }\n\n          const urlInstance = new URL(url, document.baseURI)\n          const queryParams = new URLSearchParams(urlInstance.search)\n\n          if (contentType === 'json') {\n            const res = JSON.stringify(filtered({ include, exclude }))\n            if (method === 'GET') {\n              queryParams.set('datastar', res)\n            } else {\n              req.body = res\n            }\n          } else if (contentType === 'form') {\n            const formEl = (\n              selector ? document.querySelector(selector) : el.closest('form')\n            ) as HTMLFormElement\n            if (!formEl) {\n              throw error('FetchFormNotFound', { action, selector })\n            }\n\n            // Validate the form\n            if (!formEl.checkValidity()) {\n              formEl.reportValidity()\n              cleanupFn()\n              return\n            }\n\n            // Collect the form data\n\n            const formData = new FormData(formEl)\n            let submitter = el as HTMLElement | null\n\n            if (el === formEl && evt instanceof SubmitEvent) {\n              // Get the submitter from the event\n              submitter = evt.submitter\n            } else {\n              // Prevent the form being submitted\n              const preventDefault = (evt: Event) => evt.preventDefault()\n              formEl.addEventListener('submit', preventDefault)\n              cleanupFn = () =>\n                formEl.removeEventListener('submit', preventDefault)\n            }\n\n            // Append the value of the form submitter if it is a button with a name\n            if (submitter instanceof HTMLButtonElement) {\n              const name = submitter.getAttribute('name')\n              if (name) formData.append(name, submitter.value)\n            }\n\n            const multipart =\n              formEl.getAttribute('enctype') === 'multipart/form-data'\n            // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n            if (!multipart) {\n              headers['Content-Type'] = 'application/x-www-form-urlencoded'\n            }\n\n            const formParams = new URLSearchParams(formData as any)\n            if (method === 'GET') {\n              for (const [key, value] of formParams) {\n                queryParams.append(key, value)\n              }\n            } else if (multipart) {\n              req.body = formData\n            } else {\n              req.body = formParams\n            }\n          } else {\n            throw error('FetchInvalidContentType', { action, contentType })\n          }\n\n          dispatchFetch(STARTED, el, {})\n          urlInstance.search = queryParams.toString()\n\n          try {\n            await fetchEventSource(urlInstance.toString(), el, req)\n          } catch (e: any) {\n            if (!isWrongContent(e)) {\n              throw error('FetchFailed', { method, url, error: e.message })\n            }\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they haven\u2019t\n            // set the content-type to text/event-stream\n          }\n        } finally {\n          dispatchFetch(FINISHED, el, {})\n          cleanupFn()\n        }\n      } finally {\n        if (fetchAbortControllers.get(el) === controller) {\n          fetchAbortControllers.delete(el)\n        }\n      }\n    },\n  })\n\ncreateHttpMethod('delete', 'DELETE')\ncreateHttpMethod('get', 'GET')\ncreateHttpMethod('patch', 'PATCH')\ncreateHttpMethod('post', 'POST')\ncreateHttpMethod('put', 'PUT')\n\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nconst dispatchFetch = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarFetchEvent>(DATASTAR_FETCH_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  alwaysReconnect?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  responseOverrides?: ResponseOverrides\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  selector?: string\n  requestCancellation?: 'auto' | 'disabled' | AbortController\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nconst getBytes = async (\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> => {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nconst getLines = (onLine: (line: Uint8Array, fieldLength: number) => void) => {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return (arr: Uint8Array) => {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-expect-error:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nconst getMessages = (\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n): ((line: Uint8Array, fieldLength: number) => void) => {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return (line, fieldLength) => {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ntype FetchEventSourceInit = RequestInit & {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  alwaysReconnect?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  overrides?: ResponseOverrides\n}\n\nconst fetchEventSource = (\n  input: RequestInfo,\n  el: HTMLOrSVG,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    alwaysReconnect = false,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    overrides,\n    ...rest\n  }: FetchEventSourceInit,\n): Promise<void> => {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    const onVisibilityChange = () => {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n  let retryTimer: ReturnType<typeof setTimeout> | number = 0\n    const dispose = () => {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    const create = async () => {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          overrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (overrides) {\n              const o = (overrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchFetch(dispatchType, el, argsRaw)\n          dispose()\n          resolve()\n        }\n\n        const status = response.status\n        const isRedirectStatus = status >= 300 && status < 400\n\n        if (status !== 200) {\n          onclose?.()\n          if (status !== 204 && !isRedirectStatus && alwaysReconnect !== false) {\n            clearTimeout(retryTimer)\n            retryTimer = setTimeout(create, retryInterval)\n            return\n          }\n          dispose()\n          resolve()\n          return\n        }\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html')) {\n          return await dispatchNonSSE(\n            'datastar-patch-elements',\n            response,\n            'elements',\n            overrides,\n            'selector',\n            'mode',\n            'useViewTransition',\n          )\n        }\n\n        if (ct?.includes('application/json')) {\n          return await dispatchNonSSE(\n            'datastar-patch-signals',\n            response,\n            'signals',\n            overrides,\n            'onlyIfMissing',\n          )\n        }\n\n        if (ct?.includes('text/javascript')) {\n          const script = document.createElement('script')\n          const scriptAttributesHeader = response.headers.get(\n            'datastar-script-attributes',\n          )\n\n          if (scriptAttributesHeader) {\n            for (const [name, value] of Object.entries(\n              JSON.parse(scriptAttributesHeader),\n            )) {\n              script.setAttribute(name, value as string)\n            }\n          }\n          script.textContent = await response.text()\n          document.head.appendChild(script)\n          dispose()\n          return\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n\n        if (alwaysReconnect && !isRedirectStatus) {\n          clearTimeout(retryTimer)\n          retryTimer = setTimeout(create, retryInterval)\n          return\n        }\n\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven\u2019t aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            clearTimeout(retryTimer)\n            retryTimer = setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchFetch(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'attr',\n  requirement: { value: 'must' },\n  returnsValue: true,\n  apply({ el, key, rx }) {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val == null) {\n        el.removeAttribute(key)\n      } else if (typeof val === 'string') {\n        el.setAttribute(key, val)\n      } else {\n        el.setAttribute(key, JSON.stringify(val))\n      }\n    }\n\n    const update = key\n      ? () => {\n          observer.disconnect()\n          const val = rx() as string\n          syncAttr(key, val)\n          observer.observe(el, {\n            attributeFilter: [key],\n          })\n        }\n      : () => {\n          observer.disconnect()\n          const obj = rx() as Record<string, any>\n          const attributeFilter = Object.keys(obj)\n          for (const key of attributeFilter) {\n            syncAttr(key, obj[key])\n          }\n          observer.observe(el, {\n            attributeFilter,\n          })\n        }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn\u2019t already exist) and sets up two-way data binding between it and an element\u2019s value.\n\nimport { attribute } from '@engine'\nimport { effect, getPath, mergePaths } from '@engine/signals'\nimport type { Paths } from '@engine/types'\nimport { aliasify, modifyCasing } from '@utils/text'\n\ntype SignalFile = {\n  name: string\n  contents: string\n  mime: string\n}\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst empty = Symbol('empty')\n\nconst aliasedBind = aliasify('bind')\n\nattribute({\n  name: 'bind',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value, error }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n\n    let get = (el: any, type: string) =>\n      type === 'number' ? +el.value : el.value\n\n    let set = (value: any) => {\n      ;(el as HTMLInputElement).value = `${value}`\n    }\n\n    if (el instanceof HTMLInputElement) {\n      switch (el.type) {\n        case 'range':\n        case 'number':\n          get = (el: any, type: string) =>\n            type === 'string' ? el.value : +el.value\n          break\n\n        case 'checkbox':\n          get = (el: HTMLInputElement, type: string) => {\n            if (el.value !== 'on') {\n              if (type === 'boolean') {\n                return el.checked\n              } else {\n                return el.checked ? el.value : ''\n              }\n            } else {\n              if (type === 'string') {\n                return el.checked ? el.value : ''\n              } else {\n                return el.checked\n              }\n            }\n          }\n          set = (value: string | boolean) => {\n            el.checked = typeof value === 'string' ? value === el.value : value\n          }\n          break\n\n        case 'radio':\n          // Set up radio button name attribute if not present\n          if (!el.getAttribute('name')?.length) {\n            el.setAttribute('name', signalName)\n          }\n\n          get = (el: HTMLInputElement, type: string) =>\n            el.checked ? (type === 'number' ? +el.value : el.value) : empty\n          set = (value: string | number) => {\n            el.checked =\n              value === (typeof value === 'number' ? +el.value : el.value)\n          }\n          break\n        case 'file': {\n          const syncSignal = () => {\n            const files = [...(el.files || [])]\n            const signalFiles: SignalFile[] = []\n            Promise.all(\n              files.map(\n                (f) =>\n                  new Promise<void>((resolve) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                      if (typeof reader.result !== 'string') {\n                        throw error('InvalidFileResultType', {\n                          resultType: typeof reader.result,\n                        })\n                      }\n                      const match = reader.result.match(dataURIRegex)\n                      if (!match?.groups) {\n                        throw error('InvalidDataUri', {\n                          result: reader.result,\n                        })\n                      }\n                      signalFiles.push({\n                        name: f.name,\n                        contents: match.groups.contents,\n                        mime: match.groups.mime,\n                      })\n                    }\n                    reader.onloadend = () => resolve()\n                    reader.readAsDataURL(f)\n                  }),\n              ),\n            ).then(() => {\n              mergePaths([[signalName, signalFiles]])\n            })\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          return () => {\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n      }\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        const typeMap = new Map<string, string>()\n        get = (el: HTMLSelectElement) =>\n          [...el.selectedOptions].map((option) => {\n            const type = typeMap.get(option.value)\n            return type === 'string' || type == null\n              ? option.value\n              : +option.value\n          })\n\n        set = (value: (string | number)[]) => {\n          for (const option of el.options) {\n            if (value.includes(option.value)) {\n              typeMap.set(option.value, 'string')\n              option.selected = true\n            } else if (value.includes(+option.value)) {\n              typeMap.set(option.value, 'number')\n              option.selected = true\n            } else {\n              option.selected = false\n            }\n          }\n        }\n      }\n    } else if (el instanceof HTMLTextAreaElement) {\n      // default case\n    } else {\n      // web component\n      get = (el: Element) =>\n        'value' in el ? el.value : el.getAttribute('value')\n      set = (value: any) => {\n        if ('value' in el) {\n          el.value = value\n        } else {\n          el.setAttribute('value', value)\n        }\n      }\n    }\n\n    const initialValue = getPath(signalName)\n    const type = typeof initialValue\n\n    let path = signalName\n    if (\n      Array.isArray(initialValue) &&\n      !(el instanceof HTMLSelectElement && el.multiple)\n    ) {\n      const signalNameKebab = key ? key : value!\n      const inputs = document.querySelectorAll(\n        `[${aliasedBind}\\\\:${CSS.escape(signalNameKebab)}],[${aliasedBind}=\"${CSS.escape(signalNameKebab)}\"]`,\n      ) as NodeListOf<HTMLInputElement>\n\n      const paths: Paths = []\n      let i = 0\n      for (const input of inputs) {\n        paths.push([`${path}.${i}`, get(input, 'none')])\n\n        if (el === input) {\n          break\n        }\n        i++\n      }\n      mergePaths(paths, { ifMissing: true })\n      path = `${path}.${i}`\n    } else {\n      mergePaths([[path, get(el, type)]], {\n        ifMissing: true,\n      })\n    }\n\n    const syncSignal = () => {\n      const signalValue = getPath(path)\n      if (signalValue != null) {\n        const value = get(el, typeof signalValue)\n        if (value !== empty) {\n          mergePaths([[path, value]])\n        }\n      }\n    }\n\n    el.addEventListener('input', syncSignal)\n    el.addEventListener('change', syncSignal)\n    const cleanup = effect(() => {\n      set(getPath(path))\n    })\n\n    return () => {\n      cleanup()\n      el.removeEventListener('input', syncSignal)\n      el.removeEventListener('change', syncSignal)\n    }\n  },\n})\n", "// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'class',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, el, mods, rx }) {\n    if (key) {\n      key = modifyCasing(key, mods, 'kebab')\n    }\n\n    const callback = () => {\n      observer.disconnect()\n\n      const classes = key\n        ? { [key]: rx() as boolean }\n        : (rx() as Record<string, boolean>)\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            if (!el.classList.contains(name)) {\n              el.classList.add(name)\n            }\n          }\n        } else {\n          for (const name of classNames) {\n            if (el.classList.contains(name)) {\n              el.classList.remove(name)\n            }\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      const classes = key\n        ? { [key]: rx() as boolean }\n        : (rx() as Record<string, boolean>)\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n})\n", "// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport { attribute } from '@engine'\nimport { computed, mergePaths, mergePatch } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\nimport { updateLeaves } from '@utils/paths'\n\nattribute({\n  name: 'computed',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, mods, rx, error }) {\n    if (key) {\n      mergePaths([[modifyCasing(key, mods), computed(rx)]])\n    } else {\n      const patch = Object.assign({}, rx() as Record<string, () => any>)\n      updateLeaves(patch, (old) => {\n        if (typeof old === 'function') {\n          return computed(old)\n        } else {\n          throw error('ComputedExpectedFunction')\n        }\n      })\n      mergePatch(patch)\n    }\n  },\n})\n", "// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'effect',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply: ({ rx }) => effect(rx),\n})\n", "// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport { attribute } from '@engine'\nimport { DATASTAR_FETCH_EVENT } from '@engine/consts'\nimport { mergePaths } from '@engine/signals'\nimport type { DatastarFetchEvent } from '@engine/types'\nimport { FINISHED, STARTED } from '@plugins/actions/fetch'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'indicator',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n\n    mergePaths([[signalName, false]])\n\n    const watcher = ((event: CustomEvent<DatastarFetchEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePaths([[signalName, true]])\n          break\n        case FINISHED:\n          mergePaths([[signalName, false]])\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_FETCH_EVENT, watcher)\n    return () => {\n      mergePaths([[signalName, false]])\n      document.removeEventListener(DATASTAR_FETCH_EVENT, watcher)\n    }\n  },\n})\n", "// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport { attribute } from '@engine'\nimport { effect, filtered } from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { jsStrToObject } from '@utils/text'\n\nattribute({\n  name: 'json-signals',\n  requirement: {\n    key: 'denied',\n  },\n  apply({ el, value, mods }) {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "export const tagToMs = (args: Set<string>) => {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport const tagHas = (\n  tags: Set<string>,\n  tag: string,\n  defaultValue = false,\n) => {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport const tagFirst = (tags?: Set<string>, defaultValue = ''): string => {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '@engine/types'\nimport { tagHas, tagToMs } from '@utils/tags'\n\nexport const delay = (\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler => {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport const debounce = (\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler => {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n      timer = 0\n    }, wait)\n  }\n}\n\nexport const throttle = (\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler => {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      waiting = false\n    }, wait)\n  }\n}\n\nexport const modifyTiming = (\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler => {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrailing', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trailing', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "import type { EventCallbackHandler, Modifiers } from '@engine/types'\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport const modifyViewTransition = (\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler => {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport { attribute } from '@engine'\nimport {\n  DATASTAR_FETCH_EVENT,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '@engine/consts'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\nimport { modifyTiming } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'on',\n  requirement: 'must',\n  argNames: ['evt'],\n  apply({ el, key, mods, rx }) {\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n      }\n      beginBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    callback = modifyTiming(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    const eventName = modifyCasing(key, mods, 'kebab')\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_FETCH_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n})\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport type { HTMLOrSVG } from '@engine/types'\nimport { modifyTiming } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nattribute({\n  name: 'on-intersect',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ el, mods, rx }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    callback = modifyTiming(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n})\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { tagHas, tagToMs } from '@utils/tags'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'on-interval',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ mods, rx }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n})\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { tagToMs } from '@utils/tags'\nimport { delay } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'init',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ rx, mods }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n      if (wait > 0) {\n        callback = delay(callback, wait)\n      }\n    }\n    callback()\n  },\n})\n", "// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport { attribute } from '@engine'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport { beginBatch, endBatch, filtered } from '@engine/signals'\nimport type { JSONPatch, SignalFilterOptions } from '@engine/types'\nimport { isEmpty } from '@utils/paths'\nimport { jsStrToObject } from '@utils/text'\nimport { modifyTiming } from '@utils/timing'\n\nattribute({\n  name: 'on-signal-patch',\n  requirement: {\n    value: 'must',\n  },\n  argNames: ['patch'],\n  returnsValue: true,\n  apply({ el, key, mods, rx, error }) {\n    if (!!key && key !== 'filter') {\n      throw error('KeyNotAllowed')\n    }\n\n    // Look for data-on-signal-patch-filter data attribute\n    const filtersRaw = el.getAttribute('data-on-signal-patch-filter')\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          beginBatch()\n          rx(watched)\n          endBatch()\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n})\n", "// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport { attribute } from '@engine'\nimport { mergePaths } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'ref',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n    mergePaths([[signalName, el]])\n  },\n})\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nattribute({\n  name: 'show',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ el, rx }) {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport { attribute } from '@engine'\nimport { mergePatch, mergePaths } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'signals',\n  returnsValue: true,\n  apply({ key, mods, rx }) {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePaths([[key, rx?.()]], { ifMissing })\n    } else {\n      const patch = Object.assign({}, rx?.() as Record<string, any>)\n      mergePatch(patch, { ifMissing })\n    }\n  },\n})\n", "// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\nimport { kebab } from '@utils/text'\n\nattribute({\n  name: 'style',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, el, rx }) {\n    const { style } = el\n    const initialStyles = new Map<string, string>()\n\n    const apply = (prop: string, value: any) => {\n      const initial = initialStyles.get(prop)\n      if (!value && value !== 0) {\n        initial !== undefined &&\n          (initial\n            ? style.setProperty(prop, initial)\n            : style.removeProperty(prop))\n      } else {\n        initial === undefined &&\n          initialStyles.set(prop, style.getPropertyValue(prop))\n        style.setProperty(prop, String(value))\n      }\n    }\n\n    const update = () => {\n      observer.disconnect()\n\n      if (key) {\n        apply(key, rx())\n      } else {\n        const styles = rx() as Record<string, any>\n\n        for (const [prop, initial] of initialStyles) {\n          prop in styles ||\n            (initial\n              ? style.setProperty(prop, initial)\n              : style.removeProperty(prop))\n        }\n\n        for (const prop in styles) {\n          apply(kebab(prop), styles[prop])\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n      for (const [prop, initial] of initialStyles) {\n        initial ? style.setProperty(prop, initial) : style.removeProperty(prop)\n      }\n    }\n  },\n})\n", "// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'text',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ el, rx }) {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n", "// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport { watcher } from '@engine'\nimport type { WatcherContext } from '@engine/types'\nimport { morph } from '@engine/morph'\nimport { supportsViewTransitions } from '@utils/view-transitions'\n\ntype PatchElementsMode =\n  | 'remove'\n  | 'outer'\n  | 'inner'\n  | 'replace'\n  | 'prepend'\n  | 'append'\n  | 'before'\n  | 'after'\n\ntype PatchElementsArgs = {\n  elements: string\n  mode: PatchElementsMode\n  selector: string\n  useViewTransition: boolean\n}\n\nwatcher({\n  name: 'datastar-patch-elements',\n  apply(\n    ctx,\n    { elements = '', selector = '', mode = 'outer', useViewTransition },\n  ) {\n    switch (mode) {\n      case 'remove':\n      case 'outer':\n      case 'inner':\n      case 'replace':\n      case 'prepend':\n      case 'append':\n      case 'before':\n      case 'after':\n        break\n      default:\n        throw ctx.error('PatchElementsInvalidMode', { mode })\n    }\n\n    if (!selector && mode !== 'outer' && mode !== 'replace') {\n      throw ctx.error('PatchElementsExpectedSelector')\n    }\n\n    const args2: PatchElementsArgs = {\n      mode,\n      selector,\n      elements,\n      useViewTransition: useViewTransition?.trim() === 'true',\n    }\n\n    if (supportsViewTransitions && useViewTransition) {\n      document.startViewTransition(() => onPatchElements(ctx, args2))\n    } else {\n      onPatchElements(ctx, args2)\n    }\n  },\n})\n\nconst onPatchElements = (\n  { error }: WatcherContext,\n  { elements, selector, mode }: PatchElementsArgs,\n) => {\n  const elementsWithSvgsRemoved = elements.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    '',\n  )\n  const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved)\n  const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved)\n  const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved)\n\n  const newDocument = new DOMParser().parseFromString(\n    hasHtml || hasHead || hasBody\n      ? elements\n      : `<body><template>${elements}</template></body>`,\n    'text/html',\n  )\n\n  let newContent = document.createDocumentFragment()\n  if (hasHtml) {\n    newContent.appendChild(newDocument.documentElement)\n  } else if (hasHead && hasBody) {\n    newContent.appendChild(newDocument.head)\n    newContent.appendChild(newDocument.body)\n  } else if (hasHead) {\n    newContent.appendChild(newDocument.head)\n  } else if (hasBody) {\n    newContent.appendChild(newDocument.body)\n  } else {\n    newContent = newDocument.querySelector('template')!.content\n  }\n\n  if (!selector && (mode === 'outer' || mode === 'replace')) {\n    for (const child of newContent.children) {\n      let target: Element\n      if (child instanceof HTMLHtmlElement) {\n        target = document.documentElement\n      } else if (child instanceof HTMLBodyElement) {\n        target = document.body\n      } else if (child instanceof HTMLHeadElement) {\n        target = document.head\n      } else {\n        target = document.getElementById(child.id)!\n        if (!target) {\n          console.warn(error('PatchElementsNoTargetsFound'), {\n            element: { id: child.id },\n          })\n          continue\n        }\n      }\n\n      applyToTargets(mode as PatchElementsMode, child, [target])\n    }\n  } else {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      console.warn(error('PatchElementsNoTargetsFound'), { selector })\n      return\n    }\n\n    applyToTargets(mode as PatchElementsMode, newContent, targets)\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfor (const script of document.querySelectorAll('script')) {\n  scripts.add(script)\n}\n\nconst execute = (target: Element): void => {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nconst applyPatchMode = (\n  targets: Iterable<Element>,\n  element: DocumentFragment | Element,\n  action: string,\n) => {\n  for (const target of targets) {\n    const cloned = element.cloneNode(true) as Element\n    execute(cloned)\n    // @ts-expect-error\n    target[action](cloned)\n  }\n}\n\nconst applyToTargets = (\n  mode: PatchElementsMode,\n  element: DocumentFragment | Element,\n  targets: Iterable<Element>,\n) => {\n  switch (mode) {\n    case 'remove':\n      for (const target of targets) {\n        target.remove()\n      }\n      break\n    case 'outer':\n    case 'inner':\n      for (const target of targets) {\n        morph(target, element.cloneNode(true) as Element, mode)\n        execute(target)\n      }\n      break\n    case 'replace':\n      applyPatchMode(targets, element, 'replaceWith')\n      break\n    case 'prepend':\n    case 'append':\n    case 'before':\n    case 'after':\n      applyPatchMode(targets, element, mode)\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport { watcher } from '@engine'\nimport { mergePatch } from '@engine/signals'\nimport { jsStrToObject } from '@utils/text'\n\nwatcher({\n  name: 'datastar-patch-signals',\n  apply({ error }, { signals, onlyIfMissing }) {\n    if (signals) {\n      const ifMissing = onlyIfMissing?.trim() === 'true'\n      mergePatch(jsStrToObject(signals), { ifMissing })\n    } else {\n      throw error('PatchSignalsExpectedSignals')\n    }\n  },\n})\n"],
  "mappings": ";AAAA,IAAMA,GAAM,YAAY,OACXC,GAAMD,GAAI,MAAM,EAAG,CAAC,EACpBE,GAAMF,GAAI,MAAM,CAAC,EACjBG,EAAuB,iBACvBC,EAA8B,wBCFpC,IAAMC,GAASC,GACpBA,EACG,QAAQ,qBAAsB,OAAO,EACrC,QAAQ,oBAAqB,OAAO,EACpC,QAAQ,oBAAqB,OAAO,EACpC,YAAY,EAKV,IAAMC,GAASC,GAAwBC,GAAMD,CAAG,EAAE,QAAQ,KAAM,GAAG,EAKnE,IAAME,GAAiBC,GAAgB,CAC5C,GAAI,CACF,OAAO,KAAK,MAAMA,CAAG,CACvB,MAAQ,CAGN,OAAO,SAAS,WAAWA,CAAG,GAAG,EAAE,CACrC,CACF,EAEMC,GAAiD,CACrD,MAAQC,GAAQA,EAAI,QAAQ,UAAYC,GAAMA,EAAE,CAAC,EAAE,YAAY,CAAC,EAChE,MAAQD,GAAQA,EAAI,QAAQ,KAAM,GAAG,EACrC,OAASA,GAAQA,EAAI,CAAC,EAAE,YAAY,EAAID,GAAQ,MAAMC,EAAI,MAAM,CAAC,CAAC,CACpE,EAEaE,EAAe,CAC1BF,EACAG,EACAC,EAAc,UACH,CACX,QAAWC,KAAKF,EAAK,IAAI,MAAM,GAAK,CAACC,CAAW,EAC9CJ,EAAMD,GAAQM,CAAC,IAAIL,CAAG,GAAKA,EAE7B,OAAOA,CACT,EAEaM,EAAYC,GACW,QAAQA,CAAI,GC7CzC,IAAMC,EAEX,OAAO,QAAU,OAAO,UAAU,eAAe,KCC5C,IAAMC,GAAUC,GACrBA,IAAQ,MACR,OAAOA,GAAQ,WACd,OAAO,eAAeA,CAAG,IAAM,OAAO,WACrC,OAAO,eAAeA,CAAG,IAAM,MAEtBC,GAAWD,GAAsC,CAC5D,QAAWE,KAAQF,EACjB,GAAIG,EAAOH,EAAKE,CAAI,EAClB,MAAO,GAGX,MAAO,EACT,EAEaE,EAAe,CAC1BJ,EACAK,IACG,CACH,QAAWC,KAAON,EAAK,CACrB,IAAMO,EAAMP,EAAIM,CAAG,EACfP,GAAOQ,CAAG,GAAK,MAAM,QAAQA,CAAG,EAClCH,EAAaG,EAAKF,CAAE,EAEpBL,EAAIM,CAAG,EAAID,EAAGE,CAAG,CAErB,CACF,EAEaC,GAAaC,GAAsC,CAC9D,IAAMC,EAA8B,CAAC,EACrC,OAAW,CAACC,EAAMC,CAAK,IAAKH,EAAO,CACjC,IAAMI,EAAOF,EAAK,MAAM,GAAG,EACrBG,EAAUD,EAAK,IAAI,EACnBb,EAAMa,EAAK,OAAO,CAACE,EAAKT,IAASS,EAAIT,CAAG,IAAM,CAAC,EAAII,CAAM,EAC/DV,EAAIc,CAAO,EAAIF,CACjB,CACA,OAAOF,CACT,ECuBA,IAAMM,GAAsB,CAAC,EACvBC,GAA6C,CAAC,EAChDC,GAAa,EACbC,GAAc,EACdC,GAAsB,EACtBC,GACAC,EACAC,GAAU,EAEDC,EAAa,IAAY,CACpCN,IACF,EAEaO,EAAW,IAAY,CAC7B,EAAEP,KACLQ,GAAM,EACNC,EAAS,EAEb,EAEaC,EAAgBC,GAA6B,CACxDR,GAAUC,EACVA,EAAYO,CACd,EAEaC,EAAc,IAAY,CACrCR,EAAYD,GACZA,GAAU,MACZ,EAEaU,GAAaC,GACjBC,GAAW,KAAK,EAAG,CACxB,cAAeD,EACfE,EAAQF,EACRG,EAAQ,CACV,CAAC,EAGGC,GAAiB,OAAO,UAAU,EAC3BC,GAAeC,GAAkD,CAC5E,IAAMC,EAAIC,GAAa,KAAK,EAAG,CAC7BL,EAAQ,GACR,OAAAG,CACF,CAAC,EAED,OAAAC,EAAEH,EAAc,EAAI,EACbG,CACT,EAEaE,EAAUC,GAA2B,CAChD,IAAMC,EAAiB,CACrBC,EAAKF,EACLP,EAAQ,CACV,EACIb,GACFuB,GAAKF,EAAGrB,CAAS,EAEnBM,EAAae,CAAC,EACdnB,EAAW,EACX,GAAI,CACFmB,EAAEC,EAAI,CACR,QAAE,CACAnB,EAAS,EACTK,EAAY,CACd,CACA,OAAOgB,GAAW,KAAK,EAAGH,CAAC,CAC7B,EAEMjB,GAAQ,IAAM,CAClB,KAAOP,GAAcC,IAAqB,CACxC,IAAMqB,EAASxB,GAAcE,EAAW,EACxCF,GAAcE,IAAa,EAAI,OAC/B4B,GAAIN,EAASA,EAAON,GAAU,GAAoB,CACpD,CACAhB,GAAc,EACdC,GAAsB,CACxB,EAEM4B,GAAUjB,GACV,WAAYA,EACPkB,GAAelB,CAAM,EAEvBmB,GAAanB,EAAQA,EAAOG,CAAM,EAGrCe,GAAkBV,GAA8B,CACpDX,EAAaW,CAAC,EACdY,GAAcZ,CAAC,EACf,GAAI,CACF,IAAMa,EAAWb,EAAEL,EACnB,OAAOkB,KAAcb,EAAEL,EAASK,EAAE,OAAOa,CAAQ,EACnD,QAAE,CACAtB,EAAY,EACZuB,GAAYd,CAAC,CACf,CACF,EAEMW,GAAe,CAAII,EAAmBC,KAC1CD,EAAEnB,EAAS,EACJmB,EAAE,iBAAmBA,EAAE,cAAgBC,IAG1CC,GAAU,GAAyB,CACvC,IAAMC,EAAQ,EAAEtB,EAChB,GAAI,EAAEsB,EAAQ,IAAqB,CACjC,EAAEtB,EAASsB,EAAQ,GACnB,IAAMC,EAAO,EAAEC,EACXD,EACFF,GAAOE,EAAKE,CAAmB,EAE/B3C,GAAcG,IAAqB,EAAI,CAE3C,CACF,EAEM2B,GAAM,CAAC,EAAgBU,IAA+B,CAC1D,GACEA,EAAS,IACRA,EAAS,IAAuCI,GAAW,EAAEC,EAAQ,CAAC,EACvE,CACAlC,EAAa,CAAC,EACduB,GAAc,CAAC,EACf3B,EAAW,EACX,GAAI,CACF,EAAEoB,EAAI,CACR,QAAE,CACAnB,EAAS,EACTK,EAAY,EACZuB,GAAY,CAAC,CACf,CACA,MACF,CACII,EAAS,KACX,EAAEtB,EAASsB,EAAQ,KAErB,IAAIZ,EAAO,EAAEiB,EACb,KAAOjB,GAAM,CACX,IAAMkB,EAAMlB,EAAKmB,EACXC,EAAWF,EAAI5B,EACjB8B,EAAW,IACblB,GAAIgB,EAAqBA,EAAI5B,EAAS8B,EAAW,GAAoB,EAEvEpB,EAAOA,EAAKqB,CACd,CACF,EAEMjC,GAAa,CAAIqB,KAAsBC,IAA4B,CACvE,GAAIA,EAAM,OAAQ,CAChB,GAAID,EAAEpB,KAAYoB,EAAEpB,EAASqB,EAAM,CAAC,GAAI,CACtCD,EAAEnB,EAAS,GACX,IAAMuB,EAAOJ,EAAEK,EACf,OAAID,IACFS,GAAUT,CAAI,EACTxC,IACHQ,GAAM,GAGH,EACT,CACA,MAAO,EACT,CACA,IAAM0C,EAAed,EAAEpB,EACvB,GAAIoB,EAAEnB,EAAU,IACVe,GAAaI,EAAGc,CAAY,EAAG,CACjC,IAAMT,EAAQL,EAAEK,EACZA,GACFU,GAAiBV,CAAK,CAE1B,CAEF,OAAIrC,GACFuB,GAAKS,EAAGhC,CAAS,EAEZ8C,CACT,EAEM5B,GAAmBD,GAA2B,CAClD,IAAMkB,EAAQlB,EAAEJ,EAChB,GACEsB,EAAS,IACRA,EAAS,IAAuCI,GAAWtB,EAAEuB,EAAQvB,CAAC,GAEvE,GAAIU,GAAeV,CAAC,EAAG,CACrB,IAAMmB,EAAOnB,EAAEoB,EACXD,GACFW,GAAiBX,CAAI,CAEzB,OACSD,EAAS,KAClBlB,EAAEJ,EAASsB,EAAQ,KAErB,OAAInC,GACFuB,GAAKN,EAAGjB,CAAS,EAEZiB,EAAEL,CACX,EAEMY,GAAc,GAAyB,CAC3C,IAAIiB,EAAM,EAAED,EACZ,KAAOC,GACLA,EAAMO,GAAOP,EAAK,CAAC,EAErB,IAAMlC,EAAM,EAAE8B,EACV9B,GACFyC,GAAOzC,CAAG,EAEZ,EAAEM,EAAS,CACb,EAEMU,GAAO,CAACkB,EAAmBlC,IAA4B,CAC3D,IAAM0C,EAAU1C,EAAI2C,EACpB,GAAID,GAAWA,EAAQP,IAASD,EAC9B,OAEF,IAAMU,EAAUF,EAAUA,EAAQL,EAAWrC,EAAIiC,EACjD,GAAIW,GAAWA,EAAQT,IAASD,EAAK,CACnCU,EAAQC,EAAWnD,GACnBM,EAAI2C,EAAYC,EAChB,MACF,CACA,IAAMpD,EAAU0C,EAAIY,EACpB,GAAItD,GAAWA,EAAQqD,IAAanD,IAAWF,EAAQuC,IAAS/B,EAC9D,OAEF,IAAM+C,EACH/C,EAAI2C,EACLT,EAAIY,EACF,CACED,EAAUnD,GACVyC,EAAMD,EACNH,EAAM/B,EACNgD,EAAUN,EACVL,EAAUO,EACVK,EAAUzD,CACZ,EACAoD,IACFA,EAAQI,EAAWD,GAEjBL,EACFA,EAAQL,EAAWU,EAEnB/C,EAAIiC,EAAQc,EAEVvD,EACFA,EAAQ0D,EAAWH,EAEnBb,EAAIJ,EAAQiB,CAEhB,EAEMN,GAAS,CAACzB,EAAYhB,EAAMgB,EAAKe,IAA2B,CAChE,IAAMI,EAAOnB,EAAKmB,EACZa,EAAWhC,EAAKgC,EAChBX,EAAWrB,EAAKqB,EAChBa,EAAWlC,EAAKkC,EAChBD,EAAWjC,EAAKiC,EAgBtB,GAfIZ,EACFA,EAASW,EAAWA,EAEpBhD,EAAI2C,EAAYK,EAEdA,EACFA,EAASX,EAAWA,EAEpBrC,EAAIiC,EAAQI,EAEVa,EACFA,EAASD,EAAWA,EAEpBd,EAAKW,EAAYG,EAEfA,EACFA,EAASC,EAAWA,UACX,EAAEf,EAAKL,EAAQoB,GACxB,GAAI,WAAYf,EAAM,CACpB,IAAIgB,EAAWhB,EAAKF,EACpB,GAAIkB,EAAU,CACZhB,EAAK7B,EAAS,GACd,GACE6C,EAAWV,GAAOU,EAAUhB,CAAI,QACzBgB,EACX,CACF,KAAa,kBAAmBhB,GAC9BlB,GAAWkB,CAAmB,EAGlC,OAAOE,CACT,EAEMC,GAAatB,GAAqB,CACtC,IAAIoC,EAAOpC,EAAKkC,EACZG,EAEJC,EAAK,OAAa,CAChB,IAAMtD,EAAMgB,EAAKe,EAEbH,EAAQ5B,EAAIM,EAoChB,GAhCIsB,EACC,GASDA,EAAS,GAGAA,EAAS,EAKpB,EAAEA,EAAS,KACX2B,GAAYvC,EAAMhB,CAAG,GAErBA,EAAIM,EACFsB,EAAS,GACXA,GAAS,GAETA,EAAQ,EAXR5B,EAAIM,EACDsB,EAAQ,GACR,GAJHA,EAAQ,EAJR5B,EAAIM,EAASsB,EAAS,GAoBpBA,EAAS,GACXD,GAAO3B,CAAkB,EAGvB4B,EAAS,EAAoC,CAC/C,IAAM4B,EAAUxD,EAAI8B,EACpB,GAAI0B,EAAS,CACX,IAAMC,GAAWzC,EAAOwC,GAASN,EAC7BO,IACFJ,EAAQ,CAAEhD,EAAcqD,EAAOL,CAAM,EACrCD,EAAOK,GAET,QACF,CACF,CAEA,GAAKzC,EAAOoC,EAAQ,CAClBA,EAAOpC,EAAKkC,EACZ,QACF,CAEA,KAAOG,GAGL,GAFArC,EAAOqC,EAAMhD,EACbgD,EAAQA,EAAMK,EACV1C,EAAM,CACRoC,EAAOpC,EAAKkC,EACZ,SAASI,CACX,CAGF,KACF,CACF,EAEMhC,GAAiBtB,GAA4B,CACjDN,KACAM,EAAI2C,EAAY,OAChB3C,EAAIM,EACDN,EAAIM,EACH,IAID,CACL,EAEMkB,GAAexB,GAA4B,CAC/C,IAAM2C,EAAY3C,EAAI2C,EAClBQ,EAAWR,EAAYA,EAAUN,EAAWrC,EAAIiC,EACpD,KAAOkB,GACLA,EAAWV,GAAOU,EAAUnD,CAAG,EAEjCA,EAAIM,GAAU,EAChB,EAEM0B,GAAa,CAAChB,EAAYhB,IAA+B,CAC7D,IAAIqD,EACAM,EAAa,EACbC,EAAQ,GAEZN,EAAK,OAAa,CAChB,IAAMpB,EAAMlB,EAAKmB,EACXP,EAAQM,EAAI5B,EAElB,GAAIN,EAAIM,EAAU,GAChBsD,EAAQ,YAEPhC,EAAS,MACT,IAED,GAAIT,GAAOe,CAAkC,EAAG,CAC9C,IAAML,EAAOK,EAAIJ,EACbD,EAAKqB,GACPV,GAAiBX,CAAI,EAEvB+B,EAAQ,EACV,WAEChC,EAAS,MACT,GACD,EACIZ,EAAKkC,GAAYlC,EAAKiC,KACxBI,EAAQ,CAAEhD,EAAQW,EAAM0C,EAAOL,CAAM,GAEvCrC,EAAOkB,EAAID,EACXjC,EAAMkC,EACN,EAAEyB,EACF,QACF,CAEA,GAAI,CAACC,EAAO,CACV,IAAMhB,EAAU5B,EAAKqB,EACrB,GAAIO,EAAS,CACX5B,EAAO4B,EACP,QACF,CACF,CAEA,KAAOe,KAAc,CACnB,IAAME,EAAW7D,EAAI8B,EACfgC,EAAkBD,EAASX,EAOjC,GANIY,GACF9C,EAAOqC,EAAOhD,EACdgD,EAAQA,EAAOK,GAEf1C,EAAO6C,EAELD,EAAO,CACT,GAAIzC,GAAOnB,CAAkC,EAAG,CAC1C8D,GACFtB,GAAiBqB,CAAQ,EAE3B7D,EAAMgB,EAAKe,EACX,QACF,CACA6B,EAAQ,EACV,MACE5D,EAAIM,GAAU,IAGhB,GADAN,EAAMgB,EAAKe,EACPf,EAAKqB,EAAU,CACjBrB,EAAOA,EAAKqB,EACZ,SAASiB,CACX,CACF,CAEA,OAAOM,CACT,CACF,EAEMpB,GAAoBxB,GAAqB,CAC7C,EAAG,CACD,IAAMhB,EAAMgB,EAAKe,EACXH,EAAQ5B,EAAIM,GAEfsB,EAAS,MACT,KAED5B,EAAIM,EAASsB,EAAS,GAClBA,EAAS,GACXD,GAAO3B,CAAkB,EAG/B,OAAUgB,EAAOA,EAAKkC,EACxB,EAEMK,GAAc,CAACQ,EAAiB/D,IAA+B,CACnE,IAAIgB,EAAOhB,EAAI2C,EACf,KAAO3B,GAAM,CACX,GAAIA,IAAS+C,EACX,MAAO,GAET/C,EAAOA,EAAKgC,CACd,CACA,MAAO,EACT,EAEagB,GAAoBC,GAAgC,CAC/D,IAAIC,EAASC,EACPC,EAAQH,EAAK,MAAM,GAAG,EAC5B,QAAWA,KAAQG,EAAO,CACxB,GAAIF,GAAU,MAAQ,CAACG,EAAOH,EAAQD,CAAI,EACxC,OAEFC,EAASA,EAAOD,CAAI,CACtB,CACA,OAAOC,CACT,EAEMI,GAAO,CAAC5C,EAAY6C,EAAS,KAAY,CAC7C,IAAMC,EAAQ,MAAM,QAAQ9C,CAAK,EACjC,GAAI8C,GAASC,GAAO/C,CAAK,EAAG,CAC1B,IAAMgD,EAAWF,EAAQ,CAAC,EAAI,CAAC,EAC/B,QAAWG,KAAOjD,EAChBgD,EAAQC,CAAG,EAAIzE,GACboE,GAAM5C,EAAsCiD,CAAG,EAAG,GAAGJ,EAASI,CAAG,GAAG,CACtE,EAEF,IAAMC,EAAO1E,GAAO,CAAC,EACrB,OAAO,IAAI,MAAMwE,EAAS,CACxB,IAAIG,EAAGC,EAAc,CAInB,GAAI,EAAEA,IAAS,UAAY,CAACT,EAAOK,EAASI,CAAI,GAG9C,OAAIN,GAASM,KAAQ,MAAM,WACzBF,EAAK,EACEF,EAAQI,CAAI,GAIjB,OAAOA,GAAS,SACXJ,EAAQI,CAAI,IAIjB,CAACT,EAAOK,EAASI,CAAI,GAAKJ,EAAQI,CAAI,EAAE,GAAK,QAC/CJ,EAAQI,CAAI,EAAI5E,GAAO,EAAE,EACzBJ,EAASyE,EAASO,EAAM,EAAE,EAC1BF,EAAKA,EAAK,EAAI,CAAC,GAEVF,EAAQI,CAAI,EAAE,EAEzB,EACA,IAAID,EAAGC,EAAcC,EAAU,CAC7B,IAAMd,EAAOM,EAASO,EAEtB,GAAIN,GAASM,IAAS,SAAU,CAC9B,IAAME,EAAQN,EAAQI,CAAI,EAA0BC,EAIpD,GAHAL,EAAQI,CAAI,EAAIC,EAGZC,EAAO,EAAG,CACZ,IAAMC,EAA6B,CAAC,EACpC,QAASC,EAAIH,EAAUG,EAAIR,EAAQI,CAAI,EAAGI,IACxCD,EAAMC,CAAC,EAAI,KAEbpF,EAASyE,EAAO,MAAM,EAAG,EAAE,EAAGU,CAAK,EACnCL,EAAKA,EAAK,EAAI,CAAC,CACjB,CACF,MAAWP,EAAOK,EAASI,CAAI,EACzBC,GAAY,KACd,OAAOL,EAAQI,CAAI,EAEVT,EAAOU,EAAUxE,EAAc,GACxCmE,EAAQI,CAAI,EAAIC,EAChBjF,EAASmE,EAAM,EAAE,GAERS,EAAQI,CAAI,EAAER,GAAKS,EAAU,GAAGd,CAAI,GAAG,CAAC,GACjDnE,EAASmE,EAAMc,CAAQ,EAGhBA,GAAY,OAEjBV,EAAOU,EAAUxE,EAAc,GACjCmE,EAAQI,CAAI,EAAIC,EAChBjF,EAASmE,EAAM,EAAE,IAEjBS,EAAQI,CAAI,EAAI5E,GAAOoE,GAAKS,EAAU,GAAGd,CAAI,GAAG,CAAC,EACjDnE,EAASmE,EAAMc,CAAQ,GAEzBH,EAAKA,EAAK,EAAI,CAAC,GAGjB,MAAO,EACT,EACA,eAAeC,EAAGC,EAAc,CAC9B,cAAOJ,EAAQI,CAAI,EACnBF,EAAKA,EAAK,EAAI,CAAC,EACR,EACT,EACA,SAAU,CACR,OAAAA,EAAK,EACE,QAAQ,QAAQF,CAAO,CAChC,EACA,IAAIG,EAAGC,EAAM,CACX,OAAAF,EAAK,EACEE,KAAQJ,CACjB,CACF,CAAC,CACH,CACA,OAAOhD,CACT,EAEM5B,EAAW,CAACmE,EAAevC,IAAgB,CAI/C,GAHIuC,IAAS,QAAavC,IAAU,QAClCvC,GAAa,KAAK,CAAC8E,EAAMvC,CAAK,CAAC,EAE7B,CAACrC,IAAcF,GAAa,OAAQ,CACtC,IAAMgG,EAASC,GAAUjG,EAAY,EACrCA,GAAa,OAAS,EACtB,SAAS,cACP,IAAI,YAAuBkG,EAA6B,CACtD,OAAAF,CACF,CAAC,CACH,CACF,CACF,EAEaG,EAAa,CACxBL,EACA,CAAE,UAAAM,CAAU,EAAoB,CAAC,IACxB,CACT5F,EAAW,EACX,QAAWgF,KAAOM,EACZA,EAAMN,CAAG,GAAK,KACXY,GACH,OAAOpB,EAAKQ,CAAG,EAGjBa,GAAWP,EAAMN,CAAG,EAAGA,EAAKR,EAAM,GAAIoB,CAAS,EAGnD3F,EAAS,CACX,EAEa6F,EAAa,CAACC,EAAcC,IACvCL,EAAWF,GAAUM,CAAK,EAAGC,CAAO,EAEhCH,GAAa,CACjBP,EACAW,EACAC,EACAtB,EACAgB,IACS,CACT,GAAId,GAAOQ,CAAK,EAAG,CAGbZ,EAAOwB,EAAcD,CAAM,IAC1BnB,GAAOoB,EAAaD,CAAM,CAAC,GAAK,MAAM,QAAQC,EAAaD,CAAM,CAAC,KAGrEC,EAAaD,CAAM,EAAI,CAAC,GAG1B,QAAWjB,KAAOM,EACZA,EAAMN,CAAG,GAAK,KACXY,GACH,OAAOM,EAAaD,CAAM,EAAEjB,CAAG,EAGjCa,GACEP,EAAMN,CAAG,EACTA,EACAkB,EAAaD,CAAM,EACnB,GAAGrB,EAASqB,CAAM,IAClBL,CACF,CAGN,MAAaA,GAAalB,EAAOwB,EAAcD,CAAM,IACnDC,EAAaD,CAAM,EAAIX,EAE3B,EAEMa,GAAYC,GAChB,OAAOA,GAAQ,SAAW,OAAOA,EAAI,QAAQ,WAAY,EAAE,CAAC,EAAIA,EAOrDC,EAAW,CACtB,CAAE,QAAAC,EAAU,KAAM,QAAAC,EAAU,MAAO,EAAyB,CAAC,EAC7DC,EAAiBhC,IACO,CACxB,IAAMiC,EAAYN,GAASG,CAAO,EAC5BI,EAAYP,GAASI,CAAO,EAC5BR,EAAe,CAAC,EAChBrC,EAAyB,CAAC,CAAC8C,EAAK,EAAE,CAAC,EAEzC,KAAO9C,EAAM,QAAQ,CACnB,GAAM,CAACiD,EAAM/B,CAAM,EAAIlB,EAAM,IAAI,EAEjC,QAAWsB,KAAO2B,EAAM,CACtB,IAAMrC,EAAOM,EAASI,EAClBF,GAAO6B,EAAK3B,CAAG,CAAC,EAClBtB,EAAM,KAAK,CAACiD,EAAK3B,CAAG,EAAG,GAAGV,CAAI,GAAG,CAAC,EACzBmC,EAAU,KAAKnC,CAAI,GAAK,CAACoC,EAAU,KAAKpC,CAAI,GACrDyB,EAAM,KAAK,CAACzB,EAAMD,GAAQC,CAAI,CAAC,CAAC,CAEpC,CACF,CAEA,OAAOmB,GAAUM,CAAK,CACxB,EAEavB,EAA4BG,GAAK,CAAC,CAAC,ECzvBzC,IAAMiC,EAAeC,GAC1BA,aAAc,aACdA,aAAc,YACdA,aAAc,cCWhB,IAAMC,GAAM,+BAENC,GAAQ,CACZC,EACAC,EACAC,EAAgC,CAAC,IAC9B,CACH,OAAO,OAAOA,EAAUF,CAAG,EAC3B,IAAMG,EAAI,IAAI,MACRC,EAAIC,GAAMJ,CAAM,EAChBK,EAAI,IAAI,gBAAgB,CAC5B,SAAU,KAAK,UAAUJ,CAAQ,CACnC,CAAC,EAAE,SAAS,EACNK,EAAI,KAAK,UAAUL,EAAU,KAAM,CAAC,EAC1C,OAAAC,EAAE,QAAU,GAAGF,CAAM;AAAA,aAAgBH,EAAG,IAAIM,CAAC,IAAIE,CAAC;AAAA,WAAcC,CAAC,GAC1DJ,CACT,EAEMK,GAA2C,IAAI,IAC/CC,GAAiD,IAAI,IACrDC,GAA6C,IAAI,IAE1CC,GAGT,IAAI,MACN,CAAC,EACD,CACE,IAAK,CAACC,EAAGC,IAAiBL,GAAc,IAAIK,CAAI,GAAG,MACnD,IAAK,CAACD,EAAGC,IAAiBL,GAAc,IAAIK,CAAI,EAChD,QAAS,IAAM,QAAQ,QAAQL,EAAa,EAC5C,IAAK,IAAM,GACX,eAAgB,IAAM,EACxB,CACF,EAGMM,GAAW,IAAI,IAEfC,GAAsC,CAAC,EACvCC,GAAuB,IAAI,IACpBC,EACXC,GACS,CACTH,GAAiB,KAAKG,CAAoC,EAEtDH,GAAiB,SAAW,GAC9B,WAAW,IAAM,CACf,QAAWE,KAAaF,GACtBC,GAAqB,IAAIC,EAAU,IAAI,EACvCR,GAAiB,IAAIQ,EAAU,KAAMA,CAAS,EAEhDF,GAAiB,OAAS,EAC1BI,GAAM,EACNH,GAAqB,MAAM,CAC7B,CAAC,CAEL,EAEaI,EAAaF,GAAkC,CAC1DV,GAAc,IAAIU,EAAO,KAAMA,CAAM,CACvC,EAEA,SAAS,iBAAiBG,EACxBC,GACG,CACH,IAAMJ,EAASR,GAAe,IAAIY,EAAI,OAAO,IAAI,EAC7CJ,GACFA,EAAO,MACL,CACE,MAAOnB,GAAM,KAAK,EAAG,CACnB,OAAQ,CAAE,KAAM,UAAW,KAAMmB,EAAO,IAAK,EAC7C,QAAS,CACP,GAAKI,EAAI,OAAmB,GAC5B,IAAMA,EAAI,OAAmB,OAC/B,CACF,CAAC,CACH,EACAA,EAAI,OAAO,OACb,CAEJ,CAAmB,EAEZ,IAAMC,GAAWL,GAAgC,CACtDR,GAAe,IAAIQ,EAAO,KAAMA,CAAM,CACxC,EAEMM,GAAcC,GAAmC,CACrD,QAAWC,KAAMD,EAAK,CACpB,IAAME,EAAWb,GAAS,IAAIY,CAAE,EAEhC,GAAIZ,GAAS,OAAOY,CAAE,EAAG,CACvB,QAAWE,KAAWD,EAAU,OAAO,EACrCC,EAAQ,EAEVD,EAAU,MAAM,CAClB,CACF,CACF,EAEME,GAAgBC,EAAS,QAAQ,EACjCC,GAAoB,IAAIF,EAAa,IACrCG,GAAgBN,GACpBA,EAAG,aAAa,GAAGG,EAAa,QAAQ,GAAK,CAAC,CAACH,EAAG,QAAQK,EAAiB,EAEvEE,GAAW,CAACR,EAA0BS,IAA4B,CACtE,QAAWR,KAAMD,EACf,GAAI,CAACO,GAAaN,CAAE,EAClB,QAAWS,KAAOT,EAAG,QACnBU,GACEV,EACAS,EAAI,QAAQ,SAAU,KAAK,EAAE,YAAY,EACzCT,EAAG,QAAQS,CAAG,EACdD,CACF,CAIR,EAEMG,GAAWC,GAAgC,CAC/C,OAAW,CACT,OAAAC,EACA,KAAAC,EACA,cAAAC,EACA,WAAAC,EACA,aAAAC,CACF,IAAKL,EACH,GAAIE,IAAS,YAAa,CACxB,QAAWI,KAAQD,EACbE,EAAYD,CAAI,IAClBpB,GAAW,CAACoB,CAAI,CAAC,EACjBpB,GAAWoB,EAAK,iBAA4B,GAAG,CAAC,GAIpD,QAAWA,KAAQF,EACbG,EAAYD,CAAI,IAClBX,GAAS,CAACW,CAAI,CAAC,EACfX,GAASW,EAAK,iBAA4B,GAAG,CAAC,EAGpD,SACEJ,IAAS,cACTC,EAAe,WAAW,OAAO,GACjCI,EAAYN,CAAM,GAClB,CAACP,GAAaO,CAAM,EACpB,CAEA,IAAMJ,EAAMM,EAAe,MAAM,CAAC,EAC5BK,EAAQP,EAAO,aAAaE,CAAc,EAChD,GAAIK,IAAU,KAAM,CAClB,IAAMnB,EAAWb,GAAS,IAAIyB,CAAM,EAChCZ,IACFA,EAAS,IAAIQ,CAAG,IAAI,EACpBR,EAAS,OAAOQ,CAAG,EAEvB,MACEC,GAAqBG,EAAQJ,EAAKW,CAAK,CAE3C,CAEJ,EAGMC,GAAmB,IAAI,iBAAiBV,EAAO,EAExClB,GAAQ,CACnB6B,EAA+B,SAAS,kBAC/B,CACLH,EAAYG,CAAI,GAClBf,GAAS,CAACe,CAAI,EAAG,EAAI,EAEvBf,GAASe,EAAK,iBAA4B,GAAG,EAAG,EAAI,EAEpDD,GAAiB,QAAQC,EAAM,CAC7B,QAAS,GACT,UAAW,GACX,WAAY,EACd,CAAC,CACH,EAEMZ,GAAuB,CAC3BV,EACAuB,EACAH,EACAZ,IACS,CACsC,CAC7C,IAAMgB,EAAmDD,EACnD,CAACE,EAAU,GAAGC,CAAY,EAAIF,EAAO,MAAM,IAAI,EAC/C,CAACG,EAAYlB,CAAG,EAAIgB,EAAS,MAAM,OAAO,EAC1CjC,EAAST,GAAiB,IAAI4C,CAAU,EAC9C,IAAK,CAACnB,GAAWlB,GAAqB,IAAIqC,CAAU,IAAMnC,EAAQ,CAChE,IAAMlB,EAAM,CACV,GAAA0B,EACA,OAAAwB,EACA,KAAM,IAAI,IACV,MAAOnD,GAAM,KAAK,EAAG,CACnB,OAAQ,CAAE,KAAM,YAAa,KAAMmB,EAAO,IAAK,EAC/C,QAAS,CAAE,GAAIQ,EAAG,GAAI,IAAKA,EAAG,OAAQ,EACtC,WAAY,CAAE,OAAAwB,EAAQ,IAAAf,EAAK,MAAAW,CAAM,CACnC,CAAC,EACD,IAAAX,EACA,MAAAW,EACA,GAAI,MACN,EAEMQ,EACHpC,EAAO,cACL,OAAOA,EAAO,aAAgB,SAC3BA,EAAO,YACPA,EAAO,YAAY,MACzB,UACIqC,EACHrC,EAAO,cACL,OAAOA,EAAO,aAAgB,SAC3BA,EAAO,YACPA,EAAO,YAAY,QACzB,UAEF,GAAIiB,GACF,GAAImB,IAAW,SACb,MAAMtD,EAAI,MAAM,eAAe,UAExBsD,IAAW,OACpB,MAAMtD,EAAI,MAAM,aAAa,EAG/B,GAAI8C,GACF,GAAIS,IAAa,SACf,MAAMvD,EAAI,MAAM,iBAAiB,UAE1BuD,IAAa,OACtB,MAAMvD,EAAI,MAAM,eAAe,EAGjC,GAAIsD,IAAW,aAAeC,IAAa,YAAa,CACtD,GAAIpB,GAAOW,EACT,MAAM9C,EAAI,MAAM,qBAAqB,EAEvC,GAAI,CAACmC,GAAO,CAACW,EACX,MAAM9C,EAAI,MAAM,oBAAoB,CAExC,CAEA,GAAI8C,EAAO,CACT,IAAIU,EACJxD,EAAI,GAAK,IAAIyD,KACND,IACHA,EAAWE,GAAMZ,EAAO,CACtB,aAAc5B,EAAO,aACrB,SAAUA,EAAO,QACnB,CAAC,GAEIsC,EAAS9B,EAAI,GAAG+B,CAAI,EAE/B,CAEA,QAAWE,KAAUP,EAAc,CACjC,GAAM,CAACQ,EAAO,GAAGC,CAAG,EAAIF,EAAO,MAAM,GAAG,EACxC3D,EAAI,KAAK,IAAI4D,EAAO,IAAI,IAAIC,CAAG,CAAC,CAClC,CAEA,IAAMjC,EAAUV,EAAO,MAAMlB,CAAG,EAChC,GAAI4B,EAAS,CACX,IAAID,EAAWb,GAAS,IAAIY,CAAE,EAC1BC,EACFA,EAAS,IAAIuB,CAAM,IAAI,GAEvBvB,EAAW,IAAI,IACfb,GAAS,IAAIY,EAAIC,CAAQ,GAE3BA,EAAS,IAAIuB,EAAQtB,CAAO,CAC9B,CACF,CACF,CACF,EASM8B,GAAQ,CACZZ,EACA,CAAE,aAAAgB,EAAe,GAAO,SAAAC,EAAW,CAAC,CAAE,EAAkB,CAAC,IAC7C,CACZ,IAAIC,EAAO,GACX,GAAIF,EAAc,CAqBhB,IAAMG,EACJ,4JACIC,EAAapB,EAAM,KAAK,EAAE,MAAMmB,CAAW,EACjD,GAAIC,EAAY,CACd,IAAMC,EAAUD,EAAW,OAAS,EAC9BE,EAAOF,EAAWC,CAAO,EAAE,KAAK,EACjCC,EAAK,WAAW,QAAQ,IAC3BF,EAAWC,CAAO,EAAI,WAAWC,CAAI,MAEvCJ,EAAOE,EAAW,KAAK;AAAA,CAAK,CAC9B,CACF,MACEF,EAAOlB,EAAM,KAAK,EAIpB,IAAMuB,EAAU,IAAI,IACdC,EAAW,OAAO,MAAMC,EAAG,YAAYC,EAAG,IAAK,IAAI,EACrDC,EAAU,EACd,QAAWC,KAASV,EAAK,SAASM,CAAQ,EAAG,CAC3C,IAAMK,EAAID,EAAM,CAAC,EACXE,EAAI,YAAYH,GAAS,GAC/BJ,EAAQ,IAAIO,EAAGD,CAAC,EAChBX,EAAOA,EAAK,QAAQO,GAAMI,EAAIH,GAAKI,CAAC,CACtC,CAiBAZ,EAAOA,EAEJ,QAAQ,gCAAiC,MAAM,EAE/C,QAAQ,kCAAmC,CAACpD,EAAGiE,IAC9CA,EACG,MAAM,GAAG,EACT,OAAO,CAACC,EAAaC,IAAiB,GAAGD,CAAG,KAAKC,CAAI,KAAM,GAAG,CACnE,EAEC,QACC,0BACA,CAACnE,EAAGoE,IAAY,OAAOA,EAAQ,MAAM,CAAC,CAAC,KACzC,EAEFhB,EAAOA,EAAK,WAAW,YAAa,oBAAoB,EAGxD,OAAW,CAACW,EAAGC,CAAC,IAAKP,EACnBL,EAAOA,EAAK,QAAQW,EAAGC,CAAC,EAG1B,GAAI,CACF,IAAMK,EAAK,SAAS,KAAM,IAAK,WAAY,MAAO,GAAGlB,EAAUC,CAAI,EACnE,MAAO,CAACtC,KAAkB+B,IAAgB,CACxC,IAAMrC,EAAS,CAAC8D,EAAc5D,KAA2BmC,IAAgB,CACvE,IAAM0B,EAAMpF,GAAM,KAAK,EAAG,CACxB,OAAQ,CAAE,KAAM,SAAU,KAAAmF,CAAK,EAC/B,QAAS,CAAE,GAAIxD,EAAG,GAAI,IAAKA,EAAG,OAAQ,EACtC,WAAY,CACV,UAAWsC,EACX,MAAAlB,CACF,CACF,CAAC,EACKmC,EAAKtE,GAAQuE,CAAI,EACvB,GAAID,EACF,OAAOA,EACL,CACE,GAAAvD,EACA,IAAAJ,EACA,MAAO6D,CACT,EACA,GAAG1B,CACL,EAEF,MAAM0B,EAAI,iBAAiB,CAC7B,EACA,GAAI,CACF,OAAOF,EAAGvD,EAAIsB,EAAM5B,EAAQ,OAAW,GAAGqC,CAAI,CAChD,OAAStD,EAAQ,CACf,cAAQ,MAAMA,CAAC,EACTJ,GACJ,CACE,QAAS,CAAE,GAAI2B,EAAG,GAAI,IAAKA,EAAG,OAAQ,EACtC,WAAY,CACV,UAAWsC,EACX,MAAAlB,CACF,EACA,MAAO3C,EAAE,OACX,EACA,mBACF,CACF,CACF,CACF,OAASA,EAAQ,CACf,cAAQ,MAAMA,CAAC,EACTJ,GACJ,CACE,WAAY,CACV,UAAWiE,EACX,MAAAlB,CACF,EACA,MAAO3C,EAAE,OACX,EACA,oBACF,CACF,CACF,EC3bA,IAAMiF,EAAW,IAAI,IACfC,GAAmB,IAAI,IACvBC,GAAkB,IAAI,IACtBC,GAAe,IAAI,IACnBC,GAAY,SAAS,cAAc,KAAK,EAC9CA,GAAU,OAAS,GAEnB,IAAMC,GAAqBC,EAAS,cAAc,EAC5CC,GAAyB,IAAIF,EAAkB,IACxCG,GAAQ,CACnBC,EACAC,EACAC,EAA0B,UACjB,CACT,GACGC,EAAYH,CAAM,GACjBG,EAAYF,CAAU,GACtBD,EAAO,aAAaJ,EAAkB,GACtCK,EAAW,aAAaL,EAAkB,GAC5CI,EAAO,eAAe,QAAQF,EAAsB,EAEpD,OAGF,IAAMM,EAAgB,SAAS,cAAc,KAAK,EAClDA,EAAc,OAAOH,CAAU,EAC/B,SAAS,KAAK,sBAAsB,WAAYN,EAAS,EAGzD,IAAMU,EAAgBL,EAAO,iBAAiB,MAAM,EACpD,OAAW,CAAE,GAAAM,EAAI,QAAAC,CAAQ,IAAKF,EACxBZ,GAAgB,IAAIa,CAAE,EACxBZ,GAAa,IAAIY,CAAE,EAEnBb,GAAgB,IAAIa,EAAIC,CAAO,EAG/BP,aAAkB,SAAWA,EAAO,KAClCP,GAAgB,IAAIO,EAAO,EAAE,EAC/BN,GAAa,IAAIM,EAAO,EAAE,EAE1BP,GAAgB,IAAIO,EAAO,GAAIA,EAAO,OAAO,GAIjDR,GAAiB,MAAM,EACvB,IAAMgB,EAAgBJ,EAAc,iBAAiB,MAAM,EAC3D,OAAW,CAAE,GAAAE,EAAI,QAAAC,CAAQ,IAAKC,EACxBhB,GAAiB,IAAIc,CAAE,EACzBZ,GAAa,IAAIY,CAAE,EACVb,GAAgB,IAAIa,CAAE,IAAMC,GACrCf,GAAiB,IAAIc,CAAE,EAI3B,QAAWA,KAAMZ,GACfF,GAAiB,OAAOc,CAAE,EAG5Bb,GAAgB,MAAM,EACtBC,GAAa,MAAM,EACnBH,EAAS,MAAM,EAEf,IAAMkB,EAASP,IAAS,QAAUF,EAAO,cAAiBA,EAC1DU,GAAsBD,EAAQJ,CAAa,EAC3CK,GAAsBN,EAAeI,CAAa,EAElDG,GACEF,EACAL,EACAF,IAAS,QAAUF,EAAS,KAC5BA,EAAO,WACT,EAEAL,GAAU,OAAO,CACnB,EAMMgB,GAAgB,CACpBC,EACAC,EACAC,EAA8B,KAC9BC,EAAwB,OACf,CAGPH,aAAqB,qBACrBC,aAAqB,sBAGrBD,EAAYA,EAAU,QACtBC,EAAYA,EAAU,SAExBC,IAAmBF,EAAU,WAG7B,QAAWI,KAAYH,EAAU,WAAY,CAE3C,GAAIC,GAAkBA,IAAmBC,EAAU,CACjD,IAAME,EAAYC,GAAcF,EAAUF,EAAgBC,CAAQ,EAClE,GAAIE,EAAW,CAEb,GAAIA,IAAcH,EAAgB,CAChC,IAAIK,EAAsBL,EAE1B,KAAOK,GAAUA,IAAWF,GAAW,CACrC,IAAMG,EAAWD,EACjBA,EAASA,EAAO,YAChBE,GAAWD,CAAQ,CACrB,CACF,CACAE,GAAUL,EAAWD,CAAQ,EAC7BF,EAAiBG,EAAU,YAC3B,QACF,CACF,CAGA,GAAID,aAAoB,SAAWxB,GAAiB,IAAIwB,EAAS,EAAE,EAAG,CAGpE,IAAMO,EAAa,SAAS,eAAeP,EAAS,EAAE,EAMlDQ,EAAUD,EACd,KAAQC,EAAUA,EAAQ,YAAwB,CAChD,IAAMC,EAAQlC,EAAS,IAAIiC,CAAO,EAC9BC,IACFA,EAAM,OAAOT,EAAS,EAAE,EACnBS,EAAM,MACTlC,EAAS,OAAOiC,CAAO,EAG7B,CAEAE,GAAWd,EAAWW,EAAYT,CAAc,EAChDQ,GAAUC,EAAYP,CAAQ,EAC9BF,EAAiBS,EAAW,YAC5B,QACF,CAIA,GAAIhC,EAAS,IAAIyB,CAAQ,EAAG,CAE1B,IAAMW,EAAgB,SAAS,cAC5BX,EAAqB,OACxB,EACAJ,EAAU,aAAae,EAAeb,CAAc,EACpDQ,GAAUK,EAAeX,CAAQ,EACjCF,EAAiBa,EAAc,WACjC,KAAO,CAEL,IAAMC,EAAiB,SAAS,WAAWZ,EAAU,EAAI,EACzDJ,EAAU,aAAagB,EAAgBd,CAAc,EACrDA,EAAiBc,EAAe,WAClC,CACF,CAGA,KAAOd,GAAkBA,IAAmBC,GAAU,CACpD,IAAMK,EAAWN,EACjBA,EAAiBA,EAAe,YAChCO,GAAWD,CAAQ,CACrB,CACF,EAKMF,GAAgB,CACpBW,EACAC,EACAf,IACgB,CAChB,IAAIE,EAAqC,KACrCc,EAAcF,EAAK,YACnBG,EAAwB,EACxBC,EAAqB,EAGnBC,EAAiB3C,EAAS,IAAIsC,CAAI,GAAG,MAAQ,EAE/CV,EAASW,EACb,KAAOX,GAAUA,IAAWJ,GAAU,CAEpC,GAAIoB,GAAYhB,EAAQU,CAAI,EAAG,CAC7B,IAAIO,EAAe,GACbC,EAAS9C,EAAS,IAAI4B,CAAM,EAC5BmB,EAAS/C,EAAS,IAAIsC,CAAI,EAEhC,GAAIS,GAAUD,GACZ,QAAW/B,KAAM+B,EAKf,GAAIC,EAAO,IAAIhC,CAAE,EAAG,CAClB8B,EAAe,GACf,KACF,EAIJ,GAAIA,EACF,OAAOjB,EAKT,GAAI,CAACF,GAAa,CAAC1B,EAAS,IAAI4B,CAAM,EAAG,CAEvC,GAAI,CAACe,EACH,OAAOf,EAGTF,EAAYE,CACd,CACF,CAIA,GADAc,GAAsB1C,EAAS,IAAI4B,CAAM,GAAG,MAAQ,EAChDc,EAAqBC,EAGvB,MAGEjB,IAAc,MAAQc,GAAeI,GAAYhB,EAAQY,CAAW,IAGtEC,IACAD,EAAcA,EAAY,YAKtBC,GAAyB,IAC3Bf,EAAY,SAIhBE,EAASA,EAAO,WAClB,CAEA,OAAOF,GAAa,IACtB,EAGMkB,GAAc,CAACI,EAAeC,IAClCD,EAAQ,WAAaC,EAAQ,UAC5BD,EAAoB,UAAaC,EAAoB,UAIrD,CAAED,EAAoB,IACpBA,EAAoB,KAAQC,EAAoB,IAK/CnB,GAAcQ,GAAqB,CAEvCtC,EAAS,IAAIsC,CAAI,EAEbH,GAAW/B,GAAWkC,EAAM,IAAI,EAEhCA,EAAK,YAAY,YAAYA,CAAI,CACvC,EAKMH,GAEJL,GAAW,KAAK,KAAK1B,GAAU,YAAcA,GAAU,YAAY,EAE/D8C,GAAsB5C,EAAS,eAAe,EAI9CyB,GAAY,CAChBiB,EACAC,IACS,CACT,IAAME,EAAOF,EAAQ,SAIrB,GAAIE,IAAS,EAAsB,CACjC,IAAM1C,EAASuC,EACTI,EAASH,EACf,GACExC,EAAO,aAAaJ,EAAkB,GACtC+C,EAAO,aAAa/C,EAAkB,EAEtC,OAAO2C,EAOPvC,aAAkB,kBAClB2C,aAAkB,kBAClBA,EAAO,OAAS,OAUZA,EAAO,aAAa,OAAO,IAAM3C,EAAO,aAAa,OAAO,IAC9DA,EAAO,MAAQ2C,EAAO,aAAa,OAAO,GAAK,IAGjD3C,aAAkB,qBAClB2C,aAAkB,sBAEdA,EAAO,QAAU3C,EAAO,QAC1BA,EAAO,MAAQ2C,EAAO,OAEpB3C,EAAO,YAAcA,EAAO,WAAW,YAAc2C,EAAO,QAC9D3C,EAAO,WAAW,UAAY2C,EAAO,QAIzC,IAAMC,GACHJ,EAAwB,aAAaC,EAAmB,GAAK,IAC9D,MAAM,GAAG,EAEX,OAAW,CAAE,KAAAI,EAAM,MAAAC,CAAM,IAAKH,EAAO,WAEjC3C,EAAO,aAAa6C,CAAI,IAAMC,GAC9B,CAACF,EAAc,SAASC,CAAI,GAE5B7C,EAAO,aAAa6C,EAAMC,CAAK,EAInC,QAASC,EAAI/C,EAAO,WAAW,OAAS,EAAG+C,GAAK,EAAGA,IAAK,CACtD,GAAM,CAAE,KAAAF,CAAK,EAAI7C,EAAO,WAAW+C,CAAC,EAChC,CAACJ,EAAO,aAAaE,CAAI,GAAK,CAACD,EAAc,SAASC,CAAI,GAC5D7C,EAAO,gBAAgB6C,CAAI,CAE/B,CAEK7C,EAAO,YAAY2C,CAAM,GAC5BhC,GAAcX,EAAQ2C,CAAM,CAEhC,CAEA,OAAID,IAAS,GAAmBA,IAAS,IACnCH,EAAQ,YAAcC,EAAQ,YAChCD,EAAQ,UAAYC,EAAQ,WAIzBD,CACT,EAMM7B,GAAwB,CAC5BsC,EACAC,IACS,CACT,QAAWC,KAAOD,EAChB,GAAIzD,GAAiB,IAAI0D,EAAI,EAAE,EAAG,CAChC,IAAI1B,EAA0B0B,EAE9B,KAAO1B,GAAWA,IAAYwB,GAAM,CAClC,IAAIvB,EAAQlC,EAAS,IAAIiC,CAAO,EAE3BC,IACHA,EAAQ,IAAI,IACZlC,EAAS,IAAIiC,EAASC,CAAK,GAE7BA,EAAM,IAAIyB,EAAI,EAAE,EAChB1B,EAAUA,EAAQ,aACpB,CACF,CAEJ,ECtYA2B,EAAO,CACL,KAAM,OACN,MAAMC,EAAGC,EAAe,CACtBC,EAAa,EACb,GAAI,CACF,OAAOD,EAAG,CACZ,QAAE,CACAE,EAAY,CACd,CACF,CACF,CAAC,ECHDC,EAAO,CACL,KAAM,SACN,MAAMC,EAAGC,EAAYC,EAA6B,CAGhDC,EAAa,EACb,IAAMC,EAASC,EAASH,CAAM,EAC9BI,EAAaF,EAAQ,IAAMH,CAAK,EAChCM,EAAWH,CAAM,EACjBI,EAAY,CACd,CACF,CAAC,ECXDC,EAAO,CACL,KAAM,YACN,MAAMC,EAAGC,EAA6B,CAGpCC,EAAa,EACb,IAAMC,EAASC,EAASH,CAAM,EAC9BI,EAAaF,EAASG,GAAkB,CAACA,CAAQ,EACjDC,EAAWJ,CAAM,EACjBK,EAAY,CACd,CACF,CAAC,ECXD,IAAMC,GAAwB,IAAI,QAE5BC,GAAmB,CAACC,EAAcC,IACtCC,EAAO,CACL,KAAAF,EACA,MAAO,MACL,CAAE,GAAAG,EAAI,IAAAC,EAAK,MAAAC,CAAM,EACjBC,EACA,CACE,SAAAC,EACA,QAASC,EACT,YAAAC,EAAc,OACd,cAAe,CAAE,QAAAC,EAAU,KAAM,QAAAC,EAAU,SAAU,EAAI,CAAC,EAC1D,eAAAC,EAAiB,GACjB,gBAAAC,EAAkB,GAClB,cAAAC,EAAgB,IAChB,YAAAC,EAAc,EACd,eAAAC,EAAiB,IACjB,cAAAC,EAAgB,GAChB,oBAAAC,EAAsB,MACxB,EAAe,CAAC,IACb,CACH,IAAMC,EACJD,aAA+B,gBAC3BA,EACA,IAAI,gBACJE,EAAaF,IAAwB,WAC3C,GAAI,CAACE,EAAY,CACf,IAAMC,EAAgBvB,GAAsB,IAAIK,CAAE,EAC9CkB,IACFA,EAAc,MAAM,EAEpB,MAAM,QAAQ,QAAQ,EAE1B,CAEI,CAACD,GAAc,EAAEF,aAA+B,kBAClDpB,GAAsB,IAAIK,EAAIgB,CAAU,EAG1C,GAAI,CACF,IAAIG,EAAY,IAAM,CAAC,EACvB,GAAI,CACF,GAAI,CAAChB,GAAK,OACR,MAAMD,EAAM,qBAAsB,CAAE,OAAAH,CAAO,CAAC,EAG9C,IAAMqB,GAAsC,CAC1C,OAAQ,iDACR,mBAAoB,EACtB,EACId,IAAgB,SAClBc,GAAe,cAAc,EAAI,oBAEnC,IAAMC,EAAU,OAAO,OAAO,CAAC,EAAGD,GAAgBf,CAAW,EAKvDiB,EAA4B,CAChC,OAAAxB,EACA,QAAAuB,EACA,eAAAZ,EACA,gBAAAC,EACA,cAAAC,EACA,YAAAC,EACA,eAAAC,EACA,cAAAC,EACA,OAAQE,EAAW,OACnB,OAAQ,MAAOO,GAAuB,CAChCA,EAAS,QAAU,KACrBC,GAAcC,GAAOzB,EAAI,CAAE,OAAQuB,EAAS,OAAO,SAAS,CAAE,CAAC,CACnE,EACA,UAAYtB,GAAQ,CAClB,GAAI,CAACA,EAAI,MAAM,WAAW,UAAU,EAAG,OACvC,IAAMyB,EAAOzB,EAAI,MACX0B,EAAyC,CAAC,EAEhD,QAAWC,KAAQ3B,EAAI,KAAK,MAAM;AAAA,CAAI,EAAG,CACvC,IAAM4B,EAAID,EAAK,QAAQ,GAAG,EACpBE,EAAIF,EAAK,MAAM,EAAGC,CAAC,EACnBE,GAAIH,EAAK,MAAMC,EAAI,CAAC,GACxBF,EAAaG,CAAC,IAAM,CAAC,GAAG,KAAKC,EAAC,CAClC,CAEA,IAAMC,EAAU,OAAO,YACrB,OAAO,QAAQL,CAAY,EAAE,IAAI,CAAC,CAACG,EAAGC,CAAC,IAAM,CAACD,EAAGC,EAAE,KAAK;AAAA,CAAI,CAAC,CAAC,CAChE,EAEAP,GAAcE,EAAM1B,EAAIgC,CAAO,CACjC,EACA,QAAU9B,GAAU,CAClB,GAAI+B,GAAe/B,CAAK,EAEtB,MAAMA,EAAM,+BAAgC,CAAE,IAAAC,CAAI,CAAC,EAGjDD,IACF,QAAQ,MAAMA,EAAM,OAAO,EAC3BsB,GAAcU,GAAUlC,EAAI,CAAE,QAASE,EAAM,OAAQ,CAAC,EAE1D,CACF,EAEMiC,GAAc,IAAI,IAAIhC,EAAK,SAAS,OAAO,EAC3CiC,GAAc,IAAI,gBAAgBD,GAAY,MAAM,EAE1D,GAAI7B,IAAgB,OAAQ,CAC1B,IAAM+B,EAAM,KAAK,UAAUC,EAAS,CAAE,QAAA/B,EAAS,QAAAC,CAAQ,CAAC,CAAC,EACrDV,IAAW,MACbsC,GAAY,IAAI,WAAYC,CAAG,EAE/Bf,EAAI,KAAOe,CAEf,SAAW/B,IAAgB,OAAQ,CACjC,IAAMiC,EACJnC,EAAW,SAAS,cAAcA,CAAQ,EAAIJ,EAAG,QAAQ,MAAM,EAEjE,GAAI,CAACuC,EACH,MAAMrC,EAAM,oBAAqB,CAAE,OAAAH,EAAQ,SAAAK,CAAS,CAAC,EAIvD,GAAI,CAACmC,EAAO,cAAc,EAAG,CAC3BA,EAAO,eAAe,EACtBpB,EAAU,EACV,MACF,CAIA,IAAMqB,EAAW,IAAI,SAASD,CAAM,EAChCE,EAAYzC,EAEhB,GAAIA,IAAOuC,GAAUtC,aAAe,YAElCwC,EAAYxC,EAAI,cACX,CAEL,IAAMyC,EAAkBzC,GAAeA,EAAI,eAAe,EAC1DsC,EAAO,iBAAiB,SAAUG,CAAc,EAChDvB,EAAY,IACVoB,EAAO,oBAAoB,SAAUG,CAAc,CACvD,CAGA,GAAID,aAAqB,kBAAmB,CAC1C,IAAM5C,EAAO4C,EAAU,aAAa,MAAM,EACtC5C,GAAM2C,EAAS,OAAO3C,EAAM4C,EAAU,KAAK,CACjD,CAEA,IAAME,EACJJ,EAAO,aAAa,SAAS,IAAM,sBAEhCI,IACHtB,EAAQ,cAAc,EAAI,qCAG5B,IAAMuB,EAAa,IAAI,gBAAgBJ,CAAe,EACtD,GAAI1C,IAAW,MACb,OAAW,CAAC+C,EAAKC,CAAK,IAAKF,EACzBR,GAAY,OAAOS,EAAKC,CAAK,OAEtBH,EACTrB,EAAI,KAAOkB,EAEXlB,EAAI,KAAOsB,CAEf,KACE,OAAM1C,EAAM,0BAA2B,CAAE,OAAAH,EAAQ,YAAAO,CAAY,CAAC,EAGhEkB,GAAcuB,GAAS/C,EAAI,CAAC,CAAC,EAC7BmC,GAAY,OAASC,GAAY,SAAS,EAE1C,GAAI,CACF,MAAMY,GAAiBb,GAAY,SAAS,EAAGnC,EAAIsB,CAAG,CACxD,OAAS2B,EAAQ,CACf,GAAI,CAAChB,GAAegB,CAAC,EACnB,MAAM/C,EAAM,cAAe,CAAE,OAAAJ,EAAQ,IAAAK,EAAK,MAAO8C,EAAE,OAAQ,CAAC,CAMhE,CACF,QAAE,CACAzB,GAAc0B,GAAUlD,EAAI,CAAC,CAAC,EAC9BmB,EAAU,CACZ,CACF,QAAE,CACIxB,GAAsB,IAAIK,CAAE,IAAMgB,GACpCrB,GAAsB,OAAOK,CAAE,CAEnC,CACF,CACF,CAAC,EAEHJ,GAAiB,SAAU,QAAQ,EACnCA,GAAiB,MAAO,KAAK,EAC7BA,GAAiB,QAAS,OAAO,EACjCA,GAAiB,OAAQ,MAAM,EAC/BA,GAAiB,MAAO,KAAK,EAEtB,IAAMmD,GAAU,UACVG,GAAW,WACXzB,GAAQ,QACRS,GAAW,WACXiB,GAAiB,iBAExB3B,GAAgB,CACpBE,EACA1B,EACAgC,IAEA,SAAS,cACP,IAAI,YAAgCoB,EAAsB,CACxD,OAAQ,CAAE,KAAA1B,EAAM,GAAA1B,EAAI,QAAAgC,CAAQ,CAC9B,CAAC,CACH,EAEIC,GAAkBoB,GAAa,GAAGA,CAAG,GAAG,SAAS,mBAAmB,EA+CpEC,GAAW,MACfC,EACAC,IACkB,CAClB,IAAMC,EAASF,EAAO,UAAU,EAC5BG,EAAS,MAAMD,EAAO,KAAK,EAC/B,KAAO,CAACC,EAAO,MACbF,EAAQE,EAAO,KAAK,EACpBA,EAAS,MAAMD,EAAO,KAAK,CAE/B,EAEME,GAAYC,GAA4D,CAC5E,IAAIC,EACAC,EACAC,EACAC,EAAyB,GAG7B,OAAQC,GAAoB,CACrBJ,EAMHA,EAASK,GAAOL,EAAQI,CAAG,GAL3BJ,EAASI,EACTH,EAAW,EACXC,EAAc,IAMhB,IAAMI,EAAYN,EAAO,OACrBO,EAAY,EAChB,KAAON,EAAWK,GAAW,CACvBH,IACEH,EAAOC,CAAQ,IAAM,KAAIM,EAAY,EAAEN,GAC3CE,EAAyB,IAI3B,IAAIK,EAAU,GACd,KAAOP,EAAWK,GAAaE,IAAY,GAAI,EAAEP,EAC/C,OAAQD,EAAOC,CAAQ,EAAG,CACxB,IAAK,IACCC,IAAgB,KAElBA,EAAcD,EAAWM,GAE3B,MAGF,IAAK,IACHJ,EAAyB,GAC3B,IAAK,IACHK,EAAUP,EACV,KACJ,CAGF,GAAIO,IAAY,GAAI,MAGpBT,EAAOC,EAAO,SAASO,EAAWC,CAAO,EAAGN,CAAW,EACvDK,EAAYN,EACZC,EAAc,EAChB,CAEIK,IAAcD,EAChBN,EAAS,OACFO,IAGPP,EAASA,EAAO,SAASO,CAAS,EAClCN,GAAYM,EAEhB,CACF,EAEME,GAAc,CAClBC,EACAC,EACAC,IACsD,CACtD,IAAIC,EAAUC,GAAW,EACnBC,EAAU,IAAI,YAGpB,MAAO,CAAChD,EAAMmC,IAAgB,CAC5B,GAAI,CAACnC,EAAK,OAER6C,IAAYC,CAAO,EACnBA,EAAUC,GAAW,UACZZ,EAAc,EAAG,CAI1B,IAAMc,EAAQD,EAAQ,OAAOhD,EAAK,SAAS,EAAGmC,CAAW,CAAC,EACpDe,EAAcf,GAAenC,EAAKmC,EAAc,CAAC,IAAM,GAAK,EAAI,GAChEjB,EAAQ8B,EAAQ,OAAOhD,EAAK,SAASkD,CAAW,CAAC,EAEvD,OAAQD,EAAO,CACb,IAAK,OACHH,EAAQ,KAAOA,EAAQ,KAAO,GAAGA,EAAQ,IAAI;AAAA,EAAK5B,CAAK,GAAKA,EAC5D,MACF,IAAK,QACH4B,EAAQ,MAAQ5B,EAChB,MACF,IAAK,KACHyB,EAAMG,EAAQ,GAAK5B,CAAM,EACzB,MACF,IAAK,QAAS,CACZ,IAAMiC,EAAQ,CAACjC,EACV,OAAO,MAAMiC,CAAK,GAErBP,EAASE,EAAQ,MAAQK,CAAM,EAEjC,KACF,CACF,CACF,CACF,CACF,EAEMb,GAAS,CAACc,EAAeC,IAAkB,CAC/C,IAAM5C,EAAM,IAAI,WAAW2C,EAAE,OAASC,EAAE,MAAM,EAC9C,OAAA5C,EAAI,IAAI2C,CAAC,EACT3C,EAAI,IAAI4C,EAAGD,EAAE,MAAM,EACZ3C,CACT,EAEMsC,GAAa,KAA2B,CAK5C,KAAM,GACN,MAAO,GACP,GAAI,GACJ,MAAO,MACT,GAkBM3B,GAAmB,CACvBkC,EACAlF,EACA,CACE,OAAQmF,EACR,QAASC,EACT,OAAQC,EACR,UAAAC,EACA,QAAAC,EACA,QAAAC,EACA,eAAA/E,EACA,gBAAAC,EAAkB,GAClB,MAAO+E,EACP,cAAA9E,EAAgB,IAChB,YAAAC,EAAc,EACd,eAAAC,EAAiB,IACjB,cAAAC,EAAgB,GAChB,UAAA4E,EACA,GAAGC,CACL,IAEO,IAAI,QAAc,CAACC,EAASC,IAAW,CAE5C,IAAMxE,EAAkC,CACtC,GAAG+D,CACL,EAEIU,EACEC,GAAqB,IAAM,CAC/BD,EAAqB,MAAM,EACtB,SAAS,QAAQE,EAAO,CAC/B,EAEKvF,GACH,SAAS,iBAAiB,mBAAoBsF,EAAkB,EAGpE,IAAIE,EAAqD,EACjDC,EAAU,IAAM,CACpB,SAAS,oBAAoB,mBAAoBH,EAAkB,EACnE,aAAaE,CAAU,EACvBH,EAAqB,MAAM,CAC7B,EAGAX,GAAa,iBAAiB,QAAS,IAAM,CAC3Ce,EAAQ,EACRN,EAAQ,CACV,CAAC,EAED,IAAMO,GAAQV,GAAc,OAAO,MAC7BW,GAASf,IAAgB,IAAM,CAAC,GAElCgB,EAAU,EACVC,EAAoB3F,EAClBqF,EAAS,SAAY,CACzBF,EAAuB,IAAI,gBAC3B,GAAI,CACF,IAAMvE,EAAW,MAAM4E,GAAMjB,EAAO,CAClC,GAAGS,EACH,QAAAtE,EACA,OAAQyE,EAAqB,MAC/B,CAAC,EAED,MAAMM,GAAO7E,CAAQ,EAErB,IAAMgF,EAAiB,MACrBC,EACAjF,GACA1B,GACA6F,MACGe,KACA,CACH,IAAMzE,GAAkC,CACtC,CAACnC,EAAI,EAAG,MAAM0B,GAAS,KAAK,CAC9B,EACA,QAAWmF,MAAKD,GAAU,CACxB,IAAI1E,GAAIR,GAAS,QAAQ,IAAI,YAAYoF,GAAMD,EAAC,CAAC,EAAE,EACnD,GAAIhB,GAAW,CACb,IAAMkB,GAAKlB,GAAkBgB,EAAC,EAC1BE,KAAG7E,GAAI,OAAO6E,IAAM,SAAWA,GAAI,KAAK,UAAUA,EAAC,EACzD,CACI7E,KAAGC,GAAQ0E,EAAC,EAAI3E,GACtB,CAEAP,GAAcgF,EAAcxG,EAAIgC,EAAO,EACvCkE,EAAQ,EACRN,EAAQ,CACV,EAEMiB,EAAStF,EAAS,OAClBuF,EAAmBD,GAAU,KAAOA,EAAS,IAEnD,GAAIA,IAAW,IAAK,CAElB,GADAtB,IAAU,EACNsB,IAAW,KAAO,CAACC,GAAoBpG,IAAoB,GAAO,CACpE,aAAauF,CAAU,EACvBA,EAAa,WAAWD,EAAQrF,CAAa,EAC7C,MACF,CACAuF,EAAQ,EACRN,EAAQ,EACR,MACF,CAGAS,EAAU,EACV1F,EAAgB2F,EAEhB,IAAMS,GAAKxF,EAAS,QAAQ,IAAI,cAAc,EAC9C,GAAIwF,IAAI,SAAS,WAAW,EAC1B,OAAO,MAAMR,EACX,0BACAhF,EACA,WACAmE,EACA,WACA,OACA,mBACF,EAGF,GAAIqB,IAAI,SAAS,kBAAkB,EACjC,OAAO,MAAMR,EACX,yBACAhF,EACA,UACAmE,EACA,eACF,EAGF,GAAIqB,IAAI,SAAS,iBAAiB,EAAG,CACnC,IAAMC,EAAS,SAAS,cAAc,QAAQ,EACxCC,GAAyB1F,EAAS,QAAQ,IAC9C,4BACF,EAEA,GAAI0F,GACF,OAAW,CAACpH,GAAMiD,EAAK,IAAK,OAAO,QACjC,KAAK,MAAMmE,EAAsB,CACnC,EACED,EAAO,aAAanH,GAAMiD,EAAe,EAG7CkE,EAAO,YAAc,MAAMzF,EAAS,KAAK,EACzC,SAAS,KAAK,YAAYyF,CAAM,EAChCd,EAAQ,EACR,MACF,CAyBA,GAvBA,MAAM5C,GACJ/B,EAAS,KACToC,GACEW,GACG4C,GAAO,CACFA,EAEF7F,EAAQ,eAAe,EAAI6F,EAG3B,OAAO7F,EAAQ,eAAe,CAElC,EACC0D,GAAU,CACTuB,EAAoB3F,EAAgBoE,CACtC,EACAO,CACF,CACF,CACF,EAEAC,IAAU,EAEN7E,GAAmB,CAACoG,EAAkB,CACxC,aAAab,CAAU,EACvBA,EAAa,WAAWD,EAAQrF,CAAa,EAC7C,MACF,CAEAuF,EAAQ,EACRN,EAAQ,CACV,OAASvC,EAAK,CACZ,GAAI,CAACyC,EAAqB,OAAO,QAE/B,GAAI,CAEF,IAAMqB,EAAgB3B,IAAUnC,CAAG,GAAK1C,EACxC,aAAasF,CAAU,EACvBA,EAAa,WAAWD,EAAQmB,CAAQ,EACxCxG,EAAgB,KAAK,IACnBA,EAAgBC,EAChBC,CACF,EACI,EAAEwF,GAAWvF,GACfU,GAAc2B,GAAgBnD,EAAI,CAAC,CAAC,EAEpCkG,EAAQ,EACRL,EAAO,sBAAsB,GAE7B,QAAQ,MACN,4BAA4BX,EAAM,SAAS,CAAC,gBAAgBiC,CAAQ,KACtE,CAEJ,OAASC,EAAU,CAEjBlB,EAAQ,EACRL,EAAOuB,CAAQ,CACjB,CAEJ,CACF,EAEApB,EAAO,CACT,CAAC,ECpoBHqB,EAAU,CACR,KAAM,OACN,YAAa,CAAE,MAAO,MAAO,EAC7B,aAAc,GACd,MAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,GAAAC,CAAG,EAAG,CACrB,IAAMC,EAAW,CAACF,EAAaG,IAAa,CACtCA,IAAQ,IAAMA,IAAQ,GACxBJ,EAAG,aAAaC,EAAK,EAAE,EACdG,IAAQ,IAASA,GAAO,KACjCJ,EAAG,gBAAgBC,CAAG,EACb,OAAOG,GAAQ,SACxBJ,EAAG,aAAaC,EAAKG,CAAG,EAExBJ,EAAG,aAAaC,EAAK,KAAK,UAAUG,CAAG,CAAC,CAE5C,EAEMC,EAASJ,EACX,IAAM,CACJK,EAAS,WAAW,EACpB,IAAMF,EAAMF,EAAG,EACfC,EAASF,EAAKG,CAAG,EACjBE,EAAS,QAAQN,EAAI,CACnB,gBAAiB,CAACC,CAAG,CACvB,CAAC,CACH,EACA,IAAM,CACJK,EAAS,WAAW,EACpB,IAAMC,EAAML,EAAG,EACTM,EAAkB,OAAO,KAAKD,CAAG,EACvC,QAAWN,KAAOO,EAChBL,EAASF,EAAKM,EAAIN,CAAG,CAAC,EAExBK,EAAS,QAAQN,EAAI,CACnB,gBAAAQ,CACF,CAAC,CACH,EAEEF,EAAW,IAAI,iBAAiBD,CAAM,EACtCI,EAAUC,EAAOL,CAAM,EAE7B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBG,EAAQ,CACV,CACF,CACF,CAAC,ECtCD,IAAME,GAAe,+CACfC,GAAQ,OAAO,OAAO,EAEtBC,GAAcC,EAAS,MAAM,EAEnCC,EAAU,CACR,KAAM,OACN,YAAa,YACb,MAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,MAAAC,EAAO,MAAAC,CAAM,EAAG,CACrC,IAAMC,EAAaJ,GAAO,KAAOK,EAAaL,EAAKC,CAAI,EAAIC,EAEvDI,EAAM,CAACP,EAASQ,IAClBA,IAAS,SAAW,CAACR,EAAG,MAAQA,EAAG,MAEjCS,EAAON,GAAe,CACtBH,EAAwB,MAAQ,GAAGG,CAAK,EAC5C,EAEA,GAAIH,aAAc,iBAChB,OAAQA,EAAG,KAAM,CACf,IAAK,QACL,IAAK,SACHO,EAAM,CAACP,EAASQ,IACdA,IAAS,SAAWR,EAAG,MAAQ,CAACA,EAAG,MACrC,MAEF,IAAK,WACHO,EAAM,CAACP,EAAsBQ,IACvBR,EAAG,QAAU,KACXQ,IAAS,UACJR,EAAG,QAEHA,EAAG,QAAUA,EAAG,MAAQ,GAG7BQ,IAAS,SACJR,EAAG,QAAUA,EAAG,MAAQ,GAExBA,EAAG,QAIhBS,EAAON,GAA4B,CACjCH,EAAG,QAAU,OAAOG,GAAU,SAAWA,IAAUH,EAAG,MAAQG,CAChE,EACA,MAEF,IAAK,QAEEH,EAAG,aAAa,MAAM,GAAG,QAC5BA,EAAG,aAAa,OAAQK,CAAU,EAGpCE,EAAM,CAACP,EAAsBQ,IAC3BR,EAAG,QAAWQ,IAAS,SAAW,CAACR,EAAG,MAAQA,EAAG,MAASJ,GAC5Da,EAAON,GAA2B,CAChCH,EAAG,QACDG,KAAW,OAAOA,GAAU,SAAW,CAACH,EAAG,MAAQA,EAAG,MAC1D,EACA,MACF,IAAK,OAAQ,CACX,IAAMU,EAAa,IAAM,CACvB,IAAMC,EAAQ,CAAC,GAAIX,EAAG,OAAS,CAAC,CAAE,EAC5BY,EAA4B,CAAC,EACnC,QAAQ,IACND,EAAM,IACHE,GACC,IAAI,QAAeC,GAAY,CAC7B,IAAMC,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAM,CACpB,GAAI,OAAOA,EAAO,QAAW,SAC3B,MAAMX,EAAM,wBAAyB,CACnC,WAAY,OAAOW,EAAO,MAC5B,CAAC,EAEH,IAAMC,EAAQD,EAAO,OAAO,MAAMpB,EAAY,EAC9C,GAAI,CAACqB,GAAO,OACV,MAAMZ,EAAM,iBAAkB,CAC5B,OAAQW,EAAO,MACjB,CAAC,EAEHH,EAAY,KAAK,CACf,KAAMC,EAAE,KACR,SAAUG,EAAM,OAAO,SACvB,KAAMA,EAAM,OAAO,IACrB,CAAC,CACH,EACAD,EAAO,UAAY,IAAMD,EAAQ,EACjCC,EAAO,cAAcF,CAAC,CACxB,CAAC,CACL,CACF,EAAE,KAAK,IAAM,CACXI,EAAW,CAAC,CAACZ,EAAYO,CAAW,CAAC,CAAC,CACxC,CAAC,CACH,EAEA,OAAAZ,EAAG,iBAAiB,SAAUU,CAAU,EACxCV,EAAG,iBAAiB,QAASU,CAAU,EAEhC,IAAM,CACXV,EAAG,oBAAoB,SAAUU,CAAU,EAC3CV,EAAG,oBAAoB,QAASU,CAAU,CAC5C,CACF,CACF,SACSV,aAAc,mBACvB,GAAIA,EAAG,SAAU,CACf,IAAMkB,EAAU,IAAI,IACpBX,EAAOP,GACL,CAAC,GAAGA,EAAG,eAAe,EAAE,IAAKmB,GAAW,CACtC,IAAMX,EAAOU,EAAQ,IAAIC,EAAO,KAAK,EACrC,OAAOX,IAAS,UAAYA,GAAQ,KAChCW,EAAO,MACP,CAACA,EAAO,KACd,CAAC,EAEHV,EAAON,GAA+B,CACpC,QAAWgB,KAAUnB,EAAG,QAClBG,EAAM,SAASgB,EAAO,KAAK,GAC7BD,EAAQ,IAAIC,EAAO,MAAO,QAAQ,EAClCA,EAAO,SAAW,IACThB,EAAM,SAAS,CAACgB,EAAO,KAAK,GACrCD,EAAQ,IAAIC,EAAO,MAAO,QAAQ,EAClCA,EAAO,SAAW,IAElBA,EAAO,SAAW,EAGxB,CACF,OACSnB,aAAc,sBAIvBO,EAAOP,GACL,UAAWA,EAAKA,EAAG,MAAQA,EAAG,aAAa,OAAO,EACpDS,EAAON,GAAe,CAChB,UAAWH,EACbA,EAAG,MAAQG,EAEXH,EAAG,aAAa,QAASG,CAAK,CAElC,GAGF,IAAMiB,EAAeC,GAAQhB,CAAU,EACjCG,EAAO,OAAOY,EAEhBE,EAAOjB,EACX,GACE,MAAM,QAAQe,CAAY,GAC1B,EAAEpB,aAAc,mBAAqBA,EAAG,UACxC,CACA,IAAMuB,EAAkBtB,GAAYE,EAC9BqB,EAAS,SAAS,iBACtB,IAAI3B,EAAW,MAAM,IAAI,OAAO0B,CAAe,CAAC,MAAM1B,EAAW,KAAK,IAAI,OAAO0B,CAAe,CAAC,IACnG,EAEME,EAAe,CAAC,EAClBC,EAAI,EACR,QAAWC,KAASH,EAAQ,CAG1B,GAFAC,EAAM,KAAK,CAAC,GAAGH,CAAI,IAAII,CAAC,GAAInB,EAAIoB,EAAO,MAAM,CAAC,CAAC,EAE3C3B,IAAO2B,EACT,MAEFD,GACF,CACAT,EAAWQ,EAAO,CAAE,UAAW,EAAK,CAAC,EACrCH,EAAO,GAAGA,CAAI,IAAII,CAAC,EACrB,MACET,EAAW,CAAC,CAACK,EAAMf,EAAIP,EAAIQ,CAAI,CAAC,CAAC,EAAG,CAClC,UAAW,EACb,CAAC,EAGH,IAAME,EAAa,IAAM,CACvB,IAAMkB,EAAcP,GAAQC,CAAI,EAChC,GAAIM,GAAe,KAAM,CACvB,IAAMzB,EAAQI,EAAIP,EAAI,OAAO4B,CAAW,EACpCzB,IAAUP,IACZqB,EAAW,CAAC,CAACK,EAAMnB,CAAK,CAAC,CAAC,CAE9B,CACF,EAEAH,EAAG,iBAAiB,QAASU,CAAU,EACvCV,EAAG,iBAAiB,SAAUU,CAAU,EACxC,IAAMmB,EAAUC,EAAO,IAAM,CAC3BrB,EAAIY,GAAQC,CAAI,CAAC,CACnB,CAAC,EAED,MAAO,IAAM,CACXO,EAAQ,EACR7B,EAAG,oBAAoB,QAASU,CAAU,EAC1CV,EAAG,oBAAoB,SAAUU,CAAU,CAC7C,CACF,CACF,CAAC,EC7MDqB,EAAU,CACR,KAAM,QACN,YAAa,CACX,MAAO,MACT,EACA,aAAc,GACd,MAAM,CAAE,IAAAC,EAAK,GAAAC,EAAI,KAAAC,EAAM,GAAAC,CAAG,EAAG,CACvBH,IACFA,EAAMI,EAAaJ,EAAKE,EAAM,OAAO,GAGvC,IAAMG,EAAW,IAAM,CACrBC,EAAS,WAAW,EAEpB,IAAMC,EAAUP,EACZ,CAAE,CAACA,CAAG,EAAGG,EAAG,CAAa,EACxBA,EAAG,EAER,QAAWK,KAAKD,EAAS,CACvB,IAAME,EAAaD,EAAE,MAAM,KAAK,EAAE,OAAQE,GAAOA,EAAG,OAAS,CAAC,EAC9D,GAAIH,EAAQC,CAAC,EACX,QAAWG,KAAQF,EACZR,EAAG,UAAU,SAASU,CAAI,GAC7BV,EAAG,UAAU,IAAIU,CAAI,MAIzB,SAAWA,KAAQF,EACbR,EAAG,UAAU,SAASU,CAAI,GAC5BV,EAAG,UAAU,OAAOU,CAAI,CAIhC,CAEAL,EAAS,QAAQL,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACrD,EAEMK,EAAW,IAAI,iBAAiBD,CAAQ,EACxCO,EAAUC,EAAOR,CAAQ,EAE/B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBM,EAAQ,EAER,IAAML,EAAUP,EACZ,CAAE,CAACA,CAAG,EAAGG,EAAG,CAAa,EACxBA,EAAG,EAER,QAAWK,KAAKD,EAAS,CACvB,IAAME,EAAaD,EAAE,MAAM,KAAK,EAAE,OAAQE,GAAOA,EAAG,OAAS,CAAC,EAC9D,QAAWC,KAAQF,EACjBR,EAAG,UAAU,OAAOU,CAAI,CAE5B,CACF,CACF,CACF,CAAC,ECxDDG,EAAU,CACR,KAAM,WACN,YAAa,CACX,MAAO,MACT,EACA,aAAc,GACd,MAAM,CAAE,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,MAAAC,CAAM,EAAG,CAC9B,GAAIH,EACFI,EAAW,CAAC,CAACC,EAAaL,EAAKC,CAAI,EAAGK,GAASJ,CAAE,CAAC,CAAC,CAAC,MAC/C,CACL,IAAMK,EAAQ,OAAO,OAAO,CAAC,EAAGL,EAAG,CAA8B,EACjEM,EAAaD,EAAQE,GAAQ,CAC3B,GAAI,OAAOA,GAAQ,WACjB,OAAOH,GAASG,CAAG,EAEnB,MAAMN,EAAM,0BAA0B,CAE1C,CAAC,EACDO,EAAWH,CAAK,CAClB,CACF,CACF,CAAC,ECvBDI,EAAU,CACR,KAAM,SACN,YAAa,CACX,IAAK,SACL,MAAO,MACT,EACA,MAAO,CAAC,CAAE,GAAAC,CAAG,IAAMC,EAAOD,CAAE,CAC9B,CAAC,ECHDE,EAAU,CACR,KAAM,YACN,YAAa,YACb,MAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,MAAAC,CAAM,EAAG,CAC9B,IAAMC,EAAaH,GAAO,KAAOI,EAAaJ,EAAKC,CAAI,EAAIC,EAE3DG,EAAW,CAAC,CAACF,EAAY,EAAK,CAAC,CAAC,EAEhC,IAAMG,EAAYC,GAA2C,CAC3D,GAAM,CAAE,KAAAC,EAAM,GAAIC,CAAI,EAAIF,EAAM,OAChC,GAAIE,IAAQV,EAGZ,OAAQS,EAAM,CACZ,KAAKE,GACHL,EAAW,CAAC,CAACF,EAAY,EAAI,CAAC,CAAC,EAC/B,MACF,KAAKQ,GACHN,EAAW,CAAC,CAACF,EAAY,EAAK,CAAC,CAAC,EAChC,KACJ,CACF,EACA,gBAAS,iBAAiBS,EAAsBN,CAAO,EAChD,IAAM,CACXD,EAAW,CAAC,CAACF,EAAY,EAAK,CAAC,CAAC,EAChC,SAAS,oBAAoBS,EAAsBN,CAAO,CAC5D,CACF,CACF,CAAC,EC9BDO,EAAU,CACR,KAAM,eACN,YAAa,CACX,IAAK,QACP,EACA,MAAM,CAAE,GAAAC,EAAI,MAAAC,EAAO,KAAAC,CAAK,EAAG,CACzB,IAAMC,EAASD,EAAK,IAAI,OAAO,EAAI,EAAI,EACnCE,EAA+B,CAAC,EAChCH,IACFG,EAAUC,GAAcJ,CAAK,GAG/B,IAAMK,EAAW,IAAM,CACrBC,EAAS,WAAW,EACpBP,EAAG,YAAc,KAAK,UAAUQ,EAASJ,CAAO,EAAG,KAAMD,CAAM,EAC/DI,EAAS,QAAQP,EAAI,CACnB,UAAW,GACX,cAAe,GACf,QAAS,EACX,CAAC,CACH,EACMO,EAAW,IAAI,iBAAiBD,CAAQ,EACxCG,EAAUC,EAAOJ,CAAQ,EAE/B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBE,EAAQ,CACV,CACF,CACF,CAAC,ECtCM,IAAME,EAAWC,GAAsB,CAC5C,GAAI,CAACA,GAAQA,EAAK,MAAQ,EAAG,MAAO,GACpC,QAAWC,KAAOD,EAAM,CACtB,GAAIC,EAAI,SAAS,IAAI,EACnB,MAAO,CAACA,EAAI,QAAQ,KAAM,EAAE,EAE9B,GAAIA,EAAI,SAAS,GAAG,EAClB,MAAO,CAACA,EAAI,QAAQ,IAAK,EAAE,EAAI,IAEjC,GAAI,CACF,OAAO,OAAO,WAAWA,CAAG,CAC9B,MAAY,CAAC,CACf,CACA,MAAO,EACT,EAEaC,GAAS,CACpBC,EACAC,EACAC,EAAe,KAEVF,EACEA,EAAK,IAAIC,EAAI,YAAY,CAAC,EADfC,EClBb,IAAMC,GAAQ,CACnBC,EACAC,IAEO,IAAIC,IAAgB,CACzB,WAAW,IAAM,CACfF,EAAS,GAAGE,CAAI,CAClB,EAAGD,CAAI,CACT,EAGWE,GAAW,CACtBH,EACAC,EACAG,EAAU,GACVC,EAAW,KACc,CACzB,IAAIC,EAAQ,EACZ,MAAO,IAAIJ,IAAgB,CACzBI,GAAS,aAAaA,CAAK,EAEvBF,GAAW,CAACE,GACdN,EAAS,GAAGE,CAAI,EAGlBI,EAAQ,WAAW,IAAM,CACnBD,GACFL,EAAS,GAAGE,CAAI,EAElBI,GAAS,aAAaA,CAAK,EAC3BA,EAAQ,CACV,EAAGL,CAAI,CACT,CACF,EAEaM,GAAW,CACtBP,EACAC,EACAG,EAAU,GACVC,EAAW,KACc,CACzB,IAAIG,EAAU,GAEd,MAAO,IAAIN,IAAgB,CACrBM,IAEAJ,GACFJ,EAAS,GAAGE,CAAI,EAGlBM,EAAU,GACV,WAAW,IAAM,CACXH,GACFL,EAAS,GAAGE,CAAI,EAElBM,EAAU,EACZ,EAAGP,CAAI,EACT,CACF,EAEaQ,GAAe,CAC1BT,EACAU,IACyB,CACzB,IAAMC,EAAYD,EAAK,IAAI,OAAO,EAClC,GAAIC,EAAW,CACb,IAAMV,EAAOW,EAAQD,CAAS,EAC9BX,EAAWD,GAAMC,EAAUC,CAAI,CACjC,CAEA,IAAMY,EAAeH,EAAK,IAAI,UAAU,EACxC,GAAIG,EAAc,CAChB,IAAMZ,EAAOW,EAAQC,CAAY,EAC3BT,EAAUU,GAAOD,EAAc,UAAW,EAAK,EAC/CR,EAAW,CAACS,GAAOD,EAAc,aAAc,EAAK,EAC1Db,EAAWG,GAASH,EAAUC,EAAMG,EAASC,CAAQ,CACvD,CAEA,IAAMU,EAAeL,EAAK,IAAI,UAAU,EACxC,GAAIK,EAAc,CAChB,IAAMd,EAAOW,EAAQG,CAAY,EAC3BX,EAAU,CAACU,GAAOC,EAAc,YAAa,EAAK,EAClDV,EAAWS,GAAOC,EAAc,WAAY,EAAK,EACvDf,EAAWO,GAASP,EAAUC,EAAMG,EAASC,CAAQ,CACvD,CAEA,OAAOL,CACT,ECxFO,IAAMgB,GAA0B,CAAC,CAAC,SAAS,oBAErCC,EAAuB,CAClCC,EACAC,IACyB,CACzB,GAAIA,EAAK,IAAI,gBAAgB,GAAKH,GAAyB,CACzD,IAAMI,EAAKF,EACXA,EAAW,IAAIG,IACb,SAAS,oBAAoB,IAAMD,EAAG,GAAGC,CAAI,CAAC,CAClD,CAEA,OAAOH,CACT,ECDAI,EAAU,CACR,KAAM,KACN,YAAa,OACb,SAAU,CAAC,KAAK,EAChB,MAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,GAAAC,CAAG,EAAG,CAC3B,IAAIC,EAAsCJ,EACtCE,EAAK,IAAI,QAAQ,IAAGE,EAAS,QACjC,IAAIC,EAAYC,GAAgB,CAC1BA,IACEJ,EAAK,IAAI,SAAS,GACpBI,EAAI,eAAe,EAEjBJ,EAAK,IAAI,MAAM,GACjBI,EAAI,gBAAgB,GAGxBC,EAAW,EACXJ,EAAGG,CAAG,EACNE,EAAS,CACX,EACAH,EAAWI,EAAqBJ,EAAUH,CAAI,EAC9CG,EAAWK,GAAaL,EAAUH,CAAI,EACtC,IAAMS,EAAuC,CAC3C,QAAST,EAAK,IAAI,SAAS,EAC3B,QAASA,EAAK,IAAI,SAAS,EAC3B,KAAMA,EAAK,IAAI,MAAM,CACvB,EACA,GAAIA,EAAK,IAAI,SAAS,EAAG,CACvBE,EAAS,SACT,IAAMQ,EAAKP,EACXA,EAAYC,GAAgB,CACrBN,EAAG,SAASM,GAAK,MAAqB,GACzCM,EAAGN,CAAG,CAEV,CACF,CACA,IAAMO,EAAYC,EAAab,EAAKC,EAAM,OAAO,EASjD,IANEW,IAAcE,GACdF,IAAcG,KAEdZ,EAAS,UAGPJ,aAAc,iBAAmBa,IAAc,SAAU,CAC3D,IAAMD,EAAKP,EACXA,EAAYC,GAAgB,CAC1BA,GAAK,eAAe,EACpBM,EAAGN,CAAG,CACR,CACF,CACA,OAAAF,EAAO,iBAAiBS,EAAWR,EAAUM,CAAW,EACjD,IAAM,CACXP,EAAO,oBAAoBS,EAAWR,CAAQ,CAChD,CACF,CACF,CAAC,EC7DD,IAAMY,GAAO,IAAI,QAEjBC,EAAU,CACR,KAAM,eACN,YAAa,CACX,IAAK,SACL,MAAO,MACT,EACA,MAAM,CAAE,GAAAC,EAAI,KAAAC,EAAM,GAAAC,CAAG,EAAG,CACtB,IAAIC,EAAW,IAAM,CACnBC,EAAW,EACXF,EAAG,EACHG,EAAS,CACX,EACAF,EAAWG,EAAqBH,EAAUF,CAAI,EAC9CE,EAAWI,GAAaJ,EAAUF,CAAI,EACtC,IAAMO,EAAU,CAAE,UAAW,CAAE,EAC3BP,EAAK,IAAI,MAAM,EACjBO,EAAQ,UAAY,EACXP,EAAK,IAAI,MAAM,IACxBO,EAAQ,UAAY,IAEtB,IAAIC,EAAwC,IAAI,qBAC7CC,GAAY,CACX,QAAWC,KAASD,EACdC,EAAM,iBACRR,EAAS,EACLM,GAAYX,GAAK,IAAIE,CAAE,GACzBS,EAAS,WAAW,EAI5B,EACAD,CACF,EACA,OAAAC,EAAS,QAAQT,CAAE,EACfC,EAAK,IAAI,MAAM,GACjBH,GAAK,IAAIE,CAAE,EAEN,IAAM,CACNC,EAAK,IAAI,MAAM,GAClBH,GAAK,OAAOE,CAAE,EAEZS,IACFA,EAAS,WAAW,EACpBA,EAAW,KAEf,CACF,CACF,CAAC,EClDDG,EAAU,CACR,KAAM,cACN,YAAa,CACX,IAAK,SACL,MAAO,MACT,EACA,MAAM,CAAE,KAAAC,EAAM,GAAAC,CAAG,EAAG,CAClB,IAAIC,EAAW,IAAM,CACnBC,EAAW,EACXF,EAAG,EACHG,EAAS,CACX,EACAF,EAAWG,EAAqBH,EAAUF,CAAI,EAC9C,IAAIM,EAAW,IACTC,EAAeP,EAAK,IAAI,UAAU,EACpCO,IACFD,EAAWE,EAAQD,CAAY,EACfE,GAAOF,EAAc,UAAW,EAAK,GAEnDL,EAAS,GAGb,IAAMQ,EAAa,YAAYR,EAAUI,CAAQ,EACjD,MAAO,IAAM,CACX,cAAcI,CAAU,CAC1B,CACF,CACF,CAAC,EC1BDC,EAAU,CACR,KAAM,OACN,YAAa,CACX,IAAK,SACL,MAAO,MACT,EACA,MAAM,CAAE,GAAAC,EAAI,KAAAC,CAAK,EAAG,CAClB,IAAIC,EAAW,IAAM,CACnBC,EAAW,EACXH,EAAG,EACHI,EAAS,CACX,EACAF,EAAWG,EAAqBH,EAAUD,CAAI,EAC9C,IAAIK,EAAO,EACLC,EAAYN,EAAK,IAAI,OAAO,EAC9BM,IACFD,EAAOE,EAAQD,CAAS,EACpBD,EAAO,IACTJ,EAAWO,GAAMP,EAAUI,CAAI,IAGnCJ,EAAS,CACX,CACF,CAAC,ECrBDQ,EAAU,CACR,KAAM,kBACN,YAAa,CACX,MAAO,MACT,EACA,SAAU,CAAC,OAAO,EAClB,aAAc,GACd,MAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,MAAAC,CAAM,EAAG,CAClC,GAAMH,GAAOA,IAAQ,SACnB,MAAMG,EAAM,eAAe,EAI7B,IAAMC,EAAaL,EAAG,aAAa,6BAA6B,EAC5DM,EAA+B,CAAC,EAChCD,IACFC,EAAUC,GAAcF,CAAU,GAGpC,IAAMG,EAA0BC,GAC7BC,GAAgC,CAC/B,IAAMC,EAAUC,EAASN,EAASI,EAAI,MAAM,EACvCG,GAAQF,CAAO,IAClBG,EAAW,EACXX,EAAGQ,CAAO,EACVI,EAAS,EAEb,EACAb,CACF,EAEA,gBAAS,iBAAiBc,EAA6BR,CAAQ,EACxD,IAAM,CACX,SAAS,oBAAoBQ,EAA6BR,CAAQ,CACpE,CACF,CACF,CAAC,ECxCDS,EAAU,CACR,KAAM,MACN,YAAa,YACb,MAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,MAAAC,CAAM,EAAG,CAC9B,IAAMC,EAAaH,GAAO,KAAOI,EAAaJ,EAAKC,CAAI,EAAIC,EAC3DG,EAAW,CAAC,CAACF,EAAYJ,CAAE,CAAC,CAAC,CAC/B,CACF,CAAC,ECRD,IAAMO,GAAO,OACPC,GAAU,UAEhBC,EAAU,CACR,KAAM,OACN,YAAa,CACX,IAAK,SACL,MAAO,MACT,EACA,aAAc,GACd,MAAM,CAAE,GAAAC,EAAI,GAAAC,CAAG,EAAG,CAChB,IAAMC,EAAS,IAAM,CACnBC,EAAS,WAAW,EACDF,EAAG,EAEhBD,EAAG,MAAM,UAAYH,IAAMG,EAAG,MAAM,eAAeF,EAAO,EAE9DE,EAAG,MAAM,YAAYF,GAASD,EAAI,EAEpCM,EAAS,QAAQH,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACrD,EACMG,EAAW,IAAI,iBAAiBD,CAAM,EACtCE,EAAUC,EAAOH,CAAM,EAE7B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBC,EAAQ,CACV,CACF,CACF,CAAC,EC5BDE,EAAU,CACR,KAAM,UACN,aAAc,GACd,MAAM,CAAE,IAAAC,EAAK,KAAAC,EAAM,GAAAC,CAAG,EAAG,CACvB,IAAMC,EAAYF,EAAK,IAAI,WAAW,EAEtC,GAAID,EACFA,EAAMI,EAAaJ,EAAKC,CAAI,EAC5BI,EAAW,CAAC,CAACL,EAAKE,IAAK,CAAC,CAAC,EAAG,CAAE,UAAAC,CAAU,CAAC,MACpC,CACL,IAAMG,EAAQ,OAAO,OAAO,CAAC,EAAGJ,IAAK,CAAwB,EAC7DK,EAAWD,EAAO,CAAE,UAAAH,CAAU,CAAC,CACjC,CACF,CACF,CAAC,ECdDK,EAAU,CACR,KAAM,QACN,YAAa,CACX,MAAO,MACT,EACA,aAAc,GACd,MAAM,CAAE,IAAAC,EAAK,GAAAC,EAAI,GAAAC,CAAG,EAAG,CACrB,GAAM,CAAE,MAAAC,CAAM,EAAIF,EACZG,EAAgB,IAAI,IAEpBC,EAAQ,CAACC,EAAcC,IAAe,CAC1C,IAAMC,EAAUJ,EAAc,IAAIE,CAAI,EAClC,CAACC,GAASA,IAAU,EACtBC,IAAY,SACTA,EACGL,EAAM,YAAYG,EAAME,CAAO,EAC/BL,EAAM,eAAeG,CAAI,IAE/BE,IAAY,QACVJ,EAAc,IAAIE,EAAMH,EAAM,iBAAiBG,CAAI,CAAC,EACtDH,EAAM,YAAYG,EAAM,OAAOC,CAAK,CAAC,EAEzC,EAEME,EAAS,IAAM,CAGnB,GAFAC,EAAS,WAAW,EAEhBV,EACFK,EAAML,EAAKE,EAAG,CAAC,MACV,CACL,IAAMS,EAAST,EAAG,EAElB,OAAW,CAACI,EAAME,CAAO,IAAKJ,EAC5BE,KAAQK,IACLH,EACGL,EAAM,YAAYG,EAAME,CAAO,EAC/BL,EAAM,eAAeG,CAAI,GAGjC,QAAWA,KAAQK,EACjBN,EAAMO,GAAMN,CAAI,EAAGK,EAAOL,CAAI,CAAC,CAEnC,CAEAI,EAAS,QAAQT,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACrD,EAEMS,EAAW,IAAI,iBAAiBD,CAAM,EACtCI,EAAUC,EAAOL,CAAM,EAE7B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBG,EAAQ,EACR,OAAW,CAACP,EAAME,CAAO,IAAKJ,EAC5BI,EAAUL,EAAM,YAAYG,EAAME,CAAO,EAAIL,EAAM,eAAeG,CAAI,CAE1E,CACF,CACF,CAAC,EC3DDS,EAAU,CACR,KAAM,OACN,YAAa,CACX,IAAK,SACL,MAAO,MACT,EACA,aAAc,GACd,MAAM,CAAE,GAAAC,EAAI,GAAAC,CAAG,EAAG,CAChB,IAAMC,EAAS,IAAM,CACnBC,EAAS,WAAW,EACpBH,EAAG,YAAc,GAAGC,EAAG,CAAC,GACxBE,EAAS,QAAQH,EAAI,CACnB,UAAW,GACX,cAAe,GACf,QAAS,EACX,CAAC,CACH,EAEMG,EAAW,IAAI,iBAAiBD,CAAM,EACtCE,EAAUC,EAAOH,CAAM,EAE7B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBC,EAAQ,CACV,CACF,CACF,CAAC,ECPDE,GAAQ,CACN,KAAM,0BACN,MACEC,EACA,CAAE,SAAAC,EAAW,GAAI,SAAAC,EAAW,GAAI,KAAAC,EAAO,QAAS,kBAAAC,CAAkB,EAClE,CACA,OAAQD,EAAM,CACZ,IAAK,SACL,IAAK,QACL,IAAK,QACL,IAAK,UACL,IAAK,UACL,IAAK,SACL,IAAK,SACL,IAAK,QACH,MACF,QACE,MAAMH,EAAI,MAAM,2BAA4B,CAAE,KAAAG,CAAK,CAAC,CACxD,CAEA,GAAI,CAACD,GAAYC,IAAS,SAAWA,IAAS,UAC5C,MAAMH,EAAI,MAAM,+BAA+B,EAGjD,IAAMK,EAA2B,CAC/B,KAAAF,EACA,SAAAD,EACA,SAAAD,EACA,kBAAmBG,GAAmB,KAAK,IAAM,MACnD,EAEIE,IAA2BF,EAC7B,SAAS,oBAAoB,IAAMG,GAAgBP,EAAKK,CAAK,CAAC,EAE9DE,GAAgBP,EAAKK,CAAK,CAE9B,CACF,CAAC,EAED,IAAME,GAAkB,CACtB,CAAE,MAAAC,CAAM,EACR,CAAE,SAAAP,EAAU,SAAAC,EAAU,KAAAC,CAAK,IACxB,CACH,IAAMM,EAA0BR,EAAS,QACvC,uCACA,EACF,EACMS,EAAU,WAAW,KAAKD,CAAuB,EACjDE,EAAU,WAAW,KAAKF,CAAuB,EACjDG,EAAU,WAAW,KAAKH,CAAuB,EAEjDI,EAAc,IAAI,UAAU,EAAE,gBAClCH,GAAWC,GAAWC,EAClBX,EACA,mBAAmBA,CAAQ,qBAC/B,WACF,EAEIa,EAAa,SAAS,uBAAuB,EAcjD,GAbIJ,EACFI,EAAW,YAAYD,EAAY,eAAe,EACzCF,GAAWC,GACpBE,EAAW,YAAYD,EAAY,IAAI,EACvCC,EAAW,YAAYD,EAAY,IAAI,GAC9BF,EACTG,EAAW,YAAYD,EAAY,IAAI,EAC9BD,EACTE,EAAW,YAAYD,EAAY,IAAI,EAEvCC,EAAaD,EAAY,cAAc,UAAU,EAAG,QAGlD,CAACX,IAAaC,IAAS,SAAWA,IAAS,WAC7C,QAAWY,KAASD,EAAW,SAAU,CACvC,IAAIE,EACJ,GAAID,aAAiB,gBACnBC,EAAS,SAAS,wBACTD,aAAiB,gBAC1BC,EAAS,SAAS,aACTD,aAAiB,gBAC1BC,EAAS,SAAS,aAElBA,EAAS,SAAS,eAAeD,EAAM,EAAE,EACrC,CAACC,EAAQ,CACX,QAAQ,KAAKR,EAAM,6BAA6B,EAAG,CACjD,QAAS,CAAE,GAAIO,EAAM,EAAG,CAC1B,CAAC,EACD,QACF,CAGFE,GAAed,EAA2BY,EAAO,CAACC,CAAM,CAAC,CAC3D,KACK,CACL,IAAME,EAAU,SAAS,iBAAiBhB,CAAQ,EAClD,GAAI,CAACgB,EAAQ,OAAQ,CACnB,QAAQ,KAAKV,EAAM,6BAA6B,EAAG,CAAE,SAAAN,CAAS,CAAC,EAC/D,MACF,CAEAe,GAAed,EAA2BW,EAAYI,CAAO,CAC/D,CACF,EAEMC,GAAU,IAAI,QACpB,QAAWC,KAAU,SAAS,iBAAiB,QAAQ,EACrDD,GAAQ,IAAIC,CAAM,EAGpB,IAAMC,GAAWL,GAA0B,CACzC,IAAMM,EACJN,aAAkB,kBACd,CAACA,CAAM,EACPA,EAAO,iBAAiB,QAAQ,EACtC,QAAWO,KAAOD,EAChB,GAAI,CAACH,GAAQ,IAAII,CAAG,EAAG,CACrB,IAAMH,EAAS,SAAS,cAAc,QAAQ,EAC9C,OAAW,CAAE,KAAAI,EAAM,MAAAC,CAAM,IAAKF,EAAI,WAChCH,EAAO,aAAaI,EAAMC,CAAK,EAEjCL,EAAO,KAAOG,EAAI,KAClBA,EAAI,YAAYH,CAAM,EACtBD,GAAQ,IAAIC,CAAM,CACpB,CAEJ,EAEMM,GAAiB,CACrBR,EACAS,EACAC,IACG,CACH,QAAWZ,KAAUE,EAAS,CAC5B,IAAMW,EAASF,EAAQ,UAAU,EAAI,EACrCN,GAAQQ,CAAM,EAEdb,EAAOY,CAAM,EAAEC,CAAM,CACvB,CACF,EAEMZ,GAAiB,CACrBd,EACAwB,EACAT,IACG,CACH,OAAQf,EAAM,CACZ,IAAK,SACH,QAAWa,KAAUE,EACnBF,EAAO,OAAO,EAEhB,MACF,IAAK,QACL,IAAK,QACH,QAAWA,KAAUE,EACnBY,GAAMd,EAAQW,EAAQ,UAAU,EAAI,EAAcxB,CAAI,EACtDkB,GAAQL,CAAM,EAEhB,MACF,IAAK,UACHU,GAAeR,EAASS,EAAS,aAAa,EAC9C,MACF,IAAK,UACL,IAAK,SACL,IAAK,SACL,IAAK,QACHD,GAAeR,EAASS,EAASxB,CAAI,CACzC,CACF,ECzLA4B,GAAQ,CACN,KAAM,yBACN,MAAM,CAAE,MAAAC,CAAM,EAAG,CAAE,QAAAC,EAAS,cAAAC,CAAc,EAAG,CAC3C,GAAID,EAAS,CACX,IAAME,EAAYD,GAAe,KAAK,IAAM,OAC5CE,EAAWC,GAAcJ,CAAO,EAAG,CAAE,UAAAE,CAAU,CAAC,CAClD,KACE,OAAMH,EAAM,6BAA6B,CAE7C,CACF,CAAC",
  "names": ["lol", "DSP", "DSS", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "kebab", "str", "snake", "str", "kebab", "jsStrToObject", "raw", "caseFns", "str", "x", "modifyCasing", "mods", "defaultCase", "c", "aliasify", "name", "hasOwn", "isPojo", "obj", "isEmpty", "prop", "hasOwn", "updateLeaves", "fn", "key", "val", "pathToObj", "paths", "result", "path", "value", "keys", "lastKey", "acc", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "prevSub", "activeSub", "version", "beginBatch", "endBatch", "flush", "dispatch", "startPeeking", "sub", "stopPeeking", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "effectOper", "run", "update", "updateComputed", "updateSignal", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "propagate", "currentValue", "shallowPropagate", "unlink", "prevDep", "depsTail_", "nextDep", "version_", "subsTail_", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "isValidLink", "subSubs", "nextSub", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "checkLink", "getPath", "path", "result", "root", "split", "hasOwn", "deep", "prefix", "isArr", "isPojo", "deepObj", "key", "keys", "_", "prop", "newValue", "diff", "patch", "i", "detail", "pathToObj", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "ifMissing", "mergeInner", "mergePaths", "paths", "options", "target", "targetParent", "toRegExp", "val", "filtered", "include", "exclude", "obj", "includeRe", "excludeRe", "node", "isHTMLOrSVG", "el", "url", "error", "ctx", "reason", "metadata", "e", "r", "snake", "q", "c", "actionPlugins", "attributePlugins", "watcherPlugins", "actions", "_", "prop", "removals", "queuedAttributes", "queuedAttributeNames", "attribute", "plugin", "apply", "action", "DATASTAR_FETCH_EVENT", "evt", "watcher", "cleanupEls", "els", "el", "cleanups", "cleanup", "aliasedIgnore", "aliasify", "aliasedIgnoreAttr", "shouldIgnore", "applyEls", "onlyNew", "key", "applyAttributePlugin", "observe", "mutations", "target", "type", "attributeName", "addedNodes", "removedNodes", "node", "isHTMLOrSVG", "value", "mutationObserver", "root", "attrKey", "rawKey", "namePart", "rawModifiers", "pluginName", "keyReq", "valueReq", "cachedRx", "args", "genRx", "rawMod", "label", "mod", "returnsValue", "argNames", "expr", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "counter", "match", "k", "v", "signalName", "acc", "part", "varName", "fn", "name", "err", "ctxIdMap", "ctxPersistentIds", "oldIdTagNameMap", "duplicateIds", "ctxPantry", "aliasedIgnoreMorph", "aliasify", "aliasedIgnoreMorphAttr", "morph", "oldElt", "newContent", "mode", "isHTMLOrSVG", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "parent", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "node", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "aliasedPreserveAttr", "type", "newElt", "preserveAttrs", "name", "value", "i", "root", "elements", "elt", "action", "_", "fn", "startPeeking", "stopPeeking", "action", "_", "value", "filter", "startPeeking", "masked", "filtered", "updateLeaves", "mergePatch", "stopPeeking", "action", "_", "filter", "startPeeking", "masked", "filtered", "updateLeaves", "oldValue", "mergePatch", "stopPeeking", "fetchAbortControllers", "createHttpMethod", "name", "method", "action", "el", "evt", "error", "url", "selector", "userHeaders", "contentType", "include", "exclude", "openWhenHidden", "alwaysReconnect", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "requestCancellation", "controller", "isDisabled", "oldController", "cleanupFn", "initialHeaders", "headers", "req", "response", "dispatchFetch", "ERROR", "type", "argsRawLines", "line", "i", "k", "v", "argsRaw", "isWrongContent", "RETRYING", "urlInstance", "queryParams", "res", "filtered", "formEl", "formData", "submitter", "preventDefault", "multipart", "formParams", "key", "value", "STARTED", "fetchEventSource", "e", "FINISHED", "RETRIES_FAILED", "DATASTAR_FETCH_EVENT", "err", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "field", "valueOffset", "retry", "a", "b", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "overrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "status", "isRedirectStatus", "ct", "script", "scriptAttributesHeader", "id", "interval", "innerErr", "attribute", "el", "key", "rx", "syncAttr", "val", "update", "observer", "obj", "attributeFilter", "cleanup", "effect", "dataURIRegex", "empty", "aliasedBind", "aliasify", "attribute", "el", "key", "mods", "value", "error", "signalName", "modifyCasing", "get", "type", "set", "syncSignal", "files", "signalFiles", "f", "resolve", "reader", "match", "mergePaths", "typeMap", "option", "initialValue", "getPath", "path", "signalNameKebab", "inputs", "paths", "i", "input", "signalValue", "cleanup", "effect", "attribute", "key", "el", "mods", "rx", "modifyCasing", "callback", "observer", "classes", "k", "classNames", "cn", "name", "cleanup", "effect", "attribute", "key", "mods", "rx", "error", "mergePaths", "modifyCasing", "computed", "patch", "updateLeaves", "old", "mergePatch", "attribute", "rx", "effect", "attribute", "el", "key", "mods", "value", "signalName", "modifyCasing", "mergePaths", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_FETCH_EVENT", "attribute", "el", "value", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "filtered", "cleanup", "effect", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "attribute", "el", "key", "mods", "rx", "target", "callback", "evt", "beginBatch", "endBatch", "modifyViewTransition", "modifyTiming", "evtListOpts", "cb", "eventName", "modifyCasing", "DATASTAR_FETCH_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "attribute", "el", "mods", "rx", "callback", "beginBatch", "endBatch", "modifyViewTransition", "modifyTiming", "options", "observer", "entries", "entry", "attribute", "mods", "rx", "callback", "beginBatch", "endBatch", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "attribute", "rx", "mods", "callback", "beginBatch", "endBatch", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "attribute", "el", "key", "mods", "rx", "error", "filtersRaw", "filters", "jsStrToObject", "callback", "modifyTiming", "evt", "watched", "filtered", "isEmpty", "beginBatch", "endBatch", "DATASTAR_SIGNAL_PATCH_EVENT", "attribute", "el", "key", "mods", "value", "signalName", "modifyCasing", "mergePaths", "NONE", "DISPLAY", "attribute", "el", "rx", "update", "observer", "cleanup", "effect", "attribute", "key", "mods", "rx", "ifMissing", "modifyCasing", "mergePaths", "patch", "mergePatch", "attribute", "key", "el", "rx", "style", "initialStyles", "apply", "prop", "value", "initial", "update", "observer", "styles", "kebab", "cleanup", "effect", "attribute", "el", "rx", "update", "observer", "cleanup", "effect", "watcher", "ctx", "elements", "selector", "mode", "useViewTransition", "args2", "supportsViewTransitions", "onPatchElements", "error", "elementsWithSvgsRemoved", "hasHtml", "hasHead", "hasBody", "newDocument", "newContent", "child", "target", "applyToTargets", "targets", "scripts", "script", "execute", "elScripts", "old", "name", "value", "applyPatchMode", "element", "action", "cloned", "morph", "watcher", "error", "signals", "onlyIfMissing", "ifMissing", "mergePatch", "jsStrToObject"]
}
