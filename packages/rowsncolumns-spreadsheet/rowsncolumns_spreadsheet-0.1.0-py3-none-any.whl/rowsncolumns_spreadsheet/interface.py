"""
SpreadsheetInterface class that provides YJS integration with patch tracking.

This mirrors the TypeScript SpreadsheetInterface and provides the same workflow:
1. Load data from YJS
2. Perform operations
3. Get patches
4. Apply patches back to YJS
"""

from typing import List, Optional, Dict, Any, Tuple, Callable
import copy
from .types import SpreadsheetState, Sheet, CellData, RowData, GridRange, SelectionArea
from .operations import insert_row, delete_row, insert_column, delete_column
from .patches import (
    SpreadsheetPatch,
    PatchType,
    PatchGenerator,
    serialize_for_patches,
)


class SpreadsheetInterface:
    """
    Interface for spreadsheet operations with YJS patch tracking.

    This class maintains state and generates JSON patches that can be applied
    to YJS documents, enabling collaborative editing.
    """

    def __init__(self, initial_data: Optional[Dict[str, Any]] = None):
        """
        Initialize the spreadsheet interface.

        Args:
            initial_data: Initial data loaded from YJS document
        """
        if initial_data:
            self._state = self._load_from_yjs_data(initial_data)
        else:
            # Create default state
            default_sheet = Sheet(
                sheet_id=0,
                name="Sheet1",
                index=0,
                row_count=1000,
                column_count=26,
            )
            self._state = SpreadsheetState(
                sheets=[default_sheet],
                active_sheet_id=0,
            )

        # Track patches generated by operations
        self._patches: List[SpreadsheetPatch] = []

        # Store the initial state for patch generation
        self._initial_state = copy.deepcopy(self._state)

    @property
    def state(self) -> SpreadsheetState:
        """Get the current spreadsheet state."""
        return self._state

    @property
    def patches(self) -> List[SpreadsheetPatch]:
        """Get accumulated patches."""
        return self._patches

    def clear_patches(self) -> None:
        """Clear the accumulated patches."""
        self._patches = []
        self._initial_state = copy.deepcopy(self._state)

    def _load_from_yjs_data(self, data: Dict[str, Any]) -> SpreadsheetState:
        """
        Load spreadsheet state from YJS document data.

        Args:
            data: Raw data from YJS document

        Returns:
            SpreadsheetState object
        """
        # Convert YJS data to SpreadsheetState
        # This would need to handle the specific format of your YJS data
        sheets_data = data.get('sheets', [])
        sheets = []

        for sheet_data in sheets_data:
            sheet = Sheet(**sheet_data)
            sheets.append(sheet)

        # Load other data
        sheet_data = data.get('sheetData', {})
        # Convert string keys to int keys
        int_sheet_data = {}
        for sheet_id_str, rows in sheet_data.items():
            sheet_id = int(sheet_id_str)
            converted_rows: List[Optional[RowData]] = []
            for row in rows:
                if row is None:
                    converted_rows.append(None)
                    continue
                converted_values = []
                for cell in row.get('values', []):
                    if cell is None:
                        converted_values.append(None)
                    else:
                        converted_values.append(CellData(**cell))
                converted_rows.append(RowData(values=converted_values))
            int_sheet_data[sheet_id] = converted_rows

        return SpreadsheetState(
            sheets=sheets,
            sheet_data=int_sheet_data,
            tables=data.get('tables', []),
            active_sheet_id=data.get('activeSheetId'),
            selections=data.get('selections', {}),
        )

    def _generate_state_patches(self) -> SpreadsheetPatch:
        """
        Generate patches between initial state and current state.
        """
        # Serialize both states for comparison
        before = serialize_for_patches(self._initial_state)
        after = serialize_for_patches(self._state)

        patch = SpreadsheetPatch()

        # Generate patches for each major component
        if before.get('sheets') != after.get('sheets'):
            forward, inverse = PatchGenerator.generate_patches(
                before.get('sheets', []),
                after.get('sheets', []),
                '/sheets'
            )
            patch.sheets = PatchType(patches=forward, inverse_patches=inverse)

        if before.get('sheet_data') != after.get('sheet_data'):
            forward, inverse = PatchGenerator.generate_patches(
                before.get('sheet_data', {}),
                after.get('sheet_data', {}),
                '/sheetData'
            )
            patch.sheet_data = PatchType(patches=forward, inverse_patches=inverse)

        if before.get('tables') != after.get('tables'):
            forward, inverse = PatchGenerator.generate_patches(
                before.get('tables', []),
                after.get('tables', []),
                '/tables'
            )
            patch.tables = PatchType(patches=forward, inverse_patches=inverse)

        if before.get('selections') != after.get('selections'):
            forward, inverse = PatchGenerator.generate_patches(
                before.get('selections', {}),
                after.get('selections', {}),
                '/selections'
            )
            # For selections, we store them differently
            if forward or inverse:
                patch.selections = {
                    'redo': after.get('selections'),
                    'undo': before.get('selections')
                }

        return patch

    def insert_rows(
        self,
        sheet_id: int,
        reference_row_index: int,
        num_rows: int = 1,
    ) -> None:
        """
        Insert rows and track patches.

        Args:
            sheet_id: ID of the sheet to modify
            reference_row_index: Index where rows should be inserted
            num_rows: Number of rows to insert
        """
        # Perform the operation
        new_state = insert_row(
            self._state,
            sheet_id,
            reference_row_index,
            num_rows,
            save_history=False,  # We handle history differently
        )

        # Update state
        self._state = new_state

        # Generate patches for this operation
        patch = self._generate_state_patches()
        if self._has_changes(patch):
            self._patches.append(patch)

    def delete_rows(self, sheet_id: int, row_indices: List[int]) -> None:
        """
        Delete rows and track patches.

        Args:
            sheet_id: ID of the sheet to modify
            row_indices: List of row indices to delete
        """
        new_state = delete_row(self._state, sheet_id, row_indices, save_history=False)
        self._state = new_state

        patch = self._generate_state_patches()
        if self._has_changes(patch):
            self._patches.append(patch)

    def insert_columns(
        self,
        sheet_id: int,
        reference_column_index: int,
        num_columns: int = 1,
    ) -> None:
        """Insert columns and track patches."""
        new_state = insert_column(
            self._state, sheet_id, reference_column_index, num_columns, save_history=False
        )
        self._state = new_state

        patch = self._generate_state_patches()
        if self._has_changes(patch):
            self._patches.append(patch)

    def delete_columns(self, sheet_id: int, column_indices: List[int]) -> None:
        """Delete columns and track patches."""
        new_state = delete_column(self._state, sheet_id, column_indices, save_history=False)
        self._state = new_state

        patch = self._generate_state_patches()
        if self._has_changes(patch):
            self._patches.append(patch)

    def set_cell_value(
        self,
        sheet_id: int,
        row_index: int,
        column_index: int,
        value: Any,
        formula: Optional[str] = None,
    ) -> None:
        """Set cell value and track patches."""
        # Ensure sheet data exists
        if sheet_id not in self._state.sheet_data:
            self._state.sheet_data[sheet_id] = []

        sheet_data = self._state.sheet_data[sheet_id]

        # Ensure we have enough rows
        while len(sheet_data) <= row_index:
            sheet_data.append(None)

        # Ensure the row exists and has values
        row = sheet_data[row_index]
        if row is None:
            row = RowData(values=[])
            sheet_data[row_index] = row
        # Type narrowing for static analyzers
        assert row is not None
        if row.values is None:
            row.values = []
        while len(row.values) <= column_index:
            row.values.append(None)

        # Set the cell value
        cell_data = CellData(value=value, formula=formula)
        row.values[column_index] = cell_data

        # Generate patches
        patch = self._generate_state_patches()
        if self._has_changes(patch):
            self._patches.append(patch)

    def get_cell_value(self, sheet_id: int, row_index: int, column_index: int) -> Any:
        """Get cell value."""
        if sheet_id not in self._state.sheet_data:
            return None

        sheet_data = self._state.sheet_data[sheet_id]
        if row_index >= len(sheet_data):
            return None

        row = sheet_data[row_index]
        if row is None:
            return None
        values = row.values or []
        if column_index >= len(values):
            return None

        cell = values[column_index]
        return cell.value if cell else None

    def get_patch_tuples(
        self, operation_type: str = "redo"
    ) -> List[Tuple[SpreadsheetPatch, str]]:
        """
        Get patches as tuples for YJS application.

        Args:
            operation_type: Type of operation ("redo" or "undo")

        Returns:
            List of (patch, operation_type) tuples
        """
        return [(patch, operation_type) for patch in self._patches]

    def generate_yjs_patches(self) -> List[Dict[str, Any]]:
        """
        Generate patches in a format suitable for YJS.

        Returns:
            List of patch dictionaries that can be applied to YJS
        """
        yjs_patches = []

        for spreadsheet_patch in self._patches:
            if spreadsheet_patch.sheet_data:
                for json_patch in spreadsheet_patch.sheet_data.patches:
                    yjs_patches.append(json_patch.to_dict())

            if spreadsheet_patch.sheets:
                for json_patch in spreadsheet_patch.sheets.patches:
                    yjs_patches.append(json_patch.to_dict())

            if spreadsheet_patch.tables:
                for json_patch in spreadsheet_patch.tables.patches:
                    yjs_patches.append(json_patch.to_dict())

        return yjs_patches

    def to_yjs_data(self) -> Dict[str, Any]:
        """
        Convert current state to YJS data format.

        Returns:
            Dictionary suitable for YJS document
        """
        serialized = serialize_for_patches(self._state)

        # Convert integer keys to strings for JSON compatibility
        if 'sheet_data' in serialized:
            string_sheet_data = {}
            for sheet_id, rows in serialized['sheet_data'].items():
                string_sheet_data[str(sheet_id)] = rows
            serialized['sheetData'] = string_sheet_data
            del serialized['sheet_data']

        # Convert snake_case to camelCase for YJS compatibility
        if 'active_sheet_id' in serialized:
            serialized['activeSheetId'] = serialized['active_sheet_id']
            del serialized['active_sheet_id']

        return serialized

    def _has_changes(self, patch: SpreadsheetPatch) -> bool:
        """Check if a patch contains any actual changes."""
        return any([
            patch.sheet_data and patch.sheet_data.patches,
            patch.sheets and patch.sheets.patches,
            patch.tables and patch.tables.patches,
            patch.selections,
        ])

    def reset_to_initial_state(self) -> None:
        """Reset the state to the initial state and clear patches."""
        self._state = copy.deepcopy(self._initial_state)
        self._patches = []
