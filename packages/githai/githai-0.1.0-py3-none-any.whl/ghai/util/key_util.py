"""Utility class for managing API keys and tokens for GHAI CLI."""

import json
from pathlib import Path
from typing import Any, Dict, Optional


class KeyUtil:
    """Utility class for all key-related operations in GHAI CLI."""

    @staticmethod
    def get_keys_file_path() -> Path:
        """Get the path to the keys.json file.

        Returns:
            Path to the keys.json file in the user's home directory
        """
        home_dir = Path.home()
        ghai_dir = home_dir / ".ghai"
        return ghai_dir / "keys.json"

    @staticmethod
    def ensure_keys_file() -> Path:
        """Ensure the keys.json file exists with proper permissions.

        Returns:
            Path to the keys.json file
        """
        keys_path = KeyUtil.get_keys_file_path()
        keys_path.parent.mkdir(parents=True, exist_ok=True)

        if not keys_path.exists():
            default: Dict[str, str] = {
                "// Note": "This file stores secret API credentials. Do not share!",
                "// Created": "Auto-generated by GHAI CLI",
            }
            keys_path.write_text(json.dumps(default, indent=2) + "\n")
            keys_path.chmod(0o600)  # Read/write for owner only

        return keys_path

    @staticmethod
    def load_keys() -> Dict[str, str]:
        """Load all keys from the keys.json file.

        Returns:
            Dictionary containing all stored keys

        Raises:
            json.JSONDecodeError: If the keys file contains invalid JSON
            FileNotFoundError: If the keys file cannot be found or created
        """
        keys_path = KeyUtil.ensure_keys_file()
        try:
            keys: Dict[str, str] = json.loads(keys_path.read_text())
            return keys
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON in keys file: {e}") from e

    @staticmethod
    def save_keys(keys_data: Dict[str, Any]) -> None:
        """Save keys to the keys.json file.

        Args:
            keys_data: Dictionary of keys to save

        Raises:
            OSError: If the file cannot be written
        """
        keys_path = KeyUtil.ensure_keys_file()
        keys_path.write_text(json.dumps(keys_data, indent=2) + "\n")

    @staticmethod
    def get_key_by_name(key_name: str) -> Optional[str]:
        """Get a specific key by its name.

        Args:
            key_name: The name of the key to retrieve

        Returns:
            The key value if found, None otherwise
        """
        try:
            keys_data = KeyUtil.load_keys()
            return keys_data.get(key_name)
        except Exception:
            return None

    @staticmethod
    def set_key(key_name: str, key_value: str) -> None:
        """Set a key with the given name and value.

        Args:
            key_name: The name of the key to set
            key_value: The value to store for the key

        Raises:
            ValueError: If key_name is empty or starts with "//"
            OSError: If the keys file cannot be written
        """
        if not key_name or not key_name.strip():
            raise ValueError("Key name cannot be empty")

        if key_name.startswith("//"):
            raise ValueError(
                "Key name cannot start with '//' (reserved for comments)"
            )

        keys_data = KeyUtil.load_keys()
        keys_data[key_name] = key_value
        KeyUtil.save_keys(keys_data)

    @staticmethod
    def delete_key(key_name: str) -> bool:
        """Delete a key by its name.

        Args:
            key_name: The name of the key to delete

        Returns:
            True if the key was deleted, False if it didn't exist

        Raises:
            ValueError: If trying to delete a comment key (starts with "//")
            OSError: If the keys file cannot be written
        """
        if key_name.startswith("//"):
            raise ValueError("Cannot delete comment entries")

        keys_data = KeyUtil.load_keys()

        if key_name not in keys_data:
            return False

        del keys_data[key_name]
        KeyUtil.save_keys(keys_data)
        return True

    @staticmethod
    def list_keys() -> Dict[str, str]:
        """List all stored keys.

        Returns:
            Dictionary of key names and values (values may be masked for security)
        """
        try:
            keys_data = KeyUtil.load_keys()

            return {k: v for k, v in keys_data.items() if not k.startswith("//")}
        except Exception:
            return {}

    @staticmethod
    def key_exists(key_name: str) -> bool:
        """Check if a key exists.

        Args:
            key_name: The name of the key to check

        Returns:
            True if the key exists, False otherwise
        """
        keys_data = KeyUtil.list_keys()
        return key_name in keys_data

    # Convenience methods for specific keys

    @staticmethod
    def get_default_model() -> Optional[str]:
        """Get the default model from keys.json.

        Returns:
            The default model name if set, None otherwise
        """
        return KeyUtil.get_key_by_name("DEFAULT_MODEL")

    @staticmethod
    def set_default_model(model_name: str) -> None:
        """Set the default model in keys.json.

        Args:
            model_name: The model name to set as default
        """
        KeyUtil.set_key("DEFAULT_MODEL", model_name)

    @staticmethod
    def get_github_token() -> Optional[str]:
        """Get the GitHub token from keys.json.

        Returns:
            The GitHub token if set, None otherwise
        """
        return KeyUtil.get_key_by_name("GITHUB_TOKEN")

    @staticmethod
    def set_github_token(token: str) -> None:
        """Set the GitHub token in keys.json.

        Args:
            token: The GitHub token to store
        """
        KeyUtil.set_key("GITHUB_TOKEN", token)
