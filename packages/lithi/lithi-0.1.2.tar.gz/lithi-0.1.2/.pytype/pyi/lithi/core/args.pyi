# (generated with --quick)

import abc
import argparse
import dataclasses
from typing import Callable, Optional, TypeVar, overload

ABC: type[abc.ABC]

_FuncT = TypeVar('_FuncT', bound=Callable)
_T = TypeVar('_T')

@dataclasses.dataclass
class Argument(abc.ABC):
    name: str
    flag: Optional[str] = ...
    description: Optional[str] = ...
    __doc__: str
    def __init__(self, name: str, flag: Optional[str] = ..., description: Optional[str] = ...) -> None: ...
    @abstractmethod
    def register(self, parser: argparse.ArgumentParser) -> None: ...

@dataclasses.dataclass
class ArgumentBoolean(Argument):
    default: bool = ...
    __doc__: str
    def __init__(self, name: str, flag: Optional[str] = ..., description: Optional[str] = ..., default: bool = ...) -> None: ...
    def register(self, parser: argparse.ArgumentParser) -> None: ...

@dataclasses.dataclass
class ArgumentInt(Argument):
    default: Optional[int] = ...
    __doc__: str
    def __init__(self, name: str, flag: Optional[str] = ..., description: Optional[str] = ..., default: Optional[int] = ...) -> None: ...
    def register(self, parser: argparse.ArgumentParser) -> None: ...

@dataclasses.dataclass
class ArgumentString(Argument):
    default: Optional[str] = ...
    __doc__: str
    def __init__(self, name: str, flag: Optional[str] = ..., description: Optional[str] = ..., default: Optional[str] = ...) -> None: ...
    def register(self, parser: argparse.ArgumentParser) -> None: ...

def abstractmethod(funcobj: _FuncT) -> _FuncT: ...
@overload
def dataclass(cls: None, /) -> Callable[[type[_T]], type[_T]]: ...
@overload
def dataclass(cls: type[_T], /) -> type[_T]: ...
@overload
def dataclass(*, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., match_args: bool = ..., kw_only: bool = ..., slots: bool = ...) -> Callable[[type[_T]], type[_T]]: ...
