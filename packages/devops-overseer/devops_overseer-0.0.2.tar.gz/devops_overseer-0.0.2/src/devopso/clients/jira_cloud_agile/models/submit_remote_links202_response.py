# coding: utf-8

"""
    Jira Software Cloud API

    Jira Software Cloud REST API documentation

    The version of the OpenAPI document: 1001.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from devopso.clients.jira_cloud_agile.models.remote_link_data_associations_inner import RemoteLinkDataAssociationsInner
from devopso.clients.jira_cloud_agile.models.submit_remote_links202_response_rejected_remote_links_value_inner import SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner
from typing import Optional, Set
from typing_extensions import Self

class SubmitRemoteLinks202Response(BaseModel):
    """
    The result of a successful `submitRemoteLinks` request. 
    """ # noqa: E501
    accepted_remote_links: Optional[List[StrictStr]] = Field(default=None, description="The IDs of Remote Links that have been accepted for submission.  A Remote Link may be rejected if it was only associated with unknown issue keys, unknown service IDs, or if the submitted data for that Remote Link does not match the required schema.  Note that a Remote Link that isn't updated due to it's `updateSequenceNumber` being out of order is not considered a failed submission. ", alias="acceptedRemoteLinks")
    rejected_remote_links: Optional[Dict[str, List[SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner]]] = Field(default=None, description="Details of Remote Links that have not been accepted for submission, usually due to a problem with the request data.  A Remote Link may be rejected if it was only associated with unknown issue keys, unknown service IDs, or if the submitted data for the Remote Link does not match the required schema.  The object (if present) will be keyed by Remote Link ID and include any errors associated with that Remote Link that have prevented it being submitted. ", alias="rejectedRemoteLinks")
    unknown_associations: Optional[List[RemoteLinkDataAssociationsInner]] = Field(default=None, description="Issue keys or services IDs or keys that are not known on this Jira instance (if any). ", alias="unknownAssociations")
    __properties: ClassVar[List[str]] = ["acceptedRemoteLinks", "rejectedRemoteLinks", "unknownAssociations"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SubmitRemoteLinks202Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in rejected_remote_links (dict of array)
        _field_dict_of_array = {}
        if self.rejected_remote_links:
            for _key_rejected_remote_links in self.rejected_remote_links:
                if self.rejected_remote_links[_key_rejected_remote_links] is not None:
                    _field_dict_of_array[_key_rejected_remote_links] = [
                        _item.to_dict() for _item in self.rejected_remote_links[_key_rejected_remote_links]
                    ]
            _dict['rejectedRemoteLinks'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each item in unknown_associations (list)
        _items = []
        if self.unknown_associations:
            for _item_unknown_associations in self.unknown_associations:
                if _item_unknown_associations:
                    _items.append(_item_unknown_associations.to_dict())
            _dict['unknownAssociations'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SubmitRemoteLinks202Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "acceptedRemoteLinks": obj.get("acceptedRemoteLinks"),
            "rejectedRemoteLinks": dict(
                (_k,
                        [SubmitRemoteLinks202ResponseRejectedRemoteLinksValueInner.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("rejectedRemoteLinks", {}).items()
            ),
            "unknownAssociations": [RemoteLinkDataAssociationsInner.from_dict(_item) for _item in obj["unknownAssociations"]] if obj.get("unknownAssociations") is not None else None
        })
        return _obj


