from os import PathLike
from pathlib import Path
from types import FunctionType
from typing import Callable
from jinja2 import Environment, FileSystemLoader, Template, select_autoescape

from godocs.util import dir, module
from godocs.constructor import Constructor
from godocs.constructor.constructor import ConstructorContext

type Builder = Callable[[
    str, Template, ConstructorContext, str | PathLike[str]], None]

MODELS_PATH = Path(__file__).parent / "models"
"""
The path to the directory containing the built-in **models** available for the `JinjaConstructor`.
This is set to `godocs/constructor/jinja_constructor/models`.
"""

DEFAULT_MODEL = "rst"
"""
The name of the default model from the built-in **models** used by the
`JinjaConstructor`, which defaults to `rst`.
"""

DEFAULT_FORMAT = "rst"
"""
The default file format generated by the
`JinjaConstructor`, which is set to `rst`.
"""


class JinjaConstructor(Constructor):
    """
    A specialized `Constructor` that uses the **Jinja** template language to
    build output documentation.

    Some important concepts for this class are:

    - Model: a model here refers to a **directory** where
             **Jinja** **templates** and **filters** are located.

    - Template: either a **folder** with an `index.jinja` file or a
                **Jinja** **file** with a **Jinja** template.

    - Filter: a function usable as a **Jinja** filter.

    - Builder: a function that receives a **Jinja** `Template`, a
               `ConstructorContext` and a folder `path`, and realizes the
               **creation** of one or more **output files inside** that `path`.

    For visualization, below is the structure of a model folder:

        <model>/
        ├── templates/
        │   ├── <template1.jinja>
        │   └── <template2>
        │       ├── <index.jinja>
        │       ├── <header.jinja>
        │       └── <footer.jinja>
        └── filters.py
    """

    models: list[Path] = []
    """
    A `list` with the default **models recognized** by this constructor,
    **got based** on the `MODELS_PATH` path.
    """

    model: Path | None = None
    """
    The **model** to be used by this constructor.
    """

    templates_path: Path | None = None
    """
    A **path** for a **directory** with the **templates**
    to be used with this constructor.
    """

    templates: list[Path] = []
    """
    A `list` with **templates** of this constructor,
    got **from** the `templates_path`.
    """

    filters: list[tuple[str, FunctionType]] = []
    """
    A `list` with `tuples` storing a **pair of name - filters**.
    These **filters** are got **from** the **model** chosen for
    this class, or from the `filters_path` passed to the **constructor**.
    """

    builders: dict[str, Builder] = {}
    """
    A `dict` with the **builders** this **constructor** should use.
    The **keys** here are the **names** of the `Builders`, and the
    **values** are the **builders themselves**.

    The **names** are important since they are what **link** what
    `templates` are gonna be passed to what **builders**.
    """

    env: Environment | None = None
    """
    The **Jinja environment** used by this `JinjaConstructor` to
    read **templates** and generate output.
    """

    output_format: str = DEFAULT_FORMAT

    @staticmethod
    def build_template(
        name: str,
        format: str,
        template: Template,
        context: ConstructorContext,
        path: str | PathLike[str],
    ) -> None:
        """
        **Builds** an output **document** in the `path/name` path with the
        **file extension** specified by the `OUTPUT_FORMAT` constant.

        This method **expects** a `template` that's used to create its
        result, with the use of the data inside the `context`, that
        also needs to be **supplied**.
        """

        path = Path(path)

        result = template.render(context)

        if not path.exists():
            path.mkdir(parents=True, exist_ok=True)

        path.joinpath(f"{name}.{format}").write_text(result)

    @staticmethod
    def build_class_templates(
        format: str,
        template: Template,
        context: ConstructorContext,
        path: str | PathLike[str],
    ) -> None:
        """
        **Builds** output **documents** for all `classes` specified
        in the `classes` field of the `context`.

        The **files produced** are **named** after those
        same **classes**.
        """

        for class_data in context["classes"]:
            context["class"] = class_data

            JinjaConstructor.build_template(
                class_data["name"], format, template, context, path)

    @staticmethod
    def build_index_template(
        format: str,
        template: Template,
        context: ConstructorContext,
        path: str | PathLike[str],
    ) -> None:
        """
        **Builds** an output **document** meant to store an **index**
        for the **classes** documented.

        The **name** of the generated file is `index`, with the
        **extension** from `OUTPUT_FORMAT`.
        """

        JinjaConstructor.build_template(
            "index", format, template, context, path)

    def __init__(
        self,
        model: str | PathLike[str] | None = None,
        templates_path: str | PathLike[str] | None = None,
        filters_path: str | PathLike[str] | None = None,
        builders_path: str | PathLike[str] | None = None,
        output_format: str = DEFAULT_FORMAT,
    ):
        """
        Instantiates a new `JinjaConstructor` with several optional customizations
        through parameters.

        Parameters:
            model: the **name** of the built-in **model** this constructor
                   should use or a **path** to a custom **model**.
                   By default, the `rst` model is chosen.
            templates_path: a **path** to a folder with **templates**
                            for use by this constructor.
                            Has precedence over the **templates path** got from
                            the chosen **model**.
                            By default, the `templates_path` is derived from the
                            `model` chosen.
            filters_path: a **path** to a **Python script** with **functions**
                          that can be used as **Jinja** filters by this constructor.
                          Has precedence over the **filters path** got from
                          the chosen **model**.
                          By default, the `filters_path` is derived from the
                          `model` chosen.
            builders: a `dict` mapping `str` names to `Builder` functions.
                      The name of the **templates** (file or folder name) is compared
                      with this `dict` to decide what `Builder` is used by what template.
                      By default, the `builders` support a `class` template -
                      which builds one output file for each class in the docs -
                      and an `index` template - which renders one file with an index for
                      all others.
        """

        self.models = self.find_models(MODELS_PATH)

        # model is either rst by default, or a built-in model
        # by name or a custom model by path
        if model is None:
            model = DEFAULT_MODEL
        if isinstance(model, str):
            self.model = self.find_model(model)
        if self.model is None:
            self.model = Path(model)

        # templates_path is either got from the model by default or
        # is got from the argument
        if templates_path is None:
            templates_path = self.model / "templates"

        self.templates_path = Path(templates_path)

        self.templates = self.find_templates(self.templates_path)

        # filters_path is either got from the model by default or
        # is got from the argument
        if filters_path is None:
            filters_path = self.model / "filters.py"

        self.filters = self.load_filters(Path(filters_path))

        # builders are either got from the builders_path or set
        # to the default builders
        if builders_path is not None:
            self.builders = dict(self.load_builders(Path(builders_path)))
        else:
            self.builders = {
                "class": JinjaConstructor.build_class_templates,
                "index": JinjaConstructor.build_index_template,
            }

        self.env = Environment(
            loader=FileSystemLoader(self.templates_path),
            autoescape=select_autoescape()
        )
        self.register_filters(self.env, self.filters)

        self.output_format = output_format

    def find_models(self, path: Path) -> list[Path]:
        """
        **Returns** the paths of the **models inside** the `path` directory
        (**models** here are considered **any folder** that is
        **not** `__pycache__`).

        Returns:
          list[pathlib.Path]: **Models** inside the `path`.
        """

        models = dir.get_subdirs(
            path,
            exclude=["__pycache__"],
        )

        return models

    def find_model(self, name: str) -> Path | None:
        """
        Receives the `name` of a **model** to **look for** among the
        **default models** available and **returns** the `Path` for
        the found one, if not `None`.
        """

        for model in self.models:
            if model.stem == name:
                return model

        return None

    def find_templates(self, path: Path) -> list[Path]:
        """
        **Returns** the paths of the **templates inside** the `path` directory.
        **Templates** here are considered anything that:

        - is **not** `__pycache__`;
        - has an `index.jinja`, if it's a folder;
        - is a `.jinja` file.

        Returns:
          list[pathlib.Path]: **Templates** inside the `path`.
        """

        if not path.exists():
            return []

        templates = dir.get_subitems(
            path,
            exclude=["__pycache__"],
            predicate=lambda p:
                not p.is_dir() and p.suffix == ".jinja" or (
                p.is_dir() and len(list(p.glob("index.jinja"))) == 1)
        )

        return templates

    def get_template_index(self, template: Path) -> Path:
        """
        **Returns** the **path** of the **Jinja index file** of a template
        so that it can be used by the `Environment` to render a result.

        If the `template` `Path` passed in points to a **file template**, it is
        already considered **its own index**.
        If it is a **directory**, the `index.jinja` inside it is
        considered its **index**.

        A valid `template` is **expected** by this function
        (as described by the docs of this class).

        Returns:
          str: **index** path of the **template**.
        """

        return template if not template.is_dir() else next(template.glob("index.jinja"))

    def get_template_name(self, template: Path) -> str:
        """
        **Returns** the **name** (path) of a **template relative**
        to the `templates_path` directory, so that it can be
        found by the `FileSystemLoader` used by the `Environment`.

        Returns:
          str: **name** of the **template**.
        """

        if self.templates_path is None:
            return template.stem

        return template.relative_to(self.templates_path).as_posix()

    def load_filters(self, path: Path) -> list[tuple[str, FunctionType]]:
        """
        **Loads** the **functions** from a **script** in the `path` and returns them
        as a `list` of `tuples` with **name-function pairs**, so that they can
        be used as **Jinja filters**.

        Returns:
            list[tuple[str, FunctionType]]: **Functions** from **script** in the `path`.
        """

        if not path.exists():
            return []

        mod = module.load("filters", path)

        return module.get_functions(mod)

    def load_builders(self, path: Path) -> list[tuple[str, Builder]]:
        """
        **Loads** the **functions** from a **script** in the `path` and returns them
        as a `list` of `tuples` with **name-function pairs**, so that they can
        be used as **builders**.

        Returns:
            list[tuple[str, Builder]]: **Builders** from **script** in the `path`.
        """

        if not path.exists():
            return []

        mod = module.load("builders", path)

        return module.get_functions(mod)

    def register_filters(self, env: Environment, filters: list[tuple[str, FunctionType]]) -> Environment:
        """
        **Registers** the `functions` present in the `filters` argument as
        **filters** in the `env`, so that they are usable by
        **Jinja templates** of this **constructor**.

        Returns:
            Environment: The **Jinja environment** modified by this function.
        """

        for filter in filters:
            env.filters[filter[0]] = filter[1]  # type: ignore

        return env

    def build_templates(self, env: Environment, context: ConstructorContext, path: str | PathLike[str]):
        for template_path in self.templates:
            builder = self.builders.get(template_path.stem)

            if builder is None:
                continue

            template_index = self.get_template_index(template_path)

            template = env.get_template(self.get_template_name(template_index))

            builder(self.output_format, template, context, path)

    def construct(self, context: ConstructorContext, path: str | PathLike[str]):
        if self.env is None:
            raise AttributeError("construction needs env to be defined")

        self.build_templates(self.env, context, path)
