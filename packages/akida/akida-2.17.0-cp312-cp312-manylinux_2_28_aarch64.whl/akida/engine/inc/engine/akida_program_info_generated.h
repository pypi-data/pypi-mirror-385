// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AKIDAPROGRAMINFO_AKIDA_FB_H_
#define FLATBUFFERS_GENERATED_AKIDAPROGRAMINFO_AKIDA_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "akida_np_info_generated.h"

namespace akida {
namespace fb {

struct DeviceVersion;
struct DeviceVersionBuilder;

struct RegisterValue;

struct TrackSpan;

struct SKipDmaInfoTrack;

struct FNP2TrackInfo;

struct RecordSpans;
struct RecordSpansBuilder;

struct PassSpans;
struct PassSpansBuilder;

struct LearningLayerInfo;
struct LearningLayerInfoBuilder;

struct ProgramInfo;
struct ProgramInfoBuilder;

enum IoType : int8_t {
  IoType_dense = 0,
  IoType_fnp_sparse = 1,
  IoType_cnp_sparse = 2,
  IoType_hrc_sparse = 3,
  IoType_MIN = IoType_dense,
  IoType_MAX = IoType_hrc_sparse
};

inline const IoType (&EnumValuesIoType())[4] {
  static const IoType values[] = {
    IoType_dense,
    IoType_fnp_sparse,
    IoType_cnp_sparse,
    IoType_hrc_sparse
  };
  return values;
}

inline const char * const *EnumNamesIoType() {
  static const char * const names[5] = {
    "dense",
    "fnp_sparse",
    "cnp_sparse",
    "hrc_sparse",
    nullptr
  };
  return names;
}

inline const char *EnumNameIoType(IoType e) {
  if (flatbuffers::IsOutRange(e, IoType_dense, IoType_hrc_sparse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIoType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RegisterValue FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t register_offset_;
  uint32_t value_;

 public:
  RegisterValue()
      : register_offset_(0),
        value_(0) {
  }
  RegisterValue(uint32_t _register_offset, uint32_t _value)
      : register_offset_(flatbuffers::EndianScalar(_register_offset)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  uint32_t register_offset() const {
    return flatbuffers::EndianScalar(register_offset_);
  }
  uint32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(RegisterValue, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrackSpan FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t offset_address_;
  uint32_t word_size_;

 public:
  TrackSpan()
      : offset_address_(0),
        word_size_(0) {
  }
  TrackSpan(uint32_t _offset_address, uint32_t _word_size)
      : offset_address_(flatbuffers::EndianScalar(_offset_address)),
        word_size_(flatbuffers::EndianScalar(_word_size)) {
  }
  uint32_t offset_address() const {
    return flatbuffers::EndianScalar(offset_address_);
  }
  uint32_t word_size() const {
    return flatbuffers::EndianScalar(word_size_);
  }
};
FLATBUFFERS_STRUCT_END(TrackSpan, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SKipDmaInfoTrack FLATBUFFERS_FINAL_CLASS {
 private:
  akida::fb::SkipDmaIdent ident_;
  uint8_t used_for_tnp_b_;
  uint8_t skip_length_;
  uint8_t skip_connect_id_;
  int8_t padding0__;
  uint32_t ob_32b_size_;

 public:
  SKipDmaInfoTrack()
      : ident_(),
        used_for_tnp_b_(0),
        skip_length_(0),
        skip_connect_id_(0),
        padding0__(0),
        ob_32b_size_(0) {
    (void)padding0__;
  }
  SKipDmaInfoTrack(const akida::fb::SkipDmaIdent &_ident, bool _used_for_tnp_b, uint8_t _skip_length, uint8_t _skip_connect_id, uint32_t _ob_32b_size)
      : ident_(_ident),
        used_for_tnp_b_(flatbuffers::EndianScalar(static_cast<uint8_t>(_used_for_tnp_b))),
        skip_length_(flatbuffers::EndianScalar(_skip_length)),
        skip_connect_id_(flatbuffers::EndianScalar(_skip_connect_id)),
        padding0__(0),
        ob_32b_size_(flatbuffers::EndianScalar(_ob_32b_size)) {
    (void)padding0__;
  }
  const akida::fb::SkipDmaIdent &ident() const {
    return ident_;
  }
  bool used_for_tnp_b() const {
    return flatbuffers::EndianScalar(used_for_tnp_b_) != 0;
  }
  uint8_t skip_length() const {
    return flatbuffers::EndianScalar(skip_length_);
  }
  uint8_t skip_connect_id() const {
    return flatbuffers::EndianScalar(skip_connect_id_);
  }
  uint32_t ob_32b_size() const {
    return flatbuffers::EndianScalar(ob_32b_size_);
  }
};
FLATBUFFERS_STRUCT_END(SKipDmaInfoTrack, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FNP2TrackInfo FLATBUFFERS_FINAL_CLASS {
 private:
  akida::fb::TrackSpan track_;
  akida::fb::NPIdent np_;
  int8_t padding0__;

 public:
  FNP2TrackInfo()
      : track_(),
        np_(),
        padding0__(0) {
    (void)padding0__;
  }
  FNP2TrackInfo(const akida::fb::TrackSpan &_track, const akida::fb::NPIdent &_np)
      : track_(_track),
        np_(_np),
        padding0__(0) {
    (void)padding0__;
  }
  const akida::fb::TrackSpan &track() const {
    return track_;
  }
  const akida::fb::NPIdent &np() const {
    return np_;
  }
};
FLATBUFFERS_STRUCT_END(FNP2TrackInfo, 12);

struct DeviceVersion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceVersionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VENDOR_ID = 4,
    VT_PRODUCT_ID = 6,
    VT_MAJOR_REV = 8,
    VT_MINOR_REV = 10
  };
  uint8_t vendor_id() const {
    return GetField<uint8_t>(VT_VENDOR_ID, 0);
  }
  uint8_t product_id() const {
    return GetField<uint8_t>(VT_PRODUCT_ID, 0);
  }
  uint8_t major_rev() const {
    return GetField<uint8_t>(VT_MAJOR_REV, 0);
  }
  uint8_t minor_rev() const {
    return GetField<uint8_t>(VT_MINOR_REV, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VENDOR_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCT_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAJOR_REV, 1) &&
           VerifyField<uint8_t>(verifier, VT_MINOR_REV, 1) &&
           verifier.EndTable();
  }
};

struct DeviceVersionBuilder {
  typedef DeviceVersion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vendor_id(uint8_t vendor_id) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_VENDOR_ID, vendor_id, 0);
  }
  void add_product_id(uint8_t product_id) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_PRODUCT_ID, product_id, 0);
  }
  void add_major_rev(uint8_t major_rev) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_MAJOR_REV, major_rev, 0);
  }
  void add_minor_rev(uint8_t minor_rev) {
    fbb_.AddElement<uint8_t>(DeviceVersion::VT_MINOR_REV, minor_rev, 0);
  }
  explicit DeviceVersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceVersion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceVersion>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceVersion> CreateDeviceVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t vendor_id = 0,
    uint8_t product_id = 0,
    uint8_t major_rev = 0,
    uint8_t minor_rev = 0) {
  DeviceVersionBuilder builder_(_fbb);
  builder_.add_minor_rev(minor_rev);
  builder_.add_major_rev(major_rev);
  builder_.add_product_id(product_id);
  builder_.add_vendor_id(vendor_id);
  return builder_.Finish();
}

struct RecordSpans FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordSpansBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKS = 4,
    VT_FNP2_TRACK = 6
  };
  const flatbuffers::Vector<const akida::fb::TrackSpan *> *tracks() const {
    return GetPointer<const flatbuffers::Vector<const akida::fb::TrackSpan *> *>(VT_TRACKS);
  }
  const akida::fb::FNP2TrackInfo *fnp2_track() const {
    return GetStruct<const akida::fb::FNP2TrackInfo *>(VT_FNP2_TRACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKS) &&
           verifier.VerifyVector(tracks()) &&
           VerifyField<akida::fb::FNP2TrackInfo>(verifier, VT_FNP2_TRACK, 4) &&
           verifier.EndTable();
  }
};

struct RecordSpansBuilder {
  typedef RecordSpans Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracks(flatbuffers::Offset<flatbuffers::Vector<const akida::fb::TrackSpan *>> tracks) {
    fbb_.AddOffset(RecordSpans::VT_TRACKS, tracks);
  }
  void add_fnp2_track(const akida::fb::FNP2TrackInfo *fnp2_track) {
    fbb_.AddStruct(RecordSpans::VT_FNP2_TRACK, fnp2_track);
  }
  explicit RecordSpansBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordSpans> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordSpans>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordSpans> CreateRecordSpans(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const akida::fb::TrackSpan *>> tracks = 0,
    const akida::fb::FNP2TrackInfo *fnp2_track = nullptr) {
  RecordSpansBuilder builder_(_fbb);
  builder_.add_fnp2_track(fnp2_track);
  builder_.add_tracks(tracks);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecordSpans> CreateRecordSpansDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<akida::fb::TrackSpan> *tracks = nullptr,
    const akida::fb::FNP2TrackInfo *fnp2_track = nullptr) {
  auto tracks__ = tracks ? _fbb.CreateVectorOfStructs<akida::fb::TrackSpan>(*tracks) : 0;
  return akida::fb::CreateRecordSpans(
      _fbb,
      tracks__,
      fnp2_track);
}

struct PassSpans FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassSpansBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4,
    VT_SKIPDMA_STORE_TRACK = 6,
    VT_SKIPDMA_LOAD_TRACK = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::RecordSpans>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::RecordSpans>> *>(VT_RECORDS);
  }
  const flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *> *skipdma_store_track() const {
    return GetPointer<const flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *> *>(VT_SKIPDMA_STORE_TRACK);
  }
  const flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *> *skipdma_load_track() const {
    return GetPointer<const flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *> *>(VT_SKIPDMA_LOAD_TRACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           VerifyOffset(verifier, VT_SKIPDMA_STORE_TRACK) &&
           verifier.VerifyVector(skipdma_store_track()) &&
           VerifyOffset(verifier, VT_SKIPDMA_LOAD_TRACK) &&
           verifier.VerifyVector(skipdma_load_track()) &&
           verifier.EndTable();
  }
};

struct PassSpansBuilder {
  typedef PassSpans Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::RecordSpans>>> records) {
    fbb_.AddOffset(PassSpans::VT_RECORDS, records);
  }
  void add_skipdma_store_track(flatbuffers::Offset<flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *>> skipdma_store_track) {
    fbb_.AddOffset(PassSpans::VT_SKIPDMA_STORE_TRACK, skipdma_store_track);
  }
  void add_skipdma_load_track(flatbuffers::Offset<flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *>> skipdma_load_track) {
    fbb_.AddOffset(PassSpans::VT_SKIPDMA_LOAD_TRACK, skipdma_load_track);
  }
  explicit PassSpansBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PassSpans> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassSpans>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassSpans> CreatePassSpans(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::RecordSpans>>> records = 0,
    flatbuffers::Offset<flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *>> skipdma_store_track = 0,
    flatbuffers::Offset<flatbuffers::Vector<const akida::fb::SKipDmaInfoTrack *>> skipdma_load_track = 0) {
  PassSpansBuilder builder_(_fbb);
  builder_.add_skipdma_load_track(skipdma_load_track);
  builder_.add_skipdma_store_track(skipdma_store_track);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<PassSpans> CreatePassSpansDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<akida::fb::RecordSpans>> *records = nullptr,
    const std::vector<akida::fb::SKipDmaInfoTrack> *skipdma_store_track = nullptr,
    const std::vector<akida::fb::SKipDmaInfoTrack> *skipdma_load_track = nullptr) {
  auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::RecordSpans>>(*records) : 0;
  auto skipdma_store_track__ = skipdma_store_track ? _fbb.CreateVectorOfStructs<akida::fb::SKipDmaInfoTrack>(*skipdma_store_track) : 0;
  auto skipdma_load_track__ = skipdma_load_track ? _fbb.CreateVectorOfStructs<akida::fb::SKipDmaInfoTrack>(*skipdma_load_track) : 0;
  return akida::fb::CreatePassSpans(
      _fbb,
      records__,
      skipdma_store_track__,
      skipdma_load_track__);
}

struct LearningLayerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LearningLayerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEARNING_REGISTERS = 4,
    VT_INFERENCE_REGISTERS = 6,
    VT_RAM = 8,
    VT_NP = 10
  };
  const akida::fb::TrackSpan *learning_registers() const {
    return GetStruct<const akida::fb::TrackSpan *>(VT_LEARNING_REGISTERS);
  }
  const akida::fb::TrackSpan *inference_registers() const {
    return GetStruct<const akida::fb::TrackSpan *>(VT_INFERENCE_REGISTERS);
  }
  const akida::fb::RecordSpans *ram() const {
    return GetPointer<const akida::fb::RecordSpans *>(VT_RAM);
  }
  const akida::fb::NPIdent *np() const {
    return GetStruct<const akida::fb::NPIdent *>(VT_NP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<akida::fb::TrackSpan>(verifier, VT_LEARNING_REGISTERS, 4) &&
           VerifyField<akida::fb::TrackSpan>(verifier, VT_INFERENCE_REGISTERS, 4) &&
           VerifyOffset(verifier, VT_RAM) &&
           verifier.VerifyTable(ram()) &&
           VerifyField<akida::fb::NPIdent>(verifier, VT_NP, 1) &&
           verifier.EndTable();
  }
};

struct LearningLayerInfoBuilder {
  typedef LearningLayerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_learning_registers(const akida::fb::TrackSpan *learning_registers) {
    fbb_.AddStruct(LearningLayerInfo::VT_LEARNING_REGISTERS, learning_registers);
  }
  void add_inference_registers(const akida::fb::TrackSpan *inference_registers) {
    fbb_.AddStruct(LearningLayerInfo::VT_INFERENCE_REGISTERS, inference_registers);
  }
  void add_ram(flatbuffers::Offset<akida::fb::RecordSpans> ram) {
    fbb_.AddOffset(LearningLayerInfo::VT_RAM, ram);
  }
  void add_np(const akida::fb::NPIdent *np) {
    fbb_.AddStruct(LearningLayerInfo::VT_NP, np);
  }
  explicit LearningLayerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LearningLayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LearningLayerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LearningLayerInfo> CreateLearningLayerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    const akida::fb::TrackSpan *learning_registers = nullptr,
    const akida::fb::TrackSpan *inference_registers = nullptr,
    flatbuffers::Offset<akida::fb::RecordSpans> ram = 0,
    const akida::fb::NPIdent *np = nullptr) {
  LearningLayerInfoBuilder builder_(_fbb);
  builder_.add_np(np);
  builder_.add_ram(ram);
  builder_.add_inference_registers(inference_registers);
  builder_.add_learning_registers(learning_registers);
  return builder_.Finish();
}

struct ProgramInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_DEVICE_VERSION = 6,
    VT_INPUT_DIMS = 8,
    VT_OUTPUT_DIMS = 10,
    VT_INPUT_TYPE = 12,
    VT_OUTPUT_TYPE = 14,
    VT_OUTPUT_BITS = 16,
    VT_ACTIVATION = 18,
    VT_DENSE_WINDOW_W = 20,
    VT_DENSE_WINDOW_H = 22,
    VT_SHIFTS = 24,
    VT_SCALES = 26,
    VT_MAX_NUM_DESC = 28,
    VT_EPG_TRACKS = 30,
    VT_PASSES = 32,
    VT_LEARNING_LAYER = 34,
    VT_DUMMY_HEADER = 36
  };
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const akida::fb::DeviceVersion *device_version() const {
    return GetPointer<const akida::fb::DeviceVersion *>(VT_DEVICE_VERSION);
  }
  const flatbuffers::Vector<uint32_t> *input_dims() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUT_DIMS);
  }
  const flatbuffers::Vector<uint32_t> *output_dims() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUT_DIMS);
  }
  akida::fb::IoType input_type() const {
    return static_cast<akida::fb::IoType>(GetField<int8_t>(VT_INPUT_TYPE, 0));
  }
  akida::fb::IoType output_type() const {
    return static_cast<akida::fb::IoType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  uint8_t output_bits() const {
    return GetField<uint8_t>(VT_OUTPUT_BITS, 0);
  }
  bool activation() const {
    return GetField<uint8_t>(VT_ACTIVATION, 0) != 0;
  }
  uint32_t dense_window_w() const {
    return GetField<uint32_t>(VT_DENSE_WINDOW_W, 0);
  }
  uint32_t dense_window_h() const {
    return GetField<uint32_t>(VT_DENSE_WINDOW_H, 0);
  }
  const flatbuffers::Vector<int32_t> *shifts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHIFTS);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  uint8_t max_num_desc() const {
    return GetField<uint8_t>(VT_MAX_NUM_DESC, 0);
  }
  const flatbuffers::Vector<const akida::fb::RegisterValue *> *epg_tracks() const {
    return GetPointer<const flatbuffers::Vector<const akida::fb::RegisterValue *> *>(VT_EPG_TRACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<akida::fb::PassSpans>> *passes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<akida::fb::PassSpans>> *>(VT_PASSES);
  }
  const akida::fb::LearningLayerInfo *learning_layer() const {
    return GetPointer<const akida::fb::LearningLayerInfo *>(VT_LEARNING_LAYER);
  }
  const akida::fb::TrackSpan *dummy_header() const {
    return GetStruct<const akida::fb::TrackSpan *>(VT_DUMMY_HEADER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_DEVICE_VERSION) &&
           verifier.VerifyTable(device_version()) &&
           VerifyOffset(verifier, VT_INPUT_DIMS) &&
           verifier.VerifyVector(input_dims()) &&
           VerifyOffset(verifier, VT_OUTPUT_DIMS) &&
           verifier.VerifyVector(output_dims()) &&
           VerifyField<int8_t>(verifier, VT_INPUT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_BITS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVATION, 1) &&
           VerifyField<uint32_t>(verifier, VT_DENSE_WINDOW_W, 4) &&
           VerifyField<uint32_t>(verifier, VT_DENSE_WINDOW_H, 4) &&
           VerifyOffset(verifier, VT_SHIFTS) &&
           verifier.VerifyVector(shifts()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<uint8_t>(verifier, VT_MAX_NUM_DESC, 1) &&
           VerifyOffset(verifier, VT_EPG_TRACKS) &&
           verifier.VerifyVector(epg_tracks()) &&
           VerifyOffset(verifier, VT_PASSES) &&
           verifier.VerifyVector(passes()) &&
           verifier.VerifyVectorOfTables(passes()) &&
           VerifyOffset(verifier, VT_LEARNING_LAYER) &&
           verifier.VerifyTable(learning_layer()) &&
           VerifyField<akida::fb::TrackSpan>(verifier, VT_DUMMY_HEADER, 4) &&
           verifier.EndTable();
  }
};

struct ProgramInfoBuilder {
  typedef ProgramInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ProgramInfo::VT_VERSION, version);
  }
  void add_device_version(flatbuffers::Offset<akida::fb::DeviceVersion> device_version) {
    fbb_.AddOffset(ProgramInfo::VT_DEVICE_VERSION, device_version);
  }
  void add_input_dims(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input_dims) {
    fbb_.AddOffset(ProgramInfo::VT_INPUT_DIMS, input_dims);
  }
  void add_output_dims(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output_dims) {
    fbb_.AddOffset(ProgramInfo::VT_OUTPUT_DIMS, output_dims);
  }
  void add_input_type(akida::fb::IoType input_type) {
    fbb_.AddElement<int8_t>(ProgramInfo::VT_INPUT_TYPE, static_cast<int8_t>(input_type), 0);
  }
  void add_output_type(akida::fb::IoType output_type) {
    fbb_.AddElement<int8_t>(ProgramInfo::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  void add_output_bits(uint8_t output_bits) {
    fbb_.AddElement<uint8_t>(ProgramInfo::VT_OUTPUT_BITS, output_bits, 0);
  }
  void add_activation(bool activation) {
    fbb_.AddElement<uint8_t>(ProgramInfo::VT_ACTIVATION, static_cast<uint8_t>(activation), 0);
  }
  void add_dense_window_w(uint32_t dense_window_w) {
    fbb_.AddElement<uint32_t>(ProgramInfo::VT_DENSE_WINDOW_W, dense_window_w, 0);
  }
  void add_dense_window_h(uint32_t dense_window_h) {
    fbb_.AddElement<uint32_t>(ProgramInfo::VT_DENSE_WINDOW_H, dense_window_h, 0);
  }
  void add_shifts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shifts) {
    fbb_.AddOffset(ProgramInfo::VT_SHIFTS, shifts);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(ProgramInfo::VT_SCALES, scales);
  }
  void add_max_num_desc(uint8_t max_num_desc) {
    fbb_.AddElement<uint8_t>(ProgramInfo::VT_MAX_NUM_DESC, max_num_desc, 0);
  }
  void add_epg_tracks(flatbuffers::Offset<flatbuffers::Vector<const akida::fb::RegisterValue *>> epg_tracks) {
    fbb_.AddOffset(ProgramInfo::VT_EPG_TRACKS, epg_tracks);
  }
  void add_passes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::PassSpans>>> passes) {
    fbb_.AddOffset(ProgramInfo::VT_PASSES, passes);
  }
  void add_learning_layer(flatbuffers::Offset<akida::fb::LearningLayerInfo> learning_layer) {
    fbb_.AddOffset(ProgramInfo::VT_LEARNING_LAYER, learning_layer);
  }
  void add_dummy_header(const akida::fb::TrackSpan *dummy_header) {
    fbb_.AddStruct(ProgramInfo::VT_DUMMY_HEADER, dummy_header);
  }
  explicit ProgramInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgramInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgramInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgramInfo> CreateProgramInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<akida::fb::DeviceVersion> device_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> input_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> output_dims = 0,
    akida::fb::IoType input_type = akida::fb::IoType_dense,
    akida::fb::IoType output_type = akida::fb::IoType_dense,
    uint8_t output_bits = 0,
    bool activation = false,
    uint32_t dense_window_w = 0,
    uint32_t dense_window_h = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shifts = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    uint8_t max_num_desc = 0,
    flatbuffers::Offset<flatbuffers::Vector<const akida::fb::RegisterValue *>> epg_tracks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<akida::fb::PassSpans>>> passes = 0,
    flatbuffers::Offset<akida::fb::LearningLayerInfo> learning_layer = 0,
    const akida::fb::TrackSpan *dummy_header = nullptr) {
  ProgramInfoBuilder builder_(_fbb);
  builder_.add_dummy_header(dummy_header);
  builder_.add_learning_layer(learning_layer);
  builder_.add_passes(passes);
  builder_.add_epg_tracks(epg_tracks);
  builder_.add_scales(scales);
  builder_.add_shifts(shifts);
  builder_.add_dense_window_h(dense_window_h);
  builder_.add_dense_window_w(dense_window_w);
  builder_.add_output_dims(output_dims);
  builder_.add_input_dims(input_dims);
  builder_.add_device_version(device_version);
  builder_.add_version(version);
  builder_.add_max_num_desc(max_num_desc);
  builder_.add_activation(activation);
  builder_.add_output_bits(output_bits);
  builder_.add_output_type(output_type);
  builder_.add_input_type(input_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgramInfo> CreateProgramInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    flatbuffers::Offset<akida::fb::DeviceVersion> device_version = 0,
    const std::vector<uint32_t> *input_dims = nullptr,
    const std::vector<uint32_t> *output_dims = nullptr,
    akida::fb::IoType input_type = akida::fb::IoType_dense,
    akida::fb::IoType output_type = akida::fb::IoType_dense,
    uint8_t output_bits = 0,
    bool activation = false,
    uint32_t dense_window_w = 0,
    uint32_t dense_window_h = 0,
    const std::vector<int32_t> *shifts = nullptr,
    const std::vector<float> *scales = nullptr,
    uint8_t max_num_desc = 0,
    const std::vector<akida::fb::RegisterValue> *epg_tracks = nullptr,
    const std::vector<flatbuffers::Offset<akida::fb::PassSpans>> *passes = nullptr,
    flatbuffers::Offset<akida::fb::LearningLayerInfo> learning_layer = 0,
    const akida::fb::TrackSpan *dummy_header = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto input_dims__ = input_dims ? _fbb.CreateVector<uint32_t>(*input_dims) : 0;
  auto output_dims__ = output_dims ? _fbb.CreateVector<uint32_t>(*output_dims) : 0;
  auto shifts__ = shifts ? _fbb.CreateVector<int32_t>(*shifts) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  auto epg_tracks__ = epg_tracks ? _fbb.CreateVectorOfStructs<akida::fb::RegisterValue>(*epg_tracks) : 0;
  auto passes__ = passes ? _fbb.CreateVector<flatbuffers::Offset<akida::fb::PassSpans>>(*passes) : 0;
  return akida::fb::CreateProgramInfo(
      _fbb,
      version__,
      device_version,
      input_dims__,
      output_dims__,
      input_type,
      output_type,
      output_bits,
      activation,
      dense_window_w,
      dense_window_h,
      shifts__,
      scales__,
      max_num_desc,
      epg_tracks__,
      passes__,
      learning_layer,
      dummy_header);
}

inline const akida::fb::ProgramInfo *GetProgramInfo(const void *buf) {
  return flatbuffers::GetRoot<akida::fb::ProgramInfo>(buf);
}

inline const akida::fb::ProgramInfo *GetSizePrefixedProgramInfo(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<akida::fb::ProgramInfo>(buf);
}

inline bool VerifyProgramInfoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<akida::fb::ProgramInfo>(nullptr);
}

inline bool VerifySizePrefixedProgramInfoBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<akida::fb::ProgramInfo>(nullptr);
}

inline void FinishProgramInfoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<akida::fb::ProgramInfo> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProgramInfoBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<akida::fb::ProgramInfo> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fb
}  // namespace akida

#endif  // FLATBUFFERS_GENERATED_AKIDAPROGRAMINFO_AKIDA_FB_H_
