# FedaPay Connector

![PyPI version](https://img.shields.io/pypi/v/fedapay_connector)
![Python versions](https://img.shields.io/pypi/pyversions/fedapay_connector)
![License](https://img.shields.io/pypi/l/fedapay_connector)
![Downloads](https://img.shields.io/pypi/dm/fedapay_connector)

Un client asynchrone robuste pour l'API FedaPay, offrant une gestion automatis√©e des paiements avec support complet des webhooks.

## ‚ú® Caract√©ristiques

- üîÑ **Pattern Singleton** - Une seule instance partag√©e dans toute l'application
- ‚ö° **Enti√®rement Asynchrone** - Performances optimales avec asyncio
- üîí **S√©curis√©** - Validation des signatures et gestion s√©curis√©e des webhooks
- üíæ **Persistence Automatique** - Sauvegarde et restauration des transactions
- üéØ **Callbacks Personnalisables** - Hooks pour tous les √©v√©nements
- üöÄ **Simple √† Utiliser** - API intuitive et documentation compl√®te
- üõ†Ô∏è **Module bas niveau pour controle granulaire** - Pour les dev qui veulent avoir plus de controle

## Installation

### Via pip
```bash
pip install fedapay_connector
```

### Via poetry
```bash
poetry add fedapay_connector
```

## üõ†Ô∏è Configuration

### Pr√©requis

- Python 3.9+
- Un compte FedaPay avec les cl√©s API
- Pour le serveur webhook : une URL accessible publiquement pointant vers votre serveur (via ngrok, un reverse proxy, etc.)

### Variables d'Environnement

| Variable | Description | Requis | D√©faut |
|----------|-------------|--------|---------|
| `FEDAPAY_API_KEY` | Cl√© API FedaPay | ‚úÖ | - |
| `FEDAPAY_API_URL` | URL API (sandbox/production) | ‚úÖ | - |
| `FEDAPAY_AUTH_KEY` | Cl√© secr√®te webhook | ‚úÖ | - |
| `FEDAPAY_ENDPOINT_NAME` | Endpoint webhook | ‚ùå | `webhooks` |
| `FEDAPAY_DB_URL` | URL sqlalchemy base de donn√©es  | ‚ùå | `sqlite:///fedapay_connector_persisted_data/processes.db` |

### Exemple de .env
```env
FEDAPAY_API_KEY=fp_key_live_123456789
FEDAPAY_API_URL=https://api.fedapay.com
FEDAPAY_AUTH_KEY=webhook_secret_123456789
FEDAPAY_ENDPOINT_NAME=webhooks
```

## üìö Guide d'Utilisation 

### Modes d'Utilisation module FedapayConnector

1. **Mode Simple** (non recommand√©)
   - Polling manuel du statut
   - Sans gestion des webhooks

2. **Mode Serveur Int√©gr√©** (recommand√©)
   - Serveur webhook int√©gr√©
   - Gestion automatique des √©v√©nements
   - Parfait pour une apllication python hors context d'API

3. **Mode Serveur Int√©gr√© (options avanc√©es)** (recommand√©)
   - Serveur webhook int√©gr√©
   - Gestion automatique des √©v√©nements
   - Sauvegarde et restauration automatique des processus d√©coutes apres arr√™t ou redemarrage de l'app
   - Parfait pour une apllication python hors context d'API

4. **Mode API Existante** 
   - Int√©gration avec FastAPI/Django/etc
   - Gestion personnalis√©e des webhooks

#### 1. Mode Simple 

```python
from fedapay_connector import Pays, MethodesPaiement, FedapayConnector, PaiementSetup, UserData, EventFutureStatus, PaymentHistory, WebhookHistory
import asyncio

async def main():
    # Creation de l'instance Fedapay Connector
    fedapay = FedapayConnector(use_listen_server= False) 

    # Configuration paiement
    setup = PaiementSetup(
        pays=Pays.benin,
        method=MethodesPaiement.mtn_open
    )
    
    client = UserData(
        nom="Doe",
        prenom="John",
        email="john@example.com",
        tel="0162626262"
    )

    # Ex√©cution paiement
    resp = await fedapay.fedapay_pay(
        setup=setup,
        client_infos=client,
        montant_paiement=1000,
        payment_contact="0162626262"
    )

    while True:
    # v√©rifier le resultat manuellement par polling
    status = await fedapay.fedapay_check_transaction_status(resp.id_transaction)
    if status.status == TransactionStatus.created or status.status == TransactionStatus.pending:
        await asyncio.sleep(0.1)
    else:
        break

if __name__ == "__main__":
    asyncio.run(main())
```

#### 2. Mode Serveur Int√©gr√©

Cette option n√©c√©ssite que vous ayez un reverse proxy pointant sur votre machine au port d'ecoute configurer pour le serveur
(d√©faut : 3000) depuis une url qui sera utilise√©e pour la configuration des webhook sur votre panel fedapay. 
[lien doc fedapay](https://docs.fedapay.com/integration-api/fr/webhooks-fr)

```python
from fedapay_connector import Pays, MethodesPaiement, FedapayConnector, PaiementSetup, UserData, EventFutureStatus, PaymentHistory, WebhookHistory
import asyncio

async def main():

    # Creation des callbacks
    async def payment_callback(data:PaymentHistory):
        # s'execute chaque fois qu'un nouveau paiement est initialis√© avec fedapay_pay()
            print(f"Callback de paiement re√ßu : {data.__dict__}")

    async def webhook_callback(data:WebhookHistory):
        # s'execute chaque fois qu'un nouveau webhook est re√ßu de fedapay
        print(f"Webhook re√ßu : {data.__dict__}")

    # Creation de l'instance Fedapay Connector
    fedapay = FedapayConnector(use_listen_server= True) 

    # Configuration des callbacks
    fedapay.set_payment_callback_function(payment_callback) # executer a chaques appels reussi a fedapay_pay()
    fedapay.set_webhook_callback_function(webhook_callback) # executer √† la r√©ception de webhooks fedapay valides

    # D√©marrage du listener interne
    fedapay.start_webhook_server()

    # Configuration paiement
    setup = PaiementSetup(
        pays=Pays.benin,
        method=MethodesPaiement.mtn_open
    )
    
    client = UserData(
        nom="Doe",
        prenom="John",
        email="john@example.com",
        tel="0162626262"
    )

    # Ex√©cution paiement
    resp = await fedapay.fedapay_pay(
        setup=setup,
        client_infos=client,
        montant_paiement=1000,
        payment_contact="0162626262"
    )

    # Attente r√©sultat
    status, webhooks = await fedapay.fedapay_finalise(resp.id_transaction)

    
    if status == EventFutureStatus.RESOLVED:
        print("\nTransaction r√©ussie\n")
        print(f"\nDonn√©es finales : {webhooks}\n")

        # ATTENTION :  Ce cas indique le reception d'une webhook valide et la cl√¥ture de la transaction mais ne veut pas syst√©matiquement dire due l'op√©ration √† √©t√© approuv√©e

        # Il faudra implementer par la suite votre gestion des webhook pour la validation ou tout autre traitement du paiement effectuer √† partir de la liste d'objet WebhookTransaction re√ßu.

    elif status == EventFutureStatus.TIMEOUT:
        # La v√©rification manuelle du statut de la transaction se fait automatiquement si timeout donc si timeout est lev√© pas besoin de rev√©rifier manuellement le status.

        print("\nLa transaction a expir√©.\n")

    elif status == EventFutureStatus.CANCELLED:
        print("\nTransaction annul√©e par l'utilisateur\n")

    elif status == EventFutureStatus.CANCELLED_INTERNALLY:
            print("\nTransaction annul√©e en interne -- probable redemarrage ou arret de l'application\n")
    

if __name__ == "__main__":
    asyncio.run(main())
```


#### 3. Mode Serveur Int√©gr√© (options avanc√©es)

```python
from fedapay_connector import Pays, MethodesPaiement, FedapayConnector, PaiementSetup, UserData, EventFutureStatus, PaymentHistory, WebhookHistory
import asyncio

async def main():

    # Creation des callbacks
    async def payment_callback(data:PaymentHistory):
        # s'execute chaque fois qu'un nouveau paiement est initialis√© avec fedapay_pay()
            print(f"Callback de paiement re√ßu : {data.__dict__}")

    async def webhook_callback(data:WebhookHistory):
        # s'execute chaque fois qu'un nouveau webhook est re√ßu de fedapay
        print(f"Webhook re√ßu : {data.__dict__}")
    
    async def run_after_finalise(
        status: EventFutureStatus, data: list[WebhookHistory] | None
    ):
        # s'execute apr√®s la r√©cup√©ration d'√©coute perdue une fois que la reponse de fedapay est re√ßue
        # ou que le timeout naturel survient
        if status == EventFutureStatus.RESOLVED:
            print("\nTransaction r√©ussie\n")
            print(f"\nDonn√©es finales : {data}\n")

            # ATTENTION :  Ce cas indique le reception d'une webhook valide et la cl√¥ture de la transaction mais ne veut pas syst√©matiquement dire due l'op√©ration √† √©t√© approuv√©e

            # Il faudra implementer par la suite votre gestion des webhook pour la validation ou tout autre traitement du paiement effectuer √† partir de la liste d'objet WebhookTransaction re√ßu.

        elif status == EventFutureStatus.TIMEOUT:
            # La v√©rification manuelle du statut de la transaction se fait automatiquement si timeout donc si timeout est lev√© pas besoin de rev√©rifier manuellement le status sur le coup.

            print("\nLa transaction a expir√©.\n")

        elif status == EventFutureStatus.CANCELLED:
            print("\nTransaction annul√©e par l'utilisateur\n")

        elif status == EventFutureStatus.CANCELLED_INTERNALLY:
            print("\nTransaction annul√©e en interne -- probable redemarrage ou arret de l'application\n")

    # Creation de l'instance Fedapay Connector
    fedapay = FedapayConnector(use_listen_server= True) 

    # Configuration des callbacks
    fedapay.set_payment_callback_function(payment_callback) # executer a chaques appels reussi a fedapay_pay()
    fedapay.set_webhook_callback_function(webhook_callback) # executer √† la r√©ception de webhooks fedapay valides
    fedapay.set_on_persited_listening_processes_loading_finished_callback(run_after_finalise) 
    # √©xectuer lors de la r√©cup√©ration des ecoutes d'event fedapay perduent lors d'un potentiel 
    # redemarrage de l'app pendant que des ecoutes sont actives.

    # lancement de la restauration des processus d'√©coute
    await fedapay.load_persisted_listening_processes()

    # D√©marrage du listener interne
    fedapay.start_webhook_server()

    # Configuration paiement
    setup = PaiementSetup(
        pays=Pays.benin,
        method=MethodesPaiement.moov
    )
    
    client = UserData(
        nom="Doe",
        prenom="John",
        email="john@example.com",
        tel="0164000001"
    )

    # Ex√©cution paiement
    resp = await fedapay.fedapay_pay(
        setup=setup,
        client_infos=client,
        montant_paiement=1000,
        payment_contact="0162626262"
    )

    # Attente r√©sultat
    status, webhooks = await fedapay.fedapay_finalise(resp.transaction.id)


if __name__ == "__main__":
    asyncio.run(main())
```

#### 4. Mode API Existante (Int√©gration FastAPI ou framework similaire)

Dans des cas d'usage comme pour un backend FastAPI vous devrez faire l'initialisation du module dans le lifespan au demarrage de FastAPI puis l'utiliser directement dans vos logiques m√©tiers pour le traitement des transaction.

```python
from fastapi import FastAPI
from contextlib import asynccontextmanager
from fedapay_connector import FedapayConnector


... code du fichier main.py ...

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Creation de l'instance Fedapay Connector
    fedapay = FedapayConnector(use_listen_server= False) 

    # importer ou definissez prealablement les callabacks si voulu
    # Configuration des callbacks
    fedapay.set_payment_callback_function(payment_callback) # executer a chaques appels reussi a fedapay_pay()
    fedapay.set_webhook_callback_function(webhook_callback) # executer √† la r√©ception de webhooks fedapay valides
    fedapay.set_on_persited_listening_processes_loading_finished_callback(run_after_finalise) # √©xectuer lors de la r√©cup√©ration des ecoutes d'event fedapay perduent lors d'un potentiel redemarrage de l'app pendant que des ecoutes sont actives.

    # lancement de la restauration des processus d'√©coute
    await fedapay.load_persisted_listening_processes()

    yield

    #permet un arret propre de fedapay connector
    await fedapay.shutdown_cleanup()

app = FastAPI(lifespan=lifespan)

@app.post("/webhooks/fedapay")
async def fedapay_webhook(request: Request):
    payload = await request.body()
    headers = request.headers
    
    # Validation signature
    signature = headers.get("x-fedapay-signature")
    FedapayConnector().verify_signature(payload, signature)
    
    # Traitement webhook
    event = await request.json()
    await FedapayConnector().fedapay_save_webhook_data(event)
    
    return {"status": "success"}
    
... suite de votre code ...
```

Si les methodes de paiement que vous souhaiter utilis√©s ne sont pas disponibles en paiement sans redirection vous devrez recup√©rer le paiement link et le retourner au front end pour affichage dans une webview ou un element similaire pour finalisation par l'utilisateur.
Le satut sera toutefois toujours capturer par le backend directement donc il n'est pas neccessaire de le recup√©rer cot√© client. 

### Modes d'Utilisation module Integration (Utilisation avanc√©e)

Pour les utilisateurs qui souhaitent un contr√¥le plus granulaire des appels HTTP vers l'API FedaPay (CRUD complet sur Transactions, Events, Balances, Currencies, Logs, Webhooks), utilisez la classe `Integration` fournie dans le package.

Principales caract√©ristiques :
- Fournit un point d'entr√©e unique pour les services bas-niveau : `Transactions`, `Balances`, `Currencies`, `Events`, `Logs`, `Webhooks`.
- Utilis√©e quand vous ne voulez pas du workflow automatique (Listeners / Futures) g√©r√© par `FedapayConnector` et pr√©f√©rez appeler manuellement les endpoints.

Constructeur :
- `Integration(api_url: str = os.getenv("FEDAPAY_API_URL"), logger: logging.Logger = None, default_api_key: Optional[str] = os.getenv("FEDAPAY_API_KEY"))`
- Remarque importante : `api_url` et `default_api_key` sont requis (ou doivent √™tre fournis via les variables d'environnement). Si l'un d'eux manque, le constructeur l√®vera `ValueError`.

Exemple d'utilisation basique :

```python
import asyncio
from fedapay_connector.integration import Integration

async def main():
    integ = Integration()  # lit FEDAPAY_API_URL et FEDAPAY_API_KEY depuis l'env

    # R√©cup√©rer une transaction par ID Fedapay
    tx = await integ.get_transaction_by_fedapay_id("12345")
    print(tx)

    # Cr√©er une transaction (voir models.PaiementSetup / UserData)
    setup = PaiementSetup(...)
    client = UserData(...)
    new_tx = await integ.create_transaction(setup, client, montant_paiement=1000)

    # R√©cup√©rer lien / token
    token = await integ.get_transaction_link(new_tx.id)

    # Lister les √©v√©nements
    events = await integ.get_all_events(params={})

asyncio.run(main())
```

Notes pratiques :
- Les m√©thodes `Integration` renvoient les mod√®les Pydantic pr√©sents dans `fedapay_connector.models` (ex: `Transaction`, `TransactionListResponse`, `EventResponse`).
- Pour les tests, mockez les m√©thodes des services internes (par ex. `Transactions._get_transaction_by_fedapay_id`) lorsque vous v√©rifiez la logique m√©tier d√©pendante du r√©seau.
- `Integration` est synchrone avec l'API asynchrone (utilise `aiohttp` en interne) ‚Äî appelez-le depuis une coroutine ou via `asyncio.run()`.


## Fonctionnalit√©s Avanc√©es

### Gestion des Webhooks

```python
# 1. Serveur Int√©gr√©
fedapay = FedapayConnector(
    use_listen_server=True,
    listen_server_port=3000,
    listen_server_endpoint_name="webhooks"
)
fedapay.start_webhook_server()  # convenience wrapper -> calls `WebhookServer.start_webhook_listenning()`

# 2. Int√©gration API Existante
fedapay = FedapayConnector(use_listen_server=False)
await fedapay.fedapay_save_webhook_data(webhook_data)
```

Cycle de vie du serveur interne:
- Le serveur interne est lanc√© dans un thread d'arri√®re-plan. FedapayConnector expose :
    - `start_webhook_server()` -> D√©marre le serveur interne .
    - `shutdown_cleanup()` -> m√©thode asynchrone qui annule les futures d'√©v√©nements en attente, attend les t√¢ches de rappel (avec un d√©lai d'attente) et arr√™te le serveur webhook via `stop_webhook_listenning()`.

Recommendation: call `await fedapay.shutdown_cleanup()` from your application's shutdown handler (FastAPI lifespan or SIGTERM) to ensure persisted listeners and callback tasks are cleaned up correctly.

### Callbacks Personnalis√©s

```python
async def on_payment(payment: PaymentHistory):
    """Appel√© apr√®s chaque paiement"""
    print(f"Nouveau paiement: {payment.transaction.id}")
    
async def on_webhook(webhook: WebhookHistory):
    """Appel√© pour chaque webhook"""
    print(f"Webhook re√ßu: {webhook.name}")

async def run_after_finalise(
    status: EventFutureStatus, data: list[WebhookHistory] | None
):
    """Appel√© apr√®s la r√©solution d'√©coutes r√©cup√©r√©es """
    
    if status == EventFutureStatus.RESOLVED:
        print("\nTransaction r√©ussie\n")
        print(f"\nDonn√©es finales : {data}\n")

    elif status == EventFutureStatus.TIMEOUT:
        print("\nLa transaction a expir√©.\n")

    elif status == EventFutureStatus.CANCELLED:
        print("\nTransaction annul√©e par l'utilisateur\n")
    
    elif future_event_status == EventFutureStatus.CANCELLED_INTERNALLY:
            print("\nTransaction annul√©e en interne -- probable redemarrage ou arret de l'application\n")

fedapay.set_payment_callback_function(on_payment)
fedapay.set_webhook_callback_function(on_webhook)
fedapay.set_on_persited_listening_processes_loading_finished_callback(run_after_finalise)
```

### Persistence et Restauration

Le module g√®re automatiquement :
- Sauvegarde des transactions en cours
- Restauration apr√®s red√©marrage
- Reprise des √©couteurs interrompus
- Synchronisation avec FedaPay

## üîß D√©pannage

### Probl√®mes Courants

1. **Les webhooks ne sont pas re√ßus**
   - V√©rifier l'URL configur√©e dans FedaPay
   - V√©rifier la cl√© secr√®te webhook

2. **Erreurs de timeout**
   - Augmenter la valeur du timeout
   - V√©rifier la connexion r√©seau
   - Consulter les logs pour plus de d√©tails

## Contribution

Les contributions sont les bienvenues!

## Licence

Ce projet est sous licence GNU Affero General Public License v3.0 or later (AGPL-3.0-or-later). Consultez le fichier LICENSE pour plus d'informations.

## üîí S√©curit√©

- Ne jamais exposer les cl√©s API
- Toujours valider les signatures webhook
- Utiliser HTTPS en production
- Impl√©menter des timeouts appropri√©s