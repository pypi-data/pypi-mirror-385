import{a as fe}from"./chunk-43LQFSHA.js";var W={};W.layout=(I,L,V,$)=>{let X=0,D=e=>{let d=++X;return e+d},Q=e=>{if(Array.isArray(e)&&e.every(t=>!Array.isArray(t)))return e;let d=[];for(let t of e){if(!Array.isArray(t)){d.push(t);continue}for(let i of t)d.push(i)}return d},H=(e,d,t,i)=>{let a="";do a=D(i);while(e.hasNode(a));return t.dummy=d,e.setNode(a,t),a},K=e=>{let d=new W.Graph(!0,!1);for(let t of e.nodes.values()){let i=t.v;e.hasChildren(i)||d.setNode(i,t.label)}for(let t of e.edges.values())d.setEdge(t.v,t.w,t.label);return d},se=e=>{let d=Number.NEGATIVE_INFINITY;for(let t of e.nodes.values()){let i=t.label.rank;i!==void 0&&i>d&&(d=i)}return d===Number.NEGATIVE_INFINITY?void 0:d},oe=e=>{let d=se(e),t=d===void 0?0:d+1,i=Array.from(new Array(t),()=>[]);for(let a of e.nodes.values()){let n=a.label,c=n.rank;c!==void 0&&(i[c][n.order]=a.v)}return i},le=(e,d,t)=>{t.ranksep/=2;let i=t.rankdir;for(let a of e.edges.values()){let n=a.label;n.minlen*=2,n.labelpos.toLowerCase()!=="c"&&(i==="TB"||i==="BT"?n.width+=n.labeloffset:n.height+=n.labeloffset)}},he=e=>{for(let d of e.edges.values())if(d.v===d.w){let t=d.vNode.label;t.selfEdges||(t.selfEdges=[]),t.selfEdges.push({e:d,label:d.label}),e.removeEdge(d)}},ue=e=>{let d=[],t=new Set,i=new Set,a=Array.from(e.nodes.keys()).reverse();for(;a.length>0;){let n=a.pop();if(Array.isArray(n))i.delete(n[0]);else if(!t.has(n)){t.add(n),i.add(n),a.push([n]);let c=e.node(n).out;for(let u=c.length-1;u>=0;u--){let m=c[u];i.has(m.w)&&d.push(m),a.push(m.w)}}}for(let n of d){let c=n.label;e.removeEdge(n),c.forwardName=n.name,c.reversed=!0,e.setEdge(n.w,n.v,c,D("rev"))}},be=e=>{for(let d of e.edges.values()){let t=d.label;if(t.reversed){t.points.reverse(),e.removeEdge(d);let i=t.forwardName;delete t.reversed,delete t.forwardName,e.setEdge(d.w,d.v,t,i)}}},re=(e,d)=>d.wNode.label.rank-d.vNode.label.rank-d.label.minlen,pe=e=>{e=K(e);let d=a=>{let n=new W.Graph(!1,!1),c=a.nodes.keys().next().value,u=a.nodes.size;n.setNode(c,{});let m=(w,O)=>{let A=Array.from(w.nodes.keys()).reverse();for(;A.length>0;){let P=A.pop(),z=O.node(P);for(let E of z.in.concat(z.out)){let C=E.v,G=P===C?E.w:C;!w.hasNode(G)&&!re(O,E)&&(w.setNode(G,{}),w.setEdge(P,G,{}),A.push(G))}}return w.nodes.size};for(;m(n,a)<u;){let w=Number.MAX_SAFE_INTEGER,O=null;for(let P of a.edges.values())if(n.hasNode(P.v)!==n.hasNode(P.w)){let z=re(a,P);z<w&&(w=z,O=P)}let A=n.hasNode(O.v)?re(a,O):-re(a,O);for(let P of n.nodes.keys())a.node(P).label.rank+=A}return n},t=a=>{let n=new Set,c=[Array.from(a.nodes.values()).filter(u=>u.in.length===0).reverse()];for(;c.length>0;){let u=c[c.length-1];if(Array.isArray(u)){let m=u.pop();if(u.length===0&&c.pop(),!n.has(m)){n.add(m);let w=m.out.map(O=>O.wNode);w.length>0?(c.push(m),c.push(w.reverse())):m.label.rank=0}}else{c.pop();let m=Number.MAX_SAFE_INTEGER;for(let w of u.out)m=Math.min(m,w.wNode.label.rank-w.label.minlen);u.label.rank=m}}},i=a=>{let n=E=>{let C=new W.Graph(!0,!1);for(let G of E.nodes.values())C.setNode(G.v,G.label);for(let G of E.edges.values()){let h=C.edge(G.v,G.w),_=h?h.label:{weight:0,minlen:1},v=G.label;C.setEdge(G.v,G.w,{weight:_.weight+v.weight,minlen:Math.max(_.minlen,v.minlen)})}return C},c=(E,C)=>{let G=(_,v,k)=>{let l=1,s=new Map,r=[[k,null,0]];for(;r.length>0;){let[o,f,b]=r.pop();if(b===0){if(!v.has(o)){v.add(o);let p=_.node(o).label,N=l;s.set(o,{label:p,low:N,parent:f,lim:null}),r.push([o,f,1]);for(let y of _.neighbors(o))v.has(y)||r.push([y,o,0])}}else{let p=s.get(o),N=p.label;N.low=p.low,N.lim=l++,p.parent?N.parent=p.parent:delete N.parent}}};C=E.nodes.keys().next().value,G(E,new Set,C)},u=(E,C)=>{let G=[],h=new Set,_=[Array.from(E.nodes.keys()).reverse()];for(;_.length>0;){let v=_[_.length-1];if(Array.isArray(v)){let k=v.pop();if(v.length===0&&_.pop(),!h.has(k)){h.add(k);let l=E.neighbors(k);l.size>0?(_.push(k),_.push(Array.from(l).reverse())):G.push(k)}}else G.push(_.pop())}for(let v of G.slice(0,G.length-1)){let l=E.node(v).label.parent,s=C.edge(v,l),r=!!s,f=(s?s.label:C.edge(l,v).label).weight,b=C.node(v);for(let p of b.in.concat(b.out)){let N=p.v===v,y=N?p.w:p.v;if(y!==l){let g=N===r;f+=g?p.label.weight:-p.label.weight;let M=E.edge(v,y);if(M){let x=M.label.cutvalue;f+=g?-x:x}}}E.edge(v,l).label.cutvalue=f}},m=E=>Array.from(E.edges.values()).find(C=>C.label.cutvalue<0),w=(E,C,G)=>{let h=G.v,_=G.w;C.edge(h,_)||(h=G.w,_=G.v);let v=E.node(h).label,k=E.node(_).label,l=v,s=!1;v.lim>k.lim&&(l=k,s=!0);let r=(b,p)=>p.low<=b.lim&&b.lim<=p.lim,o=Number.POSITIVE_INFINITY,f=null;for(let b of C.edges.values())if(s===r(E.node(b.v).label,l)&&s!==r(E.node(b.w).label,l)){let p=re(C,b);p<o&&(o=p,f=b)}return f},O=(E,C,G,h)=>{E.removeEdge(G),E.setEdge(h.v,h.w,{}),c(E),u(E,C);let v=[Array.from(E.nodes.keys()).find(s=>!C.node(s).label.parent)],k=new Set;for(;v.length>0;){let s=v.pop();if(!k.has(s)){k.add(s);let r=Array.from(E.neighbors(s));for(let o=r.length-1;o>=0;o--)v.push(r[o])}}let l=Array.from(k);for(let s of l.slice(1)){let r=E.node(s).label.parent,o=C.edge(s,r),f=!1;o||(o=C.edge(r,s),f=!0),C.node(s).label.rank=C.node(r).label.rank+(f?o.label.minlen:-o.label.minlen)}};a=n(a),t(a);let A=d(a);c(A),u(A,a);let P=null,z=null;for(;P=m(A);)z=w(A,a,P),O(A,a,P,z)};switch(V.ranker){case"tight-tree":t(e),d(e);break;case"longest-path":t(e);break;default:i(e);break}},we=e=>{for(let d of e.edges.values()){let t=d.label;if(t.width&&t.height){let i=d.vNode.label,a=d.wNode.label;H(e,"edge-proxy",{rank:(a.rank-i.rank)/2+i.rank,e:d},"_ep")}}},ge=(e,d)=>{if(e.nodes.size>0){let t=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,a=Array.from(e.nodes.values());for(let c of a){let u=c.label;u.rank!==void 0&&(t=Math.min(t,u.rank),i=Math.max(i,u.rank))}let n=i-t;if(n>0){let c=new Array(n);for(let w of a){let O=w.label;if(O.rank!==void 0){let A=O.rank-t;c[A]||(c[A]=[]),c[A].push(w.v)}}let u=0,m=d.nodeRankFactor;for(let w=0;w<c.length;w++){let O=c[w];if(O===void 0&&w%m!==0)u--;else if(u&&O)for(let A of O)e.node(A).label.rank+=u}}}},me=(e,d)=>{let t=H(e,"root",{},"_root"),i=w=>{let O={},A=(P,z)=>{for(let E of w.children(P))A(E,z+1);O[P]=z};for(let P of w.children())A(P,1);return O},a=(w,O,A,P,z,E,C)=>{let G=Array.from(w.children(C));if(!G.length){C!==O&&w.setEdge(O,C,{weight:0,minlen:A});return}let h=H(w,"border",{width:0,height:0},"_bt"),_=H(w,"border",{width:0,height:0},"_bb"),v=w.node(C).label;w.hasBorder=!0,w.setParent(h,C),v.borderTop=h,w.setParent(_,C),v.borderBottom=_;for(let k of G){a(w,O,A,P,z,E,k);let l=w.node(k).label,s=l.borderTop?l.borderTop:k,r=l.borderBottom?l.borderBottom:k,o=l.borderTop?P:2*P,f=s===r?z-E[C]+1:1;w.setEdge(h,s,{weight:o,minlen:f,nestingEdge:!0}),w.setEdge(r,_,{weight:o,minlen:f,nestingEdge:!0})}w.parent(C)||w.setEdge(O,h,{weight:0,minlen:z+E[C]})},n=i(e),c=Math.max(...Object.values(n))-1,u=2*c+1;d.nestingRoot=t;for(let w of e.edges.values())w.label.minlen*=u;let m=Array.from(e.edges.values()).reduce((w,O)=>w+O.label.weight,0)+1;for(let w of e.children())a(e,t,u,m,c,n,w);d.nodeRankFactor=u},ve=(e,d)=>{e.removeNode(d.nestingRoot),delete d.nestingRoot;for(let t of e.edges.values())t.label.nestingEdge&&e.removeEdge(t)},ye=(e,d)=>{let t=Number.POSITIVE_INFINITY;for(let a of e.nodes.values()){let n=a.label.rank;n!==void 0&&n<t&&(t=n)}for(let a of e.nodes.values()){let n=a.label;n.rank!==void 0&&(n.rank-=t)}let i=0;if(e.hasBorder)for(let a of e.nodes.values()){let n=a.label;n.borderTop&&(n.minRank=e.node(n.borderTop).label.rank,n.maxRank=e.node(n.borderBottom).label.rank,i=Math.max(i,n.maxRank))}d.maxRank=i},xe=(e,d)=>{d.dummyChains=[];for(let t of e.edges.values()){let i=t.v,a=t.w,n=t.name,c=t.label,u=c.labelRank,m=e.node(i).label.rank,w=e.node(a).label.rank;if(w!==m+1){e.removeEdge(t);let O=!0;for(m++;m<w;){c.points=[],delete t.key;let A={width:0,height:0,edgeLabel:c,edgeObj:t,rank:m},P=H(e,"edge",A,"_d");m===u&&(A.width=c.width,A.height=c.height,A.dummy="edge-label",A.labelpos=c.labelpos),e.setEdge(i,P,{weight:c.weight},n),O&&(d.dummyChains.push(P),O=!1),i=P,m++}e.setEdge(i,a,{weight:c.weight},n)}}},ke=(e,d)=>{for(let t of d.dummyChains){let i=e.node(t).label,a=i.edgeLabel,n=i.edgeObj;for(e.setEdge(n.v,n.w,a,n.name);i.dummy;){let c=e.successors(t).keys().next().value;e.removeNode(t),a.points.push({x:i.x,y:i.y}),i.dummy==="edge-label"&&(a.x=i.x,a.y=i.y,a.width=i.width,a.height=i.height),t=c,i=e.node(t).label}}},Ne=e=>{for(let d of e.nodes.values()){let t=d.label;t.dummy==="edge-proxy"&&(t.e.label.labelRank=t.rank,e.removeNode(d.v))}},Ie=(e,d)=>{let t=(n,c,u,m)=>{let w=Math.min(c[u].low,c[m].low),O=Math.max(c[u].lim,c[m].lim),A=u,P=[];do A=n.parent(A),P.push(A);while(A&&(c[A].low>w||O>c[A].lim));let z=A;A=m;let E=[];for(;(A=n.parent(A))!==z;)E.push(A);return{path:P.concat(E.reverse()),lca:z}},a=(n=>{let c={},u=0,m=w=>{let O=u;for(let A of n.children(w))m(A);c[w]={low:O,lim:u++}};for(let w of n.children())m(w);return c})(e);for(let n of d.dummyChains||[]){let u=e.node(n).label.edgeObj,m=t(e,a,u.v,u.w),w=m.path,O=m.lca,A=0,P=w[A],z=!0;for(;n!==u.w;){let E=e.node(n).label;if(z){for(;(P=w[A])!==O&&e.node(P).label.maxRank<E.rank;)A++;P===O&&(z=!1)}if(!z){for(;A<w.length-1&&e.node(w[A+1]).label.minRank<=E.rank;)A++;P=w[A]}e.setParent(n,P),n=e.successors(n).keys().next().value}}},Ee=e=>{let d=(i,a,n,c,u,m)=>{let w={width:0,height:0,rank:m,borderType:a},O=u[a][m-1],A=H(i,"border",w,n);u[a][m]=A,i.setParent(A,c),O&&i.setEdge(O,A,{weight:1})},t=Array.from(e.children());for(let i=0;i<t.length;i++){let a=t[i],n=e.node(a).label;if("minRank"in n){n.borderLeft=[],n.borderRight=[];let u=n.maxRank+1;for(let m=n.minRank;m<u;m++)d(e,"borderLeft","_bl",a,n,m),d(e,"borderRight","_br",a,n,m)}let c=e.children(a);for(let u of c)t.push(u)}},_e=e=>{let d=(h,_,v,k)=>{let l=(x,T)=>{let S=new Map;for(let R=0;R<x.length;R++){let j=x[R],U={indegree:0,in:[],out:[],vs:[j.v],i:R};j.barycenter!==void 0&&(U.barycenter=j.barycenter,U.weight=j.weight),S.set(j.v,U)}for(let R of T.edges.values()){let j=S.get(R.v),U=S.get(R.w);j&&U&&(U.indegree++,j.out.push(U))}let F=Array.from(S.values()).filter(R=>!R.indegree),Y=[],B=function(R){return function(j){if(!j.merged&&(j.barycenter===void 0||R.barycenter===void 0||j.barycenter>=R.barycenter)){let U=0,ee=0;R.weight&&(U+=R.barycenter*R.weight,ee+=R.weight),j.weight&&(U+=j.barycenter*j.weight,ee+=j.weight),R.vs=j.vs.concat(R.vs),R.barycenter=U/ee,R.weight=ee,R.i=Math.min(j.i,R.i),j.merged=!0}}},q=R=>function(j){j.in.push(R),--j.indegree===0&&F.push(j)};for(;F.length;){let R=F.pop();Y.push(R),R.in.reverse().forEach(B(R)),R.out.forEach(q(R))}return Y.filter(R=>!R.merged).map(R=>{let j={vs:R.vs,i:R.i};return R.barycenter!==void 0&&(j.barycenter=R.barycenter),R.weight!==void 0&&(j.weight=R.weight),j})},s=(x,T)=>Array.from(T).map(S=>{let F=x.node(S).in;if(!F.length)return{v:S};let Y=F.reduce((B,q)=>{let R=q.label,j=q.vNode.label;return{sum:B.sum+R.weight*j.order,weight:B.weight+R.weight}},{sum:0,weight:0});return{v:S,barycenter:Y.sum/Y.weight,weight:Y.weight}}),r=(x,T)=>{let S=(J,Z,ne)=>{let ce=null;for(;Z.length&&(ce=Z[Z.length-1]).i<=ne;)Z.pop(),J.push(ce.vs),ne++;return ne},F=J=>function(Z,ne){return Z.barycenter<ne.barycenter?-1:Z.barycenter>ne.barycenter?1:J?ne.i-Z.i:Z.i-ne.i},Y={lhs:[],rhs:[]};for(let J of x)"barycenter"in J?Y.lhs.push(J):Y.rhs.push(J);let B=Y.lhs,q=Y.rhs.sort((J,Z)=>-J.i+Z.i),R=[],j=0,U=0,ee=0;B.sort(F(!!T)),ee=S(R,q,ee);for(let J of B)ee+=J.vs.length,R.push(J.vs),j+=J.barycenter*J.weight,U+=J.weight,ee=S(R,q,ee);let ie={vs:Q(R)};return U&&(ie.barycenter=j/U,ie.weight=U),ie},o=h.node(_),f=o&&o.label?o.label.borderLeft:void 0,b=o&&o.label?o.label.borderRight:void 0,p={},N=f?Array.from(h.children(_)).filter(x=>x!==f&&x!==b):h.children(_),y=s(h,N);for(let x of y)if(h.hasChildren(x.v)){let T=d(h,x.v,v,k);p[x.v]=T,"barycenter"in T&&(x.barycenter===void 0?(x.barycenter=T.barycenter,x.weight=T.weight):(x.barycenter=(x.barycenter*x.weight+T.barycenter*T.weight)/(x.weight+T.weight),x.weight+=T.weight))}let g=l(y,v);for(let x of g)x.vs=Q(x.vs.map(T=>p[T]?p[T].vs:T));let M=r(g,k);if(f){M.vs=Q([f,M.vs,b]);let x=h.predecessors(f);if(x.size>0){let T=h.node(x.keys().next().value).label,S=h.node(h.predecessors(b).keys().next().value).label;"barycenter"in M||(M.barycenter=0,M.weight=0),M.barycenter=(M.barycenter*M.weight+T.order+S.order)/(M.weight+2),M.weight+=2}}return M},t=(h,_)=>{let v=new W.Graph(!0,!1);for(let k of h){let l=k.root,r=d(k,l,v,_).vs,o=r.length;for(let N=0;N<o;N++)k.node(r[N]).label.order=N;let f={},b="",p=!1;for(let N of r){let y=k.parent(N),g=null;for(;y;){let M=k.parent(y);if(M?(g=f[M],f[M]=y):(g=b,b=y),g&&g!==y){v.setEdge(g,y,null),p=!0;break}y=M}if(p)break}}},i=(h,_,v)=>{let k=0;for(let l=1;l<_.length;l++){let s=_[l-1],r=_[l],o=new Map;for(let y=0;y<r.length;y++)o.set(r[y],y);let f=[];for(let y of s){let g=[];for(let M of h.node(y).out)g.push({pos:o.get(M.w),weight:M.label.weight});g.sort((M,x)=>M.pos-x.pos);for(let M of g)f.push(M)}let b=1;for(;b<r.length;)b<<=1;let p=2*b-1;b-=1;let N=Array.from(new Array(p),()=>0);for(let y of f){let g=y.pos+b;N[g]+=y.weight;let M=0;for(;g>0;)g%2&&(M+=N[g+1]),g=g-1>>1,N[g]+=y.weight;k+=y.weight*M}if(k>v)break}return k},a=h=>{let _=new Set,v=Array.from(h.nodes.values()).filter(l=>!h.hasChildren(l.v)),k=-1;for(let l of v){let s=l.label.rank;(k===-1||s!==void 0&&s>k)&&(k=s)}if(k!==-1){let l=Array.from(new Array(k+1),()=>[]),s=v.sort((r,o)=>r.label.rank-o.label.rank).map(r=>r.v).reverse();for(let r=0;r<s.length;r++){let o=s[r];if(!_.has(o)){_.add(o);let f=h.node(o).label.rank;l[f].push(o),s.push(...h.successors(o).keys())}}return l}return[]},n=(h,_,v,k,l)=>{let s="";for(;h.hasNode(s=D("_root")););let r=new W.Graph(!0,!0);r.root=s,r.setDefaultNodeLabel(f=>{let b=h.node(f);return b?b.label:void 0});let o=_.length;if(h.hasBorder){let f=0;for(;f<o;){let b=_[f++],p=b.label;if(p.rank===k||"minRank"in p&&"maxRank"in p&&p.minRank<=k&&k<=p.maxRank){let N=b.v;r.setNode(N);let y=h.parent(N);if(r.setParent(N,y||s),l)for(let g of b.in)r.setEdge(g.v,N,{weight:g.label.weight});else for(let g of b.out)r.setEdge(g.w,N,{weight:g.label.weight});"minRank"in p&&r.setNode(N,{borderLeft:p.borderLeft[k],borderRight:p.borderRight[k]})}}}else{let f=v.get(k);for(;f<o;){let b=_[f++];if(b.label.rank!==k)break;let N=b.v;r.setNode(N);let y=h.parent(N);if(r.setParent(N,y||s),l)for(let g of b.in)r.setEdge(g.v,N,{weight:g.label.weight});else for(let g of b.out)r.setEdge(g.w,N,{weight:g.label.weight})}}return r},c=a(e),u=(h,_)=>{for(let v of _)for(let k=0;k<v.length;k++)h.node(v[k]).label.order=k};u(e,c);let m=se(e)||0,w=new Array(m),O=new Array(m),A=Array.from(e.nodes.values()),P=null;if(!e.hasBorder){A.sort((h,_)=>h.label.rank-_.label.rank),P=new Map;for(let h=0;h<A.length;++h){let v=A[h].label.rank;P.has(v)||P.set(v,h)}}for(let h=0;h<m;h++)w[h]=n(e,A,P,h+1,!0),O[h]=n(e,A,P,m-h-1,!1);let z=Number.POSITIVE_INFINITY,E=[];for(let h=0,_=0;_<4;++h,++_){t(h%2?w:O,h%4>=2),c=oe(e);let v=i(e,c,z);if(v<z){_=0;let k=c.length;E=new Array(k);for(let l=0;l<k;l++)E[l]=c[l].slice();z=v}}let C=(h,_)=>h<_?1:2;for(let h=4;h<E.length;h+=2){let _=E[h];for(let v=0;v<_.length;++v){let k=e.nodes.get(_[v]);if(k.in&&k.in.length===2){let l=k.in[0].vNode.in[0].vNode,s=k.in[1].vNode.in[0].vNode,r=[],o=0;for(let f=h-2;f>=0;f-=2){let b=E[f],p=b.indexOf(l.v),N=b.indexOf(s.v),y=C(p,N);if(o|=y,p===N||Math.abs(p-N)!==1||l.in.length!==1||s.in.length!==1||l.out.length!==1||s.out.length!==1){if(o===3){let g=y,M=f+2;for(;r.length!==0;){let x=r.pop(),T=r.pop(),S=E[M],F=E[M-1],Y=F.indexOf(e.node(S[T]).in[0].v),B=F.indexOf(e.node(S[x]).in[0].v);C(T,x)!==g&&([S[T],S[x]]=[S[x],S[T]]),C(Y,B)!==g&&([F[Y],F[B]]=[F[B],F[Y]]),M+=2}}break}r.push(p,N),l=l.in[0].vNode.in[0].vNode,s=s.in[0].vNode.in[0].vNode}}}}let G=(h,_,v)=>{let k=h.indexOf(_.v),l=h.indexOf(v.v);h[l]=_.v,h[k]=v.v};for(let h=0;h<E.length-2;h+=2){let _=E[h],v=E[h+1],k=E[h+2];for(let l=0;l<_.length;++l){let s=e.nodes.get(_[l]);if(s.out&&s.out.length>=2)for(let r=0;r<s.out.length-1;++r){let o=s.out[r].wNode,f=s.out[r+1].wNode,b=o.out[0].wNode,p=f.out[0].wNode;v.indexOf(o.v)<v.indexOf(f.v)^k.indexOf(b.v)<k.indexOf(p.v)&&G(v,o,f)}}for(let l=0;l<k.length;++l){let s=e.nodes.get(k[l]);if(s.in&&s.in.length>=2)if(s.in.length===2){let r=s.in[0].vNode,o=s.in[1].vNode,f=r.in[0].vNode,b=o.in[0].vNode;v.indexOf(r.v)<v.indexOf(o.v)^_.indexOf(f.v)<_.indexOf(b.v)&&G(v,r,o)}else{let r=[];for(let o=0;o<s.in.length;++o){let f=s.in[o].vNode,b=f.in[0].vNode,p=_.indexOf(b.v),N=v.indexOf(f.v);s.in[o].idx0=p,r.push(N)}s.in.sort((o,f)=>o.idx0-f.idx0),r.sort((o,f)=>o-f);for(let o=0;o<r.length;++o)v[r[o]]=s.in[o].v}}}for(let h=0;h<E.length-4;h+=2){let _=E[h],v=E[h+2],k=E[h+4];if(v.length>=2&&k.length>=2){let l=E[h+1],s=E[h+3];for(let r=0;r<_.length;++r){let o=e.nodes.get(_[r]);if(o.in&&o.out&&o.out.length>=2)for(let f=0;f<o.out.length-1;++f){let b=o.out[f].wNode,p=o.out[f+1].wNode,N=b.out[0].wNode,y=p.out[0].wNode;if(N.out.length===1&&y.out.length===1){let g=v.indexOf(N.v),M=v.indexOf(y.v);if(g+1===M){let x=N.out[0].wNode,T=y.out[0].wNode;if(x.out.length===1&&T.out.length===1){let S=x.out[0].wNode,F=T.out[0].wNode,Y=k.indexOf(S.v),B=k.indexOf(F.v);Y>B&&(G(l,b,p),G(v,N,y),G(s,x,T),++f)}}}}}for(let r=0;r<v.length-1;++r){let o=e.nodes.get(v[r]);if(o.in&&o.out&&o.in.length===1&&o.out.length===1){let f=e.nodes.get(v[r+1]);if(f.in&&f.out&&f.in.length===1&&f.out.length===1){let b=o.in[0].vNode,p=f.in[0].vNode;if(b.in.length===1&&p.in.length===1){let N=b.in[0].vNode,y=p.in[0].vNode,g=_.indexOf(N.v),M=_.indexOf(y.v);if(M+1===g){let x=o.out[0].wNode,T=f.out[0].wNode;g=s.indexOf(x.v),M=s.indexOf(T.v),g+1===M&&x.out[0].wNode===T.out[0].wNode&&(G(l,b,p),G(v,o,f),G(s,x,T),r+=1)}}}}}}}u(e,E)},Ae=e=>{let d=oe(e);for(let t of d){let i=0;t.forEach((a,n)=>{let c=e.node(a).label;if(c.order=n+i,c.selfEdges){for(let u of c.selfEdges)H(e,"selfedge",{width:u.label.width,height:u.label.height,rank:c.rank,order:n+ ++i,e:u.e,label:u.label},"_se");delete c.selfEdges}})}},de=e=>{for(let d of e.nodes.values()){let t=d.label,i=t.width;t.width=t.height,t.height=i}for(let d of e.edges.values()){let t=d.label,i=t.width;t.width=t.height,t.height=i}},Me=(e,d,t)=>{let i=t.rankdir.toLowerCase();(i==="lr"||i==="rl")&&de(e)},Te=(e,d,t)=>{let i=t.rankdir.toLowerCase();if(i==="bt"||i==="rl"){for(let a of e.nodes.values())a.label.y=-a.label.y;for(let a of e.edges.values()){let n=a.label;for(let c of n.points)c.y=-c.y;"y"in n&&(n.y=-n.y)}}if(i==="lr"||i==="rl"){let a=n=>{[n.x,n.y]=[n.y,n.x]};for(let n of e.nodes.values())a(n.label);for(let n of e.edges.values()){let c=n.label;for(let u of c.points)a(u);c.x!==void 0&&a(c)}de(e)}},Oe=(e,d,t)=>{let i=(l,s,r)=>{s>r&&([s,r]=[r,s]);let o=l.get(s);o||(o=new Set,l.set(s,o)),o.add(r)},a=(l,s,r)=>(s>r&&([s,r]=[r,s]),l.has(s)&&l.get(s).has(r)),n=(l,s,r,o,f)=>{let b=s.nodesep,p=s.edgesep,N=new W.Graph(!0,!1);for(let y of r){let g=null;for(let M of y){let x=o.get(M);if(N.setNode(x,{}),g){let T=o.get(g),S=l.node(M).label,F=l.node(g).label,Y=0,B=0;if(Y+=S.width/2,"labelpos"in S)switch(S.labelpos){case"l":B=-S.width/2;break;case"r":B=S.width/2;break;default:throw new W.Error(`Unsupported label position '${S.labelpos}'.`)}if(B&&(Y+=f?B:-B),B=0,Y+=(S.dummy?p:b)/2,Y+=(F.dummy?p:b)/2,Y+=F.width/2,"labelpos"in F)switch(F.labelpos){case"l":B=F.width/2;break;case"r":B=-F.width/2;break;default:throw new W.Error(`Unsupported label position '${F.labelpos}'.`)}B&&(Y+=f?B:-B);let q=N.edge(T,x),R=Math.max(Y,q?q.label:0);q?q.label=R:N.setEdge(T,x,R)}g=M}}return N},c=(l,s,r)=>{let o=new Map,f=new Map,b=new Map;for(let p of l){let N=0;for(let y of p)o.set(y,y),f.set(y,y),b.set(y,N),N++}for(let p of l){let N=-1;for(let y of p){let g=r(y);if(g.size>0){g=Array.from(g.keys()),g=g.sort((T,S)=>b.get(T)-b.get(S));let M=(g.length-1)/2.0000001,x=Math.ceil(M);for(let T=Math.floor(M);T<=x;T++){let S=g[T];if(f.get(y)===y&&N<b.get(S)&&!a(s,y,S)){let F=o.get(S);f.set(S,y),f.set(y,F),o.set(y,F),N=b.get(S)}}}}}return{root:o,align:f}},u=(l,s,r,o,f,b)=>{let p=n(l,s,r,o,b),N=b?"borderLeft":"borderRight",y=new Map;if(p.nodes.size>0){let g=Array.from(p.nodes.keys()),M=new Set;for(;g.length>0;){let x=g.pop();if(M.has(x)){let T=0;for(let S of p.node(x).in)T=Math.max(T,y.get(S.v)+S.label);y.set(x,T)}else M.add(x),g.push(x),g.push(...p.predecessors(x).keys())}}if(p.nodes.size>0){let g=Array.from(p.nodes.keys()),M=new Set;for(;g.length>0;){let x=g.pop();if(M.has(x)){let T=Number.POSITIVE_INFINITY;for(let F of p.node(x).out)T=Math.min(T,y.get(F.w)-F.label);let S=l.node(x).label;if(S.dummy)continue;T!==Number.POSITIVE_INFINITY&&S.borderType!==N&&y.set(x,Math.max(y.get(x),T))}else M.add(x),g.push(x),g.push(...p.successors(x).keys())}}for(let g of f.values())y.set(g,y.get(o.get(g)));return y},m=(l,s)=>{let r=new Map;if(s.length>0){let[o]=s;for(let f=1;f<s.length;f++){let b=s[f],p=0,N=0,y=o.length,g=b[b.length-1];for(let M=0;M<b.length;M++){let x=b[M],T=l.node(x).label.dummy?Array.from(l.predecessors(x).keys()).find(S=>l.node(S).label.dummy):null;if(T||x===g){let S=T?l.node(T).label.order:y;for(let F of b.slice(N,M+1))if(l.predecessors(F).size>0)for(let B of l.predecessors(F).keys()){let q=l.node(B).label,R=q.order;(R<p||S<R)&&!(q.dummy&&l.node(F).label.dummy)&&i(r,B,F)}N=M+1,p=S}}o=b}}return r},w=(l,s)=>{let r=new Map,o=(f,b,p,N,y)=>{for(let g=b;g<p;g++){let M=f[g];if(l.node(M).labeldummy)for(let x of l.predecessors(M).keys()){let T=l.node(x).label;T.dummy&&(T.order<N||T.order>y)&&i(r,x,M)}}};if(s.length>0){let[f]=s;for(let b=1;b<s.length;b++){let p=s[b],N=-1,y=0,g=0;p.forEach((M,x)=>{if(l.node(M).label.dummy==="border"){let T=l.predecessors(M);T.size>0&&(y=l.node(T.keys().next().value).label.order,o(p,g,x,N,y),g=x,N=y)}o(p,g,p.length,y,f.length)}),f=p}}return r};e=K(e);let O=oe(e),A=t.ranksep,P=0;for(let l of O){let s=l.reduce((r,o)=>Math.max(r,e.node(o).label.height),0);for(let r of l)e.node(r).label.y=P+s/2;P+=s+A}let z=new Map([...m(e,O).entries(),...w(e,O).entries()]),E={};for(let l of["u","d"]){let s=l==="u"?O:Object.values(O).reverse();for(let r of["l","r"]){r==="r"&&(s=s.map(p=>Object.values(p).reverse()));let o=(l==="u"?e.predecessors:e.successors).bind(e),f=c(s,z,o),b=u(e,t,s,f.root,f.align,r==="r");if(r==="r")for(let[p,N]of b.entries(b))b.set(p,-N);E[l+r]=b}}let C=Number.POSITIVE_INFINITY,G=null;for(let l of Object.values(E)){let s=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(let[f,b]of l.entries()){let p=e.node(f).label.width/2;s=Math.max(b+p,s),r=Math.min(b-p,r)}let o=s-r;o<C&&(C=o,G=l)}let h=G,_=l=>{let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let o of l)o<s&&(s=o),o>r&&(r=o);return[s,r]},v=_(h.values(h));for(let l of["u","d"])for(let s of["l","r"]){let r=l+s,o=E[r];if(o!==h){let f=_(o.values()),b=s==="l"?v[0]-f[0]:v[1]-f[1];if(b){let p=new Map;for(let[N,y]of o.entries())p.set(N,y+b);E[r]=p}}}let k=t.align;if(k){let l=E[k.toLowerCase()];for(let s of E.ul.keys())e.node(s).label.x=l.get(s)}else for(let l of E.ul.keys()){let s=[E.ul.get(l),E.ur.get(l),E.dl.get(l),E.dr.get(l)].sort((r,o)=>r-o);e.node(l).label.x=(s[1]+s[2])/2}},Re=e=>{for(let d of e.nodes.values()){let t=d.label;if(t.dummy==="selfedge"){let i=d.v,a=e.node(t.e.v).label,n=a.x+a.width/2,c=a.y,u=t.x-n,m=a.height/2;e.setEdge(t.e.v,t.e.w,t.label),e.removeNode(i),t.label.points=[{x:n+2*u/3,y:c-m},{x:n+5*u/6,y:c-m},{x:n+u,y:c},{x:n+5*u/6,y:c+m},{x:n+2*u/3,y:c+m}],t.label.x=t.x,t.label.y=t.y}}},Se=e=>{for(let d of e.nodes.values()){let t=d.v;if(e.hasChildren(t)){let i=d.label,a=e.node(i.borderTop).label,n=e.node(i.borderBottom).label,c=e.node(i.borderLeft[i.borderLeft.length-1]).label,u=e.node(i.borderRight[i.borderRight.length-1]).label;i.width=Math.abs(u.x-c.x),i.height=Math.abs(n.y-a.y),i.x=c.x+i.width/2,i.y=a.y+i.height/2}}for(let d of e.nodes.values())d.label.dummy==="border"&&e.removeNode(d.v)},Le=e=>{for(let d of e.edges.values()){let t=d.label;if("x"in t)switch((t.labelpos==="l"||t.labelpos==="r")&&(t.width-=t.labeloffset),t.labelpos){case"l":t.x-=t.width/2+t.labeloffset;break;case"r":t.x+=t.width/2+t.labeloffset;break;default:throw new W.Error(`Unsupported label position '${t.labelpos}'.`)}}},Pe=(e,d)=>{let t=Number.POSITIVE_INFINITY,i=0,a=Number.POSITIVE_INFINITY,n=0,c=u=>{let m=u.x,w=u.y,O=u.width,A=u.height;t=Math.min(t,m-O/2),i=Math.max(i,m+O/2),a=Math.min(a,w-A/2),n=Math.max(n,w+A/2)};for(let u of e.nodes.values())c(u.label);for(let u of e.edges.values()){let m=u.label;"x"in m&&c(m)}for(let u of e.nodes.values())u.label.x-=t,u.label.y-=a;for(let u of e.edges.values()){let m=u.label;for(let w of m.points)w.x-=t,w.y-=a;"x"in m&&(m.x-=t),"y"in m&&(m.y-=a)}d.width=i-t,d.height=n-a},Ce=e=>{let d=(t,i)=>{let a=t.x,n=t.y,c=i.x-a,u=i.y-n;if(c===0&&u===0)throw new Error("Not possible to find intersection inside of the rectangle");let m=t.width/2,w=t.height/2;return Math.abs(u)*m>Math.abs(c)*w?(w=u<0?-w:w,{x:a+w*c/u,y:n+w}):(m=c<0?-m:m,{x:a+m,y:n+m*u/c})};for(let t of e.edges.values()){let i=t.label,a=t.vNode.label,n=t.wNode.label,c=null,u=null;i.points?([c]=i.points,u=i.points[i.points.length-1]):(i.points=[],c=n,u=a),i.points.unshift(d(a,c)),i.points.push(d(n,u))}},te=new W.Graph(!0,!0);for(let e of I)te.setNode(e.v,{width:e.width,height:e.height}),e.parent&&te.setParent(e.v,e.parent);for(let e of L)te.setEdge(e.v,e.w,{minlen:e.minlen||1,weight:e.weight||1,width:e.width||0,height:e.height||0,labeloffset:e.labeloffset||10,labelpos:e.labelpos||"r"});V=fe({ranksep:50,edgesep:20,nodesep:50,rankdir:"tb"},V);let ae=[le,he,ue,me,pe,we,ge,ve,ye,Ne,xe,Ie,Ee,_e,Ae,Me,Oe,Re,Se,ke,Le,Te,Pe,Ce,be];for(;ae.length>0;)ae.shift()(te,$,V);for(let e of I){let d=te.node(e.v).label;e.x=d.x,e.y=d.y,te.hasChildren(e.v)&&(e.width=d.width,e.height=d.height)}for(let e of L){let d=te.edge(e.v,e.w).label;e.points=d.points,"x"in d&&(e.x=d.x,e.y=d.y)}$.log&&($.log=te.toString())};W.Graph=class{constructor(I,L){this.directed=I,this.compound=L,this._defaultNodeLabelFn=()=>{},this.nodes=new Map,this.edges=new Map,this.compound&&(this._parent=new Map,this._children=new Map,this._children.set("\0",new Map))}setDefaultNodeLabel(I){this._defaultNodeLabelFn=I}setNode(I,L){let V=this.nodes.get(I);if(V)L&&(V.label=L);else{let $={label:L||this._defaultNodeLabelFn(I),in:[],out:[],predecessors:new Map,successors:new Map,v:I};this.nodes.set(I,$),this.compound&&(this._parent.set(I,"\0"),this._children.set(I,new Map),this._children.get("\0").set(I,!0))}}node(I){return this.nodes.get(I)}hasNode(I){return this.nodes.has(I)}removeNode(I){let L=this.nodes.get(I);if(L){if(this.compound){this._children.get(this._parent.get(I)).delete(I),this._parent.delete(I);for(let V of this.children(I))this.setParent(V);this._children.delete(I)}for(let V of L.in.concat())this.removeEdge(V);for(let V of L.out.concat())this.removeEdge(V);this.nodes.delete(I)}}setParent(I,L){if(!this.compound)throw new Error("Cannot set parent in a non-compound graph");if(L){for(let V=L;V!==void 0;V=this.parent(V))if(V===I)throw new Error(`Setting ${L} as parent of ${I} would create a cycle.`);this.setNode(L)}else L="\0";this._children.get(this._parent.get(I)).delete(I),this._parent.set(I,L),this._children.get(L).set(I,!0)}parent(I){if(this.compound){let L=this._parent.get(I);if(L!=="\0")return L}return null}children(I){return this.compound?this._children.get(I===void 0?"\0":I).keys():I===void 0?this.nodes.keys():this.hasNode(I)?[]:null}hasChildren(I){return this.compound?this._children.get(I===void 0?"\0":I).size>0:I===void 0?this.nodes.size>0:!1}predecessors(I){return this.nodes.get(I).predecessors}successors(I){return this.nodes.get(I).successors}neighbors(I){let L=this.nodes.get(I),V=L.predecessors.keys(),$=L.successors.keys(),X=new Set;for(let D of V)X.add(D);for(let D of $)X.add(D);return X}edge(I,L){return this.edges.get(this._edgeKey(this.directed,I,L))}setEdge(I,L,V,$){let X=this._edgeKey(this.directed,I,L,$),D=this.edges.get(X);if(D)D.label=V;else{!this.directed&&I>L&&([I,L]=[L,I]);let Q={label:V,v:I,w:L,name:$,key:X,vNode:null,wNode:null};this.edges.set(X,Q),this.setNode(I),this.setNode(L);let H=this.nodes.get(L),K=this.nodes.get(I);Q.wNode=H,Q.vNode=K;let se=(oe,le)=>{oe.set(le,(oe.get(le)??0)+1)};se(H.predecessors,I),se(K.successors,L),H.in.push(Q),K.out.push(Q)}}removeEdge(I){let L=I.key,V=I.v,$=I.w,X=I.wNode,D=I.vNode;if(X.predecessors.has(V)){let K=X.predecessors.get(V);K===1?X.predecessors.delete(V):X.predecessors.set(V,K-1)}if(D.successors.has($)){let K=D.successors.get($);K===1?D.successors.delete($):D.successors.set($,K-1)}let Q=X.in.findIndex(K=>K.key===L);Q!==-1&&X.in.splice(Q,1);let H=D.out.findIndex(K=>K.key===L);H!==-1&&D.out.splice(H,1),this.edges.delete(L)}_edgeKey(I,L,V,$){return!I&&L>V?$?`${V}:${L}:${$}`:`${V}:${L}:`:$?`${L}:${V}:${$}`:`${L}:${V}:`}toString(){return["[nodes]",Array.from(this.nodes.values()).map(I=>JSON.stringify(I.label)).join(`
`),"[edges]",Array.from(this.edges.values()).map(I=>JSON.stringify(I.label)).join(`
`),"[parents]",JSON.stringify(this._parent,null,2),"[children]",JSON.stringify(this._children,null,2)].join(`
`)}};var{layout:Ge,Graph:Fe}=W;export{Fe as Graph,Ge as layout};
