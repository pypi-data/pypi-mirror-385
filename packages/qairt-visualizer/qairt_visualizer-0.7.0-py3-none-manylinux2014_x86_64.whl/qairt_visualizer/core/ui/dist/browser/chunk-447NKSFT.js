import{i as y}from"./chunk-43LQFSHA.js";var s={},w={},x={};s.Archive=class{static import(){return y(this,null,function*(){typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node<"u"&&(s.zlib=yield import("zlib"))})}static open(t,e){let i=t instanceof Uint8Array?new s.BinaryReader(t):t;if(i&&i.length>2){let h=i.peek(Math.min(512,i.length));if(h.length>=512){let r=h.map((l,p)=>p>=148&&p<156?32:l).reduce((l,p)=>l+p,0),o=parseInt(Array.from(h.slice(148,156)).map(l=>String.fromCharCode(l)).join("").split("\0").shift(),8);if(!isNaN(o)&&r===o)return null}if((!e||e==="zlib")&&h[0]===120&&((h[0]<<8)+h[1])%31===0)return new x.Archive(i);if((!e||e==="gzip")&&h.length>18&&h[0]===31&&h[1]===139)return new w.Archive(i);if(!e||e==="zip"){let r=h[0]===80&&h[1]===75,o=i.position,l=(f,_)=>{f=Array.from(f,m=>m.charCodeAt(0));let d=i.length,k=Math.max(i.length-16777216,0);for(;d>k;){d=Math.max(0,d-66e3),i.seek(d);let m=Math.min(i.length-d,66e3+_),b=i.read(m);for(let g=m-_;g>=0;g--)if(g=b.lastIndexOf(f[0],g),g!==-1&&f[1]===b[g+1]&&f[2]===b[g+2]&&f[3]===b[g+3])return i.seek(d+g),new s.BinaryReader(b.subarray(g,g+_));if(!r)break}return null},p=(f,_)=>{if(i.position-_>0){i.skip(-_),f=Array.from(f,k=>k.charCodeAt(0));let d=i.peek(_);if(d[0]===f[0]&&d[1]===f[1]&&d[2]===f[2]&&d[3]===f[3])return new s.BinaryReader(d)}return null},a={},u=-1,n=l("PK",22);if(n){if(u=i.position,n.skip(4),a.disk=n.uint16(),a.startDisk=n.uint16(),a.diskRecords=n.uint16(),a.totalRecords=n.uint16(),a.size=n.uint32(),a.offset=n.uint32(),a.commentLength=n.uint16(),n=null,p("PK\x07",20)&&(n=p("PK",56),!n))throw i.seek(o),new s.Error("Invalid ZIP data. ZIP64 end of central directory not found.")}else if(n=l("PK",56),!n){if(i.seek(o),r)throw new s.Error("Invalid ZIP data. End of central directory not found.");return null}if(n){if(u=i.position,n.skip(4),n.recordSize=n.uint64(),n.version=n.uint16(),n.minVersion=n.uint16(),n.disks=n.uint32(),n.startDisk=n.uint32(),a.diskRecords=n.uint64(),a.totalRecords=n.uint64(),a.size=n.uint64().toNumber(),a.offset=n.uint64(),a.offset>Number.MAX_SAFE_INTEGER)throw i.seek(o),new s.Error("ZIP 64-bit central directory offset not supported.");a.offset=a.offset.toNumber()}if(u-=a.size,u<0||u>i.length)throw i.seek(o),new s.Error("Invalid ZIP data. Central directory size is outside expected range.");if(u<a.offset)throw i.seek(o),new s.Error("Invalid ZIP data. Central directory offset is outside expected range.");i.seek(u),u-=a.offset;let c=new s.Archive(i,u);return i.seek(o),c}}return null}constructor(t,e){e=e||0,this._entries=new Map;let i=[],h=Array.from("PK",r=>r.charCodeAt(0));for(;t.position+4<t.length&&t.read(4).every((r,o)=>r===h[o]);){let r={},o=new s.BinaryReader(t.read(42));o.uint16(),o.skip(2);let l=o.uint16();if((l&1)===1)throw new s.Error("Encrypted ZIP entries not supported.");r.encoding=l&2048?"utf-8":"ascii",r.compressionMethod=o.uint16(),r.date=o.uint32(),r.crc32=o.uint32(),r.compressedSize=o.uint32(),r.size=o.uint32(),r.nameLength=o.uint16();let p=o.uint16(),a=o.uint16();r.disk=o.uint16(),o.uint16(),o.uint32(),r.localHeaderOffset=o.uint32();let u=t.read(r.nameLength),n=new TextDecoder(r.encoding);r.name=n.decode(u);let c=t.read(p);if(c.length>0){let f=new s.BinaryReader(c);for(;f.position<f.length;){let _=f.uint16(),d=f.uint16();switch(_){case 1:if(r.size===4294967295&&(r.size=f.uint64().toNumber(),r.size===void 0))throw new s.Error("ZIP 64-bit size not supported.");if(r.compressedSize===4294967295&&(r.compressedSize=f.uint64().toNumber(),r.compressedSize===void 0))throw new s.Error("ZIP 64-bit compressed size not supported.");if(r.localHeaderOffset===4294967295&&(r.localHeaderOffset=f.uint64().toNumber(),r.localHeaderOffset===void 0))throw new s.Error("ZIP 64-bit offset not supported.");r.disk===65535&&(r.disk=f.uint32());break;default:f.skip(d);break}}}t.read(a),i.push(r)}for(let r of i){if(r.size===0&&r.name.endsWith("/"))continue;let o=new s.Entry(t,r,e);this._entries.set(o.name,o.stream)}}get entries(){return this._entries}};s.Entry=class{constructor(t,e,i){if(i=i||0,this._name=e.name,t.seek(i+e.localHeaderOffset),t.position+4>t.length||String.fromCharCode(...t.read(4))!=="PK"){this._stream=new s.ErrorStream(e.size,"Invalid ZIP data. Local file header signature not found.");return}let h=new s.BinaryReader(t.read(26));h.skip(22),e.nameLength=h.uint16();let r=h.uint16();e.nameBuffer=t.read(e.nameLength),t.skip(r);let o=new TextDecoder(e.encoding);switch(this._name=o.decode(e.nameBuffer),this._stream=t.stream(e.compressedSize),e.compressionMethod){case 0:e.size!==e.compressedSize&&(this._stream=new s.ErrorStream(e.size,"Invalid ZIP entry compression size."));break;case 8:this._stream=new s.InflaterStream(this._stream,e.size);break;default:this._stream=new new s.ErrorStream(e.size,"Invalid ZIP entry compression method.");break}}get name(){return this._name}get stream(){return this._stream}};s.Inflater=class{inflateRaw(t,e){let i=null;if(s.zlib)i=s.zlib.inflateRawSync(t);else{let h=new s.BitReader(t),r=e===void 0?new s.BlockWriter:new s.BufferWriter(e);s.Inflater._staticLengthTree||(s.Inflater._codeLengths=new Uint8Array(19),s.Inflater._codeOrder=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],s.Inflater._lengthBase=[24,32,40,48,56,64,72,80,89,105,121,137,154,186,218,250,283,347,411,475,540,668,796,924,1053,1309,1565,1821,2064,7992,7992,7992],s.Inflater._distanceBase=[16,32,48,64,81,113,146,210,275,403,532,788,1045,1557,2070,3094,4119,6167,8216,12312,16409,24601,32794,49178,65563,98331,131100,196636,262173,393245,1048560,1048560]);let o=0;do switch(o=h.bits(3),o>>>1){case 0:{this._copyUncompressedBlock(h,r);break}case 1:{s.Inflater._staticLengthTree||(s.Inflater._staticLengthTree=s.HuffmanTree.create(new Uint8Array([].concat(...[[144,8],[112,9],[24,7],[8,8]].map(l=>[...Array(l[0])].map(()=>l[1]))))),s.Inflater._staticDistanceTree=s.HuffmanTree.create(new Uint8Array([...Array(32)].map(()=>5)))),this._lengthTree=s.Inflater._staticLengthTree,this._distanceTree=s.Inflater._staticDistanceTree,this._inflateBlock(h,r);break}case 2:{this._decodeTrees(h),this._inflateBlock(h,r);break}default:throw new s.Error("Unsupported block type.")}while(!(o&1));if(e!==void 0&&e!==r.length)throw new s.Error("Invalid uncompressed size.");i=r.toBuffer()}if(e!==void 0&&e!==i.length)throw new s.Error("Invalid uncompressed size.");return i}_copyUncompressedBlock(t,e){let i=t.uint16(),h=t.uint16();if(i!==(~h&65535))throw new s.Error("Invalid uncompressed block length.");e.write(t.read(i))}_decodeTrees(t){let e=t.bits(5)+257,i=t.bits(5)+1,h=t.bits(4)+4,r=s.Inflater._codeLengths;for(let c=0;c<r.length;c++)r[c]=0;let o=s.Inflater._codeOrder;for(let c=0;c<h;c++)r[o[c]]=t.bits(3);let l=s.HuffmanTree.create(r),p=l.length-1,a=new Uint8Array(e+i),u=0,n=0;for(let c=0;c<e+i;){let f=l[t.bits16()&p];t.position+=f&15;let _=f>>>4;switch(_){case 16:n=t.bits(2)+3;break;case 17:n=t.bits(3)+3,u=0;break;case 18:n=t.bits(7)+11,u=0;break;default:n=1,u=_;break}for(;n>0;n--)a[c++]=u}this._lengthTree=s.HuffmanTree.create(a.subarray(0,e)),this._distanceTree=s.HuffmanTree.create(a.subarray(e,e+i))}_inflateBlock(t,e){let i=this._lengthTree,h=this._distanceTree,r=i.length-1,o=h.length-1,l=e.buffer,p=e.threshold===void 0?e.length:e.threshold,a=e.position;for(;;){a>p&&(a=e.push(a));let u=i[t.bits16()&r];t.position+=u&15;let n=u>>>4;if(n<256)l[a++]=n;else if(n===256){e.push(a);return}else{let c=n-254;if(n>264){let b=s.Inflater._lengthBase[n-257];c=(b>>>3)+t.bits(b&7)}let f=h[t.bits16()&o];t.position+=f&15;let _=s.Inflater._distanceBase[f>>>4],d=_&15,k=(_>>>4)+(t.bits16()&(1<<d)-1);t.position+=d;let m=a-k;for(let b=0;b<c;b++)l[a++]=l[m++]}}}};s.HuffmanTree=class{static create(t){let e=Math.max.apply(null,t),i=s.HuffmanTree._rev15;if(!i){i=new Uint16Array(32768);for(let c=0;c<32768;c++){let f=c;f=(f&2863311530)>>>1|(f&1431655765)<<1,f=(f&3435973836)>>>2|(f&858993459)<<2,f=(f&4042322160)>>>4|(f&252645135)<<4,f=(f&4278255360)>>>8|(f&16711935)<<8,i[c]=(f>>>16|f<<16)>>>17}s.HuffmanTree._rev15=i,s.HuffmanTree._bitLengthCounts=new Uint16Array(16),s.HuffmanTree._nextCodes=new Uint16Array(16)}let h=t.length,r=s.HuffmanTree._bitLengthCounts;for(let n=0;n<16;n++)r[n]=0;for(let n=0;n<h;n++)r[t[n]]++;let o=s.HuffmanTree._nextCodes,l=0;r[0]=0;for(let n=0;n<e;n++)l=l+r[n]<<1,o[n+1]=l;let p=new Uint16Array(h);for(let n=0;n<h;n++){let c=t[n];c!==0&&(p[n]=o[c],o[c]++)}let a=15-e,u=new Uint16Array(1<<e);for(let n=0;n<h;n++){let c=t[n];if(c!==0){let f=n<<4|c,_=e-c,d=p[n]<<_,k=d+(1<<_);for(;d!==k;d++)u[i[d]>>>a]=f}}return u}};s.BitReader=class{constructor(t){this.buffer=t,this.position=0}bits(t){let e=Math.floor(this.position/8),i=this.position&7;return this.position+=t,(this.buffer[e]|this.buffer[e+1]<<8)>>>i&(1<<t)-1}bits16(){let t=Math.floor(this.position/8);return(this.buffer[t]|this.buffer[t+1]<<8|this.buffer[t+2]<<16)>>>(this.position&7)}read(t){let e=this.position&7;e!==0&&(this.position+=8-e);let i=Math.floor(this.position/8);return this.position+=t*8,this.buffer.subarray(i,i+t)}uint16(){let t=this.position&7;t!==0&&(this.position+=8-t);let e=Math.floor(this.position/8);return this.position+=16,this.buffer[e]|this.buffer[e+1]<<8}};s.BlockWriter=class{constructor(){this.blocks=[],this.buffer=new Uint8Array(65536),this.position=0,this.length=0,this.threshold=62464}push(t){return this.blocks.push(new Uint8Array(this.buffer.subarray(this.position,t))),this.length+=t-this.position,this.position=t,this._reset()}write(t){this.blocks.push(t);let e=t.length;this.length+=e,e>32768?(this.buffer.set(t.subarray(e-32768,e),0),this.position=32768):(this._reset(),this.buffer.set(t,this.position),this.position+=e)}toBuffer(){let t=new Uint8Array(this.length),e=0;for(let i of this.blocks)t.set(i,e),e+=i.length;return t}_reset(){return this.position>32768&&(this.buffer.set(this.buffer.subarray(this.position-32768,this.position),0),this.position=32768),this.position}};s.BufferWriter=class{constructor(t){this.buffer=new Uint8Array(t),this.length=t,this.position=0}push(t){if(this.position=t,this.position>this.length)throw new s.Error("Invalid size.");return this.position}write(t){if(this.buffer.set(t,this.position),this.position+=t.length,this.position>this.length)throw new s.Error("Invalid size.");return this.position}toBuffer(){return this.buffer}};s.InflaterStream=class{constructor(t,e){this._stream=t,this._offset=this._stream.position,this._position=0,this._length=e}get position(){return this._position}get length(){return this._length===void 0&&this._inflate(),this._length}seek(t){t!==this._position&&(this._buffer===void 0&&this._inflate(),this._position=t>=0?t:this._length+t)}skip(t){this._buffer===void 0&&this._inflate(),this._position+=t}peek(t){let e=this._position;t=t===void 0?this.length-e:t,this.skip(t);let i=this._position;return this.seek(e),e===0&&t===this.length?this._buffer:this._buffer.subarray(e,i)}read(t){let e=this._position;return t=t===void 0?this.length-e:t,this.skip(t),e===0&&t===this.length?this._buffer:this._buffer.subarray(e,this._position)}stream(t){let e=this.read(t);return new s.BinaryReader(e)}_inflate(){if(this._buffer===void 0){let t=this._stream.position;this._stream.seek(this._offset);let e=this._stream.peek();this._buffer=new s.Inflater().inflateRaw(e,this._length),this._length=this._buffer.length,this._stream.seek(t),delete this._stream}}};s.ErrorStream=class{constructor(t,e){this._message=e,this._position=0,this._length=t}get position(){return this._position}get length(){return this._length}seek(t){this._position=t>=0?t:this._length+t}skip(t){this._position+=t}peek(){this._throw()}read(){this._throw()}stream(){this._throw()}_throw(){throw new s.Error(this._message)}};s.BinaryReader=class{constructor(t){this._buffer=t,this._length=t.length,this._position=0,this._view=new DataView(t.buffer,t.byteOffset,t.byteLength)}get position(){return this._position}get length(){return this._length}create(t){return new s.BinaryReader(t)}stream(t){return this.create(this.read(t))}seek(t){this._position=t>=0?t:this._length+t}skip(t){this._position+=t}peek(t){if(this._position===0&&t===void 0)return this._buffer;let e=this._position;this.skip(t===void 0?this._length-this._position:t);let i=this._position;return this.seek(e),this._buffer.subarray(e,i)}read(t){if(this._position===0&&t===void 0)return this._position=this._length,this._buffer;let e=this._position;return this.skip(t===void 0?this._length-this._position:t),this._buffer.subarray(e,this._position)}byte(){let t=this._position;return this.skip(1),this._buffer[t]}uint16(){let t=this._position;return this.skip(2),this._view.getUint16(t,!0)}uint32(){let t=this._position;return this.skip(4),this._view.getUint32(t,!0)}uint64(){let t=this._position;return this.skip(8),this._view.getBigUint64(t,!0)}};x.Archive=class{constructor(t){let e=t.position;t.read(2),this._entries=new Map([["",new s.InflaterStream(t)]]),t.seek(e)}get entries(){return this._entries}};s.Error=class extends Error{constructor(t){super(t),this.name="ZIP Error"}};w.Archive=class{constructor(t){let e=t.position;if(t.position+10>t.length)throw new w.Error("Invalid gzip header size.");let i=t.peek(10);if(i[0]!==31||i[1]!==139)throw new w.Error("Invalid gzip signature.");if(i[2]!==8)throw t.seek(e),new w.Error(`Invalid compression method '${i[2]}'.`);t.skip(10);let h=()=>{let u="";for(;t.position<t.length;){let[n]=t.read(1);if(n===0)break;u+=String.fromCharCode(n)}return u},r=i[3]&1,o=i[3]&4,l=i[3]&8,p=i[3]&16;if(o){let u=t.read(2),n=u[0]|u[1]<<8;t.skip(n)}let a=l?h():"";p&&h(),r&&t.skip(2),this._entries=new Map,this._entries.set(a,new w.InflaterStream(t)),t.seek(e)}get entries(){return this._entries}};w.InflaterStream=class{constructor(t){this._stream=t.stream(t.length-t.position-8);let e=new s.BinaryReader(t.read(8));e.uint32(),this._length=e.uint32(),this._position=0}get position(){return this._position}get length(){return this._length}seek(t){this._buffer===void 0&&this._inflate(),this._position=t>=0?t:this._length+t}skip(t){this._buffer===void 0&&this._inflate(),this._position+=t}stream(t){return new s.BinaryReader(this.read(t))}peek(t){let e=this._position;t=t===void 0?this._length-this._position:t,this.skip(t);let i=this._position;return this.seek(e),e===0&&t===this._length?this._buffer:this._buffer.subarray(e,i)}read(t){let e=this._position;return t=t===void 0?this._length-this._position:t,this.skip(t),e===0&&t===this._length?this._buffer:this._buffer.subarray(e,this._position)}_inflate(){if(this._buffer===void 0){let t=this._stream.peek();this._buffer=new s.Inflater().inflateRaw(t,this._length),delete this._stream}}};w.Error=class extends Error{constructor(t){super(t),this.name="gzip Error"}};var I=s.Archive;export{I as a};
