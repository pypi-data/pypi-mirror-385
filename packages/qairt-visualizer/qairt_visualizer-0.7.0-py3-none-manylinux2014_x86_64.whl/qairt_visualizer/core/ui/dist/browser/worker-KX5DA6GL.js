var Q={};Q.layout=(i,c,g,b)=>{let D=0,q=e=>{let d=++D;return e+d},B=e=>{if(Array.isArray(e)&&e.every(t=>!Array.isArray(t)))return e;let d=[];for(let t of e){if(!Array.isArray(t)){d.push(t);continue}for(let l of t)d.push(l)}return d},j=(e,d,t,l)=>{let f="";do f=q(l);while(e.hasNode(f));return t.dummy=d,e.setNode(f,t),f},W=e=>{let d=new Q.Graph(!0,!1);for(let t of e.nodes.values()){let l=t.v;e.hasChildren(l)||d.setNode(l,t.label)}for(let t of e.edges.values())d.setEdge(t.v,t.w,t.label);return d},re=e=>{let d=Number.NEGATIVE_INFINITY;for(let t of e.nodes.values()){let l=t.label.rank;l!==void 0&&l>d&&(d=l)}return d===Number.NEGATIVE_INFINITY?void 0:d},se=e=>{let d=re(e),t=d===void 0?0:d+1,l=Array.from(new Array(t),()=>[]);for(let f of e.nodes.values()){let o=f.label,h=o.rank;h!==void 0&&(l[h][o.order]=f.v)}return l},ce=(e,d,t)=>{t.ranksep/=2;let l=t.rankdir;for(let f of e.edges.values()){let o=f.label;o.minlen*=2,o.labelpos.toLowerCase()!=="c"&&(l==="TB"||l==="BT"?o.width+=o.labeloffset:o.height+=o.labeloffset)}},_e=e=>{for(let d of e.edges.values())if(d.v===d.w){let t=d.vNode.label;t.selfEdges||(t.selfEdges=[]),t.selfEdges.push({e:d,label:d.label}),e.removeEdge(d)}},Oe=e=>{let d=[],t=new Set,l=new Set,f=Array.from(e.nodes.keys()).reverse();for(;f.length>0;){let o=f.pop();if(Array.isArray(o))l.delete(o[0]);else if(!t.has(o)){t.add(o),l.add(o),f.push([o]);let h=e.node(o).out;for(let m=h.length-1;m>=0;m--){let I=h[m];l.has(I.w)&&d.push(I),f.push(I.w)}}}for(let o of d){let h=o.label;e.removeEdge(o),h.forwardName=o.name,h.reversed=!0,e.setEdge(o.w,o.v,h,q("rev"))}},De=e=>{for(let d of e.edges.values()){let t=d.label;if(t.reversed){t.points.reverse(),e.removeEdge(d);let l=t.forwardName;delete t.reversed,delete t.forwardName,e.setEdge(d.w,d.v,t,l)}}},ie=(e,d)=>d.wNode.label.rank-d.vNode.label.rank-d.label.minlen,Ge=e=>{e=W(e);let d=f=>{let o=new Q.Graph(!1,!1),h=f.nodes.keys().next().value,m=f.nodes.size;o.setNode(h,{});let I=(N,V)=>{let _=Array.from(N.nodes.keys()).reverse();for(;_.length>0;){let S=_.pop(),z=V.node(S);for(let T of z.in.concat(z.out)){let P=T.v,$=S===P?T.w:P;!N.hasNode($)&&!ie(V,T)&&(N.setNode($,{}),N.setEdge(S,$,{}),_.push($))}}return N.nodes.size};for(;I(o,f)<m;){let N=Number.MAX_SAFE_INTEGER,V=null;for(let S of f.edges.values())if(o.hasNode(S.v)!==o.hasNode(S.w)){let z=ie(f,S);z<N&&(N=z,V=S)}let _=o.hasNode(V.v)?ie(f,V):-ie(f,V);for(let S of o.nodes.keys())f.node(S).label.rank+=_}return o},t=f=>{let o=new Set,h=[Array.from(f.nodes.values()).filter(m=>m.in.length===0).reverse()];for(;h.length>0;){let m=h[h.length-1];if(Array.isArray(m)){let I=m.pop();if(m.length===0&&h.pop(),!o.has(I)){o.add(I);let N=I.out.map(V=>V.wNode);N.length>0?(h.push(I),h.push(N.reverse())):I.label.rank=0}}else{h.pop();let I=Number.MAX_SAFE_INTEGER;for(let N of m.out)I=Math.min(I,N.wNode.label.rank-N.label.minlen);m.label.rank=I}}},l=f=>{let o=T=>{let P=new Q.Graph(!0,!1);for(let $ of T.nodes.values())P.setNode($.v,$.label);for(let $ of T.edges.values()){let p=P.edge($.v,$.w),R=p?p.label:{weight:0,minlen:1},v=$.label;P.setEdge($.v,$.w,{weight:R.weight+v.weight,minlen:Math.max(R.minlen,v.minlen)})}return P},h=(T,P)=>{let $=(R,v,A)=>{let a=1,s=new Map,r=[[A,null,0]];for(;r.length>0;){let[n,u,w]=r.pop();if(w===0){if(!v.has(n)){v.add(n);let y=R.node(n).label,L=a;s.set(n,{label:y,low:L,parent:u,lim:null}),r.push([n,u,1]);for(let E of R.neighbors(n))v.has(E)||r.push([E,n,0])}}else{let y=s.get(n),L=y.label;L.low=y.low,L.lim=a++,y.parent?L.parent=y.parent:delete L.parent}}};P=T.nodes.keys().next().value,$(T,new Set,P)},m=(T,P)=>{let $=[],p=new Set,R=[Array.from(T.nodes.keys()).reverse()];for(;R.length>0;){let v=R[R.length-1];if(Array.isArray(v)){let A=v.pop();if(v.length===0&&R.pop(),!p.has(A)){p.add(A);let a=T.neighbors(A);a.size>0?(R.push(A),R.push(Array.from(a).reverse())):$.push(A)}}else $.push(R.pop())}for(let v of $.slice(0,$.length-1)){let a=T.node(v).label.parent,s=P.edge(v,a),r=!!s,u=(s?s.label:P.edge(a,v).label).weight,w=P.node(v);for(let y of w.in.concat(w.out)){let L=y.v===v,E=L?y.w:y.v;if(E!==a){let x=L===r;u+=x?y.label.weight:-y.label.weight;let O=T.edge(v,E);if(O){let k=O.label.cutvalue;u+=x?-k:k}}}T.edge(v,a).label.cutvalue=u}},I=T=>Array.from(T.edges.values()).find(P=>P.label.cutvalue<0),N=(T,P,$)=>{let p=$.v,R=$.w;P.edge(p,R)||(p=$.w,R=$.v);let v=T.node(p).label,A=T.node(R).label,a=v,s=!1;v.lim>A.lim&&(a=A,s=!0);let r=(w,y)=>y.low<=w.lim&&w.lim<=y.lim,n=Number.POSITIVE_INFINITY,u=null;for(let w of P.edges.values())if(s===r(T.node(w.v).label,a)&&s!==r(T.node(w.w).label,a)){let y=ie(P,w);y<n&&(n=y,u=w)}return u},V=(T,P,$,p)=>{T.removeEdge($),T.setEdge(p.v,p.w,{}),h(T),m(T,P);let v=[Array.from(T.nodes.keys()).find(s=>!P.node(s).label.parent)],A=new Set;for(;v.length>0;){let s=v.pop();if(!A.has(s)){A.add(s);let r=Array.from(T.neighbors(s));for(let n=r.length-1;n>=0;n--)v.push(r[n])}}let a=Array.from(A);for(let s of a.slice(1)){let r=T.node(s).label.parent,n=P.edge(s,r),u=!1;n||(n=P.edge(r,s),u=!0),P.node(s).label.rank=P.node(r).label.rank+(u?n.label.minlen:-n.label.minlen)}};f=o(f),t(f);let _=d(f);h(_),m(_,f);let S=null,z=null;for(;S=I(_);)z=N(_,f,S),V(_,f,S,z)};switch(g.ranker){case"tight-tree":t(e),d(e);break;case"longest-path":t(e);break;default:l(e);break}},Ve=e=>{for(let d of e.edges.values()){let t=d.label;if(t.width&&t.height){let l=d.vNode.label,f=d.wNode.label;j(e,"edge-proxy",{rank:(f.rank-l.rank)/2+l.rank,e:d},"_ep")}}},Me=(e,d)=>{if(e.nodes.size>0){let t=Number.MAX_SAFE_INTEGER,l=Number.MIN_SAFE_INTEGER,f=Array.from(e.nodes.values());for(let h of f){let m=h.label;m.rank!==void 0&&(t=Math.min(t,m.rank),l=Math.max(l,m.rank))}let o=l-t;if(o>0){let h=new Array(o);for(let N of f){let V=N.label;if(V.rank!==void 0){let _=V.rank-t;h[_]||(h[_]=[]),h[_].push(N.v)}}let m=0,I=d.nodeRankFactor;for(let N=0;N<h.length;N++){let V=h[N];if(V===void 0&&N%I!==0)m--;else if(m&&V)for(let _ of V)e.node(_).label.rank+=m}}}},Ce=(e,d)=>{let t=j(e,"root",{},"_root"),l=N=>{let V={},_=(S,z)=>{for(let T of N.children(S))_(T,z+1);V[S]=z};for(let S of N.children())_(S,1);return V},f=(N,V,_,S,z,T,P)=>{let $=Array.from(N.children(P));if(!$.length){P!==V&&N.setEdge(V,P,{weight:0,minlen:_});return}let p=j(N,"border",{width:0,height:0},"_bt"),R=j(N,"border",{width:0,height:0},"_bb"),v=N.node(P).label;N.hasBorder=!0,N.setParent(p,P),v.borderTop=p,N.setParent(R,P),v.borderBottom=R;for(let A of $){f(N,V,_,S,z,T,A);let a=N.node(A).label,s=a.borderTop?a.borderTop:A,r=a.borderBottom?a.borderBottom:A,n=a.borderTop?S:2*S,u=s===r?z-T[P]+1:1;N.setEdge(p,s,{weight:n,minlen:u,nestingEdge:!0}),N.setEdge(r,R,{weight:n,minlen:u,nestingEdge:!0})}N.parent(P)||N.setEdge(V,p,{weight:0,minlen:z+T[P]})},o=l(e),h=Math.max(...Object.values(o))-1,m=2*h+1;d.nestingRoot=t;for(let N of e.edges.values())N.label.minlen*=m;let I=Array.from(e.edges.values()).reduce((N,V)=>N+V.label.weight,0)+1;for(let N of e.children())f(e,t,m,I,h,o,N);d.nodeRankFactor=m},Se=(e,d)=>{e.removeNode(d.nestingRoot),delete d.nestingRoot;for(let t of e.edges.values())t.label.nestingEdge&&e.removeEdge(t)},Pe=(e,d)=>{let t=Number.POSITIVE_INFINITY;for(let f of e.nodes.values()){let o=f.label.rank;o!==void 0&&o<t&&(t=o)}for(let f of e.nodes.values()){let o=f.label;o.rank!==void 0&&(o.rank-=t)}let l=0;if(e.hasBorder)for(let f of e.nodes.values()){let o=f.label;o.borderTop&&(o.minRank=e.node(o.borderTop).label.rank,o.maxRank=e.node(o.borderBottom).label.rank,l=Math.max(l,o.maxRank))}d.maxRank=l},qe=(e,d)=>{d.dummyChains=[];for(let t of e.edges.values()){let l=t.v,f=t.w,o=t.name,h=t.label,m=h.labelRank,I=e.node(l).label.rank,N=e.node(f).label.rank;if(N!==I+1){e.removeEdge(t);let V=!0;for(I++;I<N;){h.points=[],delete t.key;let _={width:0,height:0,edgeLabel:h,edgeObj:t,rank:I},S=j(e,"edge",_,"_d");I===m&&(_.width=h.width,_.height=h.height,_.dummy="edge-label",_.labelpos=h.labelpos),e.setEdge(l,S,{weight:h.weight},o),V&&(d.dummyChains.push(S),V=!1),l=S,I++}e.setEdge(l,f,{weight:h.weight},o)}}},$e=(e,d)=>{for(let t of d.dummyChains){let l=e.node(t).label,f=l.edgeLabel,o=l.edgeObj;for(e.setEdge(o.v,o.w,f,o.name);l.dummy;){let h=e.successors(t).keys().next().value;e.removeNode(t),f.points.push({x:l.x,y:l.y}),l.dummy==="edge-label"&&(f.x=l.x,f.y=l.y,f.width=l.width,f.height=l.height),t=h,l=e.node(t).label}}},Ye=e=>{for(let d of e.nodes.values()){let t=d.label;t.dummy==="edge-proxy"&&(t.e.label.labelRank=t.rank,e.removeNode(d.v))}},He=(e,d)=>{let t=(o,h,m,I)=>{let N=Math.min(h[m].low,h[I].low),V=Math.max(h[m].lim,h[I].lim),_=m,S=[];do _=o.parent(_),S.push(_);while(_&&(h[_].low>N||V>h[_].lim));let z=_;_=I;let T=[];for(;(_=o.parent(_))!==z;)T.push(_);return{path:S.concat(T.reverse()),lca:z}},f=(o=>{let h={},m=0,I=N=>{let V=m;for(let _ of o.children(N))I(_);h[N]={low:V,lim:m++}};for(let N of o.children())I(N);return h})(e);for(let o of d.dummyChains||[]){let m=e.node(o).label.edgeObj,I=t(e,f,m.v,m.w),N=I.path,V=I.lca,_=0,S=N[_],z=!0;for(;o!==m.w;){let T=e.node(o).label;if(z){for(;(S=N[_])!==V&&e.node(S).label.maxRank<T.rank;)_++;S===V&&(z=!1)}if(!z){for(;_<N.length-1&&e.node(N[_+1]).label.minRank<=T.rank;)_++;S=N[_]}e.setParent(o,S),o=e.successors(o).keys().next().value}}},ze=e=>{let d=(l,f,o,h,m,I)=>{let N={width:0,height:0,rank:I,borderType:f},V=m[f][I-1],_=j(l,"border",N,o);m[f][I]=_,l.setParent(_,h),V&&l.setEdge(V,_,{weight:1})},t=Array.from(e.children());for(let l=0;l<t.length;l++){let f=t[l],o=e.node(f).label;if("minRank"in o){o.borderLeft=[],o.borderRight=[];let m=o.maxRank+1;for(let I=o.minRank;I<m;I++)d(e,"borderLeft","_bl",f,o,I),d(e,"borderRight","_br",f,o,I)}let h=e.children(f);for(let m of h)t.push(m)}},Fe=e=>{let d=(p,R,v,A)=>{let a=(k,G)=>{let C=new Map;for(let M=0;M<k.length;M++){let H=k[M],Z={indegree:0,in:[],out:[],vs:[H.v],i:M};H.barycenter!==void 0&&(Z.barycenter=H.barycenter,Z.weight=H.weight),C.set(H.v,Z)}for(let M of G.edges.values()){let H=C.get(M.v),Z=C.get(M.w);H&&Z&&(Z.indegree++,H.out.push(Z))}let Y=Array.from(C.values()).filter(M=>!M.indegree),X=[],F=function(M){return function(H){if(!H.merged&&(H.barycenter===void 0||M.barycenter===void 0||H.barycenter>=M.barycenter)){let Z=0,te=0;M.weight&&(Z+=M.barycenter*M.weight,te+=M.weight),H.weight&&(Z+=H.barycenter*H.weight,te+=H.weight),M.vs=H.vs.concat(M.vs),M.barycenter=Z/te,M.weight=te,M.i=Math.min(H.i,M.i),H.merged=!0}}},K=M=>function(H){H.in.push(M),--H.indegree===0&&Y.push(H)};for(;Y.length;){let M=Y.pop();X.push(M),M.in.reverse().forEach(F(M)),M.out.forEach(K(M))}return X.filter(M=>!M.merged).map(M=>{let H={vs:M.vs,i:M.i};return M.barycenter!==void 0&&(H.barycenter=M.barycenter),M.weight!==void 0&&(H.weight=M.weight),H})},s=(k,G)=>Array.from(G).map(C=>{let Y=k.node(C).in;if(!Y.length)return{v:C};let X=Y.reduce((F,K)=>{let M=K.label,H=K.vNode.label;return{sum:F.sum+M.weight*H.order,weight:F.weight+M.weight}},{sum:0,weight:0});return{v:C,barycenter:X.sum/X.weight,weight:X.weight}}),r=(k,G)=>{let C=(J,ee,ne)=>{let Ie=null;for(;ee.length&&(Ie=ee[ee.length-1]).i<=ne;)ee.pop(),J.push(Ie.vs),ne++;return ne},Y=J=>function(ee,ne){return ee.barycenter<ne.barycenter?-1:ee.barycenter>ne.barycenter?1:J?ne.i-ee.i:ee.i-ne.i},X={lhs:[],rhs:[]};for(let J of k)"barycenter"in J?X.lhs.push(J):X.rhs.push(J);let F=X.lhs,K=X.rhs.sort((J,ee)=>-J.i+ee.i),M=[],H=0,Z=0,te=0;F.sort(Y(!!G)),te=C(M,K,te);for(let J of F)te+=J.vs.length,M.push(J.vs),H+=J.barycenter*J.weight,Z+=J.weight,te=C(M,K,te);let pe={vs:B(M)};return Z&&(pe.barycenter=H/Z,pe.weight=Z),pe},n=p.node(R),u=n&&n.label?n.label.borderLeft:void 0,w=n&&n.label?n.label.borderRight:void 0,y={},L=u?Array.from(p.children(R)).filter(k=>k!==u&&k!==w):p.children(R),E=s(p,L);for(let k of E)if(p.hasChildren(k.v)){let G=d(p,k.v,v,A);y[k.v]=G,"barycenter"in G&&(k.barycenter===void 0?(k.barycenter=G.barycenter,k.weight=G.weight):(k.barycenter=(k.barycenter*k.weight+G.barycenter*G.weight)/(k.weight+G.weight),k.weight+=G.weight))}let x=a(E,v);for(let k of x)k.vs=B(k.vs.map(G=>y[G]?y[G].vs:G));let O=r(x,A);if(u){O.vs=B([u,O.vs,w]);let k=p.predecessors(u);if(k.size>0){let G=p.node(k.keys().next().value).label,C=p.node(p.predecessors(w).keys().next().value).label;"barycenter"in O||(O.barycenter=0,O.weight=0),O.barycenter=(O.barycenter*O.weight+G.order+C.order)/(O.weight+2),O.weight+=2}}return O},t=(p,R)=>{let v=new Q.Graph(!0,!1);for(let A of p){let a=A.root,r=d(A,a,v,R).vs,n=r.length;for(let L=0;L<n;L++)A.node(r[L]).label.order=L;let u={},w="",y=!1;for(let L of r){let E=A.parent(L),x=null;for(;E;){let O=A.parent(E);if(O?(x=u[O],u[O]=E):(x=w,w=E),x&&x!==E){v.setEdge(x,E,null),y=!0;break}E=O}if(y)break}}},l=(p,R,v)=>{let A=0;for(let a=1;a<R.length;a++){let s=R[a-1],r=R[a],n=new Map;for(let E=0;E<r.length;E++)n.set(r[E],E);let u=[];for(let E of s){let x=[];for(let O of p.node(E).out)x.push({pos:n.get(O.w),weight:O.label.weight});x.sort((O,k)=>O.pos-k.pos);for(let O of x)u.push(O)}let w=1;for(;w<r.length;)w<<=1;let y=2*w-1;w-=1;let L=Array.from(new Array(y),()=>0);for(let E of u){let x=E.pos+w;L[x]+=E.weight;let O=0;for(;x>0;)x%2&&(O+=L[x+1]),x=x-1>>1,L[x]+=E.weight;A+=E.weight*O}if(A>v)break}return A},f=p=>{let R=new Set,v=Array.from(p.nodes.values()).filter(a=>!p.hasChildren(a.v)),A=-1;for(let a of v){let s=a.label.rank;(A===-1||s!==void 0&&s>A)&&(A=s)}if(A!==-1){let a=Array.from(new Array(A+1),()=>[]),s=v.sort((r,n)=>r.label.rank-n.label.rank).map(r=>r.v).reverse();for(let r=0;r<s.length;r++){let n=s[r];if(!R.has(n)){R.add(n);let u=p.node(n).label.rank;a[u].push(n),s.push(...p.successors(n).keys())}}return a}return[]},o=(p,R,v,A,a)=>{let s="";for(;p.hasNode(s=q("_root")););let r=new Q.Graph(!0,!0);r.root=s,r.setDefaultNodeLabel(u=>{let w=p.node(u);return w?w.label:void 0});let n=R.length;if(p.hasBorder){let u=0;for(;u<n;){let w=R[u++],y=w.label;if(y.rank===A||"minRank"in y&&"maxRank"in y&&y.minRank<=A&&A<=y.maxRank){let L=w.v;r.setNode(L);let E=p.parent(L);if(r.setParent(L,E||s),a)for(let x of w.in)r.setEdge(x.v,L,{weight:x.label.weight});else for(let x of w.out)r.setEdge(x.w,L,{weight:x.label.weight});"minRank"in y&&r.setNode(L,{borderLeft:y.borderLeft[A],borderRight:y.borderRight[A]})}}}else{let u=v.get(A);for(;u<n;){let w=R[u++];if(w.label.rank!==A)break;let L=w.v;r.setNode(L);let E=p.parent(L);if(r.setParent(L,E||s),a)for(let x of w.in)r.setEdge(x.v,L,{weight:x.label.weight});else for(let x of w.out)r.setEdge(x.w,L,{weight:x.label.weight})}}return r},h=f(e),m=(p,R)=>{for(let v of R)for(let A=0;A<v.length;A++)p.node(v[A]).label.order=A};m(e,h);let I=re(e)||0,N=new Array(I),V=new Array(I),_=Array.from(e.nodes.values()),S=null;if(!e.hasBorder){_.sort((p,R)=>p.label.rank-R.label.rank),S=new Map;for(let p=0;p<_.length;++p){let v=_[p].label.rank;S.has(v)||S.set(v,p)}}for(let p=0;p<I;p++)N[p]=o(e,_,S,p+1,!0),V[p]=o(e,_,S,I-p-1,!1);let z=Number.POSITIVE_INFINITY,T=[];for(let p=0,R=0;R<4;++p,++R){t(p%2?N:V,p%4>=2),h=se(e);let v=l(e,h,z);if(v<z){R=0;let A=h.length;T=new Array(A);for(let a=0;a<A;a++)T[a]=h[a].slice();z=v}}let P=(p,R)=>p<R?1:2;for(let p=4;p<T.length;p+=2){let R=T[p];for(let v=0;v<R.length;++v){let A=e.nodes.get(R[v]);if(A.in&&A.in.length===2){let a=A.in[0].vNode.in[0].vNode,s=A.in[1].vNode.in[0].vNode,r=[],n=0;for(let u=p-2;u>=0;u-=2){let w=T[u],y=w.indexOf(a.v),L=w.indexOf(s.v),E=P(y,L);if(n|=E,y===L||Math.abs(y-L)!==1||a.in.length!==1||s.in.length!==1||a.out.length!==1||s.out.length!==1){if(n===3){let x=E,O=u+2;for(;r.length!==0;){let k=r.pop(),G=r.pop(),C=T[O],Y=T[O-1],X=Y.indexOf(e.node(C[G]).in[0].v),F=Y.indexOf(e.node(C[k]).in[0].v);P(G,k)!==x&&([C[G],C[k]]=[C[k],C[G]]),P(X,F)!==x&&([Y[X],Y[F]]=[Y[F],Y[X]]),O+=2}}break}r.push(y,L),a=a.in[0].vNode.in[0].vNode,s=s.in[0].vNode.in[0].vNode}}}}let $=(p,R,v)=>{let A=p.indexOf(R.v),a=p.indexOf(v.v);p[a]=R.v,p[A]=v.v};for(let p=0;p<T.length-2;p+=2){let R=T[p],v=T[p+1],A=T[p+2];for(let a=0;a<R.length;++a){let s=e.nodes.get(R[a]);if(s.out&&s.out.length>=2)for(let r=0;r<s.out.length-1;++r){let n=s.out[r].wNode,u=s.out[r+1].wNode,w=n.out[0].wNode,y=u.out[0].wNode;v.indexOf(n.v)<v.indexOf(u.v)^A.indexOf(w.v)<A.indexOf(y.v)&&$(v,n,u)}}for(let a=0;a<A.length;++a){let s=e.nodes.get(A[a]);if(s.in&&s.in.length>=2)if(s.in.length===2){let r=s.in[0].vNode,n=s.in[1].vNode,u=r.in[0].vNode,w=n.in[0].vNode;v.indexOf(r.v)<v.indexOf(n.v)^R.indexOf(u.v)<R.indexOf(w.v)&&$(v,r,n)}else{let r=[];for(let n=0;n<s.in.length;++n){let u=s.in[n].vNode,w=u.in[0].vNode,y=R.indexOf(w.v),L=v.indexOf(u.v);s.in[n].idx0=y,r.push(L)}s.in.sort((n,u)=>n.idx0-u.idx0),r.sort((n,u)=>n-u);for(let n=0;n<r.length;++n)v[r[n]]=s.in[n].v}}}for(let p=0;p<T.length-4;p+=2){let R=T[p],v=T[p+2],A=T[p+4];if(v.length>=2&&A.length>=2){let a=T[p+1],s=T[p+3];for(let r=0;r<R.length;++r){let n=e.nodes.get(R[r]);if(n.in&&n.out&&n.out.length>=2)for(let u=0;u<n.out.length-1;++u){let w=n.out[u].wNode,y=n.out[u+1].wNode,L=w.out[0].wNode,E=y.out[0].wNode;if(L.out.length===1&&E.out.length===1){let x=v.indexOf(L.v),O=v.indexOf(E.v);if(x+1===O){let k=L.out[0].wNode,G=E.out[0].wNode;if(k.out.length===1&&G.out.length===1){let C=k.out[0].wNode,Y=G.out[0].wNode,X=A.indexOf(C.v),F=A.indexOf(Y.v);X>F&&($(a,w,y),$(v,L,E),$(s,k,G),++u)}}}}}for(let r=0;r<v.length-1;++r){let n=e.nodes.get(v[r]);if(n.in&&n.out&&n.in.length===1&&n.out.length===1){let u=e.nodes.get(v[r+1]);if(u.in&&u.out&&u.in.length===1&&u.out.length===1){let w=n.in[0].vNode,y=u.in[0].vNode;if(w.in.length===1&&y.in.length===1){let L=w.in[0].vNode,E=y.in[0].vNode,x=R.indexOf(L.v),O=R.indexOf(E.v);if(O+1===x){let k=n.out[0].wNode,G=u.out[0].wNode;x=s.indexOf(k.v),O=s.indexOf(G.v),x+1===O&&k.out[0].wNode===G.out[0].wNode&&($(a,w,y),$(v,n,u),$(s,k,G),r+=1)}}}}}}}m(e,T)},Be=e=>{let d=se(e);for(let t of d){let l=0;t.forEach((f,o)=>{let h=e.node(f).label;if(h.order=o+l,h.selfEdges){for(let m of h.selfEdges)j(e,"selfedge",{width:m.label.width,height:m.label.height,rank:h.rank,order:o+ ++l,e:m.e,label:m.label},"_se");delete h.selfEdges}})}},Ne=e=>{for(let d of e.nodes.values()){let t=d.label,l=t.width;t.width=t.height,t.height=l}for(let d of e.edges.values()){let t=d.label,l=t.width;t.width=t.height,t.height=l}},Xe=(e,d,t)=>{let l=t.rankdir.toLowerCase();(l==="lr"||l==="rl")&&Ne(e)},je=(e,d,t)=>{let l=t.rankdir.toLowerCase();if(l==="bt"||l==="rl"){for(let f of e.nodes.values())f.label.y=-f.label.y;for(let f of e.edges.values()){let o=f.label;for(let h of o.points)h.y=-h.y;"y"in o&&(o.y=-o.y)}}if(l==="lr"||l==="rl"){let f=o=>{[o.x,o.y]=[o.y,o.x]};for(let o of e.nodes.values())f(o.label);for(let o of e.edges.values()){let h=o.label;for(let m of h.points)f(m);h.x!==void 0&&f(h)}Ne(e)}},Ue=(e,d,t)=>{let l=(a,s,r)=>{s>r&&([s,r]=[r,s]);let n=a.get(s);n||(n=new Set,a.set(s,n)),n.add(r)},f=(a,s,r)=>(s>r&&([s,r]=[r,s]),a.has(s)&&a.get(s).has(r)),o=(a,s,r,n,u)=>{let w=s.nodesep,y=s.edgesep,L=new Q.Graph(!0,!1);for(let E of r){let x=null;for(let O of E){let k=n.get(O);if(L.setNode(k,{}),x){let G=n.get(x),C=a.node(O).label,Y=a.node(x).label,X=0,F=0;if(X+=C.width/2,"labelpos"in C)switch(C.labelpos){case"l":F=-C.width/2;break;case"r":F=C.width/2;break;default:throw new Q.Error(`Unsupported label position '${C.labelpos}'.`)}if(F&&(X+=u?F:-F),F=0,X+=(C.dummy?y:w)/2,X+=(Y.dummy?y:w)/2,X+=Y.width/2,"labelpos"in Y)switch(Y.labelpos){case"l":F=Y.width/2;break;case"r":F=-Y.width/2;break;default:throw new Q.Error(`Unsupported label position '${Y.labelpos}'.`)}F&&(X+=u?F:-F);let K=L.edge(G,k),M=Math.max(X,K?K.label:0);K?K.label=M:L.setEdge(G,k,M)}x=O}}return L},h=(a,s,r)=>{let n=new Map,u=new Map,w=new Map;for(let y of a){let L=0;for(let E of y)n.set(E,E),u.set(E,E),w.set(E,L),L++}for(let y of a){let L=-1;for(let E of y){let x=r(E);if(x.size>0){x=Array.from(x.keys()),x=x.sort((G,C)=>w.get(G)-w.get(C));let O=(x.length-1)/2.0000001,k=Math.ceil(O);for(let G=Math.floor(O);G<=k;G++){let C=x[G];if(u.get(E)===E&&L<w.get(C)&&!f(s,E,C)){let Y=n.get(C);u.set(C,E),u.set(E,Y),n.set(E,Y),L=w.get(C)}}}}}return{root:n,align:u}},m=(a,s,r,n,u,w)=>{let y=o(a,s,r,n,w),L=w?"borderLeft":"borderRight",E=new Map;if(y.nodes.size>0){let x=Array.from(y.nodes.keys()),O=new Set;for(;x.length>0;){let k=x.pop();if(O.has(k)){let G=0;for(let C of y.node(k).in)G=Math.max(G,E.get(C.v)+C.label);E.set(k,G)}else O.add(k),x.push(k),x.push(...y.predecessors(k).keys())}}if(y.nodes.size>0){let x=Array.from(y.nodes.keys()),O=new Set;for(;x.length>0;){let k=x.pop();if(O.has(k)){let G=Number.POSITIVE_INFINITY;for(let Y of y.node(k).out)G=Math.min(G,E.get(Y.w)-Y.label);let C=a.node(k).label;if(C.dummy)continue;G!==Number.POSITIVE_INFINITY&&C.borderType!==L&&E.set(k,Math.max(E.get(k),G))}else O.add(k),x.push(k),x.push(...y.successors(k).keys())}}for(let x of u.values())E.set(x,E.get(n.get(x)));return E},I=(a,s)=>{let r=new Map;if(s.length>0){let[n]=s;for(let u=1;u<s.length;u++){let w=s[u],y=0,L=0,E=n.length,x=w[w.length-1];for(let O=0;O<w.length;O++){let k=w[O],G=a.node(k).label.dummy?Array.from(a.predecessors(k).keys()).find(C=>a.node(C).label.dummy):null;if(G||k===x){let C=G?a.node(G).label.order:E;for(let Y of w.slice(L,O+1))if(a.predecessors(Y).size>0)for(let F of a.predecessors(Y).keys()){let K=a.node(F).label,M=K.order;(M<y||C<M)&&!(K.dummy&&a.node(Y).label.dummy)&&l(r,F,Y)}L=O+1,y=C}}n=w}}return r},N=(a,s)=>{let r=new Map,n=(u,w,y,L,E)=>{for(let x=w;x<y;x++){let O=u[x];if(a.node(O).labeldummy)for(let k of a.predecessors(O).keys()){let G=a.node(k).label;G.dummy&&(G.order<L||G.order>E)&&l(r,k,O)}}};if(s.length>0){let[u]=s;for(let w=1;w<s.length;w++){let y=s[w],L=-1,E=0,x=0;y.forEach((O,k)=>{if(a.node(O).label.dummy==="border"){let G=a.predecessors(O);G.size>0&&(E=a.node(G.keys().next().value).label.order,n(y,x,k,L,E),x=k,L=E)}n(y,x,y.length,E,u.length)}),u=y}}return r};e=W(e);let V=se(e),_=t.ranksep,S=0;for(let a of V){let s=a.reduce((r,n)=>Math.max(r,e.node(n).label.height),0);for(let r of a)e.node(r).label.y=S+s/2;S+=s+_}let z=new Map([...I(e,V).entries(),...N(e,V).entries()]),T={};for(let a of["u","d"]){let s=a==="u"?V:Object.values(V).reverse();for(let r of["l","r"]){r==="r"&&(s=s.map(y=>Object.values(y).reverse()));let n=(a==="u"?e.predecessors:e.successors).bind(e),u=h(s,z,n),w=m(e,t,s,u.root,u.align,r==="r");if(r==="r")for(let[y,L]of w.entries(w))w.set(y,-L);T[a+r]=w}}let P=Number.POSITIVE_INFINITY,$=null;for(let a of Object.values(T)){let s=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(let[u,w]of a.entries()){let y=e.node(u).label.width/2;s=Math.max(w+y,s),r=Math.min(w-y,r)}let n=s-r;n<P&&(P=n,$=a)}let p=$,R=a=>{let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let n of a)n<s&&(s=n),n>r&&(r=n);return[s,r]},v=R(p.values(p));for(let a of["u","d"])for(let s of["l","r"]){let r=a+s,n=T[r];if(n!==p){let u=R(n.values()),w=s==="l"?v[0]-u[0]:v[1]-u[1];if(w){let y=new Map;for(let[L,E]of n.entries())y.set(L,E+w);T[r]=y}}}let A=t.align;if(A){let a=T[A.toLowerCase()];for(let s of T.ul.keys())e.node(s).label.x=a.get(s)}else for(let a of T.ul.keys()){let s=[T.ul.get(a),T.ur.get(a),T.dl.get(a),T.dr.get(a)].sort((r,n)=>r-n);e.node(a).label.x=(s[1]+s[2])/2}},We=e=>{for(let d of e.nodes.values()){let t=d.label;if(t.dummy==="selfedge"){let l=d.v,f=e.node(t.e.v).label,o=f.x+f.width/2,h=f.y,m=t.x-o,I=f.height/2;e.setEdge(t.e.v,t.e.w,t.label),e.removeNode(l),t.label.points=[{x:o+2*m/3,y:h-I},{x:o+5*m/6,y:h-I},{x:o+m,y:h},{x:o+5*m/6,y:h+I},{x:o+2*m/3,y:h+I}],t.label.x=t.x,t.label.y=t.y}}},Ze=e=>{for(let d of e.nodes.values()){let t=d.v;if(e.hasChildren(t)){let l=d.label,f=e.node(l.borderTop).label,o=e.node(l.borderBottom).label,h=e.node(l.borderLeft[l.borderLeft.length-1]).label,m=e.node(l.borderRight[l.borderRight.length-1]).label;l.width=Math.abs(m.x-h.x),l.height=Math.abs(o.y-f.y),l.x=h.x+l.width/2,l.y=f.y+l.height/2}}for(let d of e.nodes.values())d.label.dummy==="border"&&e.removeNode(d.v)},Ke=e=>{for(let d of e.edges.values()){let t=d.label;if("x"in t)switch((t.labelpos==="l"||t.labelpos==="r")&&(t.width-=t.labeloffset),t.labelpos){case"l":t.x-=t.width/2+t.labeloffset;break;case"r":t.x+=t.width/2+t.labeloffset;break;default:throw new Q.Error(`Unsupported label position '${t.labelpos}'.`)}}},Je=(e,d)=>{let t=Number.POSITIVE_INFINITY,l=0,f=Number.POSITIVE_INFINITY,o=0,h=m=>{let I=m.x,N=m.y,V=m.width,_=m.height;t=Math.min(t,I-V/2),l=Math.max(l,I+V/2),f=Math.min(f,N-_/2),o=Math.max(o,N+_/2)};for(let m of e.nodes.values())h(m.label);for(let m of e.edges.values()){let I=m.label;"x"in I&&h(I)}for(let m of e.nodes.values())m.label.x-=t,m.label.y-=f;for(let m of e.edges.values()){let I=m.label;for(let N of I.points)N.x-=t,N.y-=f;"x"in I&&(I.x-=t),"y"in I&&(I.y-=f)}d.width=l-t,d.height=o-f},Qe=e=>{let d=(t,l)=>{let f=t.x,o=t.y,h=l.x-f,m=l.y-o;if(h===0&&m===0)throw new Error("Not possible to find intersection inside of the rectangle");let I=t.width/2,N=t.height/2;return Math.abs(m)*I>Math.abs(h)*N?(N=m<0?-N:N,{x:f+N*h/m,y:o+N}):(I=h<0?-I:I,{x:f+I,y:o+I*m/h})};for(let t of e.edges.values()){let l=t.label,f=t.vNode.label,o=t.wNode.label,h=null,m=null;l.points?([h]=l.points,m=l.points[l.points.length-1]):(l.points=[],h=o,m=f),l.points.unshift(d(f,h)),l.points.push(d(o,m))}},oe=new Q.Graph(!0,!0);for(let e of i)oe.setNode(e.v,{width:e.width,height:e.height}),e.parent&&oe.setParent(e.v,e.parent);for(let e of c)oe.setEdge(e.v,e.w,{minlen:e.minlen||1,weight:e.weight||1,width:e.width||0,height:e.height||0,labeloffset:e.labeloffset||10,labelpos:e.labelpos||"r"});g={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb",...g};let xe=[ce,_e,Oe,Ce,Ge,Ve,Me,Se,Pe,Ye,qe,He,ze,Fe,Be,Xe,Ue,We,Ze,$e,Ke,je,Je,Qe,De];for(;xe.length>0;)xe.shift()(oe,b,g);for(let e of i){let d=oe.node(e.v).label;e.x=d.x,e.y=d.y,oe.hasChildren(e.v)&&(e.width=d.width,e.height=d.height)}for(let e of c){let d=oe.edge(e.v,e.w).label;e.points=d.points,"x"in d&&(e.x=d.x,e.y=d.y)}b.log&&(b.log=oe.toString())};Q.Graph=class{constructor(i,c){this.directed=i,this.compound=c,this._defaultNodeLabelFn=()=>{},this.nodes=new Map,this.edges=new Map,this.compound&&(this._parent=new Map,this._children=new Map,this._children.set("\0",new Map))}setDefaultNodeLabel(i){this._defaultNodeLabelFn=i}setNode(i,c){let g=this.nodes.get(i);if(g)c&&(g.label=c);else{let b={label:c||this._defaultNodeLabelFn(i),in:[],out:[],predecessors:new Map,successors:new Map,v:i};this.nodes.set(i,b),this.compound&&(this._parent.set(i,"\0"),this._children.set(i,new Map),this._children.get("\0").set(i,!0))}}node(i){return this.nodes.get(i)}hasNode(i){return this.nodes.has(i)}removeNode(i){let c=this.nodes.get(i);if(c){if(this.compound){this._children.get(this._parent.get(i)).delete(i),this._parent.delete(i);for(let g of this.children(i))this.setParent(g);this._children.delete(i)}for(let g of c.in.concat())this.removeEdge(g);for(let g of c.out.concat())this.removeEdge(g);this.nodes.delete(i)}}setParent(i,c){if(!this.compound)throw new Error("Cannot set parent in a non-compound graph");if(c){for(let g=c;g!==void 0;g=this.parent(g))if(g===i)throw new Error(`Setting ${c} as parent of ${i} would create a cycle.`);this.setNode(c)}else c="\0";this._children.get(this._parent.get(i)).delete(i),this._parent.set(i,c),this._children.get(c).set(i,!0)}parent(i){if(this.compound){let c=this._parent.get(i);if(c!=="\0")return c}return null}children(i){return this.compound?this._children.get(i===void 0?"\0":i).keys():i===void 0?this.nodes.keys():this.hasNode(i)?[]:null}hasChildren(i){return this.compound?this._children.get(i===void 0?"\0":i).size>0:i===void 0?this.nodes.size>0:!1}predecessors(i){return this.nodes.get(i).predecessors}successors(i){return this.nodes.get(i).successors}neighbors(i){let c=this.nodes.get(i),g=c.predecessors.keys(),b=c.successors.keys(),D=new Set;for(let q of g)D.add(q);for(let q of b)D.add(q);return D}edge(i,c){return this.edges.get(this._edgeKey(this.directed,i,c))}setEdge(i,c,g,b){let D=this._edgeKey(this.directed,i,c,b),q=this.edges.get(D);if(q)q.label=g;else{!this.directed&&i>c&&([i,c]=[c,i]);let B={label:g,v:i,w:c,name:b,key:D,vNode:null,wNode:null};this.edges.set(D,B),this.setNode(i),this.setNode(c);let j=this.nodes.get(c),W=this.nodes.get(i);B.wNode=j,B.vNode=W;let re=(se,ce)=>{se.set(ce,(se.get(ce)??0)+1)};re(j.predecessors,i),re(W.successors,c),j.in.push(B),W.out.push(B)}}removeEdge(i){let c=i.key,g=i.v,b=i.w,D=i.wNode,q=i.vNode;if(D.predecessors.has(g)){let W=D.predecessors.get(g);W===1?D.predecessors.delete(g):D.predecessors.set(g,W-1)}if(q.successors.has(b)){let W=q.successors.get(b);W===1?q.successors.delete(b):q.successors.set(b,W-1)}let B=D.in.findIndex(W=>W.key===c);B!==-1&&D.in.splice(B,1);let j=q.out.findIndex(W=>W.key===c);j!==-1&&q.out.splice(j,1),this.edges.delete(c)}_edgeKey(i,c,g,b){return!i&&c>g?b?`${g}:${c}:${b}`:`${g}:${c}:`:b?`${c}:${g}:${b}`:`${c}:${g}:`}toString(){return["[nodes]",Array.from(this.nodes.values()).map(i=>JSON.stringify(i.label)).join(`
`),"[edges]",Array.from(this.edges.values()).map(i=>JSON.stringify(i.label)).join(`
`),"[parents]",JSON.stringify(this._parent,null,2),"[children]",JSON.stringify(this._children,null,2)].join(`
`)}};var{layout:ve,Graph:at}=Q;var be=6,ae=30,ct=be+1,Ee=12,fe=Ee+be*2;var ke="--qds-node-category-uncategorized",U={DATA:"data",NN_LAYER:"nn layer",ACTIVATION:"activation",POOLING:"pooling",NORMALIZATION:"normalization",MATH:"math",SHAPE:"shape",TRANSFORM:"transform",QUANTIZATION:"quantization",SYNTHETIC_LAYER:"synthetic layer",NAMESPACE_LAYER:"namespace layer",DEFAULT:"default"},et={[U.DATA]:"--qds-node-category-data",[U.NN_LAYER]:"--qds-node-category-layer",[U.ACTIVATION]:"--qds-node-category-activation",[U.POOLING]:"--qds-node-category-pool",[U.NORMALIZATION]:"--qds-node-category-normalization",[U.MATH]:"--qds-node-category-math",[U.SHAPE]:"--qds-node-category-shape",[U.TRANSFORM]:"--qds-node-category-transform",[U.QUANTIZATION]:"--qds-node-category-quantization",[U.SYNTHETIC_LAYER]:"--qds-synthetic-layer-header-1",[U.NAMESPACE_LAYER]:"--qds-layer-header-1",[U.DEFAULT]:ke},ft={[U.NN_LAYER]:["conv","deconv","fc","dense","linear","lstm","gru","rnn","attention","transformer","embedding"],[U.ACTIVATION]:["relu","sigmoid","tanh","softmax","gelu","swish","elu","selu","activation"],[U.POOLING]:["pool","maxpool","avgpool"],[U.NORMALIZATION]:["norm","batchnorm","layernorm","groupnorm","instancenorm","rmsnorm","lrn"],[U.MATH]:["add","sub","mul","div","mod","pow","neg","abs","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","exp","log","sqrt","reciprocal","erf","sum","mean","max","min","reducesum","reducemean","reducemax","reducemin","reduceprod","reducel1","reducel2","reducelogsum","reducelogsumexp","reducesumsquare","equal","greater","less","greaterorequal","lessorequal","and","or","xor","not","floor","ceil","round","clip","sign","matmul","bitwiseand","bitwiseor","bitwisexor","bitwisenot","cumsum"],[U.SHAPE]:["reshape","shape","size","flatten"],[U.TRANSFORM]:["transpose","gather","slice","concat","split","cast","pad","tile","repeat","flip","squeeze","unsqueeze","expand"],[U.QUANTIZATION]:["quant","dequant","quantize","dequantize"]};function le(i){return i.children?.length>0}function he(i){let c=1/0,g=1/0,b=-1/0,D=-1/0;for(let j of i)c=Math.min(c,j.x),b=Math.max(b,j.x+(j.width??0)),g=Math.min(g,j.y),D=Math.max(D,j.y+(j.height??0));let q=b-c,B=D-g;return{x:c,y:g,width:q,height:B}}var tt={nodesep:20,ranksep:20};function de(i,c,g){let b={namespace:i.namespace,nodes:[],edges:[]},D=i.children.map(B=>{let{width:j,height:W}=c[B.id];return{v:B.id,x:void 0,y:void 0,globalX:void 0,globalY:void 0,width:j,height:W,data:B,currentGraph:b,parentGraph:g}}),q=i.edges.map(B=>({v:B.sourceNode.id,w:B.targetNode.id,data:B,points:[],globalPoints:[],globalEdgeBounds:void 0}));return b.nodes=D,b.edges=q,Ae(b),b}function me(i,c){if(i.nodes.find(g=>g.data.id===c))return i;for(let g of i.nodes)if(g.childGraph){let b=me(g.childGraph,c);if(b)return b}}function Ae(i){ve(i.nodes,i.edges,tt,{}),i.nodes.forEach(c=>{c.x-=c.width/2,c.y-=c.height/2,c.globalX=c.x,c.globalY=c.y}),i.edges.forEach(c=>{c.globalPoints=c.points,c.globalEdgeBounds=he(c.globalPoints)})}function ot(i){let c=i.nodes,g=i.edges.flatMap(D=>D.points),b=[...c,...g];return he(b)}function Le(i){let c=ot(i);return{width:c.width+ae*2,height:c.height+ae*2+fe}}function ge(i,c,g){let b=i.nodes.find(D=>D.data.id===c);if(b.expanded){let{width:D,height:q}=Le(b.childGraph);b.width=D,b.height=q}else b.width=g[b.data.id].width,b.height=g[b.data.id].height;if(Ae(i),b.data.parent){let D=b.data.parent.id;b.parentGraph&&ge(b.parentGraph,D,g)}}function we(i,c,g){let b=c.nodes.find(D=>D.data.id===i);!le(b.data)||b.expanded||(b.expanded=!0,b.childGraph=de(b.data,g,c),ge(c,i,g))}function Te(i,c,g){let b=c.nodes.find(D=>D.data.id===i);!le(b.data)||!b.expanded||(b.expanded=!1,delete b.childGraph,ge(c,i,g))}function Re(i,c){let g=nt(i),b={};for(let D=g.length-1;D>=0;D--)for(let q of g[D]){let B=st(q,b,c);b[q.id]=B,c[q.id]=Le(B)}return b[i.id]}function nt(i){let c=[],g=[i];for(;g.length;){let b=g.pop();c[b.depth]??=[],c[b.depth].push(b);for(let D of b.children)le(D)&&g.push(D)}return c}function st(i,c,g){let b=de(i,g);for(let D of b.nodes)if(D.currentGraph=b,le(D.data)){D.expanded=!0,D.childGraph=c[D.data.id];for(let q of D.childGraph.nodes)q.parentGraph=b}return b}function ue(i,c){for(let g of i.edges)g.globalPoints=g.points.map(b=>({x:b.x+c.x,y:b.y+c.y})),g.globalEdgeBounds=he(g.globalPoints);for(let g of i.nodes)g.globalX=g.x+c.x,g.globalY=g.y+c.y,g.childGraph&&ue(g.childGraph,{x:g.globalX+ae,y:g.globalY+ae+fe})}function rt(i){let{type:c,data:g}=i.data;switch(c){case 0:{let{layerNode:b,nodeDimensions:D}=g,q=de(b,D);postMessage({rootViewGraph:q});break}case 1:{let{rootViewGraph:b,clickedNodeId:D,nodeDimensions:q}=g;ye(we,b,D,q),postMessage({rootViewGraph:b});break}case 2:{let{rootViewGraph:b,clickedNodeId:D,nodeDimensions:q}=g;ye(Te,b,D,q),postMessage({rootViewGraph:b});break}case 3:{let{hierarchyRoot:b,nodeDimensions:D}=g,q=Re(b,D);ue(q,{x:0,y:0}),postMessage({rootViewGraph:q});break}case 4:{let{hierarchyRoot:b,nodeDimensions:D}=g,q=de(b,D);postMessage({rootViewGraph:q});break}case 5:{let{rootViewGraph:b,ancestors:D,nodeDimensions:q}=g;for(let B of D)ye(we,b,B.id,q);postMessage({rootViewGraph:b});break}}}function ye(i,c,g,b){let D=me(c,g);if(!D){console.error(`Graph cannot be updated - clicked node "${g}" was not found`);return}i(g,D,b),ue(c,{x:0,y:0})}addEventListener("message",rt);export{rt as messageHandler};
