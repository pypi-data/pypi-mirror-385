"""Build command for Simply-MCP CLI.

This module implements the 'build' command which packages MCP servers
into portable .pyz (Python ZIP Application) files. These are single-file
executables that can be run with Python without needing to install dependencies.
"""

import json
import shutil
import sys
import tempfile
import zipapp
from pathlib import Path

import click
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

from simply_mcp.cli.utils import (
    console,
    detect_api_style,
    format_error,
    format_info,
    format_success,
    load_python_module,
    validate_python_file,
)
from simply_mcp.core.server import SimplyMCPServer


def generate_main_entrypoint(
    server_module_name: str,
    api_style: str,
) -> str:
    """Generate __main__.py entry point for the .pyz file.

    Args:
        server_module_name: Name of the server module (without .py extension)
        api_style: Detected API style ("decorator", "builder", "class")

    Returns:
        Python code for __main__.py as a string
    """
    # Generate appropriate code based on API style
    if api_style == "decorator":
        server_import = "from simply_mcp.api.decorators import get_global_server"
        server_getter = "server = get_global_server()"
    elif api_style == "builder":
        server_import = "from simply_mcp.api.programmatic import BuildMCPServer"
        server_getter = """# Find BuildMCPServer instance in module
        for attr_name in dir(module):
            attr = getattr(module, attr_name)
            if isinstance(attr, BuildMCPServer):
                server = attr.get_server()
                break
        else:
            raise RuntimeError("No BuildMCPServer instance found")"""
    elif api_style == "class":
        server_import = "from simply_mcp.core.server import SimplyMCPServer"
        server_getter = """# Find class-based server in module
        import inspect
        for attr_name in dir(module):
            attr = getattr(module, attr_name)
            if inspect.isclass(attr) and hasattr(attr, '_mcp_server'):
                server = attr._mcp_server
                if isinstance(server, SimplyMCPServer):
                    break
        else:
            raise RuntimeError("No @mcp_server decorated class found")"""
    else:
        raise ValueError(f"Unknown API style: {api_style}")

    return f'''#!/usr/bin/env python3
"""Auto-generated entry point for Simply-MCP server package.

This file is automatically generated by simply-mcp build command.
It loads the server module and runs it with the appropriate transport.
"""

import asyncio
import sys
import importlib


def main():
    """Main entry point for the packaged server."""
    try:
        # Load the server module
        module = importlib.import_module("{server_module_name}")

        # Import server detection utilities
        {server_import}

        # Get the server instance based on API style
        {server_getter}

        # Parse command-line arguments for transport selection
        import argparse
        parser = argparse.ArgumentParser(
            description="Run packaged MCP server",
            formatter_class=argparse.RawDescriptionHelpFormatter
        )
        parser.add_argument(
            "--transport",
            type=str,
            choices=["stdio", "http", "sse"],
            default="stdio",
            help="Transport type (default: stdio)"
        )
        parser.add_argument(
            "--host",
            type=str,
            default="0.0.0.0",
            help="Host for network transports (default: 0.0.0.0)"
        )
        parser.add_argument(
            "--port",
            type=int,
            default=3000,
            help="Port for network transports (default: 3000)"
        )
        parser.add_argument(
            "--cors/--no-cors",
            dest="cors",
            action="store_true",
            default=True,
            help="Enable CORS for network transports (default: enabled)"
        )

        args = parser.parse_args()

        # Run the server asynchronously
        async def run_server():
            """Initialize and run the server."""
            await server.initialize()

            if args.transport == "stdio":
                await server.run_stdio()
            elif args.transport == "http":
                await server.run_http(
                    host=args.host,
                    port=args.port,
                    cors_enabled=args.cors,
                )
            elif args.transport == "sse":
                await server.run_sse(
                    host=args.host,
                    port=args.port,
                    cors_enabled=args.cors,
                )

        # Execute the async server
        asyncio.run(run_server())

    except KeyboardInterrupt:
        print("\\nServer stopped by user", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"Error running server: {{e}}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
'''


def create_package_metadata(
    server_name: str,
    server_version: str,
    api_style: str,
    original_file: str,
) -> dict[str, str]:
    """Create package.json metadata for the .pyz file.

    Args:
        server_name: Name of the MCP server
        server_version: Version of the server
        api_style: API style used ("decorator", "builder", "class")
        original_file: Original server file path

    Returns:
        Dictionary containing package metadata
    """
    return {
        "name": server_name,
        "version": server_version,
        "api_style": api_style,
        "packaged_with": "simply-mcp build",
        "original_file": str(Path(original_file).name),
        "format": "pyz",
        "python_version": f"{sys.version_info.major}.{sys.version_info.minor}",
    }


def validate_server_file(server_file: str) -> tuple[str, SimplyMCPServer]:
    """Validate that the server file is a valid MCP server.

    Args:
        server_file: Path to server file

    Returns:
        Tuple of (api_style, server_instance)

    Raises:
        ValueError: If server file is invalid
    """
    try:
        # Load the module
        module = load_python_module(server_file)

        # Detect API style
        api_style, server = detect_api_style(module)

        if server is None or api_style == "unknown":
            raise ValueError(
                "No MCP server found in the file.\n\n"
                "Make sure your file uses one of:\n"
                "  - Decorator API: @tool(), @prompt(), @resource()\n"
                "  - Builder API: BuildMCPServer(...)\n"
                "  - Class API: @mcp_server class"
            )

        return api_style, server

    except Exception as e:
        raise ValueError(f"Failed to validate server file: {e}") from e


@click.command()
@click.argument("server_file", type=click.Path(exists=True))
@click.option(
    "--name",
    "-n",
    type=str,
    default=None,
    help="Name for the package (default: server filename)",
)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    default=None,
    help="Output .pyz file path (default: ./<name>.pyz)",
)
@click.option(
    "--vendor-deps/--no-vendor-deps",
    default=False,
    help="Include dependencies in the .pyz file (default: False)",
)
def build(
    server_file: str,
    name: str | None,
    output: str | None,
    vendor_deps: bool,
) -> None:
    """Build an MCP server into a portable .pyz package.

    This command packages a Python MCP server into a single .pyz file that
    can be executed with Python. The resulting file includes the server code
    and an auto-generated entry point.

    The .pyz file can be run directly:
        python package.pyz

    Or with simply-mcp:
        simply-mcp run package.pyz

    Examples:

        \b
        # Build with default settings
        simply-mcp build server.py

        \b
        # Build with custom name and output path
        simply-mcp build server.py --name myserver --output dist/myserver.pyz

        \b
        # Build with vendored dependencies (experimental)
        simply-mcp build server.py --vendor-deps

    Notes:
        - The .pyz file requires Python and simply-mcp to be installed
        - Use --vendor-deps to include dependencies (increases file size)
        - The package is platform-independent but requires compatible Python version
        - For fully standalone executables, use the 'bundle' command instead
    """
    try:
        # Display build info
        console.print(
            Panel(
                f"[bold cyan]Building MCP Server Package[/bold cyan]\n\n"
                f"Server File: [green]{server_file}[/green]\n"
                f"Format: [yellow].pyz (Python ZIP Application)[/yellow]",
                title="[bold blue]Simply-MCP Build[/bold blue]",
            )
        )

        # Validate Python file
        if not validate_python_file(server_file):
            format_error("Invalid Python file", "Validation Error")
            sys.exit(1)

        # Validate server and detect API style
        console.print("[dim]Validating MCP server...[/dim]")
        try:
            api_style, server = validate_server_file(server_file)
        except ValueError as e:
            format_error(str(e), "Invalid Server")
            sys.exit(1)

        format_success(f"Detected {api_style} API style")

        # Get server info
        server_config = server.config.server
        server_name = server_config.name
        server_version = server_config.version

        # Display server info
        stats = server.registry.get_stats()
        console.print(
            Panel(
                f"[bold]Server:[/bold] [cyan]{server_name}[/cyan]\n"
                f"[bold]Version:[/bold] [cyan]{server_version}[/cyan]\n"
                f"[bold]Components:[/bold] [green]{stats['tools']} tools, "
                f"{stats['prompts']} prompts, {stats['resources']} resources[/green]",
                title="[bold green]Server Info[/bold green]",
            )
        )

        # Determine package name and output path
        if name is None:
            name = Path(server_file).stem

        if output is None:
            output = f"./{name}.pyz"

        output_path = Path(output).resolve()

        # Ensure output has .pyz extension
        if not output_path.suffix == ".pyz":
            output_path = output_path.with_suffix(".pyz")

        # Create output directory if needed
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Warn about vendor-deps (not fully implemented in foundation)
        if vendor_deps:
            format_info(
                "Note: --vendor-deps is experimental and may not include all dependencies.\n"
                "For production use, install simply-mcp in the target environment.",
                "Experimental Feature",
            )

        # Build the package
        console.print("\n[bold yellow]Building package...[/bold yellow]")

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            task = progress.add_task("Creating package structure...", total=None)

            # Create temporary directory for package contents
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)

                # Copy server file to temp directory
                server_module_name = Path(server_file).stem
                dest_server = temp_path / f"{server_module_name}.py"
                shutil.copy2(server_file, dest_server)

                progress.update(task, description="Generating entry point...")

                # Generate __main__.py
                main_content = generate_main_entrypoint(
                    server_module_name=server_module_name,
                    api_style=api_style,
                )
                main_file = temp_path / "__main__.py"
                main_file.write_text(main_content, encoding="utf-8")

                progress.update(task, description="Creating metadata...")

                # Create package.json metadata
                metadata = create_package_metadata(
                    server_name=server_name,
                    server_version=server_version,
                    api_style=api_style,
                    original_file=server_file,
                )
                metadata_file = temp_path / "package.json"
                metadata_file.write_text(json.dumps(metadata, indent=2), encoding="utf-8")

                # If vendor-deps is enabled, try to copy dependencies
                # Note: This is a simple implementation - full vendoring is complex
                if vendor_deps:
                    progress.update(task, description="Vendoring dependencies (experimental)...")
                    format_info(
                        "Dependency vendoring is experimental. "
                        "The .pyz will still require simply-mcp to be installed."
                    )

                progress.update(task, description="Creating .pyz archive...")

                # Create the .pyz file using zipapp
                try:
                    zipapp.create_archive(
                        source=temp_path,
                        target=output_path,
                        interpreter="/usr/bin/env python3",
                        main=None,  # Will use __main__.py
                    )
                except Exception as e:
                    format_error(f"Failed to create .pyz archive: {e}", "Build Error")
                    sys.exit(1)

                progress.update(task, completed=True)

        format_success("Package built successfully!")

        # Display output information
        file_size = output_path.stat().st_size / 1024  # KB
        console.print(
            Panel(
                f"[bold green]Package created successfully![/bold green]\n\n"
                f"Location: [cyan]{output_path}[/cyan]\n"
                f"Size: [yellow]{file_size:.2f} KB[/yellow]\n"
                f"Format: [yellow]Python ZIP Application (.pyz)[/yellow]",
                title="[bold green]Build Complete[/bold green]",
            )
        )

        # Display usage instructions
        console.print(
            Panel(
                "[bold]Usage:[/bold]\n\n"
                f"Run the packaged server:\n"
                f"  [cyan]python {output_path}[/cyan]\n"
                f"  [cyan]python {output_path} --transport http --port 8080[/cyan]\n\n"
                f"Or with simply-mcp:\n"
                f"  [cyan]simply-mcp run {output_path}[/cyan]\n\n"
                "[bold]Requirements:[/bold]\n"
                "  - Python 3.10+\n"
                "  - simply-mcp package installed\n"
                "  - Any dependencies used by your server",
                title="[bold blue]Next Steps[/bold blue]",
            )
        )

    except Exception as e:
        format_error(f"Fatal error during build: {e}", "Error")
        import traceback

        console.print("[dim]" + traceback.format_exc() + "[/dim]")
        sys.exit(1)


__all__ = ["build"]
