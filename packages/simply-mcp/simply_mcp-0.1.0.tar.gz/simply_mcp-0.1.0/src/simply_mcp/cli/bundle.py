"""Bundle command for Simply-MCP CLI.

This module implements the 'bundle' command which packages MCP servers
into standalone executables using PyInstaller. It supports various options
for customizing the bundle output.
"""

import ast
import shutil
import subprocess
import sys
from pathlib import Path

import click
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

from simply_mcp.cli.utils import (
    console,
    format_error,
    format_info,
    format_success,
    load_python_module,
    validate_python_file,
)


def detect_imports(file_path: str) -> set[str]:
    """Detect imports in a Python file using AST parsing.

    Args:
        file_path: Path to Python file

    Returns:
        Set of imported module names
    """
    imports = set()
    try:
        with open(file_path, encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=file_path)

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name.split(".")[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split(".")[0])

    except Exception as e:
        format_error(f"Failed to parse imports: {e}", "Import Detection Error")

    return imports


def get_hidden_imports() -> list[str]:
    """Get list of hidden imports required for Simply-MCP.

    Returns:
        List of module names to include as hidden imports
    """
    return [
        "simply_mcp",
        "simply_mcp.api",
        "simply_mcp.api.builder",
        "simply_mcp.api.decorators",
        "simply_mcp.api.class_based",
        "simply_mcp.core",
        "simply_mcp.core.server",
        "simply_mcp.core.registry",
        "simply_mcp.core.config",
        "simply_mcp.core.errors",
        "simply_mcp.transports",
        "simply_mcp.transports.stdio",
        "simply_mcp.transports.http",
        "simply_mcp.transports.sse",
        "mcp",
        "mcp.server",
        "mcp.server.stdio",
        "mcp.types",
        "pydantic",
        "pydantic_settings",
        "click",
        "rich",
        "aiohttp",
        "aiohttp_cors",
    ]


def generate_spec_file(
    server_file: str,
    output_name: str,
    onefile: bool = True,
    windowed: bool = False,
    icon: str | None = None,
) -> str:
    """Generate PyInstaller spec file content.

    Args:
        server_file: Path to server Python file
        output_name: Name for the executable
        onefile: Whether to bundle as single file
        windowed: Whether to hide console window
        icon: Path to icon file (optional)

    Returns:
        Spec file content as string
    """
    abs_server_file = str(Path(server_file).resolve())
    hidden_imports = get_hidden_imports()
    hidden_imports_str = ", ".join(f"'{imp}'" for imp in hidden_imports)

    icon_line = f"icon='{icon}'," if icon else "icon=None,"

    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
# PyInstaller spec file generated by Simply-MCP bundle command

block_cipher = None

a = Analysis(
    ['{abs_server_file}'],
    pathex=[],
    binaries=[],
    datas=[],
    hiddenimports=[{hidden_imports_str}],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
'''

    if onefile:
        spec_content += f'''
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='{output_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console={not windowed},
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    {icon_line}
)
'''
    else:
        spec_content += f'''
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{output_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console={not windowed},
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    {icon_line}
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='{output_name}',
)
'''

    return spec_content


def validate_server_file(server_file: str) -> bool:
    """Validate that the server file is a valid MCP server.

    Args:
        server_file: Path to server file

    Returns:
        True if valid, False otherwise
    """
    try:
        # Try to load the module
        module = load_python_module(server_file)

        # Check for common MCP patterns
        module_vars = dir(module)

        # Check for BuildMCPServer usage
        from simply_mcp.api.builder import BuildMCPServer

        for var_name in module_vars:
            var = getattr(module, var_name)
            if isinstance(var, BuildMCPServer):
                return True

        # Check for decorator API usage
        from simply_mcp.api.decorators import get_global_server

        try:
            global_server = get_global_server()
            stats = global_server.registry.get_stats()
            if stats["total"] > 0:
                return True
        except Exception:
            pass

        # Check for class-based API
        import inspect

        for var_name in module_vars:
            var = getattr(module, var_name)
            if inspect.isclass(var) and hasattr(var, "_mcp_server"):
                return True

        return False

    except Exception as e:
        format_error(f"Failed to validate server file: {e}", "Validation Error")
        return False


@click.command()
@click.argument("server_file", type=click.Path(exists=True))
@click.option(
    "--name",
    "-n",
    type=str,
    default=None,
    help="Name for the executable (default: server filename)",
)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    default="./dist",
    help="Output directory (default: ./dist)",
)
@click.option(
    "--onefile/--no-onefile",
    "-F",
    default=True,
    help="Bundle as single file (default: True)",
)
@click.option(
    "--windowed/--no-windowed",
    "-w",
    default=False,
    help="No console window (default: False for servers)",
)
@click.option(
    "--icon",
    "-i",
    type=click.Path(exists=True),
    default=None,
    help="Custom icon file path",
)
@click.option(
    "--clean",
    is_flag=True,
    help="Clean build artifacts after bundling",
)
def bundle(
    server_file: str,
    name: str | None,
    output: str,
    onefile: bool,
    windowed: bool,
    icon: str | None,
    clean: bool,
) -> None:
    """Bundle an MCP server into a standalone executable.

    This command packages a Python MCP server into a standalone executable
    using PyInstaller. The resulting executable can be distributed without
    requiring Python or dependencies to be installed.

    Examples:

        \b
        # Bundle with default settings
        simply-mcp bundle server.py

        \b
        # Bundle with custom name and output directory
        simply-mcp bundle server.py --name myserver --output ./build

        \b
        # Bundle as directory (not single file)
        simply-mcp bundle server.py --no-onefile

        \b
        # Bundle with custom icon
        simply-mcp bundle server.py --icon icon.ico

        \b
        # Bundle and clean up build artifacts
        simply-mcp bundle server.py --clean

    Notes:
        - PyInstaller must be installed: pip install pyinstaller
        - Building may take several minutes
        - The executable will be platform-specific
        - Use --clean to remove temporary build files
    """
    try:
        # Check if PyInstaller is available
        try:
            import PyInstaller  # noqa: F401
        except ImportError:
            format_error(
                "PyInstaller is not installed.\n\n"
                "Install it with: pip install pyinstaller\n"
                "Or install with bundling extras: pip install simply-mcp[bundling]",
                "Missing Dependency",
            )
            sys.exit(1)

        # Display bundling info
        console.print(
            Panel(
                f"[bold cyan]Bundling MCP Server[/bold cyan]\n\n"
                f"Server File: [green]{server_file}[/green]\n"
                f"Output Mode: [yellow]{'Single File' if onefile else 'Directory'}[/yellow]\n"
                f"Console: [yellow]{'Hidden' if windowed else 'Visible'}[/yellow]",
                title="[bold blue]Simply-MCP Bundle[/bold blue]",
            )
        )

        # Validate server file
        if not validate_python_file(server_file):
            format_error("Invalid Python file", "Validation Error")
            sys.exit(1)

        console.print("[dim]Validating server file...[/dim]")
        if not validate_server_file(server_file):
            format_error(
                "No MCP server found in the file.\n\n"
                "Make sure your file contains a valid MCP server using:\n"
                "  - Decorator API: @tool(), @prompt(), @resource()\n"
                "  - Builder API: BuildMCPServer(...)\n"
                "  - Class API: @mcp_server class",
                "Invalid Server",
            )
            sys.exit(1)

        format_success("Server file validated successfully")

        # Determine output name
        if name is None:
            name = Path(server_file).stem

        # Create output directory
        output_path = Path(output).resolve()
        output_path.mkdir(parents=True, exist_ok=True)

        # Detect imports
        console.print("[dim]Detecting dependencies...[/dim]")
        imports = detect_imports(server_file)
        format_info(f"Detected {len(imports)} imported modules")

        # Generate spec file
        console.print("[dim]Generating PyInstaller spec file...[/dim]")
        spec_content = generate_spec_file(
            server_file=server_file,
            output_name=name,
            onefile=onefile,
            windowed=windowed,
            icon=icon,
        )

        # Write spec file to temporary location
        spec_file_path = output_path / f"{name}.spec"
        with open(spec_file_path, "w", encoding="utf-8") as f:
            f.write(spec_content)

        format_success(f"Generated spec file: {spec_file_path}")

        # Run PyInstaller
        console.print("\n[bold yellow]Building executable...[/bold yellow]")
        console.print("[dim]This may take several minutes...[/dim]\n")

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            task = progress.add_task("Running PyInstaller...", total=None)

            try:
                # Run PyInstaller with the spec file
                result = subprocess.run(
                    [
                        sys.executable,
                        "-m",
                        "PyInstaller",
                        "--clean",
                        "--distpath",
                        str(output_path),
                        "--workpath",
                        str(output_path / "build"),
                        str(spec_file_path),
                    ],
                    capture_output=True,
                    text=True,
                    check=False,
                )

                progress.update(task, completed=True)

                if result.returncode != 0:
                    format_error(
                        f"PyInstaller failed with error:\n\n{result.stderr}",
                        "Build Error",
                    )
                    sys.exit(1)

            except Exception as e:
                format_error(f"Failed to run PyInstaller: {e}", "Build Error")
                sys.exit(1)

        format_success("Build completed successfully!")

        # Display output location
        if onefile:
            exe_name = name + (".exe" if sys.platform == "win32" else "")
            exe_path = output_path / exe_name
            console.print(
                Panel(
                    f"[bold green]Executable created successfully![/bold green]\n\n"
                    f"Location: [cyan]{exe_path}[/cyan]\n"
                    f"Size: [yellow]{exe_path.stat().st_size / (1024*1024):.2f} MB[/yellow]",
                    title="[bold green]Build Complete[/bold green]",
                )
            )
        else:
            bundle_dir = output_path / name
            console.print(
                Panel(
                    f"[bold green]Bundle created successfully![/bold green]\n\n"
                    f"Location: [cyan]{bundle_dir}[/cyan]\n"
                    f"Executable: [cyan]{bundle_dir / name}[/cyan]",
                    title="[bold green]Build Complete[/bold green]",
                )
            )

        # Clean up if requested
        if clean:
            console.print("\n[dim]Cleaning up build artifacts...[/dim]")
            build_dir = output_path / "build"
            if build_dir.exists():
                shutil.rmtree(build_dir)
            if spec_file_path.exists():
                spec_file_path.unlink()
            format_info("Build artifacts cleaned up")

        # Display usage instructions
        console.print(
            Panel(
                "[bold]Usage:[/bold]\n\n"
                f"Run the bundled server:\n"
                f"  [cyan]{exe_path if onefile else bundle_dir / name}[/cyan]\n\n"
                "The executable is platform-specific and includes all dependencies.",
                title="[bold blue]Next Steps[/bold blue]",
            )
        )

    except Exception as e:
        format_error(f"Fatal error during bundling: {e}", "Error")
        import traceback

        console.print("[dim]" + traceback.format_exc() + "[/dim]")
        sys.exit(1)


__all__ = ["bundle"]
