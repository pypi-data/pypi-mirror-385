"""
Geek Cafe, LLC
MIT License.  See Project Root for the license information.

ChatChannelMember model for scalable channel membership using single-table design.
"""

from boto3_assist.dynamodb.dynamodb_index import DynamoDBIndex, DynamoDBKey
import datetime as dt
from typing import Optional
from geek_cafe_saas_sdk.models.base_model import BaseModel


class ChatChannelMember(BaseModel):
    """
    ChatChannelMember model for scalable membership tracking.
    
    Single-table design pattern:
    - PK: channel#<channel_id>
    - SK: member#<user_id>
    - GSI1PK: user#<user_id> (for "what channels am I in?")
    - GSI1SK: channel#<channel_id>#<joined_at>
    
    Benefits:
    - Unlimited members per channel
    - Fast membership checks (single GetItem)
    - Member metadata (role, permissions, preferences)
    - Efficient pagination
    - Concurrent updates without contention
    """

    def __init__(self):
        super().__init__()
        # Note: Uses normal UUID id, but pk/sk create adjacent record pattern
        self._channel_id: str | None = None
        self._user_id: str | None = None
        
        # Member metadata
        self._role: str = "member"  # member, admin, owner
        self._joined_at: float | None = None
        self._added_by_id: str | None = None
        
        # Notification preferences
        self._notification_level: str = "all"  # all, mentions, none
        self._muted: bool = False
        
        # Activity tracking
        self._last_read_message_id: str | None = None
        self._last_read_at: float | None = None
        
        # Setup DynamoDB indexes (adjacent record pattern)
        self._setup_indexes()
    
    def _setup_indexes(self):
        """Setup DynamoDB indexes for member queries."""
        
        # Primary index: Adjacent record pattern - members grouped by channel
        # Query: pk="channel#<id>" AND sk BEGINS_WITH "member#" to get all members
        primary: DynamoDBIndex = DynamoDBIndex()
        primary.name = "primary"
        primary.partition_key.attribute_name = "pk"
        primary.partition_key.value = lambda: DynamoDBKey.build_key(("channel", self.channel_id))
        primary.sort_key.attribute_name = "sk"
        primary.sort_key.value = lambda: DynamoDBKey.build_key(("member", self.user_id))
        self.indexes.add_primary(primary)
        
        # GSI1: User's channels - query channels by user
        gsi: DynamoDBIndex = DynamoDBIndex()
        gsi.name = "gsi1"
        gsi.partition_key.attribute_name = f"{gsi.name}_pk"
        gsi.partition_key.value = lambda: DynamoDBKey.build_key(("user", self.user_id))
        gsi.sort_key.attribute_name = f"{gsi.name}_sk"
        gsi.sort_key.value = lambda: DynamoDBKey.build_key(("channel", self.channel_id), ("ts", self.joined_at))
        self.indexes.add_secondary(gsi)
        
        # GSI2: Members by role - query members by role within channel
        gsi: DynamoDBIndex = DynamoDBIndex()
        gsi.name = "gsi2"
        gsi.partition_key.attribute_name = f"{gsi.name}_pk"
        gsi.partition_key.value = lambda: DynamoDBKey.build_key(("channel", self.channel_id), ("role", self.role))
        gsi.sort_key.attribute_name = f"{gsi.name}_sk"
        gsi.sort_key.value = lambda: DynamoDBKey.build_key(("member", self.user_id))
        self.indexes.add_secondary(gsi)

    @property
    def model_version(self) -> str:
        return "1.0"

    def prep_for_save(self):
        """
        Prepare member record for save.
        
        Note: ChatChannelMember uses adjacent record pattern where:
        - Normal UUID id (generated by parent)
        - pk = "channel#<channel_id>" (groups by channel)
        - sk = "member#<user_id>" (enables begins_with queries)
        """
        # Validate required fields for adjacent record pattern
        if not self.channel_id:
            raise ValueError("channel_id is required for ChatChannelMember")
        if not self.user_id:
            raise ValueError("user_id is required for ChatChannelMember")
        
        # Call parent to generate normal UUID id and set timestamps
        super().prep_for_save()

    # Properties
    @property
    def channel_id(self) -> str:
        return self._channel_id

    @channel_id.setter
    def channel_id(self, value: str | None):
        self._channel_id = value

    @property
    def user_id(self) -> str:
        return self._user_id

    @user_id.setter
    def user_id(self, value: str | None):
        self._user_id = value

    @property
    def role(self) -> str:
        return self._role

    @role.setter
    def role(self, value: str | None):
        valid_roles = ["member", "admin", "owner"]
        self._role = value if value in valid_roles else "member"

    @property
    def joined_at(self) -> float:
        return self._joined_at

    @joined_at.setter
    def joined_at(self, value: float | None):
        self._joined_at = value

    @property
    def added_by_id(self) -> str:
        return self._added_by_id

    @added_by_id.setter
    def added_by_id(self, value: str | None):
        self._added_by_id = value

    @property
    def notification_level(self) -> str:
        return self._notification_level

    @notification_level.setter
    def notification_level(self, value: str | None):
        valid_levels = ["all", "mentions", "none"]
        self._notification_level = value if value in valid_levels else "all"

    @property
    def muted(self) -> bool:
        return self._muted

    @muted.setter
    def muted(self, value: bool | None):
        self._muted = value if isinstance(value, bool) else False

    @property
    def last_read_message_id(self) -> str:
        return self._last_read_message_id

    @last_read_message_id.setter
    def last_read_message_id(self, value: str | None):
        self._last_read_message_id = value

    @property
    def last_read_at(self) -> float:
        return self._last_read_at

    @last_read_at.setter
    def last_read_at(self, value: float | None):
        self._last_read_at = value
