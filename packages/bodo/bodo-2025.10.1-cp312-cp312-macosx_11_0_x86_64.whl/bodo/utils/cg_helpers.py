"""helper functions for code generation with llvmlite"""

import llvmlite.binding as ll
from llvmlite import ir as lir
from numba.core import cgutils, types
from numba.extending import intrinsic

import bodo
from bodo.libs import array_ext

ll.add_symbol("is_na_value", array_ext.is_na_value)


def get_bitmap_bit(builder, null_bitmap_ptr, ind):
    """get bit number 'ind' of bitmap array 'null_bitmap_ptr'"""
    # (null_bitmap[i / 8] & kBitmask[i % 8])
    byte_ind = builder.lshr(ind, lir.Constant(lir.IntType(64), 3))
    bit_ind = builder.urem(ind, lir.Constant(lir.IntType(64), 8))
    byte = builder.load(builder.gep(null_bitmap_ptr, [byte_ind], inbounds=True))
    ll_typ_mask = lir.ArrayType(lir.IntType(8), 8)
    mask_tup = cgutils.alloca_once_value(
        builder, lir.Constant(ll_typ_mask, (1, 2, 4, 8, 16, 32, 64, 128))
    )
    mask = builder.load(
        builder.gep(
            mask_tup, [lir.Constant(lir.IntType(64), 0), bit_ind], inbounds=True
        )
    )
    return builder.and_(byte, mask)


@intrinsic
def set_bit_to(typingctx, null_bitmap_ptr_t, ind_t, val_t):
    """intrinsic equivalent of SetBitTo() in C++. Sets bitmap array's bit to value.

    Args:
        typingctx: Numba typing context
        null_bitmap_ptr_t (uint8_t*): bitmap array's pointer
        ind_t (int64): index in bitmap array
        val_t (bool): value to set
    """

    # C++ function:
    # inline void SetBitTo(uint8_t* bits, int64_t i, bool bit_is_set) {
    #     bits[i / 8] ^=
    #         static_cast<uint8_t>(-static_cast<uint8_t>(bit_is_set) ^ bits[i / 8]) &
    #         kBitmask[i % 8];
    # }

    # LLVM IR generated by "clang -O3 -S -emit-llvm"
    # define void @_Z8SetBitToPhxb(i8* nocapture %0, i64 %1, i1 zeroext %2) local_unnamed_addr #0 {
    #     %4 = sext i1 %2 to i8
    #     %5 = sdiv i64 %1, 8
    #     %6 = getelementptr inbounds i8, i8* %0, i64 %5
    #     %7 = load i8, i8* %6, align 1, !tbaa !4
    #     %8 = xor i8 %7, %4
    #     %9 = srem i64 %1, 8
    #     %10 = getelementptr inbounds [8 x i8], [8 x i8]* @_ZL8kBitmask, i64 0, i64 %9
    #     %11 = load i8, i8* %10, align 1, !tbaa !4
    #     %12 = and i8 %8, %11
    #     %13 = xor i8 %12, %7
    #     store i8 %13, i8* %6, align 1, !tbaa !4
    #     ret void
    # }

    def codegen(context, builder, sig, args):
        null_bitmap_ptr, ind, val = args

        val = builder.sext(val, lir.IntType(8))
        byte_ind = builder.lshr(ind, lir.Constant(lir.IntType(64), 3))
        bit_ind = builder.urem(ind, lir.Constant(lir.IntType(64), 8))
        byte_ptr = builder.gep(null_bitmap_ptr, [byte_ind], inbounds=True)
        byte = builder.load(byte_ptr)
        ll_typ_mask = lir.ArrayType(lir.IntType(8), 8)
        mask_tup = cgutils.alloca_once_value(
            builder, lir.Constant(ll_typ_mask, (1, 2, 4, 8, 16, 32, 64, 128))
        )
        mask = builder.load(
            builder.gep(
                mask_tup, [lir.Constant(lir.IntType(64), 0), bit_ind], inbounds=True
            )
        )
        b_xor_val = builder.xor(byte, val)
        out = builder.xor(builder.and_(b_xor_val, mask), byte)
        builder.store(out, byte_ptr)

    return types.void(types.voidptr, types.int64, types.bool_), codegen


def is_na_value(builder, context, val, C_NA):
    """check if Python object 'val' is an NA value (None, or np.nan or pd.NA).
    passing pd.NA in as C_NA to avoid getattr overheads inside loops.
    """
    pyobj = context.get_argument_type(types.pyobject)
    arr_isna_fnty = lir.FunctionType(lir.IntType(32), [pyobj, pyobj])
    arr_isna_fn = cgutils.get_or_insert_function(
        builder.module, arr_isna_fnty, name="is_na_value"
    )
    return builder.call(arr_isna_fn, [val, C_NA])


def gen_allocate_array(context, builder, arr_type, n_elems, dict_arr_ref, c=None):
    """gen array allocation for type 'arr_type'.
    'n_elems' is a tuple of all counts needed for allocation, e.g. (3, 5) for array item
    that has 3 arrays and 5 primitive elements.
    'dict_arr_ref' is the reference array for allocating dictionary-encoded arrays if
    available (otherwise None).
    'c' is boxing/unboxing context and can be None if not in boxing/unboxing steps.
    When in boxing/unboxing, 'call_jit_code' is used to handle Python error model.
    """
    n_counts = n_elems.type.count
    assert n_counts >= 1, "gen_allocate_array(): invalid n_elems count"
    length = builder.extract_value(n_elems, 0)

    # if nested counts are provided, pack a new tuple for them
    if n_counts != 1:
        n_nested_elems = cgutils.pack_array(
            builder, [builder.extract_value(n_elems, i) for i in range(1, n_counts)]
        )
        nested_counts_typ = types.Tuple([types.int64] * (n_counts - 1))
    else:
        n_nested_elems = context.get_dummy_value()
        nested_counts_typ = types.none

    # call alloc_type
    t_ref = types.TypeRef(arr_type)
    dict_arr_ref_typ = types.none if dict_arr_ref is None else arr_type
    dict_arr_ref_val = (
        context.get_dummy_value() if dict_arr_ref is None else dict_arr_ref
    )
    sig = arr_type(types.int64, t_ref, nested_counts_typ, dict_arr_ref_typ)
    args = [length, context.get_dummy_value(), n_nested_elems, dict_arr_ref_val]
    impl = lambda n, t, s, dict_arr_ref: bodo.utils.utils.alloc_type(
        n, t, s, dict_arr_ref
    )
    if c:
        _is_error, out_arr = c.pyapi.call_jit_code(impl, sig, args)
    else:
        out_arr = context.compile_internal(builder, impl, sig, args)
    return out_arr


def gen_alloc_meminfo(context, builder, length, dtype):
    """Allocate a meminfo for 'length' elements of type 'dtype'.
    Implementation similar to bodo.utils.utils._empty_nd_impl.

    Args:
        context (BaseContext): codegen context
        builder (IRBuilder): codegen builder
        length (lir.IntType): number of element
        dtype (types.Type): element types

    Returns:
        ll_voidptr: allocated meminfo
    """

    ll_type = context.get_data_type(dtype)
    itemsize = context.get_constant(types.intp, context.get_abi_sizeof(ll_type))

    # Check overflow, numpy also does this after checking order
    allocsize_mult = builder.smul_with_overflow(length, itemsize)
    allocsize = builder.extract_value(allocsize_mult, 0)
    overflow = builder.extract_value(allocsize_mult, 1)

    with builder.if_then(overflow, likely=False):
        cgutils.printf(
            builder,
            (
                "meminfo is too big; `length * itemsize` is larger than"
                " the maximum possible size."
            ),
        )

    align_val = context.get_preferred_array_alignment(dtype)
    align = context.get_constant(types.uint32, align_val)
    meminfo = context.nrt.meminfo_alloc_aligned(builder, size=allocsize, align=align)
    return meminfo


def meminfo_to_np_arr(context, builder, meminfo, meminfo_offset, length, arrtype):
    """Wrap meminfo in a Numpy array of type 'arrtype'.
    Implementation similar to bodo.utils.utils._empty_nd_impl.

    Args:
        context (BaseContext): codegen context
        builder (IRBuilder): codegen builder
        meminfo (ll_voidptr): input meminfo
        meminfo_offset (lir.IntType): data pointer offset from meminfo data pointer
        length (lir.IntType): number of element
        arrtype (types.Type): Numpy array type to wrap

    Returns:
        lir.LiteralStructType: Numpy array that wraps meminfo
    """

    from numba.np.arrayobj import get_itemsize, populate_array

    assert arrtype.ndim == 1 and arrtype.layout == "C", (
        "meminfo_to_np_arr: 1D array type with C layout expected"
    )

    arr = context.make_array(arrtype)(context, builder)

    datatype = context.get_data_type(arrtype.dtype)
    itemsize = context.get_constant(types.intp, get_itemsize(context, arrtype))

    meminfo_ptr = context.nrt.meminfo_data(builder, meminfo)
    data = builder.inttoptr(
        builder.add(builder.ptrtoint(meminfo_ptr, lir.IntType(64)), meminfo_offset),
        lir.IntType(8).as_pointer(),
    )
    intp_t = context.get_value_type(types.intp)
    shape_array = cgutils.pack_array(builder, (length,), ty=intp_t)
    strides_array = cgutils.pack_array(builder, (itemsize,), ty=intp_t)

    populate_array(
        arr,
        data=builder.bitcast(data, datatype.as_pointer()),
        shape=shape_array,
        strides=strides_array,
        itemsize=itemsize,
        meminfo=meminfo,
    )

    return arr._getvalue()


def is_ll_eq(builder, val1, val2):
    """
    Compare equality of two llvm values.
    Generalizes icmp_unsigned("==", ...) to handle aggregate types (Struct/Array).
    'val1' & 'val2' are pointer to llvm values.
    """
    t1 = val1.type.pointee
    t2 = val2.type.pointee
    assert t1 == t2, "invalid llvm value comparison"

    # compare individual elements for aggregate types
    if isinstance(t1, (lir.BaseStructType, lir.ArrayType)):
        n_elems = len(t1.elements) if isinstance(t1, lir.BaseStructType) else t1.count
        eq = lir.Constant(lir.IntType(1), 1)
        for i in range(n_elems):
            # NOTE: aggregate types need an extra 0 index for accessing elements in LLVM
            # e.g. gep(A, 0, 4) gives the 4th element
            ll_0 = lir.IntType(32)(0)
            ll_i = lir.IntType(32)(i)
            new_val1 = builder.gep(val1, [ll_0, ll_i], inbounds=True)
            new_val2 = builder.gep(val2, [ll_0, ll_i], inbounds=True)
            eq = builder.and_(eq, is_ll_eq(builder, new_val1, new_val2))
        return eq

    v1 = builder.load(val1)
    v2 = builder.load(val2)

    # some values may be float which we cast to int for basic equality check
    # see test_describe_many_columns
    if v1.type in (lir.FloatType(), lir.DoubleType()):
        n_bits = 32 if v1.type == lir.FloatType() else 64
        v1 = builder.bitcast(v1, lir.IntType(n_bits))
        v2 = builder.bitcast(v2, lir.IntType(n_bits))

    # integer or pointer values
    return builder.icmp_unsigned("==", v1, v2)
